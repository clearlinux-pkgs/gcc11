Alexandre Oliva (3):
      testsuite: vect: update unaligned message
      [PR105324] libstdc++: testsuite: pr105324 requires FP from_char
      libstdc++: ppc: conditionalize vsx-only simd intrinsics

Andreas Krebbel (1):
      IBM zSystems/testsuite: PR105147: Skip pr105140.c

David Malcolm (2):
      analyzer: fix ICE comparing VECTOR_CSTs [PR105252]
      analyzer: fix ICEs on complex constants [PR105365,105366]

Eric Botcazou (1):
      Fix internal error with vectorization on SPARC

Fritz Reese (1):
      fortran: Fix conv of UNION constructors [PR105310]

GCC Administrator (49):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

H.J. Lu (2):
      x86: Add missing .note.GNU-stack to assembly source
      x86: Add .note.GNU-stack section only for Linux

Harald Anlauf (2):
      Fortran: improve error recovery on invalid array section
      Fortran: fix error recovery on invalid array section

Hongyu Wang (1):
      AVX512F: Add missing macro for mask(z?)_scalf_s[sd] [PR 105339]

Iain Buclaw (2):
      libphobos: Don't call free on the TLS array in the emutls destroy function.
      libphobos: Give _Unwind_Exception an alignment that best resembles __attribute__((aligned))

Jakub Jelinek (7):
      emit-rtl: Fix -fcompare-debug bug with label references in debug insns [PR105203]
      sparc: Preserve ORIGINAL_REGNO in epilogue_renumber [PR105257]
      rtlanal: Fix up replace_rtx [PR105333]
      asan: Fix up asan_redzone_buffer::emit_redzone_byte [PR105396]
      i386: Fix up ix86_gimplify_va_arg [PR105331]
      c++: Don't emit deprecated warnings on lambda declarations
      isel: Fix up gimple_expand_vec_set_expr [PR105528]

Jan Hubicka (1):
      Fix modref_tree::remap_params

Jason Merrill (16):
      c++: rodata and defaulted ctor [PR104142]
      c++: low -faligned-new [PR102071]
      c++: local function versioning [PR104669]
      c++: empty base constexpr -fno-elide-ctors [PR105245]
      c++: temp cleanup in new [PR105265]
      c++: lambda and the current instantiation [PR82980]
      c++: constexpr trivial -fno-elide-ctors [PR104646]
      c++: pack init-capture of unresolved overload [PR102629]
      c++: template-id with current inst qualifier [PR102300]
      c++: alignment of local typedef in template [PR65211]
      c++: template conversion op [PR101698]
      c++: NRV and ref-extended temps [PR101442]
      c++: constexpr ref to array of array [PR102307]
      c++: constexpr empty aggr [PR105795]
      c++: redeclared hidden friend [PR105761]
      c++: redeclared hidden friend take 2 [PR105852]

Jeff Law (1):
      [committed] Fix more problems with new linker warnings

Jonathan Wakely (38):
      libstdc++: Avoid -Wzero-as-null-pointer-constant warning [PR103848]
      libstdc++: Fix warning in __moneypunct_cache::_M_cache [PR104966]
      libstdc++: Fix macro checked by test
      libstdc++: Fix incorrect IS number in doc comment
      libstdc++: Use LTLIBICONV when linking libstdc++.so [PR93602]
      libstdc++: Fix test failure on AIX
      libstdc++: Increase timeout for pthread7-rope.cc test
      libstdc++: Avoid overflow in ranges::advance(i, n, bound)
      libstdc++: Do not use std::isdigit in <charconv> [PR103911]
      libstdc++: Ignore cv-quals when std::allocator<void> constructs
      libstdc++: Avoid unwanted allocations in filesystem::path
      libstdc++: Reorder constraints on std::span::span(Range&&) constructor.
      libstdc++: Improvements to standard error category objects (part deux)
      libstdc++: Use std::construct_at in net::ip::address
      libstdc++: Add missing noexcept to lazy_split_view iterator (LWG 3593)
      libstdc++: Add another non-reserved name to tests
      libstdc++: Fix non-reserved name in <regex> header
      libstdc++: Fix tests that fail with fully-dynamic-string
      libstdc++: Ensure C++20 std::stringstream definitions use correct ABI
      libstdc++: Use secure_getenv for filesystem::temp_directory_path() [PR65018]
      libstdc++: Remove bogus assertion in std::from_chars [PR105324]
      libstdc++: Fix filesystem::temp_directory_path [PR101709]
      libstdc++: Fix test that fails in C++20 mode
      libstdc++: Fix ambiguous comparisons for iterators in C++20
      libstdc++: Fix test failures at -O0
      libstdc++: Remove "no stronger" assertion in compare exchange [PR102177]
      libstdc++: Remove workaround for FE bug in std::tuple [PR96592]
      libstdc++: Add deduction guides for std::packaged_task [PR105375]
      libstdc++: Fix error reporting in filesystem::copy [PR99290]
      libstdc++: Fix test that fails on Solaris [PR104731]
      libstdc++: Fix deserialization for std::normal_distribution [PR105502]
      libstdc++: Define _GNU_SOURCE for secure_getenv on Cygwin [PR104217]
      libstdc++: Add <syncstream> declarations to <iosfwd> [PR105284]
      libstdc++: Fix status docs for <bit> support
      libstdc++: Add C++23 status docs
      libstdc++: Fix hyperlink in docs
      libstdc++: Document support for constexpr optional (P2231R1)
      libstdc++: Partially revert r11-9772-g6f8133689f4397 [PR105915]

Kewen Lin (1):
      testsuite: Skip pr105250.c for powerpc and s390 [PR105266]

Kito Cheng (1):
      RISC-V: Fix wrong expansion for arch-canonicalize

Marek Polacek (4):
      c++: ambiguous call not diagnosed after DR2352 [PR97296]
      c++: wrong error with constexpr COMPOUND_EXPR [PR105321]
      c++: enum in generic lambda at global scope [PR105398]
      c++: global-namespace-qualified var after class def [PR90107]

Martin Jambor (1):
      ipa: Release body of clone_of when removing its last clone (PR 100413)

Matthias Kretz (1):
      c++: don't ICE on NAMESPACE_DECL inside FUNCTION_DECL

Max Filippov (1):
      gcc: xtensa: fix PR target/105879

Michael Meissner (1):
      rs6000: Ignore fusion option flags for inlining test [PR102059]

Patrick Palka (5):
      c++: partial ordering with dependent NTTP type [PR105289]
      c++: ICE with requires-expr and -Wsequence-point [PR105304]
      c++: decltype of non-dependent call of class type [PR105386]
      libstdc++: Don't use std::tolower in <charconv> [PR103911]
      c++: deduction guides and ttp rewriting [PR102479]

Paul A. Clarke (1):
      rs6000: __Uglify non-uglified local variables in headers

Pavel I. Kryukov (1):
      libstdc++: Add self-merge check to std::forward_list::merge [PR103853]

Qing Zhao (1):
      i386: Adjust -fzero-call-used-regs to always use XOR [PR101891]

Richard Biener (13):
      Update BASE-VER to 11.3.1
      ipa/105598 - testcase for PR105598
      middle-end/105140 - fix bogus recursion in fold_convertible_p
      tree-optimization/105250 - adjust fold_convertible_p PR105140 fix
      tree-optimization/105148 - fix IVOPTs recording uses
      tree-optimization/105163 - abnormal SSA coalescing and reassoc
      tree-optimization/105173 - fix insertion logic in reassoc
      tree-optimization/105263 - reassoc and DFP
      tree-optimization/105312 - fix ISEL VCOND expansion
      tree-optimization/105368 - avoid overflow in powi_cost
      tree-optimization/105431 - another overflow in powi handling
      rtl-optimization/105559 - avoid quadratic behavior in delete_insn_and_edges
      tree-optimization/105437 - BB vect with extern defs of throwing stmts

Sebastian Pop (1):
      [AArch64] add barriers to ool __sync builtins

Segher Boessenkool (1):
      rs6000/testsuite: Skip pr105140.c

Sergei Trofimovich (1):
      gcov-profile: Allow negative counts of indirect calls [PR105282]

Simon Cook (1):
      RISC-V: Don't unconditionally add m,a,f,d in arch-canonicalize

Tamar Christina (1):
      testsuite: Backport testsuite changes from GCC 12 to GCC 11

Thomas W Rodgers (1):
      libstdc++: Make atomic notify_one and notify_all non-const

liuhongt (1):
      Fix insn does not satisfy its constraints: sse2_lshrv1ti3

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index f628d2eafc5..0a47c95bb14 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-11.3.0
+11.3.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index a0587d18824..89370411d1a 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,291 @@
+2022-06-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backported from master:
+	2022-06-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	PR target/105879
+	* config/xtensa/xtensa.md (movdi): Rename 'first' and 'second'
+	to 'lowpart' and 'highpart' so that they match 'gen_lowpart' and
+	'gen_highpart' bitwise semantics and fix order of highpart and
+	lowpart depending on target endianness.
+
+2022-06-08  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/105854
+	* config/i386/sse.md (ssse3_palignrdi): Change alternative 2
+	from Yv to Yw.
+
+2022-06-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105437
+	* tree-vect-slp.c (vect_schedule_slp_node): Handle the
+	case where last_stmt alters control flow.
+
+2022-05-26  Simon Cook  <simon.cook@embecosm.com>
+
+	Backported from master:
+	2022-05-25  Simon Cook  <simon.cook@embecosm.com>
+
+	* config/riscv/arch-canonicalize: Only add mafd extension if
+	base was rv32/rv64g.
+
+2022-05-26  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backported from master:
+	2022-05-09  Kito Cheng  <kito.cheng@sifive.com>
+
+	* config/riscv/arch-canonicalize: Handle g correctly.
+
+2022-05-24  Qing Zhao  <qing.zhao@oracle.com>
+
+	Backported from master:
+	2022-05-09  Qing Zhao  <qing.zhao@oracle.com>
+
+	PR target/101891
+	* config/i386/i386.c (zero_call_used_regno_mode): use V2SImode
+	as a generic MMX mode instead of V4HImode.
+	(zero_all_mm_registers): Use SET to zero instead of MOV for
+	zeroing scratch registers.
+	(ix86_zero_call_used_regs): Likewise.
+
+2022-05-23  Paul A. Clarke  <pc@us.ibm.com>
+
+	PR target/104257
+	* config/rs6000/bmi2intrin.h: Uglify local variables.
+	* config/rs6000/emmintrin.h: Likewise.
+	* config/rs6000/mm_malloc.h: Likewise.
+	* config/rs6000/mmintrin.h: Likewise.
+	* config/rs6000/pmmintrin.h: Likewise.
+	* config/rs6000/smmintrin.h: Likewise.
+	* config/rs6000/tmmintrin.h: Likewise.
+	* config/rs6000/xmmintrin.h: Likewise.
+
+2022-05-19  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2022-05-06  Michael Meissner  <meissner@linux.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/102059
+	* config/rs6000/rs6000.c (rs6000_can_inline_p): Ignore -mpower8-fusion
+	and -mpower10-fusion options for inlining purposes.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/105559
+	* cfgrtl.c (delete_insn_and_edges): Only perform search to BB_END
+	for non-debug insns.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105431
+	* tree-ssa-math-opts.c (powi_as_mults_1): Make n unsigned.
+	(powi_as_mults): Use absu_hwi.
+	(gimple_expand_builtin_powi): Remove now pointless n != -n
+	check.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105368
+	* tree-ssa-math-opts.c (powi_cost): Use absu_hwi.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-20  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105312
+	* gimple-isel.cc (gimple_expand_vec_cond_expr): Query both
+	VCOND and VCONDU for EQ and NE.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105263
+	* tree-ssa-reassoc.c (try_special_add_to_ops): Do not consume
+	negates in multiplication chains with DFP.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105173
+	* tree-ssa-reassoc.c (find_insert_point): Get extra
+	insert_before output argument and compute it.
+	(insert_stmt_before_use): Adjust.
+	(rewrite_expr_tree): Likewise.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105163
+	* tree-ssa-reassoc.c (repropagate_negates): Avoid propagating
+	negated abnormals.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105148
+	* tree-ssa-loop-ivopts.c (idx_record_use): Walk raw operands
+	2 and 3 of ARRAY_REFs.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105250
+	* fold-const.c (fold_convertible_p): Revert
+	r12-7979-geaaf77dd85c333, instead check for size equality
+	of the vector types involved.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105140
+	* fold-const.c (fold_convertible_p): Allow a TYPE_P arg.
+
+2022-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-04-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/100413
+	* cgraph.c (cgraph_node::remove): Release body of the node this
+	is clone_of if appropriate.
+
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* config/aarch64/aarch64-protos.h (atomic_ool_names): Increase dimension
+	of str array.
+	* config/aarch64/aarch64.c (aarch64_atomic_ool_func): Call
+	memmodel_from_int and handle MEMMODEL_SYNC_*.
+	(DEF0): Add __aarch64_*_sync functions.
+
+2022-05-16  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-10  Jan Hubicka  <jh@suse.cz>
+
+	* ipa-modref-tree.h (modref_tree::remap_params): Fix off-by-one error.
+
+2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/105528
+	* gimple-isel.cc (gimple_expand_vec_set_expr): After gsi_remove
+	set *gsi to gsi_for_stmt (ass_stmt).  Fix up function comment.
+
+2022-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/105292
+	* config/sparc/sparc.c (sparc_vectorize_vec_perm_const): Return
+	true only for 8-byte vector modes.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105331
+	* config/i386/i386.c (ix86_gimplify_va_arg): Mark va_arg_tmp
+	temporary TREE_ADDRESSABLE before trying to gimplify ADDR_EXPR
+	of it.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105396
+	* asan.c (asan_redzone_buffer::emit_redzone_byte): Handle the case
+	where offset is bigger than off but smaller than m_prev_offset + 32
+	bits by pushing one or more 0 bytes.  Sink the
+	m_shadow_bytes.safe_push (value); flush_if_full (); statements from
+	all cases to the end of the function.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/105333
+	* rtlanal.c (replace_rtx): Use simplify_subreg or
+	simplify_unary_operation if CONST_SCALAR_INT_P rather than just
+	CONST_INT_P.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* config/i386/avx512fintrin.h (_mm512_scalef_round_pd):
+	Add parentheses for parameters and djust format.
+	(_mm512_mask_scalef_round_pd): Ditto.
+	(_mm512_maskz_scalef_round_pd): Ditto.
+	(_mm512_scalef_round_ps): Ditto.
+	(_mm512_mask_scalef_round_ps): Ditto.
+	(_mm512_maskz_scalef_round_ps): Ditto.
+	(_mm_scalef_round_sd): Use _mm_undefined_pd.
+	(_mm_scalef_round_ss): Use _mm_undefined_ps.
+	(_mm_mask_scalef_round_sd): New macro.
+	(_mm_mask_scalef_round_ss): Ditto.
+	(_mm_maskz_scalef_round_sd): Ditto.
+	(_mm_maskz_scalef_round_ss): Ditto.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* config/sparc/sparc.c (epilogue_renumber): If ORIGINAL_REGNO,
+	use gen_raw_REG instead of gen_rtx_REG and copy over also
+	ORIGINAL_REGNO.  Use return 0; instead of /* fallthrough */.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/105203
+	* emit-rtl.c (emit_copy_of_insn_after): Don't call mark_jump_label
+	on DEBUG_INSNs.
+
+2022-04-21  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-04-19  Sergei Trofimovich  <siarheit@google.com>
+
+	PR gcov-profile/105282
+	* value-prof.c (stream_out_histogram_value): Allow negative counts
+	on HIST_TYPE_INDIR_CALL.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/analyzer/ChangeLog b/gcc/analyzer/ChangeLog
index 7ae3901445e..a051997909c 100644
--- a/gcc/analyzer/ChangeLog
+++ b/gcc/analyzer/ChangeLog
@@ -1,3 +1,20 @@
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105365
+	PR analyzer/105366
+	* svalue.cc
+	(cmp_cst): Rename to...
+	(cmp_csts_same_type): ...this.  Convert all recursive calls to
+	calls to...
+	(cmp_csts_and_types): ....this new function.
+	(svalue::cmp_ptr): Update for renaming of cmp_cst
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105252
+	* svalue.cc (cmp_cst): When comparing VECTOR_CSTs, compare the
+	types of the encoded elements before calling cmp_cst on them.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/analyzer/svalue.cc b/gcc/analyzer/svalue.cc
index a16563d912a..fa33e956d41 100644
--- a/gcc/analyzer/svalue.cc
+++ b/gcc/analyzer/svalue.cc
@@ -59,6 +59,8 @@ along with GCC; see the file COPYING3.  If not see
 
 namespace ana {
 
+static int cmp_csts_and_types (const_tree cst1, const_tree cst2);
+
 /* class svalue and its various subclasses.  */
 
 /* class svalue.  */
@@ -276,7 +278,7 @@ svalue::implicitly_live_p (const svalue_set *, const region_model *) const
    of the same type.  */
 
 static int
-cmp_cst (const_tree cst1, const_tree cst2)
+cmp_csts_same_type (const_tree cst1, const_tree cst2)
 {
   gcc_assert (TREE_TYPE (cst1) == TREE_TYPE (cst2));
   gcc_assert (TREE_CODE (cst1) == TREE_CODE (cst2));
@@ -295,9 +297,10 @@ cmp_cst (const_tree cst1, const_tree cst2)
 		     TREE_REAL_CST_PTR (cst2),
 		     sizeof (real_value));
     case COMPLEX_CST:
-      if (int cmp_real = cmp_cst (TREE_REALPART (cst1), TREE_REALPART (cst2)))
+      if (int cmp_real = cmp_csts_and_types (TREE_REALPART (cst1),
+					     TREE_REALPART (cst2)))
 	return cmp_real;
-      return cmp_cst (TREE_IMAGPART (cst1), TREE_IMAGPART (cst2));
+      return cmp_csts_and_types (TREE_IMAGPART (cst1), TREE_IMAGPART (cst2));
     case VECTOR_CST:
       if (int cmp_log2_npatterns
 	    = ((int)VECTOR_CST_LOG2_NPATTERNS (cst1)
@@ -309,13 +312,29 @@ cmp_cst (const_tree cst1, const_tree cst2)
 	return cmp_nelts_per_pattern;
       unsigned encoded_nelts = vector_cst_encoded_nelts (cst1);
       for (unsigned i = 0; i < encoded_nelts; i++)
-	if (int el_cmp = cmp_cst (VECTOR_CST_ENCODED_ELT (cst1, i),
-				  VECTOR_CST_ENCODED_ELT (cst2, i)))
-	  return el_cmp;
+	{
+	  const_tree elt1 = VECTOR_CST_ENCODED_ELT (cst1, i);
+	  const_tree elt2 = VECTOR_CST_ENCODED_ELT (cst2, i);
+	  if (int el_cmp = cmp_csts_and_types (elt1, elt2))
+	    return el_cmp;
+	}
       return 0;
     }
 }
 
+/* Comparator for imposing a deterministic order on constants that might
+   not be of the same type.  */
+
+static int
+cmp_csts_and_types (const_tree cst1, const_tree cst2)
+{
+  int t1 = TYPE_UID (TREE_TYPE (cst1));
+  int t2 = TYPE_UID (TREE_TYPE (cst2));
+  if (int cmp_type = t1 - t2)
+    return cmp_type;
+  return cmp_csts_same_type (cst1, cst2);
+}
+
 /* Comparator for imposing a deterministic order on svalues.  */
 
 int
@@ -347,7 +366,7 @@ svalue::cmp_ptr (const svalue *sval1, const svalue *sval2)
 	const constant_svalue *constant_sval2 = (const constant_svalue *)sval2;
 	const_tree cst1 = constant_sval1->get_constant ();
 	const_tree cst2 = constant_sval2->get_constant ();
-	return cmp_cst (cst1, cst2);
+	return cmp_csts_same_type (cst1, cst2);
       }
       break;
     case SK_UNKNOWN:
diff --git a/gcc/asan.c b/gcc/asan.c
index ca036767134..3884f111d82 100644
--- a/gcc/asan.c
+++ b/gcc/asan.c
@@ -1497,10 +1497,14 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,
   HOST_WIDE_INT off
     = m_prev_offset + ASAN_SHADOW_GRANULARITY * m_shadow_bytes.length ();
   if (off == offset)
+    /* Consecutive shadow memory byte.  */;
+  else if (offset < m_prev_offset + (HOST_WIDE_INT) (ASAN_SHADOW_GRANULARITY
+						     * RZ_BUFFER_SIZE)
+	   && !m_shadow_bytes.is_empty ())
     {
-      /* Consecutive shadow memory byte.  */
-      m_shadow_bytes.safe_push (value);
-      flush_if_full ();
+      /* Shadow memory byte with a small gap.  */
+      for (; off < offset; off += ASAN_SHADOW_GRANULARITY)
+	m_shadow_bytes.safe_push (0);
     }
   else
     {
@@ -1521,9 +1525,9 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,
       m_shadow_mem = adjust_address (m_shadow_mem, VOIDmode,
 				     diff >> ASAN_SHADOW_SHIFT);
       m_prev_offset = offset;
-      m_shadow_bytes.safe_push (value);
-      flush_if_full ();
     }
+  m_shadow_bytes.safe_push (value);
+  flush_if_full ();
 }
 
 /* Emit RTX emission of the content of the buffer.  */
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index dff48ba4655..65de3d901d3 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,12 @@
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105304
+	* c-common.c (verify_tree) [restart]: Move up to before the
+	NULL test.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 7b8f49d78dc..16fc52302e5 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -1854,12 +1854,12 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,
   enum tree_code code;
   enum tree_code_class cl;
 
+ restart:
   /* X may be NULL if it is the operand of an empty statement expression
      ({ }).  */
   if (x == NULL)
     return;
 
- restart:
   code = TREE_CODE (x);
   cl = TREE_CODE_CLASS (code);
 
diff --git a/gcc/cfgrtl.c b/gcc/cfgrtl.c
index 8fd128b471c..4fb145ee4c4 100644
--- a/gcc/cfgrtl.c
+++ b/gcc/cfgrtl.c
@@ -233,7 +233,7 @@ delete_insn_and_edges (rtx_insn *insn)
 {
   bool purge = false;
 
-  if (INSN_P (insn) && BLOCK_FOR_INSN (insn))
+  if (NONDEBUG_INSN_P (insn) && BLOCK_FOR_INSN (insn))
     {
       basic_block bb = BLOCK_FOR_INSN (insn);
       if (BB_END (bb) == insn)
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index d7c78d518bc..4e3e348513b 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -1906,7 +1906,11 @@ cgraph_node::remove (void)
   if (prev_sibling_clone)
     prev_sibling_clone->next_sibling_clone = next_sibling_clone;
   else if (clone_of)
-    clone_of->clones = next_sibling_clone;
+    {
+      clone_of->clones = next_sibling_clone;
+      if (!clone_of->analyzed && !clone_of->clones && !clones)
+	clone_of->release_body ();
+    }
   if (next_sibling_clone)
     next_sibling_clone->prev_sibling_clone = prev_sibling_clone;
   if (clones)
diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index b91eeeba101..ad62da81d31 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -1034,7 +1034,7 @@ bool aarch64_high_bits_all_ones_p (HOST_WIDE_INT);
 
 struct atomic_ool_names
 {
-    const char *str[5][4];
+    const char *str[5][5];
 };
 
 rtx aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index c155f4883cf..7e6f9d08ea3 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -21627,14 +21627,14 @@ aarch64_emit_unlikely_jump (rtx insn)
   add_reg_br_prob_note (jump, profile_probability::very_unlikely ());
 }
 
-/* We store the names of the various atomic helpers in a 5x4 array.
+/* We store the names of the various atomic helpers in a 5x5 array.
    Return the libcall function given MODE, MODEL and NAMES.  */
 
 rtx
 aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
 			const atomic_ool_names *names)
 {
-  memmodel model = memmodel_base (INTVAL (model_rtx));
+  memmodel model = memmodel_from_int (INTVAL (model_rtx));
   int mode_idx, model_idx;
 
   switch (mode)
@@ -21674,6 +21674,11 @@ aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
     case MEMMODEL_SEQ_CST:
       model_idx = 3;
       break;
+    case MEMMODEL_SYNC_ACQUIRE:
+    case MEMMODEL_SYNC_RELEASE:
+    case MEMMODEL_SYNC_SEQ_CST:
+      model_idx = 4;
+      break;
     default:
       gcc_unreachable ();
     }
@@ -21686,7 +21691,8 @@ aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
   { "__aarch64_" #B #N "_relax", \
     "__aarch64_" #B #N "_acq", \
     "__aarch64_" #B #N "_rel", \
-    "__aarch64_" #B #N "_acq_rel" }
+    "__aarch64_" #B #N "_acq_rel", \
+    "__aarch64_" #B #N "_sync" }
 
 #define DEF4(B)  DEF0(B, 1), DEF0(B, 2), DEF0(B, 4), DEF0(B, 8), \
 		 { NULL, NULL, NULL, NULL }
diff --git a/gcc/config/i386/avx512fintrin.h b/gcc/config/i386/avx512fintrin.h
index 515ee0c1728..1ce6bade1b4 100644
--- a/gcc/config/i386/avx512fintrin.h
+++ b/gcc/config/i386/avx512fintrin.h
@@ -3244,31 +3244,67 @@ _mm_maskz_scalef_round_ss (__mmask8 __U, __m128 __A, __m128 __B, const int __R)
 						      (__mmask8) __U, __R);
 }
 #else
-#define _mm512_scalef_round_pd(A, B, C)            \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_undefined_pd(), -1, C)
-
-#define _mm512_mask_scalef_round_pd(W, U, A, B, C) \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, W, U, C)
-
-#define _mm512_maskz_scalef_round_pd(U, A, B, C)   \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_setzero_pd(), U, C)
+#define _mm512_scalef_round_pd(A, B, C)					\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_undefined_pd(),	\
+				   -1, (C)))
+
+#define _mm512_mask_scalef_round_pd(W, U, A, B, C)			\
+  ((__m512d) __builtin_ia32_scalefpd512_mask((A), (B), (W), (U), (C)))
+
+#define _mm512_maskz_scalef_round_pd(U, A, B, C)			\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_setzero_pd(),	\
+				   (U), (C)))
+
+#define _mm512_scalef_round_ps(A, B, C)					\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_undefined_ps(),	\
+				   -1, (C)))
+
+#define _mm512_mask_scalef_round_ps(W, U, A, B, C)			\
+  ((__m512) __builtin_ia32_scalefps512_mask((A), (B), (W), (U), (C)))
+
+#define _mm512_maskz_scalef_round_ps(U, A, B, C)			\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_setzero_ps(),	\
+				   (U), (C)))
+
+#define _mm_scalef_round_sd(A, B, C)					\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_undefined_pd (),	\
+				       -1, (C)))
 
-#define _mm512_scalef_round_ps(A, B, C)            \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_undefined_ps(), -1, C)
+#define _mm_scalef_round_ss(A, B, C)					\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_undefined_ps (),	\
+				       -1, (C)))
 
-#define _mm512_mask_scalef_round_ps(W, U, A, B, C) \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, W, U, C)
+#define _mm_mask_scalef_round_sd(W, U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B), (W), (U), (C)))
 
-#define _mm512_maskz_scalef_round_ps(U, A, B, C)   \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_setzero_ps(), U, C)
+#define _mm_mask_scalef_round_ss(W, U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B), (W), (U), (C)))
 
-#define _mm_scalef_round_sd(A, B, C)            \
-    (__m128d)__builtin_ia32_scalefsd_mask_round (A, B, \
-	(__v2df)_mm_setzero_pd (), -1, C)
+#define _mm_maskz_scalef_round_sd(U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_setzero_pd (),	\
+				       (U), (C)))
 
-#define _mm_scalef_round_ss(A, B, C)            \
-    (__m128)__builtin_ia32_scalefss_mask_round (A, B, \
-	(__v4sf)_mm_setzero_ps (), -1, C)
+#define _mm_maskz_scalef_round_ss(U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_setzero_ps (),	\
+				       (U), (C)))
 #endif
 
 #define _mm_mask_scalef_sd(W, U, A, B) \
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 48300af9a09..a90f64e9d39 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -3607,7 +3607,7 @@ zero_call_used_regno_mode (const unsigned int regno)
   else if (MASK_REGNO_P (regno))
     return HImode;
   else if (MMX_REGNO_P (regno))
-    return V4HImode;
+    return V2SImode;
   else
     gcc_unreachable ();
 }
@@ -3726,19 +3726,12 @@ zero_all_mm_registers (HARD_REG_SET need_zeroed_hardregs,
   if (!need_zero_all_mm)
     return false;
 
-  rtx zero_mmx = NULL_RTX;
-  machine_mode mode = V4HImode;
+  machine_mode mode = V2SImode;
   for (unsigned int regno = FIRST_MMX_REG; regno <= LAST_MMX_REG; regno++)
     if (regno != ret_mmx_regno)
       {
 	rtx reg = gen_rtx_REG (mode, regno);
-	if (zero_mmx == NULL_RTX)
-	  {
-	    zero_mmx = reg;
-	    emit_insn (gen_rtx_SET (reg, CONST0_RTX (mode)));
-	  }
-	else
-	  emit_move_insn (reg, zero_mmx);
+	emit_insn (gen_rtx_SET (reg, CONST0_RTX (mode)));
       }
   return true;
 }
@@ -3800,11 +3793,6 @@ ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)
 
   /* Now, generate instructions to zero all the other registers.  */
 
-  rtx zero_gpr = NULL_RTX;
-  rtx zero_vector = NULL_RTX;
-  rtx zero_mask = NULL_RTX;
-  rtx zero_mmx = NULL_RTX;
-
   for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
     {
       if (!TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))
@@ -3815,59 +3803,34 @@ ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)
 
       SET_HARD_REG_BIT (zeroed_hardregs, regno);
 
-      rtx reg, tmp, zero_rtx;
       machine_mode mode = zero_call_used_regno_mode (regno);
 
-      reg = gen_rtx_REG (mode, regno);
-      zero_rtx = CONST0_RTX (mode);
+      rtx reg = gen_rtx_REG (mode, regno);
+      rtx tmp = gen_rtx_SET (reg, CONST0_RTX (mode));
 
-      if (mode == SImode)
-	if (zero_gpr == NULL_RTX)
-	  {
-	    zero_gpr = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    if (!TARGET_USE_MOV0 || optimize_insn_for_size_p ())
-	      {
-		rtx clob = gen_rtx_CLOBBER (VOIDmode,
-					    gen_rtx_REG (CCmode,
-							 FLAGS_REG));
-		tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
-							     tmp,
-							     clob));
-	      }
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_gpr);
-      else if (mode == V4SFmode)
-	if (zero_vector == NULL_RTX)
-	  {
-	    zero_vector = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_vector);
-      else if (mode == HImode)
-	if (zero_mask == NULL_RTX)
-	  {
-	    zero_mask = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_mask);
-      else if (mode == V4HImode)
-	if (zero_mmx == NULL_RTX)
-	  {
-	    zero_mmx = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_mmx);
-      else
-	gcc_unreachable ();
+      switch (mode)
+	{
+	case E_SImode:
+	  if (!TARGET_USE_MOV0 || optimize_insn_for_size_p ())
+	    {
+	      rtx clob = gen_rtx_CLOBBER (VOIDmode,
+					  gen_rtx_REG (CCmode,
+						       FLAGS_REG));
+	      tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
+							   tmp,
+							   clob));
+	    }
+	  /* FALLTHRU.  */
+
+	case E_V4SFmode:
+	case E_HImode:
+	case E_V2SImode:
+	  emit_insn (tmp);
+	  break;
+
+	default:
+	  gcc_unreachable ();
+	}
     }
   return zeroed_hardregs;
 }
@@ -4754,6 +4717,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
 	{
 	  int i, prev_size = 0;
 	  tree temp = create_tmp_var (type, "va_arg_tmp");
+	  TREE_ADDRESSABLE (temp) = 1;
 
 	  /* addr = &temp; */
 	  t = build1 (ADDR_EXPR, build_pointer_type (type), temp);
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index fcfcba0134d..79dcb6b26d5 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -17256,9 +17256,9 @@
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn_and_split "ssse3_palignrdi"
-  [(set (match_operand:DI 0 "register_operand" "=y,x,Yv")
-	(unspec:DI [(match_operand:DI 1 "register_operand" "0,0,Yv")
-		    (match_operand:DI 2 "register_mmxmem_operand" "ym,x,Yv")
+  [(set (match_operand:DI 0 "register_operand" "=y,x,Yw")
+	(unspec:DI [(match_operand:DI 1 "register_operand" "0,0,Yw")
+		    (match_operand:DI 2 "register_mmxmem_operand" "ym,x,Yw")
 		    (match_operand:SI 3 "const_0_to_255_mul_8_operand" "n,n,n")]
 		   UNSPEC_PALIGNR))]
   "(TARGET_MMX || TARGET_MMX_WITH_SSE) && TARGET_SSSE3"
diff --git a/gcc/config/riscv/arch-canonicalize b/gcc/config/riscv/arch-canonicalize
index 3a91cfe687f..0bdf6aafe35 100755
--- a/gcc/config/riscv/arch-canonicalize
+++ b/gcc/config/riscv/arch-canonicalize
@@ -45,9 +45,11 @@ def arch_canonicalize(arch, isa_spec):
   is_isa_spec_2p2 = isa_spec == '2.2'
   new_arch = ""
   extra_long_ext = []
+  std_exts = []
   if arch[:5] in ['rv32e', 'rv32i', 'rv32g', 'rv64i', 'rv64g']:
-    new_arch = arch[:5].replace("g", "imafd")
+    new_arch = arch[:5].replace("g", "i")
     if arch[:5] in ['rv32g', 'rv64g']:
+      std_exts = ['m', 'a', 'f', 'd']
       if not is_isa_spec_2p2:
         extra_long_ext = ['zicsr', 'zifencei']
   else:
@@ -61,10 +63,10 @@ def arch_canonicalize(arch, isa_spec):
   if long_ext_prefixes_idx:
     first_long_ext_idx = min(long_ext_prefixes_idx)
     long_exts = arch[first_long_ext_idx:].split("_")
-    std_exts = list(arch[5:first_long_ext_idx])
+    std_exts += list(arch[5:first_long_ext_idx])
   else:
     long_exts = []
-    std_exts = list(arch[5:])
+    std_exts += list(arch[5:])
 
   long_exts += extra_long_ext
 
diff --git a/gcc/config/rs6000/bmi2intrin.h b/gcc/config/rs6000/bmi2intrin.h
index 5b7b761b9d5..03299e6cccd 100644
--- a/gcc/config/rs6000/bmi2intrin.h
+++ b/gcc/config/rs6000/bmi2intrin.h
@@ -77,39 +77,39 @@ extern __inline unsigned long long
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _pdep_u64 (unsigned long long __X, unsigned long long __M)
 {
-  unsigned long result = 0x0UL;
-  const unsigned long mask = 0x8000000000000000UL;
-  unsigned long m = __M;
-  unsigned long c, t;
-  unsigned long p;
+  unsigned long __result = 0x0UL;
+  const unsigned long __mask = 0x8000000000000000UL;
+  unsigned long __m = __M;
+  unsigned long __c, __t;
+  unsigned long __p;
 
   /* The pop-count of the mask gives the number of the bits from
    source to process.  This is also needed to shift bits from the
    source into the correct position for the result.  */
-  p = 64 - __builtin_popcountl (__M);
+  __p = 64 - __builtin_popcountl (__M);
 
   /* The loop is for the number of '1' bits in the mask and clearing
    each mask bit as it is processed.  */
-  while (m != 0)
+  while (__m != 0)
     {
-      c = __builtin_clzl (m);
-      t = __X << (p - c);
-      m ^= (mask >> c);
-      result |= (t & (mask >> c));
-      p++;
+      __c = __builtin_clzl (__m);
+      __t = __X << (__p - __c);
+      __m ^= (__mask >> __c);
+      __result |= (__t & (__mask >> __c));
+      __p++;
     }
-  return (result);
+  return __result;
 }
 
 extern __inline unsigned long long
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _pext_u64 (unsigned long long __X, unsigned long long __M)
 {
-  unsigned long p = 0x4040404040404040UL; // initial bit permute control
-  const unsigned long mask = 0x8000000000000000UL;
-  unsigned long m = __M;
-  unsigned long c;
-  unsigned long result;
+  unsigned long __p = 0x4040404040404040UL; // initial bit permute control
+  const unsigned long __mask = 0x8000000000000000UL;
+  unsigned long __m = __M;
+  unsigned long __c;
+  unsigned long __result;
 
   /* if the mask is constant and selects 8 bits or less we can use
    the Power8 Bit permute instruction.  */
@@ -118,34 +118,34 @@ _pext_u64 (unsigned long long __X, unsigned long long __M)
       /* Also if the pext mask is constant, then the popcount is
        constant, we can evaluate the following loop at compile
        time and use a constant bit permute vector.  */
-      for (long i = 0; i < __builtin_popcountl (__M); i++)
+      for (long __i = 0; __i < __builtin_popcountl (__M); __i++)
 	{
-	  c = __builtin_clzl (m);
-	  p = (p << 8) | c;
-	  m ^= (mask >> c);
+	  __c = __builtin_clzl (__m);
+	  __p = (__p << 8) | __c;
+	  __m ^= (__mask >> __c);
 	}
-      result = __builtin_bpermd (p, __X);
+      __result = __builtin_bpermd (__p, __X);
     }
   else
     {
-      p = 64 - __builtin_popcountl (__M);
-      result = 0;
+      __p = 64 - __builtin_popcountl (__M);
+      __result = 0;
       /* We could a use a for loop here, but that combined with
        -funroll-loops can expand to a lot of code.  The while
        loop avoids unrolling and the compiler commons the xor
-       from clearing the mask bit with the (m != 0) test.  The
+       from clearing the mask bit with the (__m != 0) test.  The
        result is a more compact loop setup and body.  */
-      while (m != 0)
+      while (__m != 0)
 	{
-	  unsigned long t;
-	  c = __builtin_clzl (m);
-	  t = (__X & (mask >> c)) >> (p - c);
-	  m ^= (mask >> c);
-	  result |= (t);
-	  p++;
+	  unsigned long __t;
+	  __c = __builtin_clzl (__m);
+	  __t = (__X & (__mask >> __c)) >> (__p - __c);
+	  __m ^= (__mask >> __c);
+	  __result |= (__t);
+	  __p++;
 	}
     }
-  return (result);
+  return __result;
 }
 
 /* these 32-bit implementations depend on 64-bit pdep/pext
diff --git a/gcc/config/rs6000/emmintrin.h b/gcc/config/rs6000/emmintrin.h
index ce1287edf78..991368095dd 100644
--- a/gcc/config/rs6000/emmintrin.h
+++ b/gcc/config/rs6000/emmintrin.h
@@ -141,9 +141,9 @@ _mm_setzero_pd (void)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_move_sd (__m128d __A, __m128d __B)
 {
-  __v2df result = (__v2df) __A;
-  result [0] = ((__v2df) __B)[0];
-  return (__m128d) result;
+  __v2df __result = (__v2df) __A;
+  __result [0] = ((__v2df) __B)[0];
+  return (__m128d) __result;
 }
 
 /* Load two DPFP values from P.  The address must be 16-byte aligned.  */
@@ -329,9 +329,9 @@ _mm_sqrt_pd (__m128d __A)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sqrt_sd (__m128d __A, __m128d __B)
 {
-  __v2df c;
-  c = vec_sqrt ((__v2df) _mm_set1_pd (__B[0]));
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __c;
+  __c = vec_sqrt ((__v2df) _mm_set1_pd (__B[0]));
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -343,11 +343,11 @@ _mm_min_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_sd (__m128d __A, __m128d __B)
 {
-  __v2df a, b, c;
-  a = vec_splats (__A[0]);
-  b = vec_splats (__B[0]);
-  c = vec_min (a, b);
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __a, __b, __c;
+  __a = vec_splats (__A[0]);
+  __b = vec_splats (__B[0]);
+  __c = vec_min (__a, __b);
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -359,11 +359,11 @@ _mm_max_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_sd (__m128d __A, __m128d __B)
 {
-  __v2df a, b, c;
-  a = vec_splats (__A[0]);
-  b = vec_splats (__B[0]);
-  c = vec_max (a, b);
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __a, __b, __c;
+  __a = vec_splats (__A[0]);
+  __b = vec_splats (__B[0]);
+  __c = vec_max (__a, __b);
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -399,8 +399,8 @@ _mm_cmpge_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_pd (__m128d __A, __m128d __B)
 {
-  __v2df temp = (__v2df) vec_cmpeq ((__v2df) __A, (__v2df)__B);
-  return ((__m128d)vec_nor (temp, temp));
+  __v2df __temp = (__v2df) vec_cmpeq ((__v2df) __A, (__v2df)__B);
+  return ((__m128d)vec_nor (__temp, __temp));
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -427,26 +427,18 @@ _mm_cmpnge_pd (__m128d __A, __m128d __B)
   return ((__m128d)vec_cmplt ((__v2df) __A, (__v2df) __B));
 }
 
+#if _ARCH_PWR8
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_pd (__m128d __A, __m128d __B)
 {
-#if _ARCH_PWR8
   __v2du c, d;
   /* Compare against self will return false (0's) if NAN.  */
   c = (__v2du)vec_cmpeq (__A, __A);
   d = (__v2du)vec_cmpeq (__B, __B);
-#else
-  __v2du a, b;
-  __v2du c, d;
-  const __v2du double_exp_mask  = {0x7ff0000000000000, 0x7ff0000000000000};
-  a = (__v2du)vec_abs ((__v2df)__A);
-  b = (__v2du)vec_abs ((__v2df)__B);
-  c = (__v2du)vec_cmpgt (double_exp_mask, a);
-  d = (__v2du)vec_cmpgt (double_exp_mask, b);
-#endif
   /* A != NAN and B != NAN.  */
   return ((__m128d)vec_and(c, d));
 }
+#endif
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_pd (__m128d __A, __m128d __B)
@@ -583,6 +575,7 @@ _mm_cmpnge_sd (__m128d __A, __m128d __B)
   return (__m128d) _mm_setr_pd (c[0], __A[1]);
 }
 
+#if _ARCH_PWR8
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_sd (__m128d __A, __m128d __B)
 {
@@ -590,6 +583,7 @@ _mm_cmpord_sd (__m128d __A, __m128d __B)
   r = (__v2df)_mm_cmpord_pd (vec_splats (__A[0]), vec_splats (__B[0]));
   return (__m128d) _mm_setr_pd (r[0], ((__v2df)__A)[1]);
 }
+#endif
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_sd (__m128d __A, __m128d __B)
@@ -855,12 +849,12 @@ _mm_setzero_si128 (void)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtepi32_pd (__m128i __A)
 {
-  __v2di val;
+  __v2di __val;
   /* For LE need to generate Vector Unpack Low Signed Word.
      Which is generated from unpackh.  */
-  val = (__v2di)vec_unpackh ((__v4si)__A);
+  __val = (__v2di)vec_unpackh ((__v4si)__A);
 
-  return (__m128d)vec_ctf (val, 0);
+  return (__m128d)vec_ctf (__val, 0);
 }
 #endif
 
@@ -873,116 +867,116 @@ _mm_cvtepi32_ps (__m128i __A)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_epi32 (__m128d __A)
 {
-  __v2df rounded = vec_rint (__A);
-  __v4si result, temp;
-  const __v4si vzero =
+  __v2df __rounded = vec_rint (__A);
+  __v4si __result, __temp;
+  const __v4si __vzero =
     { 0, 0, 0, 0 };
 
   /* VSX Vector truncate Double-Precision to integer and Convert to
    Signed Integer Word format with Saturate.  */
   __asm__(
       "xvcvdpsxws %x0,%x1"
-      : "=wa" (temp)
-      : "wa" (rounded)
+      : "=wa" (__temp)
+      : "wa" (__rounded)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4si) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4si) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4si) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4si) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_pi32 (__m128d __A)
 {
-  __m128i result = _mm_cvtpd_epi32(__A);
+  __m128i __result = _mm_cvtpd_epi32(__A);
 
-  return (__m64) result[0];
+  return (__m64) __result[0];
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_ps (__m128d __A)
 {
-  __v4sf result;
-  __v4si temp;
-  const __v4si vzero = { 0, 0, 0, 0 };
+  __v4sf __result;
+  __v4si __temp;
+  const __v4si __vzero = { 0, 0, 0, 0 };
 
   __asm__(
       "xvcvdpsp %x0,%x1"
-      : "=wa" (temp)
+      : "=wa" (__temp)
       : "wa" (__A)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4sf) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4sf) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4sf) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4sf) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
-  return ((__m128)result);
+  return ((__m128)__result);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttpd_epi32 (__m128d __A)
 {
-  __v4si result;
-  __v4si temp;
-  const __v4si vzero = { 0, 0, 0, 0 };
+  __v4si __result;
+  __v4si __temp;
+  const __v4si __vzero = { 0, 0, 0, 0 };
 
   /* VSX Vector truncate Double-Precision to integer and Convert to
    Signed Integer Word format with Saturate.  */
   __asm__(
       "xvcvdpsxws %x0,%x1"
-      : "=wa" (temp)
+      : "=wa" (__temp)
       : "wa" (__A)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4si) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4si) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4si) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4si) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
 
-  return ((__m128i) result);
+  return ((__m128i) __result);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttpd_pi32 (__m128d __A)
 {
-  __m128i result = _mm_cvttpd_epi32 (__A);
+  __m128i __result = _mm_cvttpd_epi32 (__A);
 
-  return (__m64) result[0];
+  return (__m64) __result[0];
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -995,35 +989,35 @@ _mm_cvtsi128_si32 (__m128i __A)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32_pd (__m64 __A)
 {
-  __v4si temp;
-  __v2di tmp2;
-  __v2df result;
+  __v4si __temp;
+  __v2di __tmp2;
+  __v2df __result;
 
-  temp = (__v4si)vec_splats (__A);
-  tmp2 = (__v2di)vec_unpackl (temp);
-  result = vec_ctf ((__vector signed long long) tmp2, 0);
-  return (__m128d)result;
+  __temp = (__v4si)vec_splats (__A);
+  __tmp2 = (__v2di)vec_unpackl (__temp);
+  __result = vec_ctf ((__vector signed long long) __tmp2, 0);
+  return (__m128d)__result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_epi32 (__m128 __A)
 {
-  __v4sf rounded;
-  __v4si result;
+  __v4sf __rounded;
+  __v4si __result;
 
-  rounded = vec_rint((__v4sf) __A);
-  result = vec_cts (rounded, 0);
-  return (__m128i) result;
+  __rounded = vec_rint((__v4sf) __A);
+  __result = vec_cts (__rounded, 0);
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttps_epi32 (__m128 __A)
 {
-  __v4si result;
+  __v4si __result;
 
-  result = vec_cts ((__v4sf) __A, 0);
-  return (__m128i) result;
+  __result = vec_cts ((__v4sf) __A, 0);
+  return (__m128i) __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1035,48 +1029,48 @@ _mm_cvtps_pd (__m128 __A)
 #else
   /* Otherwise the compiler is not current and so need to generate the
      equivalent code.  */
-  __v4sf a = (__v4sf)__A;
-  __v4sf temp;
-  __v2df result;
+  __v4sf __a = (__v4sf)__A;
+  __v4sf __temp;
+  __v2df __result;
 #ifdef __LITTLE_ENDIAN__
   /* The input float values are in elements {[0], [1]} but the convert
      instruction needs them in elements {[1], [3]}, So we use two
      shift left double vector word immediates to get the elements
      lined up.  */
-  temp = __builtin_vsx_xxsldwi (a, a, 3);
-  temp = __builtin_vsx_xxsldwi (a, temp, 2);
+  __temp = __builtin_vsx_xxsldwi (__a, __a, 3);
+  __temp = __builtin_vsx_xxsldwi (__a, __temp, 2);
 #else
   /* The input float values are in elements {[0], [1]} but the convert
      instruction needs them in elements {[0], [2]}, So we use two
      shift left double vector word immediates to get the elements
      lined up.  */
-  temp = vec_vmrghw (a, a);
+  __temp = vec_vmrghw (__a, __a);
 #endif
   __asm__(
       " xvcvspdp %x0,%x1"
-      : "=wa" (result)
-      : "wa" (temp)
+      : "=wa" (__result)
+      : "wa" (__temp)
       : );
-  return (__m128d) result;
+  return (__m128d) __result;
 #endif
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_si32 (__m128d __A)
 {
-  __v2df rounded = vec_rint((__v2df) __A);
-  int result = ((__v2df)rounded)[0];
+  __v2df __rounded = vec_rint((__v2df) __A);
+  int __result = ((__v2df)__rounded)[0];
 
-  return result;
+  return __result;
 }
 /* Intel intrinsic.  */
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_si64 (__m128d __A)
 {
-  __v2df rounded = vec_rint ((__v2df) __A );
-  long long result = ((__v2df) rounded)[0];
+  __v2df __rounded = vec_rint ((__v2df) __A );
+  long long __result = ((__v2df) __rounded)[0];
 
-  return result;
+  return __result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1089,18 +1083,18 @@ _mm_cvtsd_si64x (__m128d __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttsd_si32 (__m128d __A)
 {
-  int result = ((__v2df)__A)[0];
+  int __result = ((__v2df)__A)[0];
 
-  return result;
+  return __result;
 }
 
 /* Intel intrinsic.  */
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttsd_si64 (__m128d __A)
 {
-  long long result = ((__v2df)__A)[0];
+  long long __result = ((__v2df)__A)[0];
 
-  return result;
+  return __result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1113,46 +1107,46 @@ _mm_cvttsd_si64x (__m128d __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_ss (__m128 __A, __m128d __B)
 {
-  __v4sf result = (__v4sf)__A;
+  __v4sf __result = (__v4sf)__A;
 
 #ifdef __LITTLE_ENDIAN__
-  __v4sf temp_s;
+  __v4sf __temp_s;
   /* Copy double element[0] to element [1] for conversion.  */
-  __v2df temp_b = vec_splat((__v2df)__B, 0);
+  __v2df __temp_b = vec_splat((__v2df)__B, 0);
 
   /* Pre-rotate __A left 3 (logically right 1) elements.  */
-  result = __builtin_vsx_xxsldwi (result, result, 3);
+  __result = __builtin_vsx_xxsldwi (__result, __result, 3);
   /* Convert double to single float scalar in a vector.  */
   __asm__(
       "xscvdpsp %x0,%x1"
-      : "=wa" (temp_s)
-      : "wa" (temp_b)
+      : "=wa" (__temp_s)
+      : "wa" (__temp_b)
       : );
   /* Shift the resulting scalar into vector element [0].  */
-  result = __builtin_vsx_xxsldwi (result, temp_s, 1);
+  __result = __builtin_vsx_xxsldwi (__result, __temp_s, 1);
 #else
-  result [0] = ((__v2df)__B)[0];
+  __result [0] = ((__v2df)__B)[0];
 #endif
-  return (__m128) result;
+  return (__m128) __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi32_sd (__m128d __A, int __B)
 {
-  __v2df result = (__v2df)__A;
-  double db = __B;
-  result [0] = db;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  double __db = __B;
+  __result [0] = __db;
+  return (__m128d)__result;
 }
 
 /* Intel intrinsic.  */
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi64_sd (__m128d __A, long long __B)
 {
-  __v2df result = (__v2df)__A;
-  double db = __B;
-  result [0] = db;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  double __db = __B;
+  __result [0] = __db;
+  return (__m128d)__result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1167,45 +1161,45 @@ _mm_cvtss_sd (__m128d __A, __m128 __B)
 {
 #ifdef __LITTLE_ENDIAN__
   /* Use splat to move element [0] into position for the convert. */
-  __v4sf temp = vec_splat ((__v4sf)__B, 0);
-  __v2df res;
+  __v4sf __temp = vec_splat ((__v4sf)__B, 0);
+  __v2df __res;
   /* Convert single float scalar to double in a vector.  */
   __asm__(
       "xscvspdp %x0,%x1"
-      : "=wa" (res)
-      : "wa" (temp)
+      : "=wa" (__res)
+      : "wa" (__temp)
       : );
-  return (__m128d) vec_mergel (res, (__v2df)__A);
+  return (__m128d) vec_mergel (__res, (__v2df)__A);
 #else
-  __v2df res = (__v2df)__A;
-  res [0] = ((__v4sf)__B) [0];
-  return (__m128d) res;
+  __v2df __res = (__v2df)__A;
+  __res [0] = ((__v4sf)__B) [0];
+  return (__m128d) __res;
 #endif
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_pd(__m128d __A, __m128d __B, const int __mask)
 {
-  __vector double result;
-  const int litmsk = __mask & 0x3;
+  __vector double __result;
+  const int __litmsk = __mask & 0x3;
 
-  if (litmsk == 0)
-    result = vec_mergeh (__A, __B);
+  if (__litmsk == 0)
+    __result = vec_mergeh (__A, __B);
 #if __GNUC__ < 6
-  else if (litmsk == 1)
-    result = vec_xxpermdi (__B, __A, 2);
-  else if (litmsk == 2)
-    result = vec_xxpermdi (__B, __A, 1);
+  else if (__litmsk == 1)
+    __result = vec_xxpermdi (__B, __A, 2);
+  else if (__litmsk == 2)
+    __result = vec_xxpermdi (__B, __A, 1);
 #else
-  else if (litmsk == 1)
-    result = vec_xxpermdi (__A, __B, 2);
-  else if (litmsk == 2)
-    result = vec_xxpermdi (__A, __B, 1);
+  else if (__litmsk == 1)
+    __result = vec_xxpermdi (__A, __B, 2);
+  else if (__litmsk == 2)
+    __result = vec_xxpermdi (__A, __B, 1);
 #endif
   else
-    result = vec_mergel (__A, __B);
+    __result = vec_mergel (__A, __B);
 
-  return result;
+  return __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1223,17 +1217,17 @@ _mm_unpacklo_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_loadh_pd (__m128d __A, double const *__B)
 {
-  __v2df result = (__v2df)__A;
-  result [1] = *__B;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  __result [1] = *__B;
+  return (__m128d)__result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_loadl_pd (__m128d __A, double const *__B)
 {
-  __v2df result = (__v2df)__A;
-  result [0] = *__B;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  __result [0] = *__B;
+  return (__m128d)__result;
 }
 
 #ifdef _ARCH_PWR8
@@ -1243,8 +1237,8 @@ _mm_loadl_pd (__m128d __A, double const *__B)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_pd (__m128d  __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned int perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned int __perm_mask =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x80800040, 0x80808080, 0x80808080, 0x80808080
@@ -1253,14 +1247,14 @@ _mm_movemask_pd (__m128d  __A)
 #endif
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -1432,17 +1426,17 @@ _mm_subs_epu16 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_madd_epi16 (__m128i __A, __m128i __B)
 {
-  __vector signed int zero = {0, 0, 0, 0};
+  __vector signed int __zero = {0, 0, 0, 0};
 
-  return (__m128i) vec_vmsumshm ((__v8hi)__A, (__v8hi)__B, zero);
+  return (__m128i) vec_vmsumshm ((__v8hi)__A, (__v8hi)__B, __zero);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_epi16 (__m128i __A, __m128i __B)
 {
-  __vector signed int w0, w1;
+  __vector signed int __w0, __w1;
 
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1452,9 +1446,9 @@ _mm_mulhi_epi16 (__m128i __A, __m128i __B)
 #endif
     };
 
-  w0 = vec_vmulesh ((__v8hi)__A, (__v8hi)__B);
-  w1 = vec_vmulosh ((__v8hi)__A, (__v8hi)__B);
-  return (__m128i) vec_perm (w0, w1, xform1);
+  __w0 = vec_vmulesh ((__v8hi)__A, (__v8hi)__B);
+  __w1 = vec_vmulosh ((__v8hi)__A, (__v8hi)__B);
+  return (__m128i) vec_perm (__w0, __w1, __xform1);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1466,34 +1460,34 @@ _mm_mullo_epi16 (__m128i __A, __m128i __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mul_su32 (__m64 __A, __m64 __B)
 {
-  unsigned int a = __A;
-  unsigned int b = __B;
+  unsigned int __a = __A;
+  unsigned int __b = __B;
 
-  return ((__m64)a * (__m64)b);
+  return ((__m64)__a * (__m64)__b);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mul_epu32 (__m128i __A, __m128i __B)
 {
-#if __GNUC__ < 8
-  __v2du result;
+#if __GNUC__ < 8 || !defined (_ARCH_PWR8)
+  __v2du __result;
 
 #ifdef __LITTLE_ENDIAN__
   /* VMX Vector Multiply Odd Unsigned Word.  */
   __asm__(
       "vmulouw %0,%1,%2"
-      : "=v" (result)
+      : "=v" (__result)
       : "v" (__A), "v" (__B)
       : );
 #else
   /* VMX Vector Multiply Even Unsigned Word.  */
   __asm__(
       "vmuleuw %0,%1,%2"
-      : "=v" (result)
+      : "=v" (__result)
       : "v" (__A), "v" (__B)
       : );
 #endif
-  return (__m128i) result;
+  return (__m128i) __result;
 #else
   return (__m128i) vec_mule ((__v4su)__A, (__v4su)__B);
 #endif
@@ -1502,122 +1496,122 @@ _mm_mul_epu32 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi16 (__m128i __A, int __B)
 {
-  __v8hu lshift;
-  __v8hi result = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v8hu __lshift;
+  __v8hi __result = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__B >= 0 && __B < 16)
     {
       if (__builtin_constant_p(__B))
-	lshift = (__v8hu) vec_splat_s16(__B);
+	__lshift = (__v8hu) vec_splat_s16(__B);
       else
-	lshift = vec_splats ((unsigned short) __B);
+	__lshift = vec_splats ((unsigned short) __B);
 
-      result = vec_sl ((__v8hi) __A, lshift);
+      __result = vec_sl ((__v8hi) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi32 (__m128i __A, int __B)
 {
-  __v4su lshift;
-  __v4si result = { 0, 0, 0, 0 };
+  __v4su __lshift;
+  __v4si __result = { 0, 0, 0, 0 };
 
   if (__B >= 0 && __B < 32)
     {
       if (__builtin_constant_p(__B) && __B < 16)
-	lshift = (__v4su) vec_splat_s32(__B);
+	__lshift = (__v4su) vec_splat_s32(__B);
       else
-	lshift = vec_splats ((unsigned int) __B);
+	__lshift = vec_splats ((unsigned int) __B);
 
-      result = vec_sl ((__v4si) __A, lshift);
+      __result = vec_sl ((__v4si) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi64 (__m128i __A, int __B)
 {
-  __v2du lshift;
-  __v2di result = { 0, 0 };
+  __v2du __lshift;
+  __v2di __result = { 0, 0 };
 
   if (__B >= 0 && __B < 64)
     {
       if (__builtin_constant_p(__B) && __B < 16)
-	lshift = (__v2du) vec_splat_s32(__B);
+	__lshift = (__v2du) vec_splat_s32(__B);
       else
-	lshift = (__v2du) vec_splats ((unsigned int) __B);
+	__lshift = (__v2du) vec_splats ((unsigned int) __B);
 
-      result = vec_sl ((__v2di) __A, lshift);
+      __result = vec_sl ((__v2di) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srai_epi16 (__m128i __A, int __B)
 {
-  __v8hu rshift = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hi result;
+  __v8hu __rshift = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hi __result;
 
   if (__B < 16)
     {
       if (__builtin_constant_p(__B))
-	rshift = (__v8hu) vec_splat_s16(__B);
+	__rshift = (__v8hu) vec_splat_s16(__B);
       else
-	rshift = vec_splats ((unsigned short) __B);
+	__rshift = vec_splats ((unsigned short) __B);
     }
-  result = vec_sra ((__v8hi) __A, rshift);
+  __result = vec_sra ((__v8hi) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srai_epi32 (__m128i __A, int __B)
 {
-  __v4su rshift = { 31, 31, 31, 31 };
-  __v4si result;
+  __v4su __rshift = { 31, 31, 31, 31 };
+  __v4si __result;
 
   if (__B < 32)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v4su) vec_splat_s32(__B);
+	      __rshift = (__v4su) vec_splat_s32(__B);
 	    else
-	      rshift = (__v4su) vec_splats((unsigned int)__B);
+	      __rshift = (__v4su) vec_splats((unsigned int)__B);
 	}
       else
-	rshift = vec_splats ((unsigned int) __B);
+	__rshift = vec_splats ((unsigned int) __B);
     }
-  result = vec_sra ((__v4si) __A, rshift);
+  __result = vec_sra ((__v4si) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_bslli_si128 (__m128i __A, const int __N)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__N < 16)
-    result = vec_sld ((__v16qu) __A, zeros, __N);
+    __result = vec_sld ((__v16qu) __A, __zeros, __N);
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_bsrli_si128 (__m128i __A, const int __N)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__N < 16)
 #ifdef __LITTLE_ENDIAN__
@@ -1625,21 +1619,21 @@ _mm_bsrli_si128 (__m128i __A, const int __N)
       /* Would like to use Vector Shift Left Double by Octet
 	 Immediate here to use the immediate form and avoid
 	 load of __N * 8 value into a separate VR.  */
-      result = vec_sld (zeros, (__v16qu) __A, (16 - __N));
+      __result = vec_sld (__zeros, (__v16qu) __A, (16 - __N));
     else
 #endif
       {
-	__v16qu shift = vec_splats((unsigned char)(__N*8));
+	__v16qu __shift = vec_splats((unsigned char)(__N*8));
 #ifdef __LITTLE_ENDIAN__
-	result = vec_sro ((__v16qu)__A, shift);
+	__result = vec_sro ((__v16qu)__A, __shift);
 #else
-	result = vec_slo ((__v16qu)__A, shift);
+	__result = vec_slo ((__v16qu)__A, __shift);
 #endif
       }
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1651,239 +1645,239 @@ _mm_srli_si128 (__m128i __A, const int __N)
 extern __inline  __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_si128 (__m128i __A, const int _imm5)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (_imm5 < 16)
 #ifdef __LITTLE_ENDIAN__
-    result = vec_sld ((__v16qu) __A, zeros, _imm5);
+    __result = vec_sld ((__v16qu) __A, __zeros, _imm5);
 #else
-    result = vec_sld (zeros, (__v16qu) __A, (16 - _imm5));
+    __result = vec_sld (__zeros, (__v16qu) __A, (16 - _imm5));
 #endif
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 
 _mm_srli_epi16 (__m128i  __A, int __B)
 {
-  __v8hu rshift;
-  __v8hi result = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v8hu __rshift;
+  __v8hi __result = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__B < 16)
     {
       if (__builtin_constant_p(__B))
-	rshift = (__v8hu) vec_splat_s16(__B);
+	__rshift = (__v8hu) vec_splat_s16(__B);
       else
-	rshift = vec_splats ((unsigned short) __B);
+	__rshift = vec_splats ((unsigned short) __B);
 
-      result = vec_sr ((__v8hi) __A, rshift);
+      __result = vec_sr ((__v8hi) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srli_epi32 (__m128i __A, int __B)
 {
-  __v4su rshift;
-  __v4si result = { 0, 0, 0, 0 };
+  __v4su __rshift;
+  __v4si __result = { 0, 0, 0, 0 };
 
   if (__B < 32)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v4su) vec_splat_s32(__B);
+	      __rshift = (__v4su) vec_splat_s32(__B);
 	    else
-	      rshift = (__v4su) vec_splats((unsigned int)__B);
+	      __rshift = (__v4su) vec_splats((unsigned int)__B);
 	}
       else
-	rshift = vec_splats ((unsigned int) __B);
+	__rshift = vec_splats ((unsigned int) __B);
 
-      result = vec_sr ((__v4si) __A, rshift);
+      __result = vec_sr ((__v4si) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srli_epi64 (__m128i __A, int __B)
 {
-  __v2du rshift;
-  __v2di result = { 0, 0 };
+  __v2du __rshift;
+  __v2di __result = { 0, 0 };
 
   if (__B < 64)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v2du) vec_splat_s32(__B);
+	      __rshift = (__v2du) vec_splat_s32(__B);
 	    else
-	      rshift = (__v2du) vec_splats((unsigned long long)__B);
+	      __rshift = (__v2du) vec_splats((unsigned long long)__B);
 	}
       else
-	rshift = (__v2du) vec_splats ((unsigned int) __B);
+	__rshift = (__v2du) vec_splats ((unsigned int) __B);
 
-      result = vec_sr ((__v2di) __A, rshift);
+      __result = vec_sr ((__v2di) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi16 (__m128i __A, __m128i __B)
 {
-  __v8hu lshift;
-  __vector __bool short shmask;
-  const __v8hu shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu result;
+  __v8hu __lshift;
+  __vector __bool short __shmask;
+  const __v8hu __shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __result;
 
 #ifdef __LITTLE_ENDIAN__
-  lshift = vec_splat ((__v8hu) __B, 0);
+  __lshift = vec_splat ((__v8hu) __B, 0);
 #else
-  lshift = vec_splat ((__v8hu) __B, 3);
+  __lshift = vec_splat ((__v8hu) __B, 3);
 #endif
-  shmask = vec_cmple (lshift, shmax);
-  result = vec_sl ((__v8hu) __A, lshift);
-  result = vec_sel ((__v8hu) shmask, result, shmask);
+  __shmask = vec_cmple (__lshift, __shmax);
+  __result = vec_sl ((__v8hu) __A, __lshift);
+  __result = vec_sel ((__v8hu) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi32 (__m128i __A, __m128i __B)
 {
-  __v4su lshift;
-  __vector __bool int shmask;
-  const __v4su shmax = { 32, 32, 32, 32 };
-  __v4su result;
+  __v4su __lshift;
+  __vector __bool int __shmask;
+  const __v4su __shmax = { 32, 32, 32, 32 };
+  __v4su __result;
 #ifdef __LITTLE_ENDIAN__
-  lshift = vec_splat ((__v4su) __B, 0);
+  __lshift = vec_splat ((__v4su) __B, 0);
 #else
-  lshift = vec_splat ((__v4su) __B, 1);
+  __lshift = vec_splat ((__v4su) __B, 1);
 #endif
-  shmask = vec_cmplt (lshift, shmax);
-  result = vec_sl ((__v4su) __A, lshift);
-  result = vec_sel ((__v4su) shmask, result, shmask);
+  __shmask = vec_cmplt (__lshift, __shmax);
+  __result = vec_sl ((__v4su) __A, __lshift);
+  __result = vec_sel ((__v4su) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi64 (__m128i __A, __m128i __B)
 {
-  __v2du lshift;
-  __vector __bool long long shmask;
-  const __v2du shmax = { 64, 64 };
-  __v2du result;
+  __v2du __lshift;
+  __vector __bool long long __shmask;
+  const __v2du __shmax = { 64, 64 };
+  __v2du __result;
 
-  lshift = vec_splat ((__v2du) __B, 0);
-  shmask = vec_cmplt (lshift, shmax);
-  result = vec_sl ((__v2du) __A, lshift);
-  result = vec_sel ((__v2du) shmask, result, shmask);
+  __lshift = vec_splat ((__v2du) __B, 0);
+  __shmask = vec_cmplt (__lshift, __shmax);
+  __result = vec_sl ((__v2du) __A, __lshift);
+  __result = vec_sel ((__v2du) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_epi16 (__m128i __A, __m128i __B)
 {
-  const __v8hu rshmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu rshift;
-  __v8hi result;
+  const __v8hu __rshmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __rshift;
+  __v8hi __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v8hu)__B, 0);
+  __rshift = vec_splat ((__v8hu)__B, 0);
 #else
-  rshift = vec_splat ((__v8hu)__B, 3);
+  __rshift = vec_splat ((__v8hu)__B, 3);
 #endif
-  rshift = vec_min (rshift, rshmax);
-  result = vec_sra ((__v8hi) __A, rshift);
+  __rshift = vec_min (__rshift, __rshmax);
+  __result = vec_sra ((__v8hi) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_epi32 (__m128i __A, __m128i __B)
 {
-  const __v4su rshmax = { 31, 31, 31, 31 };
-  __v4su rshift;
-  __v4si result;
+  const __v4su __rshmax = { 31, 31, 31, 31 };
+  __v4su __rshift;
+  __v4si __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v4su)__B, 0);
+  __rshift = vec_splat ((__v4su)__B, 0);
 #else
-  rshift = vec_splat ((__v4su)__B, 1);
+  __rshift = vec_splat ((__v4su)__B, 1);
 #endif
-  rshift = vec_min (rshift, rshmax);
-  result = vec_sra ((__v4si) __A, rshift);
+  __rshift = vec_min (__rshift, __rshmax);
+  __result = vec_sra ((__v4si) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi16 (__m128i __A, __m128i __B)
 {
-  __v8hu rshift;
-  __vector __bool short shmask;
-  const __v8hu shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu result;
+  __v8hu __rshift;
+  __vector __bool short __shmask;
+  const __v8hu __shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v8hu) __B, 0);
+  __rshift = vec_splat ((__v8hu) __B, 0);
 #else
-  rshift = vec_splat ((__v8hu) __B, 3);
+  __rshift = vec_splat ((__v8hu) __B, 3);
 #endif
-  shmask = vec_cmple (rshift, shmax);
-  result = vec_sr ((__v8hu) __A, rshift);
-  result = vec_sel ((__v8hu) shmask, result, shmask);
+  __shmask = vec_cmple (__rshift, __shmax);
+  __result = vec_sr ((__v8hu) __A, __rshift);
+  __result = vec_sel ((__v8hu) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi32 (__m128i __A, __m128i __B)
 {
-  __v4su rshift;
-  __vector __bool int shmask;
-  const __v4su shmax = { 32, 32, 32, 32 };
-  __v4su result;
+  __v4su __rshift;
+  __vector __bool int __shmask;
+  const __v4su __shmax = { 32, 32, 32, 32 };
+  __v4su __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v4su) __B, 0);
+  __rshift = vec_splat ((__v4su) __B, 0);
 #else
-  rshift = vec_splat ((__v4su) __B, 1);
+  __rshift = vec_splat ((__v4su) __B, 1);
 #endif
-  shmask = vec_cmplt (rshift, shmax);
-  result = vec_sr ((__v4su) __A, rshift);
-  result = vec_sel ((__v4su) shmask, result, shmask);
+  __shmask = vec_cmplt (__rshift, __shmax);
+  __result = vec_sr ((__v4su) __A, __rshift);
+  __result = vec_sel ((__v4su) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi64 (__m128i __A, __m128i __B)
 {
-  __v2du rshift;
-  __vector __bool long long shmask;
-  const __v2du shmax = { 64, 64 };
-  __v2du result;
+  __v2du __rshift;
+  __vector __bool long long __shmask;
+  const __v2du __shmax = { 64, 64 };
+  __v2du __result;
 
-  rshift = vec_splat ((__v2du) __B, 0);
-  shmask = vec_cmplt (rshift, shmax);
-  result = vec_sr ((__v2du) __A, rshift);
-  result = vec_sel ((__v2du) shmask, result, shmask);
+  __rshift = vec_splat ((__v2du) __B, 0);
+  __shmask = vec_cmplt (__rshift, __shmax);
+  __result = vec_sr ((__v2du) __A, __rshift);
+  __result = vec_sel ((__v2du) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
@@ -1998,11 +1992,11 @@ _mm_extract_epi16 (__m128i const __A, int const __N)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi16 (__m128i const __A, int const __D, int const __N)
 {
-  __v8hi result = (__v8hi)__A;
+  __v8hi __result = (__v8hi)__A;
 
-  result [(__N & 7)] = __D;
+  __result [(__N & 7)] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -2038,21 +2032,21 @@ _mm_min_epu8 (__m128i __A, __m128i __B)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_epi8 (__m128i __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned char perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned char __perm_mask =
     {
 	0x78, 0x70, 0x68, 0x60, 0x58, 0x50, 0x48, 0x40,
 	0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x08, 0x00
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -2060,8 +2054,8 @@ _mm_movemask_epi8 (__m128i __A)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_epu16 (__m128i __A, __m128i __B)
 {
-  __v4su w0, w1;
-  __v16qu xform1 = {
+  __v4su __w0, __w1;
+  __v16qu __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -2071,19 +2065,19 @@ _mm_mulhi_epu16 (__m128i __A, __m128i __B)
 #endif
     };
 
-  w0 = vec_vmuleuh ((__v8hu)__A, (__v8hu)__B);
-  w1 = vec_vmulouh ((__v8hu)__A, (__v8hu)__B);
-  return (__m128i) vec_perm (w0, w1, xform1);
+  __w0 = vec_vmuleuh ((__v8hu)__A, (__v8hu)__B);
+  __w1 = vec_vmulouh ((__v8hu)__A, (__v8hu)__B);
+  return (__m128i) vec_perm (__w0, __w1, __xform1);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shufflehi_epi16 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_98 = __mask & 0x03;
-  unsigned long element_selector_BA = (__mask >> 2) & 0x03;
-  unsigned long element_selector_DC = (__mask >> 4) & 0x03;
-  unsigned long element_selector_FE = (__mask >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_98 = __mask & 0x03;
+  unsigned long __element_selector_BA = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_DC = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_FE = (__mask >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0908, 0x0B0A, 0x0D0C, 0x0F0E
@@ -2091,33 +2085,33 @@ _mm_shufflehi_epi16 (__m128i __A, const int __mask)
 	      0x0809, 0x0A0B, 0x0C0D, 0x0E0F
 #endif
     };
-  __v2du pmask =
+  __v2du __pmask =
 #ifdef __LITTLE_ENDIAN__
       { 0x1716151413121110UL,  0UL};
 #else
       { 0x1011121314151617UL,  0UL};
 #endif
-  __m64_union t;
-  __v2du a, r;
+  __m64_union __t;
+  __v2du __a, __r;
 
-  t.as_short[0] = permute_selectors[element_selector_98];
-  t.as_short[1] = permute_selectors[element_selector_BA];
-  t.as_short[2] = permute_selectors[element_selector_DC];
-  t.as_short[3] = permute_selectors[element_selector_FE];
-  pmask[1] = t.as_m64;
-  a = (__v2du)__A;
-  r = vec_perm (a, a, (__vector unsigned char)pmask);
-  return (__m128i) r;
+  __t.as_short[0] = __permute_selectors[__element_selector_98];
+  __t.as_short[1] = __permute_selectors[__element_selector_BA];
+  __t.as_short[2] = __permute_selectors[__element_selector_DC];
+  __t.as_short[3] = __permute_selectors[__element_selector_FE];
+  __pmask[1] = __t.as_m64;
+  __a = (__v2du)__A;
+  __r = vec_perm (__a, __a, (__vector unsigned char)__pmask);
+  return (__m128i) __r;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shufflelo_epi16 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0100, 0x0302, 0x0504, 0x0706
@@ -2125,32 +2119,32 @@ _mm_shufflelo_epi16 (__m128i __A, const int __mask)
 	      0x0001, 0x0203, 0x0405, 0x0607
 #endif
     };
-  __v2du pmask =
+  __v2du __pmask =
 #ifdef __LITTLE_ENDIAN__
                  { 0UL,  0x1f1e1d1c1b1a1918UL};
 #else
                  { 0UL,  0x18191a1b1c1d1e1fUL};
 #endif
-  __m64_union t;
-  __v2du a, r;
-  t.as_short[0] = permute_selectors[element_selector_10];
-  t.as_short[1] = permute_selectors[element_selector_32];
-  t.as_short[2] = permute_selectors[element_selector_54];
-  t.as_short[3] = permute_selectors[element_selector_76];
-  pmask[0] = t.as_m64;
-  a = (__v2du)__A;
-  r = vec_perm (a, a, (__vector unsigned char)pmask);
-  return (__m128i) r;
+  __m64_union __t;
+  __v2du __a, __r;
+  __t.as_short[0] = __permute_selectors[__element_selector_10];
+  __t.as_short[1] = __permute_selectors[__element_selector_32];
+  __t.as_short[2] = __permute_selectors[__element_selector_54];
+  __t.as_short[3] = __permute_selectors[__element_selector_76];
+  __pmask[0] = __t.as_m64;
+  __a = (__v2du)__A;
+  __r = vec_perm (__a, __a, (__vector unsigned char)__pmask);
+  return (__m128i) __r;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_epi32 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned int permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned int __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C
@@ -2158,26 +2152,26 @@ _mm_shuffle_epi32 (__m128i __A, const int __mask)
       0x00010203, 0x04050607, 0x08090A0B, 0x0C0D0E0F
 #endif
     };
-  __v4su t;
+  __v4su __t;
 
-  t[0] = permute_selectors[element_selector_10];
-  t[1] = permute_selectors[element_selector_32];
-  t[2] = permute_selectors[element_selector_54] + 0x10101010;
-  t[3] = permute_selectors[element_selector_76] + 0x10101010;
-  return (__m128i)vec_perm ((__v4si) __A, (__v4si)__A, (__vector unsigned char)t);
+  __t[0] = __permute_selectors[__element_selector_10];
+  __t[1] = __permute_selectors[__element_selector_32];
+  __t[2] = __permute_selectors[__element_selector_54] + 0x10101010;
+  __t[3] = __permute_selectors[__element_selector_76] + 0x10101010;
+  return (__m128i)vec_perm ((__v4si) __A, (__v4si)__A, (__vector unsigned char)__t);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)
 {
-  __v2du hibit = { 0x7f7f7f7f7f7f7f7fUL, 0x7f7f7f7f7f7f7f7fUL};
-  __v16qu mask, tmp;
-  __m128i_u *p = (__m128i_u*)__C;
+  __v2du __hibit = { 0x7f7f7f7f7f7f7f7fUL, 0x7f7f7f7f7f7f7f7fUL};
+  __v16qu __mask, __tmp;
+  __m128i_u *__p = (__m128i_u*)__C;
 
-  tmp = (__v16qu)_mm_loadu_si128(p);
-  mask = (__v16qu)vec_cmpgt ((__v16qu)__B, (__v16qu)hibit);
-  tmp = vec_sel (tmp, (__v16qu)__A, mask);
-  _mm_storeu_si128 (p, (__m128i)tmp);
+  __tmp = (__v16qu)_mm_loadu_si128(__p);
+  __mask = (__v16qu)vec_cmpgt ((__v16qu)__B, (__v16qu)__hibit);
+  __tmp = vec_sel (__tmp, (__v16qu)__A, __mask);
+  _mm_storeu_si128 (__p, (__m128i)__tmp);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -2196,29 +2190,29 @@ _mm_avg_epu16 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sad_epu8 (__m128i __A, __m128i __B)
 {
-  __v16qu a, b;
-  __v16qu vmin, vmax, vabsdiff;
-  __v4si vsum;
-  const __v4su zero = { 0, 0, 0, 0 };
-  __v4si result;
-
-  a = (__v16qu) __A;
-  b = (__v16qu) __B;
-  vmin = vec_min (a, b);
-  vmax = vec_max (a, b);
-  vabsdiff = vec_sub (vmax, vmin);
+  __v16qu __a, __b;
+  __v16qu __vmin, __vmax, __vabsdiff;
+  __v4si __vsum;
+  const __v4su __zero = { 0, 0, 0, 0 };
+  __v4si __result;
+
+  __a = (__v16qu) __A;
+  __b = (__v16qu) __B;
+  __vmin = vec_min (__a, __b);
+  __vmax = vec_max (__a, __b);
+  __vabsdiff = vec_sub (__vmax, __vmin);
   /* Sum four groups of bytes into integers.  */
-  vsum = (__vector signed int) vec_sum4s (vabsdiff, zero);
+  __vsum = (__vector signed int) vec_sum4s (__vabsdiff, __zero);
   /* Sum across four integers with two integer results.  */
-  result = vec_sum2s (vsum, (__vector signed int) zero);
+  __result = vec_sum2s (__vsum, (__vector signed int) __zero);
   /* Rotate the sums into the correct position.  */
 #ifdef __LITTLE_ENDIAN__
-  result = vec_sld (result, result, 4);
+  __result = vec_sld (__result, __result, 4);
 #else
-  result = vec_sld (result, result, 6);
+  __result = vec_sld (__result, __result, 6);
 #endif
   /* Rotate the sums into the correct position.  */
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/mm_malloc.h b/gcc/config/rs6000/mm_malloc.h
index c04348068e0..4503e75ce18 100644
--- a/gcc/config/rs6000/mm_malloc.h
+++ b/gcc/config/rs6000/mm_malloc.h
@@ -35,28 +35,28 @@ extern "C" int posix_memalign (void **, size_t, size_t) throw ();
 #endif
 
 static __inline void *
-_mm_malloc (size_t size, size_t alignment)
+_mm_malloc (size_t __size, size_t __alignment)
 {
   /* PowerPC64 ELF V2 ABI requires quadword alignment.  */
-  size_t vec_align = sizeof (__vector float);
+  size_t __vec_align = sizeof (__vector float);
   /* Linux GLIBC malloc alignment is at least 2 X ptr size.  */
-  size_t malloc_align = (sizeof (void *) + sizeof (void *));
-  void *ptr;
-
-  if (alignment == malloc_align && alignment == vec_align)
-    return malloc (size);
-  if (alignment < vec_align)
-    alignment = vec_align;
-  if (posix_memalign (&ptr, alignment, size) == 0)
-    return ptr;
+  size_t __malloc_align = (sizeof (void *) + sizeof (void *));
+  void *__ptr;
+
+  if (__alignment == __malloc_align && __alignment == __vec_align)
+    return malloc (__size);
+  if (__alignment < __vec_align)
+    __alignment = __vec_align;
+  if (posix_memalign (&__ptr, __alignment, __size) == 0)
+    return __ptr;
   else
     return NULL;
 }
 
 static __inline void
-_mm_free (void * ptr)
+_mm_free (void * __ptr)
 {
-  free (ptr);
+  free (__ptr);
 }
 
 #endif /* _MM_MALLOC_H_INCLUDED */
diff --git a/gcc/config/rs6000/mmintrin.h b/gcc/config/rs6000/mmintrin.h
index 0bd929c5afe..a826fdd0c7f 100644
--- a/gcc/config/rs6000/mmintrin.h
+++ b/gcc/config/rs6000/mmintrin.h
@@ -170,17 +170,17 @@ _mm_cvtsi64_si64x (__m64 __i)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short vm1;
-  __vector signed char vresult;
+  __vector signed short __vm1;
+  __vector signed char __vresult;
 
-  vm1 = (__vector signed short) (__vector unsigned long long)
+  __vm1 = (__vector signed short) (__vector unsigned long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
-  vresult = vec_packs (vm1, vm1);
-  return (__m64) ((__vector long long) vresult)[0];
+  __vresult = vec_packs (__vm1, __vm1);
+  return (__m64) ((__vector long long) __vresult)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -195,17 +195,17 @@ _m_packsswb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pi32 (__m64 __m1, __m64 __m2)
 {
-  __vector signed int vm1;
-  __vector signed short vresult;
+  __vector signed int __vm1;
+  __vector signed short __vresult;
 
-  vm1 = (__vector signed int) (__vector unsigned long long)
+  __vm1 = (__vector signed int) (__vector unsigned long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
-  vresult = vec_packs (vm1, vm1);
-  return (__m64) ((__vector long long) vresult)[0];
+  __vresult = vec_packs (__vm1, __vm1);
+  return (__m64) ((__vector long long) __vresult)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -220,19 +220,19 @@ _m_packssdw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char r;
-  __vector signed short vm1 = (__vector signed short) (__vector long long)
+  __vector unsigned char __r;
+  __vector signed short __vm1 = (__vector signed short) (__vector long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
   const __vector signed short __zero = { 0 };
-  __vector __bool short __select = vec_cmplt (vm1, __zero);
-  r = vec_packs ((__vector unsigned short) vm1, (__vector unsigned short) vm1);
-  __vector __bool char packsel = vec_pack (__select, __select);
-  r = vec_sel (r, (const __vector unsigned char) __zero, packsel);
-  return (__m64) ((__vector long long) r)[0];
+  __vector __bool short __select = vec_cmplt (__vm1, __zero);
+  __r = vec_packs ((__vector unsigned short) __vm1, (__vector unsigned short) __vm1);
+  __vector __bool char __packsel = vec_pack (__select, __select);
+  __r = vec_sel (__r, (const __vector unsigned char) __zero, __packsel);
+  return (__m64) ((__vector long long) __r)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -248,28 +248,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_mergel (a, b);
-  return (__m64) ((__vector long long) c)[1];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_mergel (__a, __b);
+  return (__m64) ((__vector long long) __c)[1];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[4];
-  res.as_char[1] = m2.as_char[4];
-  res.as_char[2] = m1.as_char[5];
-  res.as_char[3] = m2.as_char[5];
-  res.as_char[4] = m1.as_char[6];
-  res.as_char[5] = m2.as_char[6];
-  res.as_char[6] = m1.as_char[7];
-  res.as_char[7] = m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[4];
+  __res.as_char[1] = __mu2.as_char[4];
+  __res.as_char[2] = __mu1.as_char[5];
+  __res.as_char[3] = __mu2.as_char[5];
+  __res.as_char[4] = __mu1.as_char[6];
+  __res.as_char[5] = __mu2.as_char[6];
+  __res.as_char[6] = __mu1.as_char[7];
+  __res.as_char[7] = __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -284,17 +284,17 @@ _m_punpckhbw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[2];
-  res.as_short[1] = m2.as_short[2];
-  res.as_short[2] = m1.as_short[3];
-  res.as_short[3] = m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[2];
+  __res.as_short[1] = __mu2.as_short[2];
+  __res.as_short[2] = __mu1.as_short[3];
+  __res.as_short[3] = __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -307,15 +307,15 @@ _m_punpckhwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[1];
-  res.as_int[1] = m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[1];
+  __res.as_int[1] = __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -329,28 +329,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_mergel (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_mergel (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0];
-  res.as_char[1] = m2.as_char[0];
-  res.as_char[2] = m1.as_char[1];
-  res.as_char[3] = m2.as_char[1];
-  res.as_char[4] = m1.as_char[2];
-  res.as_char[5] = m2.as_char[2];
-  res.as_char[6] = m1.as_char[3];
-  res.as_char[7] = m2.as_char[3];
+  __res.as_char[0] = __mu1.as_char[0];
+  __res.as_char[1] = __mu2.as_char[0];
+  __res.as_char[2] = __mu1.as_char[1];
+  __res.as_char[3] = __mu2.as_char[1];
+  __res.as_char[4] = __mu1.as_char[2];
+  __res.as_char[5] = __mu2.as_char[2];
+  __res.as_char[6] = __mu1.as_char[3];
+  __res.as_char[7] = __mu2.as_char[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -364,17 +364,17 @@ _m_punpcklbw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0];
-  res.as_short[1] = m2.as_short[0];
-  res.as_short[2] = m1.as_short[1];
-  res.as_short[3] = m2.as_short[1];
+  __res.as_short[0] = __mu1.as_short[0];
+  __res.as_short[1] = __mu2.as_short[0];
+  __res.as_short[2] = __mu1.as_short[1];
+  __res.as_short[3] = __mu2.as_short[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -388,15 +388,15 @@ _m_punpcklwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0];
-  res.as_int[1] = m2.as_int[0];
+  __res.as_int[0] = __mu1.as_int[0];
+  __res.as_int[1] = __mu2.as_int[0];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -410,28 +410,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0] + m2.as_char[0];
-  res.as_char[1] = m1.as_char[1] + m2.as_char[1];
-  res.as_char[2] = m1.as_char[2] + m2.as_char[2];
-  res.as_char[3] = m1.as_char[3] + m2.as_char[3];
-  res.as_char[4] = m1.as_char[4] + m2.as_char[4];
-  res.as_char[5] = m1.as_char[5] + m2.as_char[5];
-  res.as_char[6] = m1.as_char[6] + m2.as_char[6];
-  res.as_char[7] = m1.as_char[7] + m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[0] + __mu2.as_char[0];
+  __res.as_char[1] = __mu1.as_char[1] + __mu2.as_char[1];
+  __res.as_char[2] = __mu1.as_char[2] + __mu2.as_char[2];
+  __res.as_char[3] = __mu1.as_char[3] + __mu2.as_char[3];
+  __res.as_char[4] = __mu1.as_char[4] + __mu2.as_char[4];
+  __res.as_char[5] = __mu1.as_char[5] + __mu2.as_char[5];
+  __res.as_char[6] = __mu1.as_char[6] + __mu2.as_char[6];
+  __res.as_char[7] = __mu1.as_char[7] + __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -446,24 +446,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0] + m2.as_short[0];
-  res.as_short[1] = m1.as_short[1] + m2.as_short[1];
-  res.as_short[2] = m1.as_short[2] + m2.as_short[2];
-  res.as_short[3] = m1.as_short[3] + m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[0] + __mu2.as_short[0];
+  __res.as_short[1] = __mu1.as_short[1] + __mu2.as_short[1];
+  __res.as_short[2] = __mu1.as_short[2] + __mu2.as_short[2];
+  __res.as_short[3] = __mu1.as_short[3] + __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -478,22 +478,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0] + m2.as_int[0];
-  res.as_int[1] = m1.as_int[1] + m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[0] + __mu2.as_int[0];
+  __res.as_int[1] = __mu1.as_int[1] + __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -508,28 +508,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0] - m2.as_char[0];
-  res.as_char[1] = m1.as_char[1] - m2.as_char[1];
-  res.as_char[2] = m1.as_char[2] - m2.as_char[2];
-  res.as_char[3] = m1.as_char[3] - m2.as_char[3];
-  res.as_char[4] = m1.as_char[4] - m2.as_char[4];
-  res.as_char[5] = m1.as_char[5] - m2.as_char[5];
-  res.as_char[6] = m1.as_char[6] - m2.as_char[6];
-  res.as_char[7] = m1.as_char[7] - m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[0] - __mu2.as_char[0];
+  __res.as_char[1] = __mu1.as_char[1] - __mu2.as_char[1];
+  __res.as_char[2] = __mu1.as_char[2] - __mu2.as_char[2];
+  __res.as_char[3] = __mu1.as_char[3] - __mu2.as_char[3];
+  __res.as_char[4] = __mu1.as_char[4] - __mu2.as_char[4];
+  __res.as_char[5] = __mu1.as_char[5] - __mu2.as_char[5];
+  __res.as_char[6] = __mu1.as_char[6] - __mu2.as_char[6];
+  __res.as_char[7] = __mu1.as_char[7] - __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -544,24 +544,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0] - m2.as_short[0];
-  res.as_short[1] = m1.as_short[1] - m2.as_short[1];
-  res.as_short[2] = m1.as_short[2] - m2.as_short[2];
-  res.as_short[3] = m1.as_short[3] - m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[0] - __mu2.as_short[0];
+  __res.as_short[1] = __mu1.as_short[1] - __mu2.as_short[1];
+  __res.as_short[2] = __mu1.as_short[2] - __mu2.as_short[2];
+  __res.as_short[3] = __mu1.as_short[3] - __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -576,22 +576,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0] - m2.as_int[0];
-  res.as_int[1] = m1.as_int[1] - m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[0] - __mu2.as_int[0];
+  __res.as_int[1] = __mu1.as_int[1] - __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -729,30 +729,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)
 {
 #if defined(_ARCH_PWR6) && defined(__powerpc64__)
-  __m64 res;
+  __m64 __res;
   __asm__(
       "cmpb %0,%1,%2;\n"
-      : "=r" (res)
+      : "=r" (__res)
       : "r" (__m1),
 	"r" (__m2)
       : );
-  return (res);
+  return (__res);
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = (m1.as_char[0] == m2.as_char[0])? -1: 0;
-  res.as_char[1] = (m1.as_char[1] == m2.as_char[1])? -1: 0;
-  res.as_char[2] = (m1.as_char[2] == m2.as_char[2])? -1: 0;
-  res.as_char[3] = (m1.as_char[3] == m2.as_char[3])? -1: 0;
-  res.as_char[4] = (m1.as_char[4] == m2.as_char[4])? -1: 0;
-  res.as_char[5] = (m1.as_char[5] == m2.as_char[5])? -1: 0;
-  res.as_char[6] = (m1.as_char[6] == m2.as_char[6])? -1: 0;
-  res.as_char[7] = (m1.as_char[7] == m2.as_char[7])? -1: 0;
+  __res.as_char[0] = (__mu1.as_char[0] == __mu2.as_char[0])? -1: 0;
+  __res.as_char[1] = (__mu1.as_char[1] == __mu2.as_char[1])? -1: 0;
+  __res.as_char[2] = (__mu1.as_char[2] == __mu2.as_char[2])? -1: 0;
+  __res.as_char[3] = (__mu1.as_char[3] == __mu2.as_char[3])? -1: 0;
+  __res.as_char[4] = (__mu1.as_char[4] == __mu2.as_char[4])? -1: 0;
+  __res.as_char[5] = (__mu1.as_char[5] == __mu2.as_char[5])? -1: 0;
+  __res.as_char[6] = (__mu1.as_char[6] == __mu2.as_char[6])? -1: 0;
+  __res.as_char[7] = (__mu1.as_char[7] == __mu2.as_char[7])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -766,28 +766,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = (__vector signed char)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = (__vector signed char)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = (m1.as_char[0] > m2.as_char[0])? -1: 0;
-  res.as_char[1] = (m1.as_char[1] > m2.as_char[1])? -1: 0;
-  res.as_char[2] = (m1.as_char[2] > m2.as_char[2])? -1: 0;
-  res.as_char[3] = (m1.as_char[3] > m2.as_char[3])? -1: 0;
-  res.as_char[4] = (m1.as_char[4] > m2.as_char[4])? -1: 0;
-  res.as_char[5] = (m1.as_char[5] > m2.as_char[5])? -1: 0;
-  res.as_char[6] = (m1.as_char[6] > m2.as_char[6])? -1: 0;
-  res.as_char[7] = (m1.as_char[7] > m2.as_char[7])? -1: 0;
+  __res.as_char[0] = (__mu1.as_char[0] > __mu2.as_char[0])? -1: 0;
+  __res.as_char[1] = (__mu1.as_char[1] > __mu2.as_char[1])? -1: 0;
+  __res.as_char[2] = (__mu1.as_char[2] > __mu2.as_char[2])? -1: 0;
+  __res.as_char[3] = (__mu1.as_char[3] > __mu2.as_char[3])? -1: 0;
+  __res.as_char[4] = (__mu1.as_char[4] > __mu2.as_char[4])? -1: 0;
+  __res.as_char[5] = (__mu1.as_char[5] > __mu2.as_char[5])? -1: 0;
+  __res.as_char[6] = (__mu1.as_char[6] > __mu2.as_char[6])? -1: 0;
+  __res.as_char[7] = (__mu1.as_char[7] > __mu2.as_char[7])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -803,24 +803,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = (__vector signed short)vec_cmpeq (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = (__vector signed short)vec_cmpeq (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = (m1.as_short[0] == m2.as_short[0])? -1: 0;
-  res.as_short[1] = (m1.as_short[1] == m2.as_short[1])? -1: 0;
-  res.as_short[2] = (m1.as_short[2] == m2.as_short[2])? -1: 0;
-  res.as_short[3] = (m1.as_short[3] == m2.as_short[3])? -1: 0;
+  __res.as_short[0] = (__mu1.as_short[0] == __mu2.as_short[0])? -1: 0;
+  __res.as_short[1] = (__mu1.as_short[1] == __mu2.as_short[1])? -1: 0;
+  __res.as_short[2] = (__mu1.as_short[2] == __mu2.as_short[2])? -1: 0;
+  __res.as_short[3] = (__mu1.as_short[3] == __mu2.as_short[3])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -834,24 +834,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = (__vector signed short)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = (__vector signed short)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = (m1.as_short[0] > m2.as_short[0])? -1: 0;
-  res.as_short[1] = (m1.as_short[1] > m2.as_short[1])? -1: 0;
-  res.as_short[2] = (m1.as_short[2] > m2.as_short[2])? -1: 0;
-  res.as_short[3] = (m1.as_short[3] > m2.as_short[3])? -1: 0;
+  __res.as_short[0] = (__mu1.as_short[0] > __mu2.as_short[0])? -1: 0;
+  __res.as_short[1] = (__mu1.as_short[1] > __mu2.as_short[1])? -1: 0;
+  __res.as_short[2] = (__mu1.as_short[2] > __mu2.as_short[2])? -1: 0;
+  __res.as_short[3] = (__mu1.as_short[3] > __mu2.as_short[3])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -867,22 +867,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = (__vector signed int)vec_cmpeq (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = (__vector signed int)vec_cmpeq (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = (m1.as_int[0] == m2.as_int[0])? -1: 0;
-  res.as_int[1] = (m1.as_int[1] == m2.as_int[1])? -1: 0;
+  __res.as_int[0] = (__mu1.as_int[0] == __mu2.as_int[0])? -1: 0;
+  __res.as_int[1] = (__mu1.as_int[1] == __mu2.as_int[1])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -896,22 +896,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = (__vector signed int)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = (__vector signed int)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = (m1.as_int[0] > m2.as_int[0])? -1: 0;
-  res.as_int[1] = (m1.as_int[1] > m2.as_int[1])? -1: 0;
+  __res.as_int[0] = (__mu1.as_int[0] > __mu2.as_int[0])? -1: 0;
+  __res.as_int[1] = (__mu1.as_int[1] > __mu2.as_int[1])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -927,12 +927,12 @@ _m_pcmpgtd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pi8 (__m64 __m1, __m64 __m2)
 {
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -945,12 +945,12 @@ _m_paddsb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -963,12 +963,12 @@ _m_paddsw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pu8 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -982,12 +982,12 @@ _m_paddusb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__m1);
-  b = (__vector unsigned short)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__m1);
+  __b = (__vector unsigned short)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1001,12 +1001,12 @@ _m_paddusw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pi8 (__m64 __m1, __m64 __m2)
 {
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1020,12 +1020,12 @@ _m_psubsb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1039,12 +1039,12 @@ _m_psubsw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pu8 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1058,12 +1058,12 @@ _m_psubusb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__m1);
-  b = (__vector unsigned short)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__m1);
+  __b = (__vector unsigned short)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1078,14 +1078,14 @@ _m_psubusw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_madd_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b;
-  __vector signed int c;
-  __vector signed int zero = {0, 0, 0, 0};
+  __vector signed short __a, __b;
+  __vector signed int __c;
+  __vector signed int __zero = {0, 0, 0, 0};
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_vmsumshm (a, b, zero);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_vmsumshm (__a, __b, __zero);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1098,10 +1098,10 @@ _m_pmaddwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b;
-  __vector signed short c;
-  __vector signed int w0, w1;
-  __vector unsigned char xform1 = {
+  __vector signed short __a, __b;
+  __vector signed short __c;
+  __vector signed int __w0, __w1;
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1111,14 +1111,14 @@ _mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
 #endif
     };
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
 
-  w0 = vec_vmulesh (a, b);
-  w1 = vec_vmulosh (a, b);
-  c = (__vector signed short)vec_perm (w0, w1, xform1);
+  __w0 = vec_vmulesh (__a, __b);
+  __w1 = vec_vmulosh (__a, __b);
+  __c = (__vector signed short)vec_perm (__w0, __w1, __xform1);
 
-  return (__m64) ((__vector long long) c)[0];
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1132,12 +1132,12 @@ _m_pmulhw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mullo_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = a * b;
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = __a * __b;
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1150,15 +1150,15 @@ _m_pmullw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_pi16 (__m64 __m, __m64 __count)
 {
-  __vector signed short m, r;
-  __vector unsigned short c;
+  __vector signed short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-      m = (__vector signed short)vec_splats (__m);
-      c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-      r = vec_sl (m, (__vector unsigned short)c);
-      return (__m64) ((__vector long long) r)[0];
+      __r = (__vector signed short)vec_splats (__m);
+      __c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+      __r = vec_sl (__r, (__vector unsigned short)__c);
+      return (__m64) ((__vector long long) __r)[0];
     }
   else
   return (0);
@@ -1187,13 +1187,13 @@ _m_psllwi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = m.as_int[0] << __count;
-  res.as_int[1] = m.as_int[1] << __count;
-  return (res.as_m64);
+  __res.as_int[0] = __res.as_int[0] << __count;
+  __res.as_int[1] = __res.as_int[1] << __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1219,15 +1219,15 @@ _m_pslldi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_pi16 (__m64 __m, __m64 __count)
 {
-  __vector signed short m, r;
-  __vector unsigned short c;
+  __vector signed short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-	m = (__vector signed short)vec_splats (__m);
-	c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-	r = vec_sra (m, (__vector unsigned short)c);
-        return (__m64) ((__vector long long) r)[0];
+	__r = (__vector signed short)vec_splats (__m);
+	__c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+	__r = vec_sra (__r, (__vector unsigned short)__c);
+        return (__m64) ((__vector long long) __r)[0];
     }
   else
   return (0);
@@ -1256,13 +1256,13 @@ _m_psrawi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = m.as_int[0] >> __count;
-  res.as_int[1] = m.as_int[1] >> __count;
-  return (res.as_m64);
+  __res.as_int[0] = __res.as_int[0] >> __count;
+  __res.as_int[1] = __res.as_int[1] >> __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1288,15 +1288,15 @@ _m_psradi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_pi16 (__m64 __m, __m64 __count)
 {
-  __vector unsigned short m, r;
-  __vector unsigned short c;
+  __vector unsigned short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-	m = (__vector unsigned short)vec_splats (__m);
-	c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-	r = vec_sr (m, (__vector unsigned short)c);
-        return (__m64) ((__vector long long) r)[0];
+	__r = (__vector unsigned short)vec_splats (__m);
+	__c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+	__r = vec_sr (__r, (__vector unsigned short)__c);
+        return (__m64) ((__vector long long) __r)[0];
     }
   else
     return (0);
@@ -1325,13 +1325,13 @@ _m_psrlwi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = (unsigned int)m.as_int[0] >> __count;
-  res.as_int[1] = (unsigned int)m.as_int[1] >> __count;
-  return (res.as_m64);
+  __res.as_int[0] = (unsigned int)__res.as_int[0] >> __count;
+  __res.as_int[1] = (unsigned int)__res.as_int[1] >> __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1358,24 +1358,24 @@ _m_psrldi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set_pi32 (int __i1, int __i0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i0;
-  res.as_int[1] = __i1;
-  return (res.as_m64);
+  __res.as_int[0] = __i0;
+  __res.as_int[1] = __i1;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of four 16-bit values; W0 is least significant.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_short[0] = __w0;
-  res.as_short[1] = __w1;
-  res.as_short[2] = __w2;
-  res.as_short[3] = __w3;
-  return (res.as_m64);
+  __res.as_short[0] = __w0;
+  __res.as_short[1] = __w1;
+  __res.as_short[2] = __w2;
+  __res.as_short[3] = __w3;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of eight 8-bit values; B0 is least significant.  */
@@ -1383,28 +1383,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,
 	     char __b3, char __b2, char __b1, char __b0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_char[0] = __b0;
-  res.as_char[1] = __b1;
-  res.as_char[2] = __b2;
-  res.as_char[3] = __b3;
-  res.as_char[4] = __b4;
-  res.as_char[5] = __b5;
-  res.as_char[6] = __b6;
-  res.as_char[7] = __b7;
-  return (res.as_m64);
+  __res.as_char[0] = __b0;
+  __res.as_char[1] = __b1;
+  __res.as_char[2] = __b2;
+  __res.as_char[3] = __b3;
+  __res.as_char[4] = __b4;
+  __res.as_char[5] = __b5;
+  __res.as_char[6] = __b6;
+  __res.as_char[7] = __b7;
+  return (__res.as_m64);
 }
 
 /* Similar, but with the arguments in reverse order.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_setr_pi32 (int __i0, int __i1)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i0;
-  res.as_int[1] = __i1;
-  return (res.as_m64);
+  __res.as_int[0] = __i0;
+  __res.as_int[1] = __i1;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1424,11 +1424,11 @@ _mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set1_pi32 (int __i)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i;
-  res.as_int[1] = __i;
-  return (res.as_m64);
+  __res.as_int[0] = __i;
+  __res.as_int[1] = __i;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of four 16-bit values, all elements containing W.  */
@@ -1441,13 +1441,13 @@ _mm_set1_pi16 (short __w)
   w = (__vector signed short)vec_splats (__w);
   return (__m64) ((__vector long long) w)[0];
 #else
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_short[0] = __w;
-  res.as_short[1] = __w;
-  res.as_short[2] = __w;
-  res.as_short[3] = __w;
-  return (res.as_m64);
+  __res.as_short[0] = __w;
+  __res.as_short[1] = __w;
+  __res.as_short[2] = __w;
+  __res.as_short[3] = __w;
+  return (__res.as_m64);
 #endif
 }
 
@@ -1456,22 +1456,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_set1_pi8 (signed char __b)
 {
 #if _ARCH_PWR8
-  __vector signed char b;
+  __vector signed char __res;
 
-  b = (__vector signed char)vec_splats (__b);
-  return (__m64) ((__vector long long) b)[0];
+  __res = (__vector signed char)vec_splats (__b);
+  return (__m64) ((__vector long long) __res)[0];
 #else
-  __m64_union res;
-
-  res.as_char[0] = __b;
-  res.as_char[1] = __b;
-  res.as_char[2] = __b;
-  res.as_char[3] = __b;
-  res.as_char[4] = __b;
-  res.as_char[5] = __b;
-  res.as_char[6] = __b;
-  res.as_char[7] = __b;
-  return (res.as_m64);
+  __m64_union __res;
+
+  __res.as_char[0] = __b;
+  __res.as_char[1] = __b;
+  __res.as_char[2] = __b;
+  __res.as_char[3] = __b;
+  __res.as_char[4] = __b;
+  __res.as_char[5] = __b;
+  __res.as_char[6] = __b;
+  __res.as_char[7] = __b;
+  return (__res.as_m64);
 #endif
 }
 #endif /* _MMINTRIN_H_INCLUDED */
diff --git a/gcc/config/rs6000/pmmintrin.h b/gcc/config/rs6000/pmmintrin.h
index eab712fdfa6..4d7e14f312a 100644
--- a/gcc/config/rs6000/pmmintrin.h
+++ b/gcc/config/rs6000/pmmintrin.h
@@ -58,55 +58,55 @@
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_addsub_ps (__m128 __X, __m128 __Y)
 {
-  const __v4sf even_n0 = {-0.0, 0.0, -0.0, 0.0};
-  __v4sf even_neg_Y = vec_xor(__Y, even_n0);
-  return (__m128) vec_add (__X, even_neg_Y);
+  const __v4sf __even_n0 = {-0.0, 0.0, -0.0, 0.0};
+  __v4sf __even_neg_Y = vec_xor(__Y, __even_n0);
+  return (__m128) vec_add (__X, __even_neg_Y);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_addsub_pd (__m128d __X, __m128d __Y)
 {
-  const __v2df even_n0 = {-0.0, 0.0};
-  __v2df even_neg_Y = vec_xor(__Y, even_n0);
-  return (__m128d) vec_add (__X, even_neg_Y);
+  const __v2df __even_n0 = {-0.0, 0.0};
+  __v2df __even_neg_Y = vec_xor(__Y, __even_n0);
+  return (__m128d) vec_add (__X, __even_neg_Y);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_hadd_ps (__m128 __X, __m128 __Y)
 {
-  __vector unsigned char xform2 = {
+  __vector unsigned char __xform2 = {
       0x00, 0x01, 0x02, 0x03,
       0x08, 0x09, 0x0A, 0x0B,
       0x10, 0x11, 0x12, 0x13,
       0x18, 0x19, 0x1A, 0x1B
     };
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
       0x04, 0x05, 0x06, 0x07,
       0x0C, 0x0D, 0x0E, 0x0F,
       0x14, 0x15, 0x16, 0x17,
       0x1C, 0x1D, 0x1E, 0x1F
     };
-  return (__m128) vec_add (vec_perm ((__v4sf) __X, (__v4sf) __Y, xform2),
-			   vec_perm ((__v4sf) __X, (__v4sf) __Y, xform1));
+  return (__m128) vec_add (vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform2),
+			   vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform1));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_hsub_ps (__m128 __X, __m128 __Y)
 {
-  __vector unsigned char xform2 = {
+  __vector unsigned char __xform2 = {
       0x00, 0x01, 0x02, 0x03,
       0x08, 0x09, 0x0A, 0x0B,
       0x10, 0x11, 0x12, 0x13,
       0x18, 0x19, 0x1A, 0x1B
     };
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
       0x04, 0x05, 0x06, 0x07,
       0x0C, 0x0D, 0x0E, 0x0F,
       0x14, 0x15, 0x16, 0x17,
       0x1C, 0x1D, 0x1E, 0x1F
     };
-  return (__m128) vec_sub (vec_perm ((__v4sf) __X, (__v4sf) __Y, xform2),
-			   vec_perm ((__v4sf) __X, (__v4sf) __Y, xform1));
+  return (__m128) vec_sub (vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform2),
+			   vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform1));
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 0421dc7adb3..83748d47657 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -25074,6 +25074,11 @@ rs6000_can_inline_p (tree caller, tree callee)
       else
 	caller_isa = rs6000_isa_flags;
 
+      /* Ignore -mpower8-fusion and -mpower10-fusion options for inlining
+	 purposes.  */
+      callee_isa &= ~(OPTION_MASK_P8_FUSION | OPTION_MASK_P10_FUSION);
+      explicit_isa &= ~(OPTION_MASK_P8_FUSION | OPTION_MASK_P10_FUSION);
+
       /* The callee's options must be a subset of the caller's options, i.e.
 	 a vsx function may inline an altivec function, but a no-vsx function
 	 must not inline a vsx function.  However, for those options that the
diff --git a/gcc/config/rs6000/smmintrin.h b/gcc/config/rs6000/smmintrin.h
index bdf6eb365d8..9d9df7842ba 100644
--- a/gcc/config/rs6000/smmintrin.h
+++ b/gcc/config/rs6000/smmintrin.h
@@ -45,31 +45,31 @@
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi8 (__m128i const __A, int const __D, int const __N)
 {
-  __v16qi result = (__v16qi)__A;
+  __v16qi __result = (__v16qi)__A;
 
-  result [__N & 0xf] = __D;
+  __result [__N & 0xf] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi32 (__m128i const __A, int const __D, int const __N)
 {
-  __v4si result = (__v4si)__A;
+  __v4si __result = (__v4si)__A;
 
-  result [__N & 3] = __D;
+  __result [__N & 3] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi64 (__m128i const __A, long long const __D, int const __N)
 {
-  __v2di result = (__v2di)__A;
+  __v2di __result = (__v2di)__A;
 
-  result [__N & 1] = __D;
+  __result [__N & 1] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/tmmintrin.h b/gcc/config/rs6000/tmmintrin.h
index 971511260b7..63e3f8a8262 100644
--- a/gcc/config/rs6000/tmmintrin.h
+++ b/gcc/config/rs6000/tmmintrin.h
@@ -112,8 +112,8 @@ _mm_alignr_epi8 (__m128i __A, __m128i __B, const unsigned int __count)
     {
       if (__count >= 32)
 	{
-	  const __v16qu zero = { 0 };
-	  return (__m128i) zero;
+	  const __v16qu __zero = { 0 };
+	  return (__m128i) __zero;
 	}
       else
 	{
diff --git a/gcc/config/rs6000/xmmintrin.h b/gcc/config/rs6000/xmmintrin.h
index ae1a33e8d95..ba311cbf2df 100644
--- a/gcc/config/rs6000/xmmintrin.h
+++ b/gcc/config/rs6000/xmmintrin.h
@@ -127,14 +127,14 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_loadr_ps (float const *__P)
 {
   __v4sf   __tmp;
-  __m128 result;
-  static const __vector unsigned char permute_vector =
+  __m128 __result;
+  static const __vector unsigned char __permute_vector =
     { 0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B, 0x14, 0x15, 0x16,
 	0x17, 0x10, 0x11, 0x12, 0x13 };
 
   __tmp = vec_ld (0, (__v4sf *) __P);
-  result = (__m128) vec_perm (__tmp, __tmp, permute_vector);
-  return result;
+  __result = (__m128) vec_perm (__tmp, __tmp, __permute_vector);
+  return __result;
 }
 
 /* Create a vector with all four elements equal to F.  */
@@ -184,11 +184,11 @@ extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artific
 _mm_storer_ps (float *__P, __m128 __A)
 {
   __v4sf   __tmp;
-  static const __vector unsigned char permute_vector =
+  static const __vector unsigned char __permute_vector =
     { 0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B, 0x14, 0x15, 0x16,
 	0x17, 0x10, 0x11, 0x12, 0x13 };
 
-  __tmp = (__m128) vec_perm (__A, __A, permute_vector);
+  __tmp = (__m128) vec_perm (__A, __A, __permute_vector);
 
   _mm_store_ps (__P, __tmp);
 }
@@ -218,9 +218,9 @@ _mm_set_ss (float __F)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_move_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
 
-  return (vec_sel ((__v4sf)__A, (__v4sf)__B, mask));
+  return (vec_sel ((__v4sf)__A, (__v4sf)__B, __mask));
 }
 
 /* Create a vector with element 0 as *P and the rest zero.  */
@@ -245,18 +245,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_add_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a + b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a + __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] + __B[0];
   return (__A);
@@ -267,18 +267,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_sub_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a - b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a - __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] - __B[0];
   return (__A);
@@ -289,18 +289,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_mul_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a * b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a * __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] * __B[0];
   return (__A);
@@ -311,18 +311,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_div_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a / b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a / __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] / __B[0];
   return (__A);
@@ -332,17 +332,17 @@ _mm_div_ss (__m128 __A, __m128 __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sqrt_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = vec_sqrt (a);
+  __a = vec_splat (__A, 0);
+  __c = vec_sqrt (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 /* Perform the respective operation on the four SPFP values in A and B.  */
@@ -391,81 +391,81 @@ _mm_rsqrt_ps (__m128 __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_rcp_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = _mm_rcp_ps (a);
+  __a = vec_splat (__A, 0);
+  __c = _mm_rcp_ps (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_rsqrt_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = vec_rsqrte (a);
+  __a = vec_splat (__A, 0);
+  __c = vec_rsqrte (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_ss (__m128 __A, __m128 __B)
 {
-  __v4sf a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __v4sf __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower float)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper float values) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf)__A, 0);
-  b = vec_splat ((__v4sf)__B, 0);
-  c = vec_min (a, b);
+  __a = vec_splat ((__v4sf)__A, 0);
+  __b = vec_splat ((__v4sf)__B, 0);
+  __c = vec_min (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel ((__v4sf)__A, c, mask));
+  return (vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_ss (__m128 __A, __m128 __B)
 {
-  __v4sf a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __v4sf __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower float)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper float values) we splat the lower float
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = vec_max (a, b);
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = vec_max (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel ((__v4sf)__A, c, mask));
+  return (vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_ps (__m128 __A, __m128 __B)
 {
-  __vector __bool int m = vec_cmpgt ((__v4sf) __B, (__v4sf) __A);
-  return vec_sel (__B, __A, m);
+  __vector __bool int __m = vec_cmpgt ((__v4sf) __B, (__v4sf) __A);
+  return vec_sel (__B, __A, __m);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_ps (__m128 __A, __m128 __B)
 {
-  __vector __bool int m = vec_cmpgt ((__v4sf) __A, (__v4sf) __B);
-  return vec_sel (__B, __A, m);
+  __vector __bool int __m = vec_cmpgt ((__v4sf) __A, (__v4sf) __B);
+  return vec_sel (__B, __A, __m);
 }
 
 /* Perform logical bit-wise operations on 128-bit values.  */
@@ -530,8 +530,8 @@ _mm_cmpge_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_ps (__m128  __A, __m128  __B)
 {
-  __v4sf temp = (__v4sf ) vec_cmpeq ((__v4sf) __A, (__v4sf)__B);
-  return ((__m128)vec_nor (temp, temp));
+  __v4sf __temp = (__v4sf ) vec_cmpeq ((__v4sf) __A, (__v4sf)__B);
+  return ((__m128)vec_nor (__temp, __temp));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -561,31 +561,31 @@ _mm_cmpnge_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_ps (__m128  __A, __m128  __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (float_exp_mask, a);
-  d = (__vector unsigned int) vec_cmpgt (float_exp_mask, b);
-  return ((__m128 ) vec_and (c, d));
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __a);
+  __d = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __b);
+  return ((__m128 ) vec_and (__c, __d));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_ps (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (a, float_exp_mask);
-  d = (__vector unsigned int) vec_cmpgt (b, float_exp_mask);
-  return ((__m128 ) vec_or (c, d));
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__a, __float_exp_mask);
+  __d = (__vector unsigned int) vec_cmpgt (__b, __float_exp_mask);
+  return ((__m128 ) vec_or (__c, __d));
 }
 
 /* Perform a comparison on the lower SPFP values of A and B.  If the
@@ -594,222 +594,222 @@ _mm_cmpunord_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpeq_ss (__m128  __A, __m128  __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpeq(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpeq (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmplt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmplt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmplt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmple_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmple(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmple(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpgt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpgt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpgt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpge_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpge(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpge(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpeq(a, b);
-  c = vec_nor (c, c);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpeq(__a, __b);
+  __c = vec_nor (__c, __c);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnlt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpge(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpge(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnle_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpgt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpgt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpngt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmple(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmple(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnge_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we do the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmplt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmplt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_ss (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (float_exp_mask, a);
-  d = (__vector unsigned int) vec_cmpgt (float_exp_mask, b);
-  c = vec_and (c, d);
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __a);
+  __d = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __b);
+  __c = vec_and (__c, __d);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)__c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_ss (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (a, float_exp_mask);
-  d = (__vector unsigned int) vec_cmpgt (b, float_exp_mask);
-  c = vec_or (c, d);
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__a, __float_exp_mask);
+  __d = (__vector unsigned int) vec_cmpgt (__b, __float_exp_mask);
+  __c = vec_or (__c, __d);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)__c, __mask));
 }
 
 /* Compare the lower SPFP values of A and B and return 1 if true
@@ -905,9 +905,9 @@ _mm_cvtss_f32 (__m128 __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtss_si32 (__m128 __A)
 {
-  int res;
+  int __res;
 #ifdef _ARCH_PWR8
-  double dtmp;
+  double __dtmp;
   __asm__(
 #ifdef __LITTLE_ENDIAN__
       "xxsldwi %x0,%x0,%x0,3;\n"
@@ -916,13 +916,13 @@ _mm_cvtss_si32 (__m128 __A)
       "fctiw  %2,%2;\n"
       "mfvsrd  %1,%x2;\n"
       : "+wa" (__A),
-        "=r" (res),
-        "=f" (dtmp)
+        "=r" (__res),
+        "=f" (__dtmp)
       : );
 #else
-  res = __builtin_rint(__A[0]);
+  __res = __builtin_rint(__A[0]);
 #endif
-  return (res);
+  return __res;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -938,9 +938,9 @@ _mm_cvt_ss2si (__m128 __A)
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtss_si64 (__m128 __A)
 {
-  long long res;
+  long long __res;
 #if defined (_ARCH_PWR8) && defined (__powerpc64__)
-  double dtmp;
+  double __dtmp;
   __asm__(
 #ifdef __LITTLE_ENDIAN__
       "xxsldwi %x0,%x0,%x0,3;\n"
@@ -949,13 +949,13 @@ _mm_cvtss_si64 (__m128 __A)
       "fctid  %2,%2;\n"
       "mfvsrd  %1,%x2;\n"
       : "+wa" (__A),
-        "=r" (res),
-        "=f" (dtmp)
+        "=r" (__res),
+        "=f" (__dtmp)
       : );
 #else
-  res = __builtin_llrint(__A[0]);
+  __res = __builtin_llrint(__A[0]);
 #endif
-  return (res);
+  return __res;
 }
 
 /* Microsoft intrinsic.  */
@@ -992,15 +992,15 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cvtps_pi32 (__m128 __A)
 {
   /* Splat two lower SPFP values to both halves.  */
-  __v4sf temp, rounded;
-  __vector unsigned long long result;
+  __v4sf __temp, __rounded;
+  __vector unsigned long long __result;
 
   /* Splat two lower SPFP values to both halves.  */
-  temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
-  rounded = vec_rint(temp);
-  result = (__vector unsigned long long) vec_cts (rounded, 0);
+  __temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
+  __rounded = vec_rint (__temp);
+  __result = (__vector unsigned long long) vec_cts (__rounded, 0);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1014,9 +1014,9 @@ extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artifici
 _mm_cvttss_si32 (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1030,9 +1030,9 @@ extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __ar
 _mm_cvttss_si64 (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 /* Microsoft intrinsic.  */
@@ -1040,9 +1040,9 @@ extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __ar
 _mm_cvttss_si64x (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 /* Truncate the two lower SPFP values to 32-bit integers.  Return the
@@ -1050,14 +1050,14 @@ _mm_cvttss_si64x (__m128 __A)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttps_pi32 (__m128 __A)
 {
-  __v4sf temp;
-  __vector unsigned long long result;
+  __v4sf __temp;
+  __vector unsigned long long __result;
 
   /* Splat two lower SPFP values to both halves.  */
-  temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
-  result = (__vector unsigned long long) vec_cts (temp, 0);
+  __temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
+  __result = (__vector unsigned long long) vec_cts (__temp, 0);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1070,8 +1070,8 @@ _mm_cvtt_ps2pi (__m128 __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi32_ss (__m128 __A, int __B)
 {
-  float temp = __B;
-  __A[0] = temp;
+  float __temp = __B;
+  __A[0] = __temp;
 
   return __A;
 }
@@ -1087,8 +1087,8 @@ _mm_cvt_si2ss (__m128 __A, int __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi64_ss (__m128 __A, long long __B)
 {
-  float temp = __B;
-  __A[0] = temp;
+  float __temp = __B;
+  __A[0] = __temp;
 
   return __A;
 }
@@ -1105,14 +1105,14 @@ _mm_cvtsi64x_ss (__m128 __A, long long __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32_ps (__m128        __A, __m64        __B)
 {
-  __vector signed int vm1;
-  __vector float vf1;
+  __vector signed int __vm1;
+  __vector float __vf1;
 
-  vm1 = (__vector signed int) (__vector unsigned long long) {__B, __B};
-  vf1 = (__vector float) vec_ctf (vm1, 0);
+  __vm1 = (__vector signed int) (__vector unsigned long long) {__B, __B};
+  __vf1 = (__vector float) vec_ctf (__vm1, 0);
 
   return ((__m128) (__vector unsigned long long)
-    { ((__vector unsigned long long)vf1) [0],
+    { ((__vector unsigned long long)__vf1) [0],
 	((__vector unsigned long long)__A) [1]});
 }
 
@@ -1126,54 +1126,54 @@ _mm_cvt_pi2ps (__m128 __A, __m64 __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi16_ps (__m64 __A)
 {
-  __vector signed short vs8;
-  __vector signed int vi4;
-  __vector float vf1;
+  __vector signed short __vs8;
+  __vector signed int __vi4;
+  __vector float __vf1;
 
-  vs8 = (__vector signed short) (__vector unsigned long long) { __A, __A };
-  vi4 = vec_vupklsh (vs8);
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vs8 = (__vector signed short) (__vector unsigned long long) { __A, __A };
+  __vi4 = vec_vupklsh (__vs8);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the four unsigned 16-bit values in A to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpu16_ps (__m64 __A)
 {
-  const __vector unsigned short zero =
+  const __vector unsigned short __zero =
     { 0, 0, 0, 0, 0, 0, 0, 0 };
-  __vector unsigned short vs8;
-  __vector unsigned int vi4;
-  __vector float vf1;
+  __vector unsigned short __vs8;
+  __vector unsigned int __vi4;
+  __vector float __vf1;
 
-  vs8 = (__vector unsigned short) (__vector unsigned long long) { __A, __A };
-  vi4 = (__vector unsigned int) vec_mergel
+  __vs8 = (__vector unsigned short) (__vector unsigned long long) { __A, __A };
+  __vi4 = (__vector unsigned int) vec_mergel
 #ifdef __LITTLE_ENDIAN__
-                                           (vs8, zero);
+                                           (__vs8, __zero);
 #else
-                                           (zero, vs8);
+                                           (__zero, __vs8);
 #endif
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the low four signed 8-bit values in A to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi8_ps (__m64 __A)
 {
-  __vector signed char vc16;
-  __vector signed short vs8;
-  __vector signed int vi4;
-  __vector float vf1;
+  __vector signed char __vc16;
+  __vector signed short __vs8;
+  __vector signed int __vi4;
+  __vector float __vf1;
 
-  vc16 = (__vector signed char) (__vector unsigned long long) { __A, __A };
-  vs8 = vec_vupkhsb (vc16);
-  vi4 = vec_vupkhsh (vs8);
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vc16 = (__vector signed char) (__vector unsigned long long) { __A, __A };
+  __vs8 = vec_vupkhsb (__vc16);
+  __vi4 = vec_vupkhsh (__vs8);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the low four unsigned 8-bit values in A to SPFP form.  */
@@ -1181,70 +1181,70 @@ extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __art
 
 _mm_cvtpu8_ps (__m64  __A)
 {
-  const __vector unsigned char zero =
+  const __vector unsigned char __zero =
     { 0, 0, 0, 0, 0, 0, 0, 0 };
-  __vector unsigned char vc16;
-  __vector unsigned short vs8;
-  __vector unsigned int vi4;
-  __vector float vf1;
+  __vector unsigned char __vc16;
+  __vector unsigned short __vs8;
+  __vector unsigned int __vi4;
+  __vector float __vf1;
 
-  vc16 = (__vector unsigned char) (__vector unsigned long long) { __A, __A };
+  __vc16 = (__vector unsigned char) (__vector unsigned long long) { __A, __A };
 #ifdef __LITTLE_ENDIAN__
-  vs8 = (__vector unsigned short) vec_mergel (vc16, zero);
-  vi4 = (__vector unsigned int) vec_mergeh (vs8,
-					    (__vector unsigned short) zero);
+  __vs8 = (__vector unsigned short) vec_mergel (__vc16, __zero);
+  __vi4 = (__vector unsigned int) vec_mergeh (__vs8,
+					    (__vector unsigned short) __zero);
 #else
-  vs8 = (__vector unsigned short) vec_mergel (zero, vc16);
-  vi4 = (__vector unsigned int) vec_mergeh ((__vector unsigned short) zero,
-                                            vs8);
+  __vs8 = (__vector unsigned short) vec_mergel (__zero, __vc16);
+  __vi4 = (__vector unsigned int) vec_mergeh ((__vector unsigned short) __zero,
+                                            __vs8);
 #endif
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the four signed 32-bit values in A and B to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32x2_ps (__m64 __A, __m64 __B)
 {
-  __vector signed int vi4;
-  __vector float vf4;
+  __vector signed int __vi4;
+  __vector float __vf4;
 
-  vi4 = (__vector signed int) (__vector unsigned long long) { __A, __B };
-  vf4 = (__vector float) vec_ctf (vi4, 0);
-  return (__m128) vf4;
+  __vi4 = (__vector signed int) (__vector unsigned long long) { __A, __B };
+  __vf4 = (__vector float) vec_ctf (__vi4, 0);
+  return (__m128) __vf4;
 }
 
 /* Convert the four SPFP values in A to four signed 16-bit integers.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_pi16 (__m128 __A)
 {
-  __v4sf rounded;
-  __vector signed int temp;
-  __vector unsigned long long result;
+  __v4sf __rounded;
+  __vector signed int __temp;
+  __vector unsigned long long __result;
 
-  rounded = vec_rint(__A);
-  temp = vec_cts (rounded, 0);
-  result = (__vector unsigned long long) vec_pack (temp, temp);
+  __rounded = vec_rint(__A);
+  __temp = vec_cts (__rounded, 0);
+  __result = (__vector unsigned long long) vec_pack (__temp, __temp);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 /* Convert the four SPFP values in A to four signed 8-bit integers.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_pi8 (__m128 __A)
 {
-  __v4sf rounded;
-  __vector signed int tmp_i;
-  static const __vector signed int zero = {0, 0, 0, 0};
-  __vector signed short tmp_s;
-  __vector signed char res_v;
+  __v4sf __rounded;
+  __vector signed int __tmp_i;
+  static const __vector signed int __zero = {0, 0, 0, 0};
+  __vector signed short __tmp_s;
+  __vector signed char __res_v;
 
-  rounded = vec_rint(__A);
-  tmp_i = vec_cts (rounded, 0);
-  tmp_s = vec_pack (tmp_i, zero);
-  res_v = vec_pack (tmp_s, tmp_s);
-  return (__m64) ((__vector long long) res_v)[0];
+  __rounded = vec_rint(__A);
+  __tmp_i = vec_cts (__rounded, 0);
+  __tmp_s = vec_pack (__tmp_i, __zero);
+  __res_v = vec_pack (__tmp_s, __tmp_s);
+  return (__m64) ((__vector long long) __res_v)[0];
 }
 
 /* Selects four specific SPFP values from A and B based on MASK.  */
@@ -1252,11 +1252,11 @@ extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __art
 
 _mm_shuffle_ps (__m128  __A, __m128  __B, int const __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned int permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned int __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
       0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C
@@ -1264,13 +1264,13 @@ _mm_shuffle_ps (__m128  __A, __m128  __B, int const __mask)
       0x00010203, 0x04050607, 0x08090A0B, 0x0C0D0E0F
 #endif
     };
-  __vector unsigned int t;
+  __vector unsigned int __t;
 
-  t[0] = permute_selectors[element_selector_10];
-  t[1] = permute_selectors[element_selector_32];
-  t[2] = permute_selectors[element_selector_54] + 0x10101010;
-  t[3] = permute_selectors[element_selector_76] + 0x10101010;
-  return vec_perm ((__v4sf) __A, (__v4sf)__B, (__vector unsigned char)t);
+  __t[0] = __permute_selectors[__element_selector_10];
+  __t[1] = __permute_selectors[__element_selector_32];
+  __t[2] = __permute_selectors[__element_selector_54] + 0x10101010;
+  __t[3] = __permute_selectors[__element_selector_76] + 0x10101010;
+  return vec_perm ((__v4sf) __A, (__v4sf)__B, (__vector unsigned char)__t);
 }
 
 /* Selects and interleaves the upper two SPFP values from A and B.  */
@@ -1352,8 +1352,8 @@ _mm_storel_pi (__m64 *__P, __m128 __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_ps (__m128  __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned int perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned int __perm_mask =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x00204060, 0x80808080, 0x80808080, 0x80808080
@@ -1362,14 +1362,14 @@ _mm_movemask_ps (__m128  __A)
 #endif
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -1391,12 +1391,12 @@ _mm_load_ps1 (float const *__P)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_extract_pi16 (__m64 const __A, int const __N)
 {
-  unsigned int shiftr = __N & 3;
+  unsigned int __shiftr = __N & 3;
 #ifdef __BIG_ENDIAN__
-  shiftr = 3 - shiftr;
+  __shiftr = 3 - __shiftr;
 #endif
 
-  return ((__A >> (shiftr * 16)) & 0xffff);
+  return ((__A >> (__shiftr * 16)) & 0xffff);
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1410,12 +1410,12 @@ _m_pextrw (__m64 const __A, int const __N)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_pi16 (__m64 const __A, int const __D, int const __N)
 {
-  const int shiftl = (__N & 3) * 16;
-  const __m64 shiftD = (const __m64) __D << shiftl;
-  const __m64 mask = 0xffffUL << shiftl;
-  __m64 result = (__A & (~mask)) | (shiftD & mask);
+  const int __shiftl = (__N & 3) * 16;
+  const __m64 __shiftD = (const __m64) __D << __shiftl;
+  const __m64 __mask = 0xffffUL << __shiftl;
+  __m64 __result = (__A & (~__mask)) | (__shiftD & __mask);
 
-  return (result);
+  return __result;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1430,30 +1430,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_max_pi16 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, r;
-  __vector __bool short c;
-
-  a = (__vector signed short)vec_splats (__A);
-  b = (__vector signed short)vec_splats (__B);
-  c = (__vector __bool short)vec_cmpgt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __vector signed short __a, __b, __r;
+  __vector __bool short __c;
+
+  __a = (__vector signed short)vec_splats (__A);
+  __b = (__vector signed short)vec_splats (__B);
+  __c = (__vector __bool short)vec_cmpgt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __m1, __m2, __res;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
-  res.as_short[0] =
-      (m1.as_short[0] > m2.as_short[0]) ? m1.as_short[0] : m2.as_short[0];
-  res.as_short[1] =
-      (m1.as_short[1] > m2.as_short[1]) ? m1.as_short[1] : m2.as_short[1];
-  res.as_short[2] =
-      (m1.as_short[2] > m2.as_short[2]) ? m1.as_short[2] : m2.as_short[2];
-  res.as_short[3] =
-      (m1.as_short[3] > m2.as_short[3]) ? m1.as_short[3] : m2.as_short[3];
+  __res.as_short[0] =
+      (__m1.as_short[0] > __m2.as_short[0]) ? __m1.as_short[0] : __m2.as_short[0];
+  __res.as_short[1] =
+      (__m1.as_short[1] > __m2.as_short[1]) ? __m1.as_short[1] : __m2.as_short[1];
+  __res.as_short[2] =
+      (__m1.as_short[2] > __m2.as_short[2]) ? __m1.as_short[2] : __m2.as_short[2];
+  __res.as_short[3] =
+      (__m1.as_short[3] > __m2.as_short[3]) ? __m1.as_short[3] : __m2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1468,28 +1468,27 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_max_pu8 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, r;
-  __vector __bool char c;
-
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = (__vector __bool char)vec_cmpgt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __vector unsigned char __a, __b, __r;
+  __vector __bool char __c;
+
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = (__vector __bool char)vec_cmpgt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
-  long i;
+  __m64_union __m1, __m2, __res;
+  long __i;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
+  for (__i = 0; __i < 8; __i++)
+    __res.as_char[__i] =
+      ((unsigned char) __m1.as_char[__i] > (unsigned char) __m2.as_char[__i]) ?
+	  __m1.as_char[__i] : __m2.as_char[__i];
 
-  for (i = 0; i < 8; i++)
-  res.as_char[i] =
-      ((unsigned char) m1.as_char[i] > (unsigned char) m2.as_char[i]) ?
-	  m1.as_char[i] : m2.as_char[i];
-
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1504,30 +1503,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_min_pi16 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, r;
-  __vector __bool short c;
-
-  a = (__vector signed short)vec_splats (__A);
-  b = (__vector signed short)vec_splats (__B);
-  c = (__vector __bool short)vec_cmplt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __vector signed short __a, __b, __r;
+  __vector __bool short __c;
+
+  __a = (__vector signed short)vec_splats (__A);
+  __b = (__vector signed short)vec_splats (__B);
+  __c = (__vector __bool short)vec_cmplt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __m1, __m2, __res;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
-  res.as_short[0] =
-      (m1.as_short[0] < m2.as_short[0]) ? m1.as_short[0] : m2.as_short[0];
-  res.as_short[1] =
-      (m1.as_short[1] < m2.as_short[1]) ? m1.as_short[1] : m2.as_short[1];
-  res.as_short[2] =
-      (m1.as_short[2] < m2.as_short[2]) ? m1.as_short[2] : m2.as_short[2];
-  res.as_short[3] =
-      (m1.as_short[3] < m2.as_short[3]) ? m1.as_short[3] : m2.as_short[3];
+  __res.as_short[0] =
+      (__m1.as_short[0] < __m2.as_short[0]) ? __m1.as_short[0] : __m2.as_short[0];
+  __res.as_short[1] =
+      (__m1.as_short[1] < __m2.as_short[1]) ? __m1.as_short[1] : __m2.as_short[1];
+  __res.as_short[2] =
+      (__m1.as_short[2] < __m2.as_short[2]) ? __m1.as_short[2] : __m2.as_short[2];
+  __res.as_short[3] =
+      (__m1.as_short[3] < __m2.as_short[3]) ? __m1.as_short[3] : __m2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1542,28 +1541,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_min_pu8 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, r;
-  __vector __bool char c;
-
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = (__vector __bool char)vec_cmplt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __vector unsigned char __a, __b, __r;
+  __vector __bool char __c;
+
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = (__vector __bool char)vec_cmplt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
-  long i;
+  __m64_union __m1, __m2, __res;
+  long __i;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
 
-  for (i = 0; i < 8; i++)
-  res.as_char[i] =
-      ((unsigned char) m1.as_char[i] < (unsigned char) m2.as_char[i]) ?
-	  m1.as_char[i] : m2.as_char[i];
+  for (__i = 0; __i < 8; __i++)
+    __res.as_char[__i] =
+      ((unsigned char) __m1.as_char[__i] < (unsigned char) __m2.as_char[__i]) ?
+	  __m1.as_char[__i] : __m2.as_char[__i];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1578,24 +1577,24 @@ extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artifici
 _mm_movemask_pi8 (__m64 __A)
 {
 #ifdef __powerpc64__
-  unsigned long long p =
+  unsigned long long __p =
 #ifdef __LITTLE_ENDIAN__
                          0x0008101820283038UL; // permute control for sign bits
 #else
                          0x3830282018100800UL; // permute control for sign bits
 #endif
-  return __builtin_bpermd (p, __A);
+  return __builtin_bpermd (__p, __A);
 #else
 #ifdef __LITTLE_ENDIAN__
-  unsigned int mask = 0x20283038UL;
-  unsigned int r1 = __builtin_bpermd (mask, __A) & 0xf;
-  unsigned int r2 = __builtin_bpermd (mask, __A >> 32) & 0xf;
+  unsigned int __mask = 0x20283038UL;
+  unsigned int __r1 = __builtin_bpermd (__mask, __A) & 0xf;
+  unsigned int __r2 = __builtin_bpermd (__mask, __A >> 32) & 0xf;
 #else
-  unsigned int mask = 0x38302820UL;
-  unsigned int r1 = __builtin_bpermd (mask, __A >> 32) & 0xf;
-  unsigned int r2 = __builtin_bpermd (mask, __A) & 0xf;
+  unsigned int __mask = 0x38302820UL;
+  unsigned int __r1 = __builtin_bpermd (__mask, __A >> 32) & 0xf;
+  unsigned int __r2 = __builtin_bpermd (__mask, __A) & 0xf;
 #endif
-  return (r2 << 4) | r1;
+  return (__r2 << 4) | __r1;
 #endif
 }
 
@@ -1610,10 +1609,10 @@ _m_pmovmskb (__m64 __A)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_pu16 (__m64 __A, __m64 __B)
 {
-  __vector unsigned short a, b;
-  __vector unsigned short c;
-  __vector unsigned int w0, w1;
-  __vector unsigned char xform1 = {
+  __vector unsigned short __a, __b;
+  __vector unsigned short __c;
+  __vector unsigned int __w0, __w1;
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1623,14 +1622,14 @@ _mm_mulhi_pu16 (__m64 __A, __m64 __B)
 #endif
     };
 
-  a = (__vector unsigned short)vec_splats (__A);
-  b = (__vector unsigned short)vec_splats (__B);
+  __a = (__vector unsigned short)vec_splats (__A);
+  __b = (__vector unsigned short)vec_splats (__B);
 
-  w0 = vec_vmuleuh (a, b);
-  w1 = vec_vmulouh (a, b);
-  c = (__vector unsigned short)vec_perm (w0, w1, xform1);
+  __w0 = vec_vmuleuh (__a, __b);
+  __w1 = vec_vmulouh (__a, __b);
+  __c = (__vector unsigned short)vec_perm (__w0, __w1, __xform1);
 
-  return (__m64) ((__vector long long) c)[0];
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1644,11 +1643,11 @@ _m_pmulhuw (__m64 __A, __m64 __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_pi16 (__m64 __A, int const __N)
 {
-  unsigned long element_selector_10 = __N & 0x03;
-  unsigned long element_selector_32 = (__N >> 2) & 0x03;
-  unsigned long element_selector_54 = (__N >> 4) & 0x03;
-  unsigned long element_selector_76 = (__N >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_10 = __N & 0x03;
+  unsigned long __element_selector_32 = (__N >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__N >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__N >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0908, 0x0B0A, 0x0D0C, 0x0F0E
@@ -1656,24 +1655,24 @@ _mm_shuffle_pi16 (__m64 __A, int const __N)
 	      0x0607, 0x0405, 0x0203, 0x0001
 #endif
     };
-  __m64_union t;
-  __vector unsigned long long a, p, r;
+  __m64_union __t;
+  __vector unsigned long long __a, __p, __r;
 
 #ifdef __LITTLE_ENDIAN__
-  t.as_short[0] = permute_selectors[element_selector_10];
-  t.as_short[1] = permute_selectors[element_selector_32];
-  t.as_short[2] = permute_selectors[element_selector_54];
-  t.as_short[3] = permute_selectors[element_selector_76];
+  __t.as_short[0] = __permute_selectors[__element_selector_10];
+  __t.as_short[1] = __permute_selectors[__element_selector_32];
+  __t.as_short[2] = __permute_selectors[__element_selector_54];
+  __t.as_short[3] = __permute_selectors[__element_selector_76];
 #else
-  t.as_short[3] = permute_selectors[element_selector_10];
-  t.as_short[2] = permute_selectors[element_selector_32];
-  t.as_short[1] = permute_selectors[element_selector_54];
-  t.as_short[0] = permute_selectors[element_selector_76];
+  __t.as_short[3] = __permute_selectors[__element_selector_10];
+  __t.as_short[2] = __permute_selectors[__element_selector_32];
+  __t.as_short[1] = __permute_selectors[__element_selector_54];
+  __t.as_short[0] = __permute_selectors[__element_selector_76];
 #endif
-  p = vec_splats (t.as_m64);
-  a = vec_splats (__A);
-  r = vec_perm (a, a, (__vector unsigned char)p);
-  return (__m64) ((__vector long long) r)[0];
+  __p = vec_splats (__t.as_m64);
+  __a = vec_splats (__A);
+  __r = vec_perm (__a, __a, (__vector unsigned char)__p);
+  return (__m64) ((__vector long long) __r)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1688,14 +1687,14 @@ _m_pshufw (__m64 __A, int const __N)
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
 {
-  __m64 hibit = 0x8080808080808080UL;
-  __m64 mask, tmp;
-  __m64 *p = (__m64*)__P;
+  __m64 __hibit = 0x8080808080808080UL;
+  __m64 __mask, __tmp;
+  __m64 *__p = (__m64*)__P;
 
-  tmp = *p;
-  mask = _mm_cmpeq_pi8 ((__N & hibit), hibit);
-  tmp = (tmp & (~mask)) | (__A & mask);
-  *p = tmp;
+  __tmp = *__p;
+  __mask = _mm_cmpeq_pi8 ((__N & __hibit), __hibit);
+  __tmp = (__tmp & (~__mask)) | (__A & __mask);
+  *__p = __tmp;
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1708,12 +1707,12 @@ _m_maskmovq (__m64 __A, __m64 __N, char *__P)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_avg_pu8 (__m64 __A, __m64 __B)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = vec_avg (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = vec_avg (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1726,12 +1725,12 @@ _m_pavgb (__m64 __A, __m64 __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_avg_pu16 (__m64 __A, __m64 __B)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__A);
-  b = (__vector unsigned short)vec_splats (__B);
-  c = vec_avg (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__A);
+  __b = (__vector unsigned short)vec_splats (__B);
+  __c = vec_avg (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1746,26 +1745,26 @@ _m_pavgw (__m64 __A, __m64 __B)
 extern __inline    __m64    __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sad_pu8 (__m64  __A, __m64  __B)
 {
-  __vector unsigned char a, b;
-  __vector unsigned char vmin, vmax, vabsdiff;
-  __vector signed int vsum;
-  const __vector unsigned int zero =
+  __vector unsigned char __a, __b;
+  __vector unsigned char __vmin, __vmax, __vabsdiff;
+  __vector signed int __vsum;
+  const __vector unsigned int __zero =
     { 0, 0, 0, 0 };
-  __m64_union result = {0};
+  __m64_union __result = {0};
 
-  a = (__vector unsigned char) (__vector unsigned long long) { 0UL, __A };
-  b = (__vector unsigned char) (__vector unsigned long long) { 0UL, __B };
-  vmin = vec_min (a, b);
-  vmax = vec_max (a, b);
-  vabsdiff = vec_sub (vmax, vmin);
+  __a = (__vector unsigned char) (__vector unsigned long long) { 0UL, __A };
+  __b = (__vector unsigned char) (__vector unsigned long long) { 0UL, __B };
+  __vmin = vec_min (__a, __b);
+  __vmax = vec_max (__a, __b);
+  __vabsdiff = vec_sub (__vmax, __vmin);
   /* Sum four groups of bytes into integers.  */
-  vsum = (__vector signed int) vec_sum4s (vabsdiff, zero);
+  __vsum = (__vector signed int) vec_sum4s (__vabsdiff, __zero);
   /* Sum across four integers with integer result.  */
-  vsum = vec_sums (vsum, (__vector signed int) zero);
+  __vsum = vec_sums (__vsum, (__vector signed int) __zero);
   /* The sum is in the right most 32-bits of the vector result.
      Transfer to a GPR and truncate to 16 bits.  */
-  result.as_short[0] = vsum[3];
-  return result.as_m64;
+  __result.as_short[0] = __vsum[3];
+  return __result.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 7c8a1f18c39..e4fe2f065c9 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -8956,8 +8956,20 @@ epilogue_renumber (rtx *where, int test)
       if (REGNO (*where) >= 8 && REGNO (*where) < 24)      /* oX or lX */
 	return 1;
       if (! test && REGNO (*where) >= 24 && REGNO (*where) < 32)
-	*where = gen_rtx_REG (GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));
-      /* fallthrough */
+	{
+	  if (ORIGINAL_REGNO (*where))
+	    {
+	      rtx n = gen_raw_REG (GET_MODE (*where),
+				   OUTGOING_REGNO (REGNO (*where)));
+	      ORIGINAL_REGNO (n) = ORIGINAL_REGNO (*where);
+	      *where = n;
+	    }
+	  else
+	    *where = gen_rtx_REG (GET_MODE (*where),
+				  OUTGOING_REGNO (REGNO (*where)));
+	}
+      return 0;
+
     case SCRATCH:
     case CC0:
     case PC:
@@ -13074,9 +13086,9 @@ sparc_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,
   if (!TARGET_VIS2)
     return false;
 
-  /* All permutes are supported.  */
+  /* All 8-byte permutes are supported.  */
   if (!target)
-    return true;
+    return GET_MODE_SIZE (vmode) == 8;
 
   /* Force target-independent code to convert constant permutations on other
      modes down to V8QI.  Rely on this to avoid the complexity of the byte
diff --git a/gcc/config/xtensa/xtensa.md b/gcc/config/xtensa/xtensa.md
index cdf22f14b94..fabc313197a 100644
--- a/gcc/config/xtensa/xtensa.md
+++ b/gcc/config/xtensa/xtensa.md
@@ -754,11 +754,14 @@
 	 because of offering further optimization opportunities.  */
       if (register_operand (operands[0], DImode))
 	{
-	  rtx first, second;
-
-	  split_double (operands[1], &first, &second);
-	  emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), first));
-	  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), second));
+	  rtx lowpart, highpart;
+
+	  if (TARGET_BIG_ENDIAN)
+	    split_double (operands[1], &highpart, &lowpart);
+	  else
+	    split_double (operands[1], &lowpart, &highpart);
+	  emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), lowpart));
+	  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), highpart));
 	  DONE;
 	}
 
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 85c8fdd38cd..6eb46f22f68 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,190 @@
+2022-06-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105852
+	PR c++/105761
+	* decl.c (duplicate_decls): Avoid copying template info
+	from non-templated friend even if newdecl isn't a definition.
+	Correct handling of DECL_UNIQUE_FRIEND_P on templates.
+	* pt.c (non_templated_friend_p): New.
+	* cp-tree.h (non_templated_friend_p): Declare it.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105761
+	* decl.c (duplicate_decls): Don't copy DECL_TEMPLATE_INFO
+	from a hidden friend.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105795
+	* constexpr.c (cxx_eval_bare_aggregate): Always call
+	init_subob_ctx.
+
+2022-05-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102307
+	* decl.c (check_initializer): Use build_cplus_new in case of
+	constexpr failure.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101442
+	* decl.c (cp_finish_decl): Don't pass decl to push_cleanup.
+	* init.c (perform_member_init): Likewise.
+	* semantics.c (push_cleanup): Adjust comment.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101698
+	* pt.c (tsubst_baselink): Also check dependent optype.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65211
+	* pt.c (tsubst_decl) [TYPE_DECL]: Copy TYPE_ALIGN.
+
+2022-05-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-09-27  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102479
+	* pt.c (rewrite_template_parm): Handle single-level tsubst_args.
+	Avoid a tree cycle when assigning the DECL_TEMPLATE_PARMS for a
+	rewritten ttp.
+	(alias_ctad_tweaks): Set current_template_parms accordingly.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102300
+	* parser.c (cp_parser_template_name): Use dependent_scope_p.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102629
+	* pt.c (gen_elem_of_pack_expansion_instantiation): Clear
+	TEMPLATE_TYPE_PARAMETER_PACK on auto.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104646
+	* constexpr.c (maybe_save_constexpr_fundef): Don't do extra
+	checks for defaulted ctors.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82980
+	* lambda.c (type_deducible_expression_p): New.
+	(lambda_capture_field_type): Check it.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105265
+	PR c++/100838
+	* call.c (build_user_type_conversion_1): Drop
+	flag_elide_constructors check.
+	(convert_like_internal): Likewise.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105245
+	PR c++/100111
+	* constexpr.c (cxx_eval_store_expression): Build a CONSTRUCTOR
+	as needed in empty base handling.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104669
+	* decl.c (decls_match): Compare versions even if not recording.
+	(duplicate_decls): Propagate attributes to alias.
+	* decl2.c (find_last_decl): Give up if versioned.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102071
+	* init.c (build_new_1): Include cookie in alignment.  Omit
+	constexpr wrapper from alloc_call.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104142
+	* decl.c (check_initializer): Check TREE_SIDE_EFFECTS.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* lambda.c: Include decl.h.
+	(maybe_add_lambda_conv_op): Temporarily override deprecated_state to
+	DEPRECATED_SUPPRESS.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105386
+	* semantics.c (finish_decltype_type): Pass tf_decltype to
+	instantiate_non_dependent_expr_sfinae.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105289
+	PR c++/86193
+	* pt.c (process_partial_specialization): Downgrade "partial
+	specialization isn't more specialized" diagnostic from permerror
+	to an on-by-default pedwarn.
+	(unify) <case TEMPLATE_PARM_INDEX>: When substituting into the
+	NTTP type a second time, use the original type not the
+	substituted type.
+
+2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90107
+	* parser.c (cp_parser_class_specifier_1): Accept :: after a class
+	definition.
+
+2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105398
+	* pt.c (uses_template_parms): Return false for any NAMESPACE_DECL.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105321
+	* constexpr.c (cxx_eval_logical_expression): Always pass false for lval
+	to cxx_eval_constant_expression.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97296
+	* call.c (direct_reference_binding): strip_top_quals when creating
+	a ck_qual.
+
+2022-04-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2021-12-19  Matthias Kretz  <m.kretz@gsi.de>
+
+	* module.cc (trees_out::get_merge_kind): NAMESPACE_DECLs also
+	cannot have a DECL_TEMPLATE_INFO.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 55bb9c45f8c..46c2a066499 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -1683,8 +1683,19 @@ direct_reference_binding (tree type, conversion *conv)
        because the types "int *" and "const int *const" are
        reference-related and we were binding both directly and they
        had the same rank.  To break it up, we add a ck_qual under the
-       ck_ref_bind so that conversion sequence ranking chooses #1.  */
-    conv = build_conv (ck_qual, t, conv);
+       ck_ref_bind so that conversion sequence ranking chooses #1.
+
+       We strip_top_quals here which is also what standard_conversion
+       does.  Failure to do so would confuse comp_cv_qual_signature
+       into thinking that in
+
+	 void f(const int * const &); // #1
+	 void f(const int *); // #2
+	 int *x;
+	 f(x);
+
+       #2 is a better match than #1 even though they're ambiguous (97296).  */
+    conv = build_conv (ck_qual, strip_top_quals (t), conv);
 
   return build_conv (ck_ref_bind, type, conv);
 }
@@ -4117,7 +4128,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,
 	     We represent this in the conversion sequence with an
 	     rvalue conversion, which means a constructor call.  */
 	  if (!TYPE_REF_P (totype)
-	      && (flag_elide_constructors || (flags & LOOKUP_ONLYCONVERTING))
+	      && cxx_dialect < cxx17
+	      && (flags & LOOKUP_ONLYCONVERTING)
 	      && !(convflags & LOOKUP_NO_TEMP_BIND))
 	    cand->second_conv
 	      = build_conv (ck_rvalue, totype, cand->second_conv);
@@ -7804,13 +7816,10 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,
       break;
     };
 
-  tsubst_flags_t sub_complain = complain;
-  if (!flag_elide_constructors)
-    sub_complain &= ~tf_no_cleanup;
   expr = convert_like (next_conversion (convs), expr, fn, argnum,
 		       convs->kind == ck_ref_bind
 		       ? issue_conversion_warnings : false,
-		       c_cast_p, sub_complain);
+		       c_cast_p, complain & ~tf_no_cleanup);
   if (expr == error_mark_node)
     return error_mark_node;
 
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index c13c920ade3..7be5f25b10f 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -890,7 +890,7 @@ maybe_save_constexpr_fundef (tree fun)
   if (!potential && !DECL_GENERATED_P (fun))
     require_potential_rvalue_constant_expression (massaged);
 
-  if (DECL_CONSTRUCTOR_P (fun)
+  if (DECL_CONSTRUCTOR_P (fun) && !DECL_DEFAULTED_FN (fun)
       && cx_check_missing_mem_inits (DECL_CONTEXT (fun),
 				     massaged, !DECL_GENERATED_P (fun)))
     potential = false;
@@ -4280,19 +4280,18 @@ cxx_eval_bit_cast (const constexpr_ctx *ctx, tree t, bool *non_constant_p,
 static tree
 cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,
                              tree bailout_value, tree continue_value,
-			     bool lval,
-			     bool *non_constant_p, bool *overflow_p)
+			     bool, bool *non_constant_p, bool *overflow_p)
 {
   tree r;
   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),
-					   lval,
-					   non_constant_p, overflow_p);
+					   /*lval*/false, non_constant_p,
+					   overflow_p);
   VERIFY_CONSTANT (lhs);
   if (tree_int_cst_equal (lhs, bailout_value))
     return lhs;
   gcc_assert (tree_int_cst_equal (lhs, continue_value));
   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),
-				    lval, non_constant_p,
+				    /*lval*/false, non_constant_p,
 				    overflow_p);
   VERIFY_CONSTANT (r);
   return r;
@@ -4468,12 +4467,9 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,
       tree orig_value = value;
       /* Like in cxx_eval_store_expression, omit entries for empty fields.  */
       bool no_slot = TREE_CODE (type) == RECORD_TYPE && is_empty_field (index);
-      if (no_slot)
-	new_ctx = *ctx;
-      else
-	init_subob_ctx (ctx, new_ctx, index, value);
+      init_subob_ctx (ctx, new_ctx, index, value);
       int pos_hint = -1;
-      if (new_ctx.ctor != ctx->ctor)
+      if (new_ctx.ctor != ctx->ctor && !no_slot)
 	{
 	  /* If we built a new CONSTRUCTOR, attach it now so that other
 	     initializers can refer to it.  */
@@ -5579,6 +5575,12 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,
     {
       /* See above on initialization of empty bases.  */
       gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);
+      if (!*valp)
+	{
+	  /* But do make sure we have something in *valp.  */
+	  *valp = build_constructor (type, nullptr);
+	  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;
+	}
       return init;
     }
   else
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index a2d8c1c77b3..fded2527e5e 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -7242,6 +7242,7 @@ extern bool push_tinst_level_loc                (tree, location_t);
 extern bool push_tinst_level_loc                (tree, tree, location_t);
 extern void pop_tinst_level                     (void);
 extern struct tinst_level *outermost_tinst_level(void);
+extern bool non_templated_friend_p		(tree);
 extern void init_template_processing		(void);
 extern void print_template_statistics		(void);
 bool template_template_parameter_p		(const_tree);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index bffbd004167..679ea9c8be7 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -1059,11 +1059,14 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)
       if (types_match
 	  && !DECL_EXTERN_C_P (newdecl)
 	  && !DECL_EXTERN_C_P (olddecl)
-	  && record_versions
-	  && maybe_version_functions (newdecl, olddecl,
-				      (!DECL_FUNCTION_VERSIONED (newdecl)
-				       || !DECL_FUNCTION_VERSIONED (olddecl))))
-	return 0;
+	  && targetm.target_option.function_versions (newdecl, olddecl))
+	{
+	  if (record_versions)
+	    maybe_version_functions (newdecl, olddecl,
+				     (!DECL_FUNCTION_VERSIONED (newdecl)
+				      || !DECL_FUNCTION_VERSIONED (olddecl)));
+	  return 0;
+	}
     }
   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)
     {
@@ -2221,8 +2224,8 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
 	      check_no_redeclaration_friend_default_args
 		(old_result, new_result);
 	    }
-	  if (!DECL_UNIQUE_FRIEND_P (old_result))
-	    DECL_UNIQUE_FRIEND_P (new_result) = false;
+	  if (!DECL_UNIQUE_FRIEND_P (new_result))
+	    DECL_UNIQUE_FRIEND_P (old_result) = false;
 
 	  check_default_args (newdecl);
 
@@ -2523,7 +2526,12 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
       else
 	{
 	  retrofit_lang_decl (newdecl);
-	  DECL_LOCAL_DECL_ALIAS (newdecl) = DECL_LOCAL_DECL_ALIAS (olddecl);
+	  tree alias = DECL_LOCAL_DECL_ALIAS (newdecl)
+	    = DECL_LOCAL_DECL_ALIAS (olddecl);
+	  DECL_ATTRIBUTES (alias)
+	    = (*targetm.merge_decl_attributes) (alias, newdecl);
+	  if (TREE_CODE (newdecl) == FUNCTION_DECL)
+	    merge_attribute_bits (newdecl, alias);
 	}
     }
 
@@ -2581,7 +2589,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
 		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
 		  = TINFO_USED_TEMPLATE_ID (new_template_info);
 	    }
-	  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);
+
+	  if (non_templated_friend_p (olddecl))
+	    /* Don't copy tinfo from a non-templated friend (PR105761).  */;
+	  else
+	    DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);
 	}
 
       if (DECL_DECLARES_FUNCTION_P (newdecl))
@@ -7167,12 +7179,19 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)
 	      /* Declared constexpr or constinit, but no suitable initializer;
 		 massage init appropriately so we can pass it into
 		 store_init_value for the error.  */
-	      if (CLASS_TYPE_P (type)
-		  && (!init || TREE_CODE (init) == TREE_LIST))
+	      tree new_init = NULL_TREE;
+	      if (!processing_template_decl
+		  && TREE_CODE (init_code) == CALL_EXPR)
+		new_init = build_cplus_new (type, init_code, tf_none);
+	      else if (CLASS_TYPE_P (type)
+		       && (!init || TREE_CODE (init) == TREE_LIST))
+		new_init = build_functional_cast (input_location, type,
+						  init, tf_none);
+	      if (new_init)
 		{
-		  init = build_functional_cast (input_location, type,
-						init, tf_none);
-		  if (TREE_CODE (init) == TARGET_EXPR)
+		  init = new_init;
+		  if (TREE_CODE (init) == TARGET_EXPR
+		      && !(flags & LOOKUP_ONLYCONVERTING))
 		    TARGET_EXPR_DIRECT_INIT_P (init) = true;
 		}
 	      init_code = NULL_TREE;
@@ -7227,6 +7246,10 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)
   if (init && init != error_mark_node)
     init_code = build2 (INIT_EXPR, type, decl, init);
 
+  if (init_code && !TREE_SIDE_EFFECTS (init_code)
+      && init_code != error_mark_node)
+    init_code = NULL_TREE;
+
   if (init_code)
     {
       /* We might have set these in cp_finish_decl.  */
@@ -8300,7 +8323,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
     {
       unsigned i; tree t;
       FOR_EACH_VEC_ELT (*cleanups, i, t)
-	push_cleanup (decl, t, false);
+	push_cleanup (NULL_TREE, t, false);
       release_tree_vector (cleanups);
     }
 
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 885c4749989..c00508103e9 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -1531,8 +1531,16 @@ find_last_decl (tree decl)
 	  if (TREE_CODE (*iter) == OVERLOAD)
 	    continue;
 
-	  if (decls_match (decl, *iter, /*record_decls=*/false))
-	    return *iter;
+	  tree d = *iter;
+
+	  /* We can't compare versions in the middle of processing the
+	     attribute that has the version.  */
+	  if (TREE_CODE (d) == FUNCTION_DECL
+	      && DECL_FUNCTION_VERSIONED (d))
+	    return NULL_TREE;
+
+	  if (decls_match (decl, d, /*record_decls=*/false))
+	    return d;
 	}
       return NULL_TREE;
     }
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index bd27c92324b..f694c9a5776 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -911,7 +911,7 @@ perform_member_init (tree member, tree init)
       init = build2 (INIT_EXPR, type, decl, init);
       finish_expr_stmt (init);
       FOR_EACH_VEC_ELT (*cleanups, i, t)
-	push_cleanup (decl, t, false);
+	push_cleanup (NULL_TREE, t, false);
     }
   else if (type_build_ctor_call (type)
 	   || (init && CLASS_TYPE_P (strip_array_types (type))))
@@ -3079,7 +3079,13 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
 
   tree align_arg = NULL_TREE;
   if (type_has_new_extended_alignment (elt_type))
-    align_arg = build_int_cst (align_type_node, TYPE_ALIGN_UNIT (elt_type));
+    {
+      unsigned align = TYPE_ALIGN_UNIT (elt_type);
+      /* Also consider the alignment of the cookie, if any.  */
+      if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))
+	align = MAX (align, TYPE_ALIGN_UNIT (size_type_node));
+      align_arg = build_int_cst (align_type_node, align);
+    }
 
   alloc_fn = NULL_TREE;
 
@@ -3261,18 +3267,19 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
 	}
     }
 
+  alloc_expr = alloc_call;
   if (cookie_size)
-    alloc_call = maybe_wrap_new_for_constexpr (alloc_call, type,
+    alloc_expr = maybe_wrap_new_for_constexpr (alloc_call, type,
 					       cookie_size);
 
   /* In the simple case, we can stop now.  */
   pointer_type = build_pointer_type (type);
   if (!cookie_size && !is_initialized)
-    return build_nop (pointer_type, alloc_call);
+    return build_nop (pointer_type, alloc_expr);
 
   /* Store the result of the allocation call in a variable so that we can
      use it more than once.  */
-  alloc_expr = get_target_expr (alloc_call);
+  alloc_expr = get_target_expr (alloc_expr);
   alloc_node = TARGET_EXPR_SLOT (alloc_expr);
 
   /* Strip any COMPOUND_EXPRs from ALLOC_CALL.  */
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index d8efe91d9fe..1508e232091 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "toplev.h"
 #include "gimplify.h"
 #include "target.h"
+#include "decl.h"
 
 /* Constructor for a lambda expression.  */
 
@@ -202,6 +203,24 @@ lambda_function (tree lambda)
   return lambda;
 }
 
+/* True if EXPR is an expression whose type can be used directly in lambda
+   capture.  Not to be used for 'auto'.  */
+
+static bool
+type_deducible_expression_p (tree expr)
+{
+  if (!type_dependent_expression_p (expr))
+    return true;
+  if (BRACE_ENCLOSED_INITIALIZER_P (expr)
+      || TREE_CODE (expr) == EXPR_PACK_EXPANSION)
+    return false;
+  tree t = non_reference (TREE_TYPE (expr));
+  if (!t) return false;
+  while (TREE_CODE (t) == POINTER_TYPE)
+    t = TREE_TYPE (t);
+  return currently_open_class (t);
+}
+
 /* Returns the type to use for the FIELD_DECL corresponding to the
    capture of EXPR.  EXPLICIT_INIT_P indicates whether this is a
    C++14 init capture, and BY_REFERENCE_P indicates whether we're
@@ -228,7 +247,7 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,
       else
 	type = do_auto_deduction (type, expr, auto_node);
     }
-  else if (!is_this && type_dependent_expression_p (expr))
+  else if (!is_this && !type_deducible_expression_p (expr))
     {
       type = cxx_make_type (DECLTYPE_TYPE);
       DECLTYPE_TYPE_EXPR (type) = expr;
@@ -1177,9 +1196,13 @@ maybe_add_lambda_conv_op (tree type)
 	}
     }
   else
-    call = build_call_a (callop,
-			 direct_argvec->length (),
-			 direct_argvec->address ());
+    {
+      /* Don't warn on deprecated lambda declarations, unless
+	 the lambda is actually called.  */
+      auto du = make_temp_override (deprecated_state, DEPRECATED_SUPPRESS);
+      call = build_call_a (callop, direct_argvec->length (),
+			   direct_argvec->address ());
+    }
 
   CALL_FROM_THUNK_P (call) = 1;
   SET_EXPR_LOCATION (call, UNKNOWN_LOCATION);
diff --git a/gcc/cp/module.cc b/gcc/cp/module.cc
index b97b1bcb2f8..6cb926c044a 100644
--- a/gcc/cp/module.cc
+++ b/gcc/cp/module.cc
@@ -10059,9 +10059,10 @@ trees_out::get_merge_kind (tree decl, depset *dep)
       tree ctx = CP_DECL_CONTEXT (decl);
       if (TREE_CODE (ctx) == FUNCTION_DECL)
 	{
-	  /* USING_DECLs cannot have DECL_TEMPLATE_INFO -- this isn't
-	     permitting them to have one.   */
+	  /* USING_DECLs and NAMESPACE_DECLs cannot have DECL_TEMPLATE_INFO --
+	     this isn't permitting them to have one.   */
 	  gcc_checking_assert (TREE_CODE (decl) == USING_DECL
+			       || TREE_CODE (decl) == NAMESPACE_DECL
 			       || !DECL_LANG_SPECIFIC (decl)
 			       || !DECL_TEMPLATE_INFO (decl));
 
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 90d119eaa28..b53cc6d360e 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -17728,7 +17728,7 @@ cp_parser_template_name (cp_parser* parser,
 			: parser->context->object_type);
 	  if (scope && TYPE_P (scope)
 	      && (!CLASS_TYPE_P (scope)
-		  || (check_dependency_p && dependent_type_p (scope))))
+		  || (check_dependency_p && dependent_scope_p (scope))))
 	    {
 	      /* We're optimizing away the call to cp_parser_lookup_name, but
 		 we still need to do this.  */
@@ -17739,8 +17739,8 @@ cp_parser_template_name (cp_parser* parser,
     }
 
   /* cp_parser_lookup_name clears OBJECT_TYPE.  */
-  const bool scoped_p = ((parser->scope ? parser->scope
-			  : parser->context->object_type) != NULL_TREE);
+  tree scope = (parser->scope ? parser->scope
+		: parser->context->object_type);
 
   /* Look up the name.  */
   decl = cp_parser_lookup_name (parser, identifier,
@@ -17753,6 +17753,19 @@ cp_parser_template_name (cp_parser* parser,
 
   decl = strip_using_decl (decl);
 
+  /* 13.3 [temp.names] A < is interpreted as the delimiter of a
+    template-argument-list if it follows a name that is not a
+    conversion-function-id and
+    - that follows the keyword template or a ~ after a nested-name-specifier or
+    in a class member access expression, or
+    - for which name lookup finds the injected-class-name of a class template
+    or finds any declaration of a template, or
+    - that is an unqualified name for which name lookup either finds one or
+    more functions or finds nothing, or
+    - that is a terminal name in a using-declarator (9.9), in a declarator-id
+    (9.3.4), or in a type-only context other than a nested-name-specifier
+    (13.8).  */
+
   /* If DECL is a template, then the name was a template-name.  */
   if (TREE_CODE (decl) == TEMPLATE_DECL)
     {
@@ -17772,11 +17785,7 @@ cp_parser_template_name (cp_parser* parser,
     }
   else
     {
-      /* The standard does not explicitly indicate whether a name that
-	 names a set of overloaded declarations, some of which are
-	 templates, is a template-name.  However, such a name should
-	 be a template-name; otherwise, there is no way to form a
-	 template-id for the overloaded templates.  */
+      /* Look through an overload set for any templates.  */
       bool found = false;
 
       for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (decl));
@@ -17784,16 +17793,14 @@ cp_parser_template_name (cp_parser* parser,
 	if (TREE_CODE (*iter) == TEMPLATE_DECL)
 	  found = true;
 
+      /* "an unqualified name for which name lookup either finds one or more
+	 functions or finds nothing".  */
       if (!found
 	  && (cxx_dialect > cxx17)
-	  && !scoped_p
+	  && !scope
 	  && cp_lexer_next_token_is (parser->lexer, CPP_LESS)
 	  && tag_type == none_type)
 	{
-	  /* [temp.names] says "A name is also considered to refer to a template
-	     if it is an unqualified-id followed by a < and name lookup finds
-	     either one or more functions or finds nothing."  */
-
 	  /* The "more functions" case.  Just use the OVERLOAD as normally.
 	     We don't use is_overloaded_fn here to avoid considering
 	     BASELINKs.  */
@@ -17806,6 +17813,13 @@ cp_parser_template_name (cp_parser* parser,
 	    return identifier;
 	}
 
+      /* "that follows the keyword template"..."in a type-only context" */
+      if (!found && scope
+	  && (template_keyword_p || tag_type != none_type)
+	  && TYPE_P (scope) && dependent_type_p (scope)
+	  && cp_parser_nth_token_starts_template_argument_list_p (parser, 1))
+	return identifier;
+
       if (!found)
 	{
 	  /* The name does not name a template.  */
@@ -24967,6 +24981,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)
       case CPP_OPEN_PAREN:
       case CPP_CLOSE_PAREN:
       case CPP_COMMA:
+      case CPP_SCOPE:
         want_semicolon = false;
         break;
 
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 318d42d800d..588c46504b4 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -5200,8 +5200,9 @@ process_partial_specialization (tree decl)
 	   && !get_partial_spec_bindings (maintmpl, maintmpl, specargs))
     {
       auto_diagnostic_group d;
-      if (permerror (input_location, "partial specialization %qD is not "
-		     "more specialized than", decl))
+      if (pedwarn (input_location, 0,
+		   "partial specialization %qD is not more specialized than",
+		   decl))
 	inform (DECL_SOURCE_LOCATION (maintmpl), "primary template %qD",
 		maintmpl);
     }
@@ -10889,7 +10890,7 @@ uses_template_parms (tree t)
 		   || uses_template_parms (TREE_CHAIN (t)));
   else if (TREE_CODE (t) == TYPE_DECL)
     dependent_p = dependent_type_p (TREE_TYPE (t));
-  else if (t == error_mark_node)
+  else if (t == error_mark_node || TREE_CODE (t) == NAMESPACE_DECL)
     dependent_p = false;
   else
     dependent_p = instantiation_dependent_expression_p (t);
@@ -11136,6 +11137,33 @@ outermost_tinst_level (void)
   return level;
 }
 
+/* True iff T is a friend function declaration that is not itself a template
+   and is not defined in a class template.  */
+
+bool
+non_templated_friend_p (tree t)
+{
+  if (t && TREE_CODE (t) == FUNCTION_DECL
+      && DECL_UNIQUE_FRIEND_P (t))
+    {
+      tree ti = DECL_TEMPLATE_INFO (t);
+      if (!ti)
+	return true;
+      /* DECL_FRIEND_CONTEXT is set for a friend defined in class.  */
+      if (DECL_FRIEND_CONTEXT (t))
+	return false;
+      /* Non-templated friends in a class template are still represented with a
+	 TEMPLATE_DECL; check that its primary template is the befriending
+	 class.  Note that DECL_PRIMARY_TEMPLATE is null for
+	 template <class T> friend A<T>::f(); */
+      tree tmpl = TI_TEMPLATE (ti);
+      tree primary = DECL_PRIMARY_TEMPLATE (tmpl);
+      return (primary && primary != tmpl);
+    }
+  else
+    return false;
+}
+
 /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the
    vector of template arguments, as for tsubst.
 
@@ -12641,7 +12669,13 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,
     t = tsubst_expr (pattern, args, complain, in_decl,
 		     /*integral_constant_expression_p=*/false);
   else
-    t = tsubst (pattern, args, complain, in_decl);
+    {
+      t = tsubst (pattern, args, complain, in_decl);
+      if (is_auto (t) && !ith_elem_is_expansion)
+	/* When expanding the fake auto... pack expansion from add_capture, we
+	   need to mark that the expansion is no longer a pack.  */
+	TEMPLATE_TYPE_PARAMETER_PACK (t) = false;
+    }
 
   /*  If the Ith argument pack element is a pack expansion, then
       the Ith element resulting from the substituting is going to
@@ -14072,7 +14106,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
       /* This special case arises when we have something like this:
 
 	 template <class T> struct S {
-	 friend void f<int>(int, double);
+	   friend void f<int>(int, double);
 	 };
 
 	 Here, the DECL_TI_TEMPLATE for the friend declaration
@@ -15110,6 +15144,12 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	  {
 	    DECL_ORIGINAL_TYPE (r) = NULL_TREE;
 	    set_underlying_type (r);
+
+	    /* common_handle_aligned_attribute doesn't apply the alignment
+	       to DECL_ORIGINAL_TYPE.  */
+	    if (TYPE_USER_ALIGN (TREE_TYPE (t)))
+	      TREE_TYPE (r) = build_aligned_type (TREE_TYPE (r),
+						  TYPE_ALIGN (TREE_TYPE (t)));
 	  }
 
 	layout_decl (r, 0);
@@ -16404,7 +16444,8 @@ tsubst_baselink (tree baselink, tree object_type,
 
   tree binfo_type = BINFO_TYPE (BASELINK_BINFO (baselink));
   binfo_type = tsubst (binfo_type, args, complain, in_decl);
-  bool dependent_p = binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink));
+  bool dependent_p = (binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink))
+		      || optype != BASELINK_OPTYPE (baselink));
 
   if (dependent_p)
     {
@@ -23928,7 +23969,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,
 	      /* Now check whether the type of this parameter is still
 		 dependent, and give up if so.  */
 	      ++processing_template_decl;
-	      tparm = tsubst (tparm, targs, tf_none, NULL_TREE);
+	      tparm = tsubst (TREE_TYPE (parm), targs, tf_none, NULL_TREE);
 	      --processing_template_decl;
 	      if (uses_template_parms (tparm))
 		return unify_success (explain_p);
@@ -28726,7 +28767,7 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,
 	  const int depth = TMPL_ARGS_DEPTH (tsubst_args);
 	  tree ttargs = make_tree_vec (depth + 1);
 	  for (int i = 0; i < depth; ++i)
-	    TREE_VEC_ELT (ttargs, i) = TREE_VEC_ELT (tsubst_args, i);
+	    TREE_VEC_ELT (ttargs, i) = TMPL_ARGS_LEVEL (tsubst_args, i + 1);
 	  TREE_VEC_ELT (ttargs, depth)
 	    = template_parms_level_to_args (ttparms);
 	  // Substitute ttargs into ttparms to fix references to
@@ -28739,8 +28780,17 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,
 	  ttparms = tsubst_template_parms_level (ttparms, ttargs,
 						 complain);
 	  // Finally, tack the adjusted parms onto tparms.
-	  ttparms = tree_cons (size_int (depth), ttparms,
-			       current_template_parms);
+	  ttparms = tree_cons (size_int (level + 1), ttparms,
+			       copy_node (current_template_parms));
+	  // As with all template template parms, the parameter list captured
+	  // by this template template parm that corresponds to its own level
+	  // should be empty.  This avoids infinite recursion when structurally
+	  // comparing two such rewritten template template parms (PR102479).
+	  gcc_assert (!TREE_VEC_LENGTH
+		      (TREE_VALUE (TREE_CHAIN (DECL_TEMPLATE_PARMS (olddecl)))));
+	  gcc_assert (TMPL_PARMS_DEPTH (TREE_CHAIN (ttparms)) == level);
+	  TREE_VALUE (TREE_CHAIN (ttparms)) = make_tree_vec (0);
+	  // All done.
 	  DECL_TEMPLATE_PARMS (newdecl) = ttparms;
 	}
     }
@@ -29238,6 +29288,11 @@ alias_ctad_tweaks (tree tmpl, tree uguides)
 	      ++ndlen;
 	  tree gtparms = make_tree_vec (natparms + ndlen);
 
+	  /* Set current_template_parms as in build_deduction_guide.  */
+	  auto ctp = make_temp_override (current_template_parms);
+	  current_template_parms = copy_node (DECL_TEMPLATE_PARMS (tmpl));
+	  TREE_VALUE (current_template_parms) = gtparms;
+
 	  /* First copy over the parms of A.  */
 	  for (j = 0; j < natparms; ++j)
 	    TREE_VEC_ELT (gtparms, j) = TREE_VEC_ELT (atparms, j);
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index d447ce80174..baae5a0f1e4 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -655,7 +655,8 @@ do_pushlevel (scope_kind sk)
 
 /* Queue a cleanup.  CLEANUP is an expression/statement to be executed
    when the current scope is exited.  EH_ONLY is true when this is not
-   meant to apply to normal control flow transfer.  */
+   meant to apply to normal control flow transfer.  DECL is the VAR_DECL
+   being cleaned up, if any, or null for temporaries or subobjects.  */
 
 void
 push_cleanup (tree decl, tree cleanup, bool eh_only)
@@ -10220,7 +10221,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,
     }
   else if (processing_template_decl)
     {
-      expr = instantiate_non_dependent_expr_sfinae (expr, complain);
+      expr = instantiate_non_dependent_expr_sfinae (expr, complain|tf_decltype);
       if (expr == error_mark_node)
 	return error_mark_node;
     }
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 07e908624a0..0dc51220682 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -6465,7 +6465,8 @@ emit_copy_of_insn_after (rtx_insn *insn, rtx_insn *after)
     }
 
   /* Update LABEL_NUSES.  */
-  mark_jump_label (PATTERN (new_rtx), new_rtx, 0);
+  if (NONDEBUG_INSN_P (insn))
+    mark_jump_label (PATTERN (new_rtx), new_rtx, 0);
 
   INSN_LOCATION (new_rtx) = INSN_LOCATION (insn);
 
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 70c5b3886ef..572d70b039d 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -2355,7 +2355,7 @@ build_zero_vector (tree type)
 bool
 fold_convertible_p (const_tree type, const_tree arg)
 {
-  tree orig = TREE_TYPE (arg);
+  const_tree orig = TREE_TYPE (arg);
 
   if (type == orig)
     return true;
@@ -2387,7 +2387,7 @@ fold_convertible_p (const_tree type, const_tree arg)
       return (VECTOR_TYPE_P (orig)
 	      && known_eq (TYPE_VECTOR_SUBPARTS (type),
 			   TYPE_VECTOR_SUBPARTS (orig))
-	      && fold_convertible_p (TREE_TYPE (type), TREE_TYPE (orig)));
+	      && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)));
 
     default:
       return false;
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index ee1c7bb4b31..93de92023d7 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,30 @@
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-05-11  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105230
+	* expr.c (find_array_section): Correct logic to avoid NULL
+	pointer dereference on invalid array section.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-03-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104849
+	* expr.c (find_array_section): Avoid NULL pointer dereference on
+	invalid array section.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* trans-expr.c (gfc_conv_union_initializer): Pass vec* by reference.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index edacd974a21..6f27b4bf440 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -1591,7 +1591,9 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)
 	{
 	  if ((begin && begin->expr_type != EXPR_CONSTANT)
 	      || (finish && finish->expr_type != EXPR_CONSTANT)
-	      || (step && step->expr_type != EXPR_CONSTANT))
+	      || (step && step->expr_type != EXPR_CONSTANT)
+	      || !lower
+	      || !upper)
 	    {
 	      t = false;
 	      goto cleanup;
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index a5c391d077e..9b65b9cf474 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -8782,8 +8782,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init, bool coarray)
   return gfc_finish_block (&block);
 }
 
-void
-gfc_conv_union_initializer (vec<constructor_elt, va_gc> *v,
+static void
+gfc_conv_union_initializer (vec<constructor_elt, va_gc> *&v,
                             gfc_component *un, gfc_expr *init)
 {
   gfc_constructor *ctor;
diff --git a/gcc/gimple-isel.cc b/gcc/gimple-isel.cc
index 2c78a08d3f1..3690782eca4 100644
--- a/gcc/gimple-isel.cc
+++ b/gcc/gimple-isel.cc
@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see
 /* Expand all ARRAY_REF(VIEW_CONVERT_EXPR) gimple assignments into calls to
    internal function based on vector type of selected expansion.
    i.e.:
-     VIEW_CONVERT_EXPR<int[4]>(u)[_1] =  = i_4(D);
+     VIEW_CONVERT_EXPR<int[4]>(u)[_1] = i_4(D);
    =>
      _7 = u;
      _8 = .VEC_SET (_7, i_4(D), _1);
@@ -100,6 +100,7 @@ gimple_expand_vec_set_expr (gimple_stmt_iterator *gsi)
 
 	  gimple_move_vops (ass_stmt, stmt);
 	  gsi_remove (gsi, true);
+	  *gsi = gsi_for_stmt (ass_stmt);
 	}
     }
 
@@ -241,6 +242,14 @@ gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,
 			GET_MODE_NUNITS (cmp_op_mode)));
 
   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);
+  /* Some targets do not have vcondeq and only vcond with NE/EQ
+     but not vcondu, so make sure to also try vcond here as
+     vcond_icode_p would canonicalize the optab query to.  */
+  if (icode == CODE_FOR_nothing
+      && (tcode == NE_EXPR || tcode == EQ_EXPR)
+      && ((icode = get_vcond_icode (mode, cmp_op_mode, !unsignedp))
+	  != CODE_FOR_nothing))
+    unsignedp = !unsignedp;
   if (icode == CODE_FOR_nothing)
     {
       if (tcode == LT_EXPR
diff --git a/gcc/ipa-modref-tree.h b/gcc/ipa-modref-tree.h
index d36c28c0470..9927fc0982b 100644
--- a/gcc/ipa-modref-tree.h
+++ b/gcc/ipa-modref-tree.h
@@ -560,7 +560,7 @@ struct GTY((user)) modref_tree
 	    size_t k;
 	    modref_access_node *access_node;
 	    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)
-	      if (access_node->parm_index > 0)
+	      if (access_node->parm_index >= 0)
 		{
 		  if (access_node->parm_index < (int)map->length ())
 		    access_node->parm_index = (*map)[access_node->parm_index];
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 67a49e65fd8..88b37584f74 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -3405,7 +3405,7 @@ replace_rtx (rtx x, rtx from, rtx to, bool all_regs)
     {
       rtx new_rtx = replace_rtx (SUBREG_REG (x), from, to, all_regs);
 
-      if (CONST_INT_P (new_rtx))
+      if (CONST_SCALAR_INT_P (new_rtx))
 	{
 	  x = simplify_subreg (GET_MODE (x), new_rtx,
 			       GET_MODE (SUBREG_REG (x)),
@@ -3421,7 +3421,7 @@ replace_rtx (rtx x, rtx from, rtx to, bool all_regs)
     {
       rtx new_rtx = replace_rtx (XEXP (x, 0), from, to, all_regs);
 
-      if (CONST_INT_P (new_rtx))
+      if (CONST_SCALAR_INT_P (new_rtx))
 	{
 	  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
 					new_rtx, GET_MODE (XEXP (x, 0)));
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 5fc23605244..291c52e847a 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,481 @@
+2022-06-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105852
+	PR c++/105761
+	* g++.dg/modules/tpl-friend-2_a.C: Adjust expected dump.
+	* g++.dg/template/friend74.C: New test.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105761
+	* g++.dg/cpp1y/auto-fn64.C: New test.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105795
+	* g++.dg/cpp1z/constexpr-aggr-base1.C: New test.
+
+2022-06-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105437
+	* g++.dg/vect/pr105437.cc: New testcase.
+
+2022-05-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102307
+	* g++.dg/cpp1z/constexpr-array2.C: New test.
+
+2022-05-27  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-04-18  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/105266
+	* gcc.dg/pr105250.c: Skip for powerpc*-*-* and s390*-*-*.
+
+2022-05-25  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backported from master:
+	2022-04-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/105147
+	* gcc.dg/pr105140.c: Skip for s390*-*-*.
+
+2022-05-25  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/105147
+	* gcc.dg/pr105140.c: Skip for powerpc*-*-*.
+
+2022-05-24  Qing Zhao  <qing.zhao@oracle.com>
+
+	Backported from master:
+	2022-05-09  Qing Zhao  <qing.zhao@oracle.com>
+
+	* gcc.target/i386/zero-scratch-regs-1.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-10.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-13.c: Add -msse.
+	* gcc.target/i386/zero-scratch-regs-14.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-15.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-16.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-17.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-18.c: Add -fno-stack-protector
+	-fno-PIC, adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-19.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-2.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-20.c: Add -msse.
+	* gcc.target/i386/zero-scratch-regs-21.c: Add -fno-stack-protector
+	-fno-PIC, Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-22.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-23.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-26.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-27.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-28.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-3.c: Add -fno-stack-protector.
+	* gcc.target/i386/zero-scratch-regs-31.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-4.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-5.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-6.c: Add -fno-stack-protector.
+	* gcc.target/i386/zero-scratch-regs-7.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-8.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-9.c: Add -fno-stack-protector.
+
+2022-05-19  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2022-05-06  Michael Meissner  <meissner@linux.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/102059
+	* gcc.target/powerpc/pr102059-4.c: New test.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-20  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105312
+	* gcc.target/arm/pr105312.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105263
+	* gcc.dg/pr105263.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105173
+	* gcc.dg/pr105173.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105163
+	* gcc.dg/torture/pr105163.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105148
+	* gcc.dg/torture/pr105148.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105250
+	* gcc.dg/pr105250.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105140
+	* gcc.dg/pr105140.c: New testcase.
+
+2022-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-04-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/100413
+	* g++.dg/ipa/pr100413.C: New test.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-05-11  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105230
+	* gfortran.dg/pr105230.f90: New test.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-03-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104849
+	* gfortran.dg/pr104849.f90: New test.
+
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* gcc.target/aarch64/sync-comp-swap-ool.c: New.
+	* gcc.target/aarch64/sync-op-acquire-ool.c: New.
+	* gcc.target/aarch64/sync-op-full-ool.c: New.
+	* gcc.target/aarch64/target_attr_20.c: Update check.
+	* gcc.target/aarch64/target_attr_21.c: Same.
+
+2022-05-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-16  Richard Biener  <rguenther@suse.de>
+
+	* gcc.dg/torture/pr105598.c: New testcase.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101442
+	* g++.dg/cpp0x/initlist-nrv1.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101698
+	* g++.dg/template/conv19.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65211
+	* g++.target/i386/vec-tmpl1.C: New test.
+
+2022-05-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-09-27  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102479
+	* g++.dg/cpp1z/class-deduction12.C: Also test alias CTAD in the
+	same way.
+	* g++.dg/cpp1z/class-deduction99.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102300
+	* g++.dg/parse/no-typename1.C: Remove expected error.
+	* g++.dg/template/nested7.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102629
+	* g++.dg/cpp2a/lambda-pack-init7.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104646
+	* g++.dg/cpp0x/constexpr-fno-elide-ctors1.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82980
+	* g++.dg/cpp0x/lambda/lambda-current-inst1.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105265
+	PR c++/100838
+	* g++.dg/cpp0x/initlist-new6.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105245
+	PR c++/100111
+	* g++.dg/cpp1y/constexpr-empty2.C: Add -fno-elide-constructors.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104669
+	* g++.target/i386/mv31.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102071
+	* g++.dg/cpp1z/aligned-new9.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104142
+	* g++.dg/opt/const7.C: New test.
+
+2022-05-10  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-05-10  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/105472
+	* gcc.target/i386/iamcu/asm-support.S: Add .note.GNU-stack section
+	only for Linux.
+	* gcc.target/x86_64/abi/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512f/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/ms-sysv/do-test.S: Likewise.
+
+2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/105528
+	* gcc.dg/pr105528.c: New test.
+
+2022-05-10  Jeff Law  <jeffreyalaw@gmail.com>
+
+	Backported from master:
+	2022-04-28  Jeff Law  <jeffreyalaw@gmail.com>
+
+	* lib/prune.exp (prune_gcc_output): Prune new linker warning.
+
+2022-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20220510-1.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/cpp23/lambda-attr1.C: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105331
+	* gcc.dg/pr105331.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105396
+	* gcc.dg/asan/pr105396.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/105333
+	* gcc.dg/pr105333.c: New test.
+
+2022-05-06  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-05-02  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR testsuite/105433
+	* gcc.target/i386/iamcu/asm-support.S: Add .note.GNU-stack.
+	* gcc.target/x86_64/abi/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512f/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/ms-sysv/do-test.S: Likewise.
+
+2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	* gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c: Update
+	the expected message for the case in which unaligned accesses
+	are not allowed.
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105365
+	PR analyzer/105366
+	* gcc.dg/analyzer/pr105365.c: New test.
+	* gcc.dg/analyzer/pr105366.c: New test.
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105252
+	* gcc.dg/analyzer/pr105252.c: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105386
+	* g++.dg/cpp0x/decltype81.C: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105304
+	* g++.dg/cpp2a/concepts-requires30.C: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105289
+	PR c++/86193
+	* g++.dg/template/partial-specialization11.C: New test.
+	* g++.dg/template/partial-specialization12.C: New test.
+
+2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90107
+	* g++.dg/parse/qualified6.C: New test.
+
+2022-04-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR testsuite/105095
+	* gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c: Update for
+	codegen.
+	* gcc.dg/vect/complex/fast-math-complex-add-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c:
+	Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mla-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-half-float.c: Likewise.
+	* gcc.dg/vect/vect.exp: Add extra letter to filter.
+
+2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105398
+	* g++.dg/cpp1y/lambda-generic-enum2.C: New test.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* gcc.target/i386/sse-14.c: Add tests for new macro.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105321
+	* g++.dg/cpp0x/constexpr-105321.C: New test.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97296
+	* g++.dg/cpp0x/ref-bind4.C: Add dg-error.
+	* g++.dg/cpp0x/ref-bind8.C: New test.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* gfortran.dg/dec_union_12.f90: New test.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* gcc.dg/pr105257.c: New test.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/105203
+	* gfortran.dg/g77/pr105203.f: New test.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C
new file mode 100644
index 00000000000..adb6830ff22
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C
@@ -0,0 +1,18 @@
+// PR c++/105321
+// { dg-do compile { target c++11 } }
+
+bool handle_error();
+
+constexpr int echo(int value, bool yes = true) noexcept
+{
+    return (yes || handle_error()), value;
+}
+
+static_assert(echo(10) == 10, "");
+
+constexpr int echo2(int value, bool no = false) noexcept
+{
+    return (!no || handle_error()), value;
+}
+
+static_assert(echo2(10) == 10, "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C
new file mode 100644
index 00000000000..71c76fa0247
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C
@@ -0,0 +1,89 @@
+// PR c++/104646
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fno-elide-constructors }
+
+template <typename _T1> struct pair {
+  _T1 first;
+  int second;
+};
+template <typename _Iterator> class __normal_iterator {
+  _Iterator __traits_type;
+
+public:
+  constexpr __normal_iterator() {}
+};
+template <typename> class allocator;
+template <typename> struct allocator_traits;
+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
+  using value_type = _Tp;
+  template <typename _Up> using rebind_alloc = allocator<_Up>;
+};
+template <typename _Alloc> struct __alloc_traits {
+  typedef allocator_traits<_Alloc> _Base_type;
+  typedef typename _Base_type::value_type &const_reference;
+  template <typename _Tp> struct rebind {
+    typedef typename _Base_type::template rebind_alloc<_Tp> other;
+  };
+};
+template <typename _Tp, typename _Alloc> struct _Vector_base {
+  typedef typename __alloc_traits<_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;
+};
+template <typename _Tp, typename _Alloc = allocator<_Tp>> class vector {
+public:
+  typename __alloc_traits<
+      typename _Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::const_reference
+  operator[](long);
+};
+enum match_flag_type {};
+template <typename, typename> class Trans_NS___cxx11_basic_regex;
+class Trans_NS___cxx11_match_results;
+enum _RegexExecutorPolicy { _S_auto };
+template <typename, typename, typename _CharT, typename _TraitsT,
+          _RegexExecutorPolicy, bool>
+bool __regex_algo_impl(Trans_NS___cxx11_match_results &,
+                       const Trans_NS___cxx11_basic_regex<_CharT, _TraitsT> &);
+template <typename, typename, typename, bool> class _Executor;
+template <typename _Ch_type, typename = _Ch_type>
+class Trans_NS___cxx11_basic_regex {};
+class Trans_NS___cxx11_match_results : vector<int> {
+  template <typename, typename, typename _Cp, typename _Rp,
+            _RegexExecutorPolicy, bool>
+  friend bool __regex_algo_impl(Trans_NS___cxx11_match_results &,
+                                const Trans_NS___cxx11_basic_regex<_Cp, _Rp> &);
+};
+template <typename _Bi_iter, typename _Alloc, typename _Ch_type,
+          typename _Rx_traits>
+void regex_search(_Bi_iter, _Alloc,
+                  Trans_NS___cxx11_basic_regex<_Ch_type, _Rx_traits>) {
+  __regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits, _S_auto, false>;
+}
+match_flag_type __regex_algo_impl___flags;
+template <typename, typename, typename _CharT, typename _TraitsT,
+          _RegexExecutorPolicy, bool>
+bool __regex_algo_impl(
+    Trans_NS___cxx11_match_results &__m,
+    const Trans_NS___cxx11_basic_regex<_CharT, _TraitsT> &__re) {
+  __normal_iterator<const char *> __e, __s;
+  _Executor<int, int, _TraitsT, false> __executor(__s, __e, __m, __re,
+                                                  __regex_algo_impl___flags);
+  __executor._M_match();
+  return false;
+}
+template <typename, typename, typename, bool> class _Executor {
+public:
+  _Executor(__normal_iterator<const char *>, __normal_iterator<const char *>,
+            vector<int>, Trans_NS___cxx11_basic_regex<char>, match_flag_type);
+  void _M_match() { _M_dfs(); }
+  void _M_dfs();
+  vector<pair<__normal_iterator<char *>>> _M_rep_count;
+};
+long _M_rep_once_more___i;
+template <typename _BiIter, typename _Alloc, typename _TraitsT, bool __dfs_mode>
+void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::_M_dfs() {
+  auto __rep_count = _M_rep_count[_M_rep_once_more___i];
+}
+char main___trans_tmp_1;
+void main___trans_tmp_2() {
+  Trans_NS___cxx11_basic_regex<char> re;
+  regex_search(main___trans_tmp_1, main___trans_tmp_2, re);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype81.C b/gcc/testsuite/g++.dg/cpp0x/decltype81.C
new file mode 100644
index 00000000000..7d25db39d9c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype81.C
@@ -0,0 +1,15 @@
+// PR c++/105386
+// { dg-do compile { target c++11 } }
+
+template<class T> struct NoInst {
+  static_assert(sizeof(T) == 9999, "NoInst instantiated");
+};
+
+template<class T> NoInst<T> f(T);
+
+template<class>
+struct A {
+  using type = decltype(f(0));
+};
+
+A<int> a;
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C b/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C
new file mode 100644
index 00000000000..0ef27806acf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C
@@ -0,0 +1,39 @@
+// PR c++/105265
+// { dg-do run { target c++11 } }
+
+int c;
+
+class Block
+{
+public:
+  Block(int n) : data{new char[n]}, size{n}
+  {
+    ++c;
+  }
+
+  ~Block()
+  {
+    --c;
+    delete[] data;
+  }
+
+private:
+  char* data;
+  int size;
+};
+
+struct Cargo
+{
+  Block const& block;
+};
+
+int main()
+{
+  {
+    Cargo* c = new Cargo{{4000}};
+    delete c;
+  }
+  if (c != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C b/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C
new file mode 100644
index 00000000000..e44dbecfece
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C
@@ -0,0 +1,34 @@
+// PR c++/101442
+// { dg-do run { target c++11 } }
+
+bool destroyed = false;
+
+struct A
+{
+  A() {}
+  A(const A &) = delete;
+  A &operator=(const A &) = delete;
+  ~A() {destroyed = true;}
+};
+
+struct B
+{
+  const A &a;
+  struct string {
+    string(const char*) { }
+    ~string() { }
+  } s;
+};
+
+B foo()
+{
+  B ret{ A{}, "" };
+  return ret;
+}
+
+int main()
+{
+  B b = foo();
+  if (!destroyed)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C
new file mode 100644
index 00000000000..a6631c5ca99
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C
@@ -0,0 +1,18 @@
+// PR c++/82980
+// { dg-do compile { target c++11 } }
+
+template <class T>
+struct Outer
+{
+  template <class U>
+  void f();
+
+  void bar(Outer outer) {
+    [outer](){ outer.f<int>(); };
+  }
+  void baz(Outer *p) {
+    [&](){ p->f<int>(); };
+  }
+};
+
+int main() { }
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C b/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
index 85ac9fbfd79..d296d7c3b72 100644
--- a/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
@@ -51,6 +51,6 @@ g (int *p, const int *pc, const int **q)
      similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-
      qualification signature of type T1 is a proper subset of  the  cv-
      qualification signature of type T2  */
-  f8 (q);
+  f8 (q); // { dg-error "call of overloaded" }
   f9 (q);
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C b/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C
new file mode 100644
index 00000000000..eee78fd5e74
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C
@@ -0,0 +1,10 @@
+// PR c++/97296
+// { dg-do compile }
+
+void f(const int * const &);
+void f(const int *);
+int *x;
+int main()
+{
+  f(x); // { dg-error "call of overloaded" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C b/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C
new file mode 100644
index 00000000000..13f3175da45
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C
@@ -0,0 +1,12 @@
+// PR c++/105761
+// { dg-do compile { target c++14 } }
+// { dg-additional-options -Wno-non-template-friend }
+
+template <class T>
+class X {
+  friend auto f(X);
+};
+
+struct Y : X<long> {
+  friend auto f(X) { return 0L; }
+};
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
index 2acfa98364b..9768b89904e 100644
--- a/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
@@ -1,4 +1,5 @@
 // { dg-do compile { target c++14 } }
+// { dg-additional-options -fno-elide-constructors }
 
 struct A
 {
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C
new file mode 100644
index 00000000000..77cf0bb9d02
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C
@@ -0,0 +1,15 @@
+// PR c++/105398
+// { dg-do compile { target c++14 } }
+
+auto f = [](auto &&m) {
+    enum E { _,e3,e2,e1,C4,C3,C2,C1 };
+    static constexpr int x_coeffs[3][4] = {
+        {e1,C2,C3,C4},
+        {e2,C1,C3,C4},
+        {e3,C1,C2,C4},
+    };
+};
+
+int main() {
+    f(0);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C b/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C
new file mode 100644
index 00000000000..3fa0ed996bd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C
@@ -0,0 +1,30 @@
+// PR c++/102071
+// { dg-do run { target c++17 } }
+// { dg-additional-options -faligned-new=2 }
+
+#include <new>
+
+int nalign;
+void *operator new (std::size_t s, std::align_val_t a)
+{
+  nalign = (int)a;
+  return operator new (s);
+}
+
+struct X { ~X(); int c; };
+
+int align = (alignof (X) > alignof (std::size_t)
+	     ? alignof (X) : alignof (std::size_t));
+
+int n = 4;
+
+int main()
+{
+  X *p = new X[n];
+  if (nalign != align)
+    __builtin_abort ();
+
+  X *p2 = new X;
+  if (nalign != alignof (X))
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
index a31cc1526db..f0d7ea0e16b 100644
--- a/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
@@ -15,3 +15,9 @@ A a(&i,2,B<42>());
 template <class,class> class same;
 template <class T> class same<T,T> {};
 same<decltype(a), A<int*>> s;
+
+#if __cpp_deduction_guides >= 201907
+template <class T> using C = A<const T*>;
+
+same<decltype(C(&i, 2, B<42>())), A<const int*>> t;
+#endif
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C
new file mode 100644
index 00000000000..6daa4b7c55c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C
@@ -0,0 +1,35 @@
+// PR c++/102479
+// { dg-do compile { target c++17 } }
+
+template<class T> struct A;
+
+template<class T>
+struct tuple {
+  tuple(T);
+
+  template<template<class> class Tmpl>
+  tuple(Tmpl<T>);
+
+  template<template<class> class Tmpl, typename A<Tmpl<char>>::type = 0>
+  tuple(Tmpl<T>);
+
+  template<template<class> class Tmpl, typename A<Tmpl<long>>::type = 0>
+  tuple(Tmpl<T>);
+};
+
+template<class T> struct B { };
+
+using ty1 = tuple<int>;
+using ty1 = decltype(tuple(0));
+using ty1 = decltype(tuple(B<int>{}));
+
+#if __cpp_deduction_guides >= 201907
+template<class T> using const_tuple = tuple<const T>;
+
+using ty2 = const_tuple<int>;
+using ty2 = decltype(const_tuple(0));
+using ty2 = decltype(const_tuple(B<const int>{}));
+
+using ty3 = const_tuple<B<int>>;
+using ty3 = decltype(const_tuple(B<int>{}));
+#endif
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C
new file mode 100644
index 00000000000..06acb4a9f78
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C
@@ -0,0 +1,27 @@
+// PR c++/105795
+// { dg-do compile { target c++17 } }
+
+struct empty
+{};
+
+template <typename T>
+struct tuple_holder
+{
+    [[no_unique_address]] T value;
+};
+
+struct tuple : tuple_holder<int>, tuple_holder<empty>
+{};
+
+constexpr auto make_tuple(int&& i, empty&& e)
+{
+    return tuple{i, e};
+}
+
+constexpr int foo()
+{
+    auto tuple = make_tuple(1, empty{});
+    return static_cast<const tuple_holder<int>&>(tuple).value;
+}
+
+static_assert (foo() == 1);
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C
new file mode 100644
index 00000000000..c30e3f2361d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C
@@ -0,0 +1,12 @@
+// PR c++/102307
+// { dg-do compile { target c++11 } }
+
+#include <array>
+template <unsigned N, unsigned M> struct Matrix {
+  constexpr Matrix(double const (&arr)[N][M]); // { dg-warning "never defined" }
+  constexpr Matrix(std::array<std::array<double, M>, N> const &arr);
+};
+int main() {
+  constexpr Matrix<2, 3>
+    mat {{ {1.0, 2.0, 3.0}, {4.0, 5.0, 6.0} }}; // { dg-error "before its definition" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C b/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C
new file mode 100644
index 00000000000..1528f734461
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C
@@ -0,0 +1,29 @@
+// P2173R1 - Attributes on Lambda-Expressions
+// { dg-do compile { target c++11 } }
+
+void
+foo (bool x, bool y)
+{
+  auto a = [][[noreturn]] () {};	// { dg-warning "'noreturn' function does return" }
+  if (x)
+    a ();
+  auto b = [][[noreturn]] {};		// { dg-warning "'noreturn' function does return" }
+  if (y)
+    b ();
+  auto c = [] [[ deprecated ]] () {};	// { dg-bogus "is deprecated" }
+  c ();					// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is deprecated" }
+  auto d = [][[deprecated]] {};		// { dg-bogus "is deprecated" }
+  d ();					// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is deprecated" }
+#if __cpp_generic_lambdas >= 201304
+  auto e = [] [[deprecated]] (auto x) {};	// { dg-bogus "is deprecated" }
+  e (0.0);				// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(auto:1\\\)>\[^\n\r]*' is deprecated" "" { target c++14 } }
+#endif
+#if __cpp_generic_lambdas >= 201707
+  auto f = [] <typename T> [[deprecated]] (T) {};	// { dg-bogus "is deprecated" }
+  f (1);				// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(T\\\)>\[^\n\r]*' is deprecated" "" { target c++20 } }
+#endif
+  auto g = [][[nodiscard]](int) { return 1; };
+  g (1);				// { dg-warning "ignoring return value of 'foo\\\(bool, bool\\\)::<lambda\\\(int\\\)>', declared with attribute 'nodiscard'" }
+  auto h = [] [[nodiscard]] { return 0; };
+  h ();					// { dg-warning "ignoring return value of 'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>', declared with attribute 'nodiscard'" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C b/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C
new file mode 100644
index 00000000000..f500af3f616
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C
@@ -0,0 +1,10 @@
+// PR c++/105304
+// { dg-do compile { target c++20 } }
+// { dg-additional-options "-Wall -Wsequence-point" }
+
+struct A { };
+
+int main() {
+  if (requires { A(); })
+    ;
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C
new file mode 100644
index 00000000000..f3c3899e97a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C
@@ -0,0 +1,18 @@
+// PR c++/102629
+// { dg-do compile { target c++20 } }
+
+template <class T> T&& forward(T&);
+template <class T> T&& forward(T&&);
+
+struct S {};
+
+template <typename... Args>
+void foo(Args&&... args) {
+  [...args = forward<Args> /*(args)*/] { // { dg-error "" }
+    [](auto...) { } (forward<Args>(args)...);
+  };
+}
+
+void bar( ) {
+  foo(S{});
+}
diff --git a/gcc/testsuite/g++.dg/ipa/pr100413.C b/gcc/testsuite/g++.dg/ipa/pr100413.C
new file mode 100644
index 00000000000..96d71e7cf35
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr100413.C
@@ -0,0 +1,64 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c++11 -O2 -fno-guess-branch-probability -fno-inline-functions-called-once -fipa-cp-clone -fipa-pta -fnon-call-exceptions --param=ipa-cp-eval-threshold=0" } */
+
+
+template <typename> class allocator {
+public:
+  ~allocator();
+};
+template <typename> struct allocator_traits;
+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
+  using allocator_type = allocator<_Tp>;
+  template <typename _Up> using rebind_alloc = allocator<_Up>;
+  static void deallocate(allocator_type);
+};
+template <typename _ForwardIterator, typename _Tp>
+void _Destroy(_ForwardIterator, _ForwardIterator, _Tp);
+struct __alloc_traits : allocator_traits<allocator<int>> {
+  struct rebind {
+    typedef rebind_alloc<int> other;
+  };
+};
+struct _Vector_base {
+  struct _Vector_impl_data {
+    int _M_start;
+    int _M_finish;
+  };
+  struct _Vector_impl : __alloc_traits::rebind::other, _Vector_impl_data {};
+  __alloc_traits::rebind::other _M_get_Tp_allocator();
+  ~_Vector_base() { _M_deallocate(); }
+  _Vector_impl _M_impl;
+  void _M_deallocate() { __alloc_traits::deallocate(_M_impl); }
+};
+class vector : _Vector_base {
+public:
+  vector() noexcept {
+    allocator<int> __trans_tmp_1 = _M_get_Tp_allocator();
+    _Destroy(_M_impl._M_start, _M_impl._M_finish, __trans_tmp_1);
+  }
+  void size();
+};
+struct HTTPCallback {
+  virtual void OnFailure();
+};
+struct ContentCallback {
+  virtual void OnDownloadProgress();
+};
+class ClientNetworkContentSocketHandler : ContentCallback, HTTPCallback {
+  vector requested;
+  vector infos;
+  vector lastActivity;
+  void OnFailure();
+public:
+  int IDLE_TIMEOUT = 0;
+  ClientNetworkContentSocketHandler();
+  void DownloadSelectedContent();
+} _network_content_client;
+void ClientNetworkContentSocketHandler::DownloadSelectedContent() {
+  vector content;
+  content.size();
+}
+void ClientNetworkContentSocketHandler::OnFailure() {
+  DownloadSelectedContent();
+}
+ClientNetworkContentSocketHandler::ClientNetworkContentSocketHandler() {}
diff --git a/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C b/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
index 3acacf8ee34..c12857fbf69 100644
--- a/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
+++ b/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
@@ -16,5 +16,5 @@ template class TPL<int>;  // instantiate
 void foo (int, void *);
 
 // { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl definition '::template TPL'\n(  \[.\]=[^\n]*'\n)*  \[.\]=decl declaration '::template foo'\n(  \[.\]=[^\n]*'\n)*  \[.\]=binding '::TPL'} module } }
-// { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl declaration '::foo<int>'\n  \[.\]=binding '::foo'} module } }
+// { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl declaration '::foo'\n  \[.\]=binding '::foo'} module } }
 // { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=specialization definition '::TPL<int>'} module } }
diff --git a/gcc/testsuite/g++.dg/opt/const7.C b/gcc/testsuite/g++.dg/opt/const7.C
new file mode 100644
index 00000000000..5bcf94897a8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/const7.C
@@ -0,0 +1,7 @@
+// PR c++/104142
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -Wunused-variable }
+
+struct B { B()=default; };
+static const B b_var;		//  { dg-bogus "" }
+// { dg-final { scan-assembler-symbol-section {b_var} {^\.(const|rodata)|\[RO\]} } }
diff --git a/gcc/testsuite/g++.dg/parse/no-typename1.C b/gcc/testsuite/g++.dg/parse/no-typename1.C
index 711c621e26a..f40ea0ec13c 100644
--- a/gcc/testsuite/g++.dg/parse/no-typename1.C
+++ b/gcc/testsuite/g++.dg/parse/no-typename1.C
@@ -6,6 +6,6 @@ template <typename T> struct A
 {
     template <typename U> struct B
     {
-        A<T>::template B<U> foo(); // { dg-error "" "" { target c++17_down } }
+        A<T>::template B<U> foo();
     };
 };
diff --git a/gcc/testsuite/g++.dg/parse/qualified6.C b/gcc/testsuite/g++.dg/parse/qualified6.C
new file mode 100644
index 00000000000..68b51f771ec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/parse/qualified6.C
@@ -0,0 +1,10 @@
+// PR c++/90107
+// { dg-do compile }
+
+struct A;
+namespace N { extern A a; }
+struct A {} ::N::a;
+
+struct A1;
+struct B { static A1 a1; };
+struct A1 {} ::B::a1;
diff --git a/gcc/testsuite/g++.dg/template/conv19.C b/gcc/testsuite/g++.dg/template/conv19.C
new file mode 100644
index 00000000000..7a3da939c1f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/conv19.C
@@ -0,0 +1,34 @@
+// PR c++/101698
+// { dg-do compile { target c++11 } }
+
+class Base {
+ public:
+  template <class T>
+  operator const T&() const = delete;
+
+  virtual operator const int&() const {
+    static int res;
+    return res;
+  }
+};
+
+template <class T>
+class Derive : public Base {
+ public:
+  operator const T&() const override {
+    using Y = int;
+    //static_assert(__is_same_as(T,Y), "");
+
+    static int res;
+
+    res = Base::operator const Y&(); // OK
+    res = Base::operator const T&(); // { dg-bogus "deleted" }
+    return res;
+  }
+};
+
+int main() {
+  Derive<int> a;
+  const int& b = a;
+  (void)b;
+}
diff --git a/gcc/testsuite/g++.dg/template/friend74.C b/gcc/testsuite/g++.dg/template/friend74.C
new file mode 100644
index 00000000000..51708334d81
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/friend74.C
@@ -0,0 +1,8 @@
+// PR c++/105852
+// { dg-additional-options -w }
+
+template <class> struct Local { friend Local False(int *); };
+Local<int> loc;
+Local<int> False(int *);
+void New() { False; }
+Local<int> False(int *) { return Local<int>(); }
diff --git a/gcc/testsuite/g++.dg/template/nested7.C b/gcc/testsuite/g++.dg/template/nested7.C
new file mode 100644
index 00000000000..3a5930c0f31
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/nested7.C
@@ -0,0 +1,12 @@
+// PR c++/102300
+
+template<typename T>
+struct holder
+{
+  template<typename F> struct fn {};
+
+  struct t1 : fn<T> {};                      // pass
+  struct t2 : holder<T >::fn<T> {};          // fail
+  struct t3 : holder<T >::template fn<T> {}; // fail
+  struct t4 : holder<T*>::template fn<T> {}; // pass
+};
diff --git a/gcc/testsuite/g++.dg/template/partial-specialization11.C b/gcc/testsuite/g++.dg/template/partial-specialization11.C
new file mode 100644
index 00000000000..556224a3104
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/partial-specialization11.C
@@ -0,0 +1,11 @@
+// PR c++/86193
+// CWG 455 (active)
+// { dg-options "" } // clear -pedantic-errors
+
+template<class T> struct value_type;
+
+template<class T, typename value_type<T>::type V>
+struct A;
+
+template<class T, int V>
+struct A<T*, V> { }; // { dg-warning "not more specialized" }
diff --git a/gcc/testsuite/g++.dg/template/partial-specialization12.C b/gcc/testsuite/g++.dg/template/partial-specialization12.C
new file mode 100644
index 00000000000..5f51e8a27de
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/partial-specialization12.C
@@ -0,0 +1,12 @@
+// PR c++/105289
+// CWG 455 (active)
+// { dg-do compile { target c++11 } }
+
+template<class T>
+struct value_type;
+
+template<class List, typename value_type<List>::type Element>
+struct push_front_vlist;
+
+template<template<class X, X...> class XList, class T, T Arg, T... Vs>
+struct push_front_vlist<XList<T, Vs...>, Arg> { }; // { dg-error "not more specialized" }
diff --git a/gcc/testsuite/g++.dg/vect/pr105437.cc b/gcc/testsuite/g++.dg/vect/pr105437.cc
new file mode 100644
index 00000000000..b3b440debef
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr105437.cc
@@ -0,0 +1,24 @@
+// { dg-do compile }
+
+struct ControlClass
+{
+    virtual ~ControlClass();
+
+    int Width;
+    int Height;
+    unsigned IsToRepaint : 1;
+};
+
+struct SelectClass : ControlClass
+{
+    SelectClass(void);
+};
+
+int Non_Folded_Value();
+
+SelectClass::SelectClass(void)
+{
+    int factor = Non_Folded_Value();
+    Width = 32 << factor;
+    Height = 24 << factor;
+}
diff --git a/gcc/testsuite/g++.target/i386/mv31.C b/gcc/testsuite/g++.target/i386/mv31.C
new file mode 100644
index 00000000000..5d8fd1ddf75
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/mv31.C
@@ -0,0 +1,10 @@
+// PR c++/104669
+
+void bar()
+{
+  int foo(void);
+  int foo(void) __attribute__((target("sse")));
+  int foo(void) __attribute__((target("default")));
+  int (*p)(void) = &foo;
+  return;
+}
diff --git a/gcc/testsuite/g++.target/i386/vec-tmpl1.C b/gcc/testsuite/g++.target/i386/vec-tmpl1.C
new file mode 100644
index 00000000000..e0865e3515b
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/vec-tmpl1.C
@@ -0,0 +1,17 @@
+// PR c++/65211
+// { dg-additional-options "-Wno-psabi" }
+// { dg-final { scan-assembler-not "movdqa" } }
+
+typedef unsigned v4ui __attribute__ ((vector_size(16), aligned (16)));
+
+template<int I>
+static v4ui t1(unsigned *dest_data)
+{
+  typedef unsigned v4ui_1 __attribute__ ((vector_size (16), aligned (4)));
+  return ((const v4ui_1*)dest_data)[0];
+}
+
+v4ui f(unsigned int *array)
+{
+    return t1<1>(array+7);
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105252.c b/gcc/testsuite/gcc.dg/analyzer/pr105252.c
new file mode 100644
index 00000000000..a093eababc5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105252.c
@@ -0,0 +1,20 @@
+/* { dg-additional-options "-fnon-call-exceptions -O" } */
+
+typedef unsigned char C;
+typedef unsigned char __attribute__((__vector_size__ (4))) V;
+
+C m;
+
+static inline void
+bar (C c, V v, V *r)
+{
+  v %= (c | v) % m;
+  *r = v;
+}
+
+void
+foo (void)
+{
+  V x;
+  bar (0, (V){2}, &x);
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105365.c b/gcc/testsuite/gcc.dg/analyzer/pr105365.c
new file mode 100644
index 00000000000..aa576d08632
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105365.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target int128 } */
+
+typedef _Float32 f32;
+typedef _Complex _Float32 cf32;
+_Float32 g;
+__int128 i;
+
+extern void bar(int);
+
+void
+foo(_Float32 k) {
+  f32 f = 0;
+  f /= (_Complex char)__builtin_llround(g);
+  k /= (cf32)__builtin_copysignf(0, i);
+  bar(f + k);
+  foo(0);
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105366.c b/gcc/testsuite/gcc.dg/analyzer/pr105366.c
new file mode 100644
index 00000000000..3dba870e4e9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105366.c
@@ -0,0 +1,19 @@
+/* { dg-require-effective-target int128 } */
+/* { dg-additional-options "-O" } */
+
+extern void bar(int);
+extern void baz(void);
+
+typedef unsigned u32;
+
+void
+foo(u32 u, __int128 i) {
+  baz();
+  _Complex int c = i;
+  c /= (u32)(__UINTPTR_TYPE__)foo;
+  short s = (short)(__UINTPTR_TYPE__)foo;
+  u /= (_Complex short)s;
+  u32 r = u + c;
+  bar(r);
+  foo(0, 0);
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr105396.c b/gcc/testsuite/gcc.dg/asan/pr105396.c
new file mode 100644
index 00000000000..d4bd7f12476
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asan/pr105396.c
@@ -0,0 +1,19 @@
+/* PR sanitizer/105396 */
+/* { dg-do run } */
+/* { dg-skip-if "" { *-*-* } { "*" } { "-O0" } } */
+/* { dg-shouldfail "asan" } */
+
+int
+main ()
+{
+  int a;
+  int *b[1];
+  int c[10];
+  int d[1][1];
+  for (a = 0; a < 1; a++)
+    d[1][a] = 0;
+  return 0;
+}
+
+/* { dg-output "ERROR: AddressSanitizer: stack-buffer-overflow on address.*(\n|\r\n|\r)" } */
+/* { dg-output "WRITE of size.*" } */
diff --git a/gcc/testsuite/gcc.dg/pr105140.c b/gcc/testsuite/gcc.dg/pr105140.c
new file mode 100644
index 00000000000..7d30985e850
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105140.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -w -Wno-psabi" } */
+/* { dg-skip-if "PR105147" { powerpc*-*-* s390*-*-* } } */
+
+typedef char __attribute__((__vector_size__ (16 * sizeof (char)))) U;
+typedef int __attribute__((__vector_size__ (16 * sizeof (int)))) V;
+
+void bar ();
+
+bar (int i, int j, int k, V v)
+{
+}
+
+void
+foo (void)
+{
+  bar ((V){}, (V){}, (V){}, (U){});
+}
diff --git a/gcc/testsuite/gcc.dg/pr105173.c b/gcc/testsuite/gcc.dg/pr105173.c
new file mode 100644
index 00000000000..3effb2996b0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105173.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-Ofast" } */
+
+int i;
+
+int
+foo(char c, _Decimal32 d)
+{
+  d *= i;
+  d *= -(_Decimal64)c;
+  return d;
+}
diff --git a/gcc/testsuite/gcc.dg/pr105250.c b/gcc/testsuite/gcc.dg/pr105250.c
new file mode 100644
index 00000000000..4683e0e63a2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105250.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-w -Wno-psabi -O2" } */
+/* { dg-skip-if "PR105266" { powerpc*-*-* s390*-*-* } } */
+
+typedef int __attribute__((__vector_size__(4))) T;
+typedef int __attribute__((__vector_size__(8))) U;
+typedef int __attribute__((__vector_size__(16))) V;
+typedef int __attribute__((__vector_size__(32))) W;
+typedef _Float32 __attribute__((__vector_size__(16))) F;
+typedef _Float64 __attribute__((__vector_size__(32))) G;
+void foo();
+
+foo(int, int, int, int, U, U, V, V, W, W, int,
+     T, int, U, U, V, V, W, W, T,
+     T, int, U, U, V, V, W, W, T,
+     T, int, W, W, T, T, int, int, int,
+     int, int, int, W, int, int, int, int, int, int,
+     V, W, T, int, int, U, F, int, int, int,
+     int, int, int, G)
+{
+  foo(0, 0, 0, 0, (U){}, (U){}, (V){}, (V){}, (W){},
+       (W){}, 2, (T){}, 0, 0, 0, 0, (U){}, (U){},
+       (V){}, (V){}, (W){}, (W){}, (T){},
+       (T){}, 0, 0, 0, 0, (U){}, (U){}, (V){},
+       (V){}, (W){}, (W){}, (T){}, (T){}, 0, 0, 0,
+       0, 0, 0, (T){},
+       (T){}, (W){},
+       (W){}, (T){}, (T){}, 0, 0, 0, 0, 0, 0, (W){},
+       (V){}, (W){}, (T){}, 0, 0, (U){}, (F){});
+}
diff --git a/gcc/testsuite/gcc.dg/pr105257.c b/gcc/testsuite/gcc.dg/pr105257.c
new file mode 100644
index 00000000000..4232942d791
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105257.c
@@ -0,0 +1,16 @@
+/* PR target/105257 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+extern int sigsetjmp (void **, int);
+void *buf[32];
+void (*fn) (void);
+
+const char *
+bar (void)
+{
+  sigsetjmp (buf, 0);
+  fn ();
+  return "";
+}
diff --git a/gcc/testsuite/gcc.dg/pr105263.c b/gcc/testsuite/gcc.dg/pr105263.c
new file mode 100644
index 00000000000..5cb7fcd09a2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105263.c
@@ -0,0 +1,15 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-O -ffast-math -w -Wno-psabi" } */
+
+typedef _Decimal64 __attribute__((__vector_size__ (8))) U;
+typedef _Decimal64 __attribute__((__vector_size__ (16))) V;
+
+V v;
+
+U
+foo (U u)
+{
+  u *= u;
+  u *= -(U){ v[1] };
+  return u;
+}
diff --git a/gcc/testsuite/gcc.dg/pr105331.c b/gcc/testsuite/gcc.dg/pr105331.c
new file mode 100644
index 00000000000..06cf6d6d901
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105331.c
@@ -0,0 +1,11 @@
+/* PR target/105331 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+#include <stdarg.h>
+
+int
+foo (va_list *va)
+{
+  return va_arg (*va, double _Complex);	/* { dg-bogus "may be used uninitialized" } */
+}
diff --git a/gcc/testsuite/gcc.dg/pr105333.c b/gcc/testsuite/gcc.dg/pr105333.c
new file mode 100644
index 00000000000..bd8bd4cd56c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105333.c
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/105333 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-Og -fno-tree-coalesce-vars -fno-tree-fre" } */
+
+int g;
+short s;
+
+static inline unsigned short
+bar (short a, __int128 b)
+{
+  b ^= (unsigned long) -a;
+  __builtin_strncpy ((void *) &s, (void *) &a, 1);
+  b *= 14;
+  return b;
+}
+
+void
+foo (void)
+{
+  g *= (__int128) bar (1, 1);
+}
diff --git a/gcc/testsuite/gcc.dg/pr105528.c b/gcc/testsuite/gcc.dg/pr105528.c
new file mode 100644
index 00000000000..e380d56ee06
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105528.c
@@ -0,0 +1,23 @@
+/* PR tree-optimization/105528 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wno-psabi -fcompare-debug" } */
+/* { dg-additional-options "-mavx512f" { target i?86-*-* x86_64-*-* } } */
+
+typedef unsigned V __attribute__((__vector_size__ (64)));
+V g;
+
+V
+bar (V v)
+{
+  V w;
+  v <<= (V){(V){}[53]} >= v & 5;
+  w[w[5]] -= ~0;
+  v %= ~0;
+  return v + w;
+}
+
+void
+foo (void)
+{
+  g -= (V){bar((V){~0})[3]};
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105148.c b/gcc/testsuite/gcc.dg/torture/pr105148.c
new file mode 100644
index 00000000000..3338b0f3281
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105148.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+
+extern void foo (void);
+
+static inline int
+bar (int n)
+{
+  for (int i = 0; i < n; i++)
+    {
+      foo ();
+      int y[1][i];
+      y[n][i] = 0;
+    }
+}
+
+int
+baz (void)
+{
+  return bar (5);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105163.c b/gcc/testsuite/gcc.dg/torture/pr105163.c
new file mode 100644
index 00000000000..23e04107f68
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105163.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target nonlocal_goto } */
+
+#include <setjmp.h>
+
+extern int bar (unsigned int *);
+extern jmp_buf *baz (void);
+struct C { int c1; };
+void foo (struct C *x, int *z, int e)
+{
+  unsigned int d = 0;
+  long f;
+  setjmp (*baz());
+  f = 1 + ~d;
+  d = 8;
+  if ((!0) && !e && bar(z)) *z = 1 + f;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105598.c b/gcc/testsuite/gcc.dg/torture/pr105598.c
new file mode 100644
index 00000000000..0a4ea3b0bd1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105598.c
@@ -0,0 +1,32 @@
+/* { dg-do run } */
+
+typedef struct { unsigned int num; } info_t;
+typedef struct { unsigned int flag, type; } block_t;
+info_t info;
+block_t blocks[] = { {2,0}, {3,0}, {1,0}, {1,0} };
+
+static block_t *
+f (info_t *i, block_t *b)
+{
+  while (1) {
+    unsigned int is_last = b->flag & 0x01;
+    i->num++;
+    if (b->flag & 0x02) {
+      if (b->type != 0x1) b->type = b->type;
+      b = f (i, b+1);
+    }
+    if (is_last)
+      break;
+    b++;
+  }
+  return b;
+}
+
+int
+main ()
+{
+  f(&info, &blocks[0]);
+  if (info.num != 4)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
index 827687b92fa..8eb8baceb31 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
@@ -1,10 +1,11 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target vect_complex_add_float } */
+/* { dg-additional-options "-fno-tree-loop-vectorize" } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
 #define N 16
 #include "complex-mul-template.c"
 
-/* { dg-final { scan-tree-dump "Found COMPLEX_MUL_CONJ" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_MUL" "vect" } } */
+/* { dg-final { scan-tree-dump "Found COMPLEX_MUL_CONJ" "slp1" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump "Found COMPLEX_MUL" "slp1" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
index f935405e3d9..5cff373b80d 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
@@ -6,7 +6,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_double } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect"  { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect"  { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
index 71f391db7bb..312df88ee68 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
@@ -6,7 +6,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_float } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
index e5b826f1ca7..046f014240b 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
 /* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
@@ -6,5 +7,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_half } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect" { target { vect_complex_add_half } } } } */
+/* Vectorization is failing for these cases.  They should work but for now ignore.  */
+
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
index 5b70d834c24..9c8b99bc003 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
@@ -6,8 +6,7 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
index 3ef05645a2c..ca5f5b257d3 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
@@ -6,8 +6,7 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
index 06a9216add7..c6617f5dad0 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-require-effective-target vect_float } */
+/* { dg-require-effective-target vect_complex_add_half } */
 /* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
@@ -7,10 +7,8 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_half } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_half } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_half } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_half } && ! target { arm*-*-* } } } } */
 
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
index 34146f3d1e7..7beb6b8b5d8 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
@@ -1,5 +1,7 @@
 /* { dg-do compile } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 
 #define TYPE _Float16
 #define N 200
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
index 0982a2b8ead..fc4cd6151c7 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_double } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE double
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
index a069533b22a..43a77ff8591 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
@@ -1,10 +1,10 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_float } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
 #define N 200
 #include "complex-mls-template.c"
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMA" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS_CONJ" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
index 89ac54c2a42..3d1c5755bef 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
@@ -1,9 +1,10 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
 #define TYPE _Float16
 #define N 200
 #include "complex-mls-template.c"
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS_CONJ" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
index 56a8ea4ae02..b6b21529a10 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_double } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE double
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
index 969416d7dc7..aa8efb4c2db 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_float } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
index da1b9213a6b..51331625745 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
@@ -1,4 +1,6 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
 #define TYPE _Float16
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
index 72b4930d9bb..c57f065cccd 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
@@ -46,5 +46,5 @@ int main (void)
   return main1 ();
 } 
 
-/* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 1 "vect" { target { ! vect_hw_misalign } } } } */
+/* { dg-final { scan-tree-dump-times "unsupported unaligned access" 1 "vect" { target { ! vect_hw_misalign } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_hw_misalign } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect.exp b/gcc/testsuite/gcc.dg/vect/vect.exp
index dca9a4db6f6..3c60eff7072 100644
--- a/gcc/testsuite/gcc.dg/vect/vect.exp
+++ b/gcc/testsuite/gcc.dg/vect/vect.exp
@@ -118,7 +118,7 @@ et-dg-runtest dg-runtest [lsort \
 set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS
 lappend DEFAULT_VECTCFLAGS "-ffast-math"
 et-dg-runtest dg-runtest [lsort \
-	[glob -nocomplain $srcdir/$subdir/fast-math-\[ipsv\]*.\[cS\]]] \
+	[glob -nocomplain $srcdir/$subdir/fast-math-\[ipsvc\]*.\[cS\]]] \
 	"" $DEFAULT_VECTCFLAGS
 
 # -ffast-math SLP tests
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c
new file mode 100644
index 00000000000..372f4aa8746
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf -moutline-atomics" } */
+
+#include "sync-comp-swap.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_cas4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c
new file mode 100644
index 00000000000..95d9c56b5e1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -moutline-atomics" } */
+
+#include "sync-op-acquire.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_swp4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c
new file mode 100644
index 00000000000..2f3881d9755
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -moutline-atomics" } */
+
+#include "sync-op-full.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldadd4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldclr4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldeor4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldset4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/target_attr_20.c b/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
index 509fb039e84..c9454fc420b 100644
--- a/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
+++ b/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
@@ -24,4 +24,4 @@ bar (void)
     }
 }
 
-/* { dg-final { scan-assembler-not "bl.*__aarch64_cas2_acq_rel" } } */
+/* { dg-final { scan-assembler-not "bl.*__aarch64_cas2_sync" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/target_attr_21.c b/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
index acace4c8f2a..b8e56223b02 100644
--- a/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
+++ b/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
@@ -24,4 +24,4 @@ bar (void)
     }
 }
 
-/* { dg-final { scan-assembler-times "bl.*__aarch64_cas2_acq_rel" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_cas2_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/arm/pr105312.c b/gcc/testsuite/gcc.target/arm/pr105312.c
new file mode 100644
index 00000000000..a02831bcbcf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr105312.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mcpu=cortex-a15" } */
+/* { dg-add-options arm_neon } */
+
+typedef float stress_matrix_type_t;
+typedef unsigned int size_t;
+static void __attribute__((optimize("-O3"))) stress_matrix_xy_identity(
+ const size_t n,
+ stress_matrix_type_t a[restrict n][n],
+ stress_matrix_type_t b[restrict n][n],
+ stress_matrix_type_t r[restrict n][n])
+{
+ register size_t i;
+ (void)a;
+ (void)b;
+ for (i = 0; i < n; i++) {
+  register size_t j;
+  for (j = 0; j < n; j++)
+   r[i][j] = (i == j) ? 1.0 : 0.0;
+   return;
+ }
+}
diff --git a/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S b/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
index b4a4a140e54..9d6be88e7d5 100644
--- a/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
+++ b/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
@@ -300,3 +300,6 @@ iamcu_noprintf:
 	.align 4
 .LCiamcu_noprintf1:
 	.long	1132527616
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/i386/sse-14.c b/gcc/testsuite/gcc.target/i386/sse-14.c
index 4ce0ffffaf3..4c728f230f7 100644
--- a/gcc/testsuite/gcc.target/i386/sse-14.c
+++ b/gcc/testsuite/gcc.target/i386/sse-14.c
@@ -429,7 +429,9 @@ test_3 (_mm_maskz_mul_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_mul_round_ps, __m512, __mmask16, __m512, __m512, 9)
 test_3 (_mm_maskz_mul_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_scalef_round_pd, __m512d, __mmask8, __m512d, __m512d, 9)
+test_3 (_mm_maskz_scalef_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_scalef_round_ps, __m512, __mmask16, __m512, __m512, 9)
+test_3 (_mm_maskz_scalef_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_shuffle_f32x4, __m512, __mmask16, __m512, __m512, 1)
 test_3 (_mm512_maskz_shuffle_f64x2, __m512d, __mmask8, __m512d, __m512d, 1)
 test_3 (_mm512_maskz_shuffle_i32x4, __m512i, __mmask16, __m512i, __m512i, 1)
@@ -543,7 +545,9 @@ test_4 (_mm_mask_mul_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_mul_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
 test_4 (_mm_mask_mul_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_scalef_round_pd, __m512d, __m512d, __mmask8, __m512d, __m512d, 9)
+test_4 (_mm_mask_scalef_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_scalef_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
+test_4 (_mm_mask_scalef_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_shuffle_f32x4, __m512, __m512, __mmask16, __m512, __m512, 1)
 test_4 (_mm512_mask_shuffle_f64x2, __m512d, __m512d, __mmask8, __m512d, __m512d, 1)
 test_4 (_mm512_mask_shuffle_i32x4, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
index 1ea6de880aa..818a56f1116 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -fno-stack-protector -fno-PIC" } */
 
 void
 foo (void)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
index 389b1142264..01f6857fb56 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
@@ -11,11 +11,11 @@ foo (int x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
-/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
index 07d8de7c66f..4ed036e9f88 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7 -msse" } */
 
 void
 foo (void)
@@ -7,15 +7,28 @@ foo (void)
 }
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 7 { target { ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 15 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm8, %xmm8" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm9, %xmm9" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm10, %xmm10" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm11, %xmm11" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm12, %xmm12" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm13, %xmm13" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm14, %xmm14" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm15, %xmm15" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
index 55a272cc53f..c361c0b3afd 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
@@ -9,11 +9,11 @@ foo (void)
 /* { dg-final { scan-assembler-times "vzeroall" 1 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
index d0e975cb3d3..4d45fa56b2a 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("used")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
index d41a2557d10..fb5e6ddc1cd 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("skip")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
index c79fcd39d7b..10cfa12f9ca 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -fno-stack-protector" } */
 
 int
 foo (int x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
index 6f90723cc8e..0e399d4ebb0 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 float
 foo (float z, float y, float x)
@@ -9,5 +9,5 @@ foo (float z, float y, float x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm1, %xmm2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm2, %xmm2" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-not "xorl\[ \t\]+%" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
index 491d2d56774..cb0d5ebce04 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 float
 foo (float z, float y, float x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
index 52406fc70aa..cb93209a8ba 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
@@ -9,11 +9,11 @@ foo (void)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
index ccd491775c2..123bd05b51e 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7 -msse" } */
 
 float
 foo (float z, float y, float x)
@@ -8,16 +8,28 @@ foo (float z, float y, float x)
 }
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" { target { ia32 } } } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 7 { target { ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm1, %xmm\[0-9\]+" 14 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm8, %xmm8" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm9, %xmm9" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm10, %xmm10" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm11, %xmm11" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm12, %xmm12" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm13, %xmm13" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm14, %xmm14" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm15, %xmm15" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
index b3570f318c1..e8c3d9b5f3d 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 __attribute__ ((zero_call_used_regs("used")))
 float
@@ -10,5 +10,5 @@ foo (float z, float y, float x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm1, %xmm2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm2, %xmm2" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-not "xorl\[ \t\]+%" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
index b25342065e9..63adbb9d356 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
@@ -11,11 +11,11 @@ foo (void)
 /* { dg-final { scan-assembler-times "fstp\[ \t\]+%st\\(0\\)" 8 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
index 69d42d732fd..a3285bed8a0 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
@@ -11,19 +11,19 @@ foo (void)
 /* { dg-final { scan-assembler-times "fstp\[ \t\]+%st\\(0\\)" 8 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "kxorw\[ \t\]+%k0, %k0, %k0" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k2" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k3" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k4" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k5" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k6" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k7" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k1, %k1, %k1" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k2, %k2, %k2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k3, %k3, %k3" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k4, %k4, %k4" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k5, %k5, %k5" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k6, %k6, %k6" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k7, %k7, %k7" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
index 8fb5299be56..3f22375d2fa 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
@@ -8,16 +8,16 @@ foo (int x)
 }
 
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm1" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm2" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm3" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm4" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm5" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm6" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm7" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
index 26ceacf435d..b307d107319 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
@@ -8,8 +8,8 @@ foo (int x)
 }
 
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
index 044e4af10f0..dfa8e01dc38 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
@@ -10,9 +10,9 @@ __v2si ret_mmx (void)
 }
 
 /* { dg-final { scan-assembler "pxor\[ \t\]+%mm1, %mm1" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm2" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm3" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm4" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm5" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm6" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm7" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm2, %mm2" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm3, %mm3" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm4, %mm4" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm5, %mm5" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm6, %mm6" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm7, %mm7" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
index 89e69b8ba72..6cd5c4cb067 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector" } */
 
 void
 foo (void)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
index afa8b337b36..5a0e53110e6 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
@@ -10,5 +10,5 @@ __v2si ret_mmx (void)
 }
 
 /* { dg-final { scan-assembler "pxor\[ \t\]+%mm1, %mm1" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm2" } } */
-/* { dg-final { scan-assembler-not "movq\[ \t\]+%mm1, %mm\[34567\]" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm2, %mm2" } } */
+/* { dg-final { scan-assembler-not "pxor\[ \t\]+%mm\[34567\], %mm\[34567\]" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
index 1e98d17df7f..becc5b8b438 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("used-gpr")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
index 56aecdafad8..4367f96a859 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
@@ -10,11 +10,11 @@ foo (void)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
index fa831857ad8..88e3156b132 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all-gpr" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all-gpr -fno-stack-protector" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("skip")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
index 0444a21f4da..460c301ec12 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used-gpr" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used-gpr -fno-stack-protector" } */
 
 int
 foo (int x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
index 75356db63c3..0eab76933f5 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
@@ -10,10 +10,10 @@ foo (int x)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
index 64755b00c39..42dcaea4988 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector" } */
 
 extern int foo (int) __attribute__ ((zero_call_used_regs("used-gpr")));
 
diff --git a/gcc/testsuite/gcc.target/powerpc/pr102059-4.c b/gcc/testsuite/gcc.target/powerpc/pr102059-4.c
new file mode 100644
index 00000000000..4a0ad3daf73
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr102059-4.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+/* { dg-require-effective-target power10_ok } */
+
+/* Verify that power10 can explicity include functions compiled for power8.
+   The issue was -mcpu=power8 enables -mpower8-fusion, but -mcpu=power9 or
+   -mcpu=power10 do not set power8-fusion by default.  Thus when doing this
+   compilation, they would get an error that the inline function failed in its
+   inlining due to having incompatible options.  */
+
+static inline int __attribute__ ((always_inline,target("cpu=power8,no-htm")))
+foo (int *b)
+{
+  *b += 10;
+  return *b;
+}
+
+int
+bar (int *a)
+{
+  *a = foo (a);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/sparc/20220510-1.c b/gcc/testsuite/gcc.target/sparc/20220510-1.c
new file mode 100644
index 00000000000..f321cab8482
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20220510-1.c
@@ -0,0 +1,31 @@
+/* PR target/105292 */
+/* Reported by Koakuma <koachan+gccbugs@protonmail.com> */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mvis2" } */
+
+extern void get_vbytes_v2 (unsigned);
+
+typedef struct {
+  unsigned ctt_info;
+  unsigned ctt_size;
+} ctf_type_t;
+
+typedef struct {
+  unsigned short cts_offset;
+  unsigned short cts_bits;
+} ctf_slice_t;
+
+void flip_types_len (ctf_type_t *t, int bsx1, int bsx2)
+{
+  const int kind = t->ctt_info;
+
+  get_vbytes_v2 (t->ctt_size);
+
+  if (kind == 4)
+    {
+      ctf_slice_t *s = (ctf_slice_t *)t;
+      s->cts_offset = __builtin_bswap16(bsx1);
+      s->cts_bits   = __builtin_bswap16(bsx2);
+    }
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
index 7a8ed03d119..b2ad67aef87 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
@@ -82,3 +82,6 @@ snapshot_ret:
 	.comm	xmm_regs,256,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
index 73a59191d6d..24c8b3c9023 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
@@ -79,3 +79,6 @@ snapshot_ret:
 	.comm	ymm_regs,512,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
index 0ef82876dd9..86d54d11c58 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
@@ -95,3 +95,6 @@ snapshot_ret:
 	.comm	zmm_regs,2048,64
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S b/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
index 1d6cd9503e2..ed6f32ea041 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
@@ -30,6 +30,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #ifdef __ELF__
 # define FN_TYPE(fn) .type fn,@function
 # define FN_SIZE(fn) .size fn,.-fn
+# ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+# endif
 #else
 # define FN_TYPE(fn)
 # define FN_SIZE(fn)
diff --git a/gcc/testsuite/gfortran.dg/dec_union_12.f90 b/gcc/testsuite/gfortran.dg/dec_union_12.f90
new file mode 100755
index 00000000000..26671230b05
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec_union_12.f90
@@ -0,0 +1,43 @@
+! { dg-do compile }
+! { dg-options "-std=legacy -ffree-form -finit-local-zero -finit-derived -fdec-structure" }
+!
+! PR fortran/105310
+!
+! Test that gfc_conv_union_initializer does not cause an ICE when called
+! to build the constructor for a field which triggers a vector resize.
+!
+
+program dec_union_12
+  implicit none
+STRUCTURE /foo8u/
+  ! 8 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo16u/
+  ! 16 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo32u/
+  ! 32 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  INTEGER(4) :: aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+  record /foo8u/ bar8u
+  record /foo16u/ bar16u
+  record /foo32u/ bar32u
+  bar8u.a = 1
+  bar16u.a = 1
+  bar32u.a = 1
+end
diff --git a/gcc/testsuite/gfortran.dg/g77/pr105203.f b/gcc/testsuite/gfortran.dg/g77/pr105203.f
new file mode 100644
index 00000000000..3b47210fb40
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/g77/pr105203.f
@@ -0,0 +1,20 @@
+C Test case for PR debug/105203
+C Origin: kmccarty@princeton.edu
+C
+C { dg-do compile }
+C { dg-options "-O2 -fcompare-debug -ftracer -w" }
+C { dg-additional-options "-fPIC" { target fpic } }
+      SUBROUTINE FOO (B)
+
+  10  CALL BAR (A)
+      ASSIGN 20 TO M
+      IF (100.LT.A) GOTO 10
+      GOTO 40
+C
+  20  IF (B.LT.ABS(A)) GOTO 10
+      ASSIGN 30 TO M
+      GOTO 40
+C
+  30  ASSIGN 10 TO M
+  40  GOTO M,(10,20,30)
+      END
diff --git a/gcc/testsuite/gfortran.dg/pr104849.f90 b/gcc/testsuite/gfortran.dg/pr104849.f90
new file mode 100644
index 00000000000..ae221b5ba10
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr104849.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/104849 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1, 2] ! { dg-error "deferred shape" }
+  integer :: x(2)
+  data x /a(:)/                       ! { dg-error "Invalid" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr105230.f90 b/gcc/testsuite/gfortran.dg/pr105230.f90
new file mode 100644
index 00000000000..6c6b42ef9bf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr105230.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/105230 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1, 2] ! { dg-error "deferred shape" }
+  print *, reshape([3, 4], a(1:2))
+end
diff --git a/gcc/testsuite/lib/prune.exp b/gcc/testsuite/lib/prune.exp
index 2809f88b16f..25fb98c6bed 100644
--- a/gcc/testsuite/lib/prune.exp
+++ b/gcc/testsuite/lib/prune.exp
@@ -76,6 +76,11 @@ proc prune_gcc_output { text } {
     regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $text "" text
     regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $text "" text
 
+    # Ideally the tests would indicate that executable stacks were needed
+    # to the linker.  But the option for that varies and may not even exist
+    # on some targets.  So we're stuck pruning the warning.
+    regsub -all "(^|\n)(\[^\n\]*: warning:\[^\n\]*requires executable stack\[^\n\]*\n?)+" $text "\\1" text
+
     # Ignore harmless warnings from Xcode 3.2.x.
     regsub -all "(^|\n)\[^\n\]*ld: warning: can't add line info to anonymous symbol\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*warning: DWARFDebugInfoEntry::AppendDependants\[^\n\]*AT_\[^\n\]*FORM_ref4\[^\n\]*" $text "" text
diff --git a/gcc/tree-ssa-loop-ivopts.c b/gcc/tree-ssa-loop-ivopts.c
index 4012ae3f19d..913b3ad4258 100644
--- a/gcc/tree-ssa-loop-ivopts.c
+++ b/gcc/tree-ssa-loop-ivopts.c
@@ -2125,8 +2125,10 @@ idx_record_use (tree base, tree *idx,
   find_interesting_uses_op (data, *idx);
   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
     {
-      find_interesting_uses_op (data, array_ref_element_size (base));
-      find_interesting_uses_op (data, array_ref_low_bound (base));
+      if (TREE_OPERAND (base, 2))
+	find_interesting_uses_op (data, TREE_OPERAND (base, 2));
+      if (TREE_OPERAND (base, 3))
+	find_interesting_uses_op (data, TREE_OPERAND (base, 3));
     }
   return true;
 }
diff --git a/gcc/tree-ssa-math-opts.c b/gcc/tree-ssa-math-opts.c
index 94f9cc4d6b6..adeb70fd635 100644
--- a/gcc/tree-ssa-math-opts.c
+++ b/gcc/tree-ssa-math-opts.c
@@ -1459,7 +1459,7 @@ powi_cost (HOST_WIDE_INT n)
     return 0;
 
   /* Ignore the reciprocal when calculating the cost.  */
-  val = (n < 0) ? -n : n;
+  val = absu_hwi (n);
 
   /* Initialize the exponent cache.  */
   memset (cache, 0, POWI_TABLE_SIZE * sizeof (bool));
@@ -1492,7 +1492,7 @@ powi_cost (HOST_WIDE_INT n)
 
 static tree
 powi_as_mults_1 (gimple_stmt_iterator *gsi, location_t loc, tree type,
-		 HOST_WIDE_INT n, tree *cache)
+		 unsigned HOST_WIDE_INT n, tree *cache)
 {
   tree op0, op1, ssa_target;
   unsigned HOST_WIDE_INT digit;
@@ -1545,7 +1545,7 @@ powi_as_mults (gimple_stmt_iterator *gsi, location_t loc,
   memset (cache, 0, sizeof (cache));
   cache[1] = arg0;
 
-  result = powi_as_mults_1 (gsi, loc, type, (n < 0) ? -n : n, cache);
+  result = powi_as_mults_1 (gsi, loc, type, absu_hwi (n), cache);
   if (n >= 0)
     return result;
 
@@ -1569,11 +1569,9 @@ static tree
 gimple_expand_builtin_powi (gimple_stmt_iterator *gsi, location_t loc, 
 			    tree arg0, HOST_WIDE_INT n)
 {
-  /* Avoid largest negative number.  */
-  if (n != -n
-      && ((n >= -1 && n <= 2)
-	  || (optimize_function_for_speed_p (cfun)
-	      && powi_cost (n) <= POWI_MAX_MULTS)))
+  if ((n >= -1 && n <= 2)
+      || (optimize_function_for_speed_p (cfun)
+	  && powi_cost (n) <= POWI_MAX_MULTS))
     return powi_as_mults (gsi, loc, arg0, n);
 
   return NULL_TREE;
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
index 32e1632705b..c8cb7328a63 100644
--- a/gcc/tree-ssa-reassoc.c
+++ b/gcc/tree-ssa-reassoc.c
@@ -5054,17 +5054,26 @@ swap_ops_for_binary_stmt (vec<operand_entry *> ops,
 }
 
 /* If definition of RHS1 or RHS2 dominates STMT, return the later of those
-   two definitions, otherwise return STMT.  */
+   two definitions, otherwise return STMT.  Sets INSERT_BEFORE to indicate
+   whether RHS1 op RHS2 can be inserted before or needs to be inserted
+   after the returned stmt.  */
 
 static inline gimple *
-find_insert_point (gimple *stmt, tree rhs1, tree rhs2)
+find_insert_point (gimple *stmt, tree rhs1, tree rhs2, bool &insert_before)
 {
+  insert_before = true;
   if (TREE_CODE (rhs1) == SSA_NAME
       && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs1)))
-    stmt = SSA_NAME_DEF_STMT (rhs1);
+    {
+      stmt = SSA_NAME_DEF_STMT (rhs1);
+      insert_before = false;
+    }
   if (TREE_CODE (rhs2) == SSA_NAME
       && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs2)))
-    stmt = SSA_NAME_DEF_STMT (rhs2);
+    {
+      stmt = SSA_NAME_DEF_STMT (rhs2);
+      insert_before = false;
+    }
   return stmt;
 }
 
@@ -5076,7 +5085,8 @@ insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)
   gcc_assert (is_gimple_assign (stmt_to_insert));
   tree rhs1 = gimple_assign_rhs1 (stmt_to_insert);
   tree rhs2 = gimple_assign_rhs2 (stmt_to_insert);
-  gimple *insert_point = find_insert_point (stmt, rhs1, rhs2);
+  bool insert_before;
+  gimple *insert_point = find_insert_point (stmt, rhs1, rhs2, insert_before);
   gimple_stmt_iterator gsi = gsi_for_stmt (insert_point);
   gimple_set_uid (stmt_to_insert, gimple_uid (insert_point));
 
@@ -5084,7 +5094,7 @@ insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)
      the point where operand rhs1 or rhs2 is defined. In this case,
      stmt_to_insert has to be inserted afterwards. This would
      only happen when the stmt insertion point is flexible. */
-  if (stmt == insert_point)
+  if (insert_before)
     gsi_insert_before (&gsi, stmt_to_insert, GSI_NEW_STMT);
   else
     insert_stmt_after (stmt_to_insert, insert_point);
@@ -5143,22 +5153,25 @@ rewrite_expr_tree (gimple *stmt, enum tree_code rhs_code, unsigned int opindex,
 	     return lhs), force creation of a new SSA_NAME.  */
 	  if (changed || ((rhs1 != oe2->op || rhs2 != oe1->op) && opindex))
 	    {
+	      bool insert_before;
 	      gimple *insert_point
-		= find_insert_point (stmt, oe1->op, oe2->op);
+		= find_insert_point (stmt, oe1->op, oe2->op, insert_before);
 	      lhs = make_ssa_name (TREE_TYPE (lhs));
 	      stmt
 		= gimple_build_assign (lhs, rhs_code,
 				       oe1->op, oe2->op);
 	      gimple_set_uid (stmt, uid);
 	      gimple_set_visited (stmt, true);
-	      if (insert_point == gsi_stmt (gsi))
+	      if (insert_before)
 		gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
 	      else
 		insert_stmt_after (stmt, insert_point);
 	    }
 	  else
 	    {
-	      gcc_checking_assert (find_insert_point (stmt, oe1->op, oe2->op)
+	      bool insert_before;
+	      gcc_checking_assert (find_insert_point (stmt, oe1->op, oe2->op,
+						      insert_before)
 				   == stmt);
 	      gimple_assign_set_rhs1 (stmt, oe1->op);
 	      gimple_assign_set_rhs2 (stmt, oe2->op);
@@ -5214,21 +5227,25 @@ rewrite_expr_tree (gimple *stmt, enum tree_code rhs_code, unsigned int opindex,
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);
 	  unsigned int uid = gimple_uid (stmt);
-	  gimple *insert_point = find_insert_point (stmt, new_rhs1, oe->op);
+	  bool insert_before;
+	  gimple *insert_point = find_insert_point (stmt, new_rhs1, oe->op,
+						    insert_before);
 
 	  lhs = make_ssa_name (TREE_TYPE (lhs));
 	  stmt = gimple_build_assign (lhs, rhs_code,
 				      new_rhs1, oe->op);
 	  gimple_set_uid (stmt, uid);
 	  gimple_set_visited (stmt, true);
-	  if (insert_point == gsi_stmt (gsi))
+	  if (insert_before)
 	    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
 	  else
 	    insert_stmt_after (stmt, insert_point);
 	}
       else
 	{
-	  gcc_checking_assert (find_insert_point (stmt, new_rhs1, oe->op)
+	  bool insert_before;
+	  gcc_checking_assert (find_insert_point (stmt, new_rhs1, oe->op,
+						  insert_before)
 			       == stmt);
 	  gimple_assign_set_rhs1 (stmt, new_rhs1);
 	  gimple_assign_set_rhs2 (stmt, oe->op);
@@ -5708,7 +5725,9 @@ try_special_add_to_ops (vec<operand_entry *> *ops,
 	   && gimple_assign_rhs_code (def_stmt) == NEGATE_EXPR
 	   && !HONOR_SNANS (TREE_TYPE (op))
 	   && (!HONOR_SIGNED_ZEROS (TREE_TYPE (op))
-	       || !COMPLEX_FLOAT_TYPE_P (TREE_TYPE (op))))
+	       || !COMPLEX_FLOAT_TYPE_P (TREE_TYPE (op)))
+	   && (!FLOAT_TYPE_P (TREE_TYPE (op))
+	       || !DECIMAL_FLOAT_MODE_P (element_mode (op))))
     {
       tree rhs1 = gimple_assign_rhs1 (def_stmt);
       tree cst = build_minus_one_cst (TREE_TYPE (op));
@@ -5838,10 +5857,14 @@ repropagate_negates (void)
   FOR_EACH_VEC_ELT (plus_negates, i, negate)
     {
       gimple *user = get_single_immediate_use (negate);
-
       if (!user || !is_gimple_assign (user))
 	continue;
 
+      tree negateop = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (negate));
+      if (TREE_CODE (negateop) == SSA_NAME
+	  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (negateop))
+	continue;
+
       /* The negate operand can be either operand of a PLUS_EXPR
 	 (it can be the LHS if the RHS is a constant for example).
 
@@ -5864,9 +5887,9 @@ repropagate_negates (void)
 	  if (gimple_assign_rhs2 (user) == negate)
 	    {
 	      tree rhs1 = gimple_assign_rhs1 (user);
-	      tree rhs2 = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (negate));
 	      gimple_stmt_iterator gsi = gsi_for_stmt (user);
-	      gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, rhs1, rhs2);
+	      gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, rhs1,
+					      negateop);
 	      update_stmt (user);
 	    }
 	}
@@ -5875,21 +5898,20 @@ repropagate_negates (void)
 	  if (gimple_assign_rhs1 (user) == negate)
 	    {
 	      /* We have
-	           x = -a
+		   x = -negateop
 		   y = x - b
 		 which we transform into
-		   x = a + b
+		   x = negateop + b
 		   y = -x .
 		 This pushes down the negate which we possibly can merge
 		 into some other operation, hence insert it into the
 		 plus_negates vector.  */
 	      gimple *feed = SSA_NAME_DEF_STMT (negate);
-	      tree a = gimple_assign_rhs1 (feed);
 	      tree b = gimple_assign_rhs2 (user);
 	      gimple_stmt_iterator gsi = gsi_for_stmt (feed);
 	      gimple_stmt_iterator gsi2 = gsi_for_stmt (user);
 	      tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)));
-	      gimple *g = gimple_build_assign (x, PLUS_EXPR, a, b);
+	      gimple *g = gimple_build_assign (x, PLUS_EXPR, negateop, b);
 	      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);
 	      gimple_assign_set_rhs_with_ops (&gsi2, NEGATE_EXPR, x);
 	      user = gsi_stmt (gsi2);
@@ -5900,13 +5922,11 @@ repropagate_negates (void)
 	    }
 	  else
 	    {
-	      /* Transform "x = -a; y = b - x" into "y = b + a", getting
-	         rid of one operation.  */
-	      gimple *feed = SSA_NAME_DEF_STMT (negate);
-	      tree a = gimple_assign_rhs1 (feed);
+	      /* Transform "x = -negateop; y = b - x" into "y = b + negateop",
+		 getting rid of one operation.  */
 	      tree rhs1 = gimple_assign_rhs1 (user);
 	      gimple_stmt_iterator gsi = gsi_for_stmt (user);
-	      gimple_assign_set_rhs_with_ops (&gsi, PLUS_EXPR, rhs1, a);
+	      gimple_assign_set_rhs_with_ops (&gsi, PLUS_EXPR, rhs1, negateop);
 	      update_stmt (gsi_stmt (gsi));
 	    }
 	}
diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
index 7289656db0f..a034abf9628 100644
--- a/gcc/tree-vect-slp.c
+++ b/gcc/tree-vect-slp.c
@@ -6319,6 +6319,13 @@ vect_schedule_slp_node (vec_info *vinfo,
 	  gcc_assert (seen_vector_def);
 	  si = gsi_after_labels (as_a <bb_vec_info> (vinfo)->bbs[0]);
 	}
+      else if (is_ctrl_altering_stmt (last_stmt))
+	{
+	  /* We split regions to vectorize at control altering stmts
+	     with a definition so this must be an external which
+	     we can insert at the start of the region.  */
+	  si = gsi_after_labels (as_a <bb_vec_info> (vinfo)->bbs[0]);
+	}
       else if (is_a <bb_vec_info> (vinfo)
 	       && gimple_bb (last_stmt) != gimple_bb (stmt_info->stmt)
 	       && gimple_could_trap_p (stmt_info->stmt))
diff --git a/gcc/value-prof.c b/gcc/value-prof.c
index 42748771192..688089b04d2 100644
--- a/gcc/value-prof.c
+++ b/gcc/value-prof.c
@@ -336,6 +336,10 @@ stream_out_histogram_value (struct output_block *ob, histogram_value hist)
 	/* Note that the IOR counter tracks pointer values and these can have
 	   sign bit set.  */
 	;
+      else if (hist->type == HIST_TYPE_INDIR_CALL && i == 0)
+	/* 'all' counter overflow is stored as a negative value. Individual
+	   counters and values are expected to be non-negative.  */
+	;
       else
 	gcc_assert (value >= 0);
 
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index ceaa3e21b19..a1c6e184a50 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,9 @@
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* config/aarch64/lse.S: Define BARRIER and handle memory MODEL 5.
+	* config/aarch64/t-lse: Add a 5th memory model for _sync functions.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgcc/config/aarch64/lse.S b/libgcc/config/aarch64/lse.S
index df965b5a524..9215873842b 100644
--- a/libgcc/config/aarch64/lse.S
+++ b/libgcc/config/aarch64/lse.S
@@ -87,24 +87,44 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 # define L
 # define M     0x000000
 # define N     0x000000
+# define BARRIER
 #elif MODEL == 2
 # define SUFF  _acq
 # define A     a
 # define L
 # define M     0x400000
 # define N     0x800000
+# define BARRIER
 #elif MODEL == 3
 # define SUFF  _rel
 # define A
 # define L     l
 # define M     0x008000
 # define N     0x400000
+# define BARRIER
 #elif MODEL == 4
 # define SUFF  _acq_rel
 # define A     a
 # define L     l
 # define M     0x408000
 # define N     0xc00000
+# define BARRIER
+#elif MODEL == 5
+# define SUFF  _sync
+#ifdef L_swp
+/* swp has _acq semantics.  */
+#  define A    a
+#  define L
+#  define M    0x400000
+#  define N    0x800000
+#else
+/* All other _sync functions have _seq semantics.  */
+#  define A    a
+#  define L    l
+#  define M    0x408000
+#  define N    0xc00000
+#endif
+# define BARRIER dmb		ish
 #else
 # error
 #endif
@@ -127,7 +147,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #endif
 
 #define NAME(BASE)		glue4(__aarch64_, BASE, SIZE, SUFF)
-#define LDXR			glue4(ld, A, xr, S)
+#if MODEL == 5
+/* Drop A for _sync functions.  */
+# define LDXR			glue3(ld, xr, S)
+#else
+# define LDXR			glue4(ld, A, xr, S)
+#endif
 #define STXR			glue4(st, L, xr, S)
 
 /* Temporary registers used.  Other than these, only the return value
@@ -183,10 +208,16 @@ STARTFN	NAME(cas)
 	bne		1f
 	STXR		w(tmp1), s(1), [x2]
 	cbnz		w(tmp1), 0b
-1:	ret
+1:	BARRIER
+	ret
 
 #else
-#define LDXP	glue3(ld, A, xp)
+#if MODEL == 5
+/* Drop A for _sync functions.  */
+# define LDXP	glue2(ld, xp)
+#else
+# define LDXP	glue3(ld, A, xp)
+#endif
 #define STXP	glue3(st, L, xp)
 #ifdef HAVE_AS_LSE
 # define CASP	glue3(casp, A, L)	x0, x1, x2, x3, [x4]
@@ -205,7 +236,8 @@ STARTFN	NAME(cas)
 	bne		1f
 	STXP		w(tmp2), x2, x3, [x4]
 	cbnz		w(tmp2), 0b
-1:	ret
+1:	BARRIER
+	ret
 
 #endif
 
@@ -229,6 +261,7 @@ STARTFN	NAME(swp)
 0:	LDXR		s(0), [x1]
 	STXR		w(tmp1), s(tmp0), [x1]
 	cbnz		w(tmp1), 0b
+	BARRIER
 	ret
 
 ENDFN	NAME(swp)
@@ -273,6 +306,7 @@ STARTFN	NAME(LDNM)
 	OP		s(tmp1), s(0), s(tmp0)
 	STXR		w(tmp2), s(tmp1), [x1]
 	cbnz		w(tmp2), 0b
+	BARRIER
 	ret
 
 ENDFN	NAME(LDNM)
diff --git a/libgcc/config/aarch64/t-lse b/libgcc/config/aarch64/t-lse
index 88d2d84d100..6ec6df79392 100644
--- a/libgcc/config/aarch64/t-lse
+++ b/libgcc/config/aarch64/t-lse
@@ -18,13 +18,13 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-# Compare-and-swap has 5 sizes and 4 memory models.
+# Compare-and-swap has 5 sizes and 5 memory models.
 S0 := $(foreach s, 1 2 4 8 16, $(addsuffix _$(s), cas))
-O0 := $(foreach m, 1 2 3 4, $(addsuffix _$(m)$(objext), $(S0)))
+O0 := $(foreach m, 1 2 3 4 5, $(addsuffix _$(m)$(objext), $(S0)))
 
-# Swap, Load-and-operate have 4 sizes and 4 memory models
+# Swap, Load-and-operate have 4 sizes and 5 memory models
 S1 := $(foreach s, 1 2 4 8, $(addsuffix _$(s), swp ldadd ldclr ldeor ldset))
-O1 := $(foreach m, 1 2 3 4, $(addsuffix _$(m)$(objext), $(S1)))
+O1 := $(foreach m, 1 2 3 4 5, $(addsuffix _$(m)$(objext), $(S1)))
 
 LSE_OBJS := $(O0) $(O1)
 
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index acd0b312ef2..35950df774d 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,19 @@
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-09-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/unwind/generic.d (__aligned__): Define.
+	(_Unwind_Exception): Align struct to __aligned__.
+
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/emutls.d (emutlsDestroyThread): Clear the per-thread
+	TLS array, don't call free().
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libphobos/libdruntime/gcc/emutls.d b/libphobos/libdruntime/gcc/emutls.d
index 462230508ab..ebeeb8deda3 100644
--- a/libphobos/libdruntime/gcc/emutls.d
+++ b/libphobos/libdruntime/gcc/emutls.d
@@ -222,9 +222,9 @@ void** emutlsAlloc(shared __emutls_object* obj) nothrow @nogc
 }
 
 /*
- * When a thread has finished, remove the TLS array from the GC
- * scan list emutlsArrays, free all allocated TLS variables and
- * finally free the array.
+ * When a thread has finished, free all allocated TLS variables and empty the
+ * array.  The pointer is not free'd as it is stil referenced by the GC scan
+ * list emutlsArrays, which gets destroyed when druntime is unloaded.
  */
 extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
 {
@@ -236,7 +236,7 @@ extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
             free(entry[-1]);
     }
 
-    free(arr);
+    arr.length = 0;
 }
 
 /*
diff --git a/libphobos/libdruntime/gcc/unwind/generic.d b/libphobos/libdruntime/gcc/unwind/generic.d
index 592b3afcb71..68ddd1d5410 100644
--- a/libphobos/libdruntime/gcc/unwind/generic.d
+++ b/libphobos/libdruntime/gcc/unwind/generic.d
@@ -123,7 +123,27 @@ enum : _Unwind_Reason_Code
 // @@@ The IA-64 ABI says that this structure must be double-word aligned.
 // Taking that literally does not make much sense generically.  Instead we
 // provide the maximum alignment required by any type for the machine.
-struct _Unwind_Exception
+     version (ARM)      private enum __aligned__ = 8;
+else version (AArch64)  private enum __aligned__ = 16;
+else version (HPPA)     private enum __aligned__ = 8;
+else version (HPPA64)   private enum __aligned__ = 16;
+else version (MIPS_N32) private enum __aligned__ = 16;
+else version (MIPS_N64) private enum __aligned__ = 16;
+else version (MIPS32)   private enum __aligned__ = 8;
+else version (MIPS64)   private enum __aligned__ = 8;
+else version (PPC)      private enum __aligned__ = 16;
+else version (PPC64)    private enum __aligned__ = 16;
+else version (RISCV32)  private enum __aligned__ = 16;
+else version (RISCV64)  private enum __aligned__ = 16;
+else version (S390)     private enum __aligned__ = 8;
+else version (SPARC)    private enum __aligned__ = 8;
+else version (SPARC64)  private enum __aligned__ = 16;
+else version (SystemZ)  private enum __aligned__ = 8;
+else version (X86)      private enum __aligned__ = 16;
+else version (X86_64)   private enum __aligned__ = 16;
+else static assert( false, "Platform not supported.");
+
+align(__aligned__) struct _Unwind_Exception
 {
     _Unwind_Exception_Class exception_class;
     _Unwind_Exception_Cleanup_Fn exception_cleanup;
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 85e04c45288..dedd557c4d9 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,440 @@
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2023.xml: Update status.
+	* doc/html/manual/status.html: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/prerequisites.xml: Fix attributes for external
+	hyperlink.
+	* doc/html/manual/setup.html: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Include new chapter.
+	* doc/xml/manual/status_cxx2020.xml: Tweak release numbers.
+	* doc/xml/manual/status_cxx2023.xml: New file.
+	* doc/html/*: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/html/manual/status.html: Regenerate.
+	* doc/xml/manual/status_cxx2020.xml: Fix supported version for
+	C++20 bit operations.
+
+2022-05-13  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-06  Alexandre Oliva  <oliva@adacore.com>
+
+	* include/experimental/bits/simd.h [__ALTIVEC__]: Require VSX
+	for double, long long, and 64-bit long intrinsic types.
+	[__ALTIVEC__] (__intrinsic_type): Mention 128-bit in
+	preexisting long double diagnostic, adjust no-VSX double
+	diagnostic to cover 64-bit long double as well.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-05-02  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/103911
+	* src/c++17/floating_from_chars.cc (find_end_of_float): Accept
+	two delimeters for the exponent part in the form of a possibly
+	NULL string of length two.  Don't use std::tolower.
+	(pattern): Adjust calls to find_end_of_float accordingly.
+
+2022-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105284
+	* include/std/iosfwd: Add declarations for <synstream> class
+	templates and typedefs.
+	* include/std/syncstream (basic_syncbuf, basic_osyncstream):
+	Remove default template arguments.
+	* testsuite/27_io/headers/iosfwd/synopsis.cc: New test.
+	* testsuite/27_io/headers/iosfwd/types.cc: New test.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104217
+	* src/c++17/fs_ops.cc (_GNU_SOURCE): Define.
+	* src/filesystem/dir.cc (_GNU_SOURCE): Define.
+	* src/filesystem/ops.cc (_GNU_SOURCE): Define.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105502
+	* include/bits/random.tcc
+	(operator>>(basic_istream<C,T>&, normal_distribution<R>&)):
+	Update state when __state_avail is false.
+	* testsuite/26_numerics/random/normal_distribution/operators/serialize.cc:
+	Check that deserialized object equals serialized one.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104731
+	* testsuite/27_io/filesystem/iterators/error_reporting.cc:
+	Use a trailing char array as storage for dirent::d_name.
+
+2022-05-06  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	PR c++/105324
+	* testsuite/20_util/from_chars/pr105324.cc: Guard test body
+	with conditional for floating-point overloads of from_char.
+
+2022-04-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99290
+	* src/c++17/fs_ops.cc (fs::copy): Pass error_code to
+	directory_iterator constructor, and check on each iteration.
+	* src/filesystem/ops.cc (fs::copy): Likewise.
+	* testsuite/27_io/filesystem/operations/copy.cc: Check for
+	errors during recursion.
+	* testsuite/experimental/filesystem/operations/copy.cc:
+	Likewise.
+
+2022-04-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105375
+	* include/std/future (packaged_task): Add deduction guides.
+	* testsuite/30_threads/packaged_task/cons/deduction.cc: New test.
+
+2022-04-22  Thomas W Rodgers  <trodgers@redhat.com>
+
+	Backported from master:
+	2022-04-22  Thomas W Rodgers  <trodgers@redhat.com>
+
+	PR libstdc++/102994
+	* include/bits/atomic_base.h (atomic_flag::notify_one,
+	notify_all): Remove const qualification.
+	(__atomic_base::notify_one, notify_all): Likewise.
+	* include/std/atomic (atomic<bool>::notify_one, notify_all):
+	Likewise.
+	(atomic::notify_one, notify_all): Likewise.
+	(atomic<T*>::notify_one, notify_all): Likewise.
+	(atomic_notify_one, atomic_notify_all): Likewise.
+	* testsuite/29_atomics/atomic/wait_notify/102994.cc: Adjust test
+	to account for change in notify_one/notify_all signature.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96592
+	* include/std/tuple (tuple::is_constructible): Remove.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/102177
+	* include/bits/atomic_base.h (__is_valid_cmpexch_failure_order):
+	New function to check if a memory order is valid for the failure
+	case of compare exchange operations.
+	(__atomic_base<I>::compare_exchange_weak): Simplify assertions
+	by using __is_valid_cmpexch_failure_order.
+	(__atomic_base<I>::compare_exchange_strong): Likewise.
+	(__atomic_base<P*>::compare_exchange_weak): Likewise.
+	(__atomic_base<P*>::compare_exchange_strong): Likewise.
+	(__atomic_impl::compare_exchange_weak): Add assertion.
+	(__atomic_impl::compare_exchange_strong): Likewise.
+	* include/std/atomic (atomic::compare_exchange_weak): Likewise.
+	(atomic::compare_exchange_strong): Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/monotonic_buffer_resource/allocate.cc:
+	Ignore -Walloc-larger-than warning.
+	* testsuite/20_util/unsynchronized_pool_resource/allocate.cc:
+	Likewise.
+	* testsuite/29_atomics/atomic/cons/user_pod.cc: Compile with -O1
+	to avoid linker error for __atomic_is_lock_free.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (operator==, operator<=>): Define
+	overloads for homogeneous specializations of reverse_iterator,
+	__normal_iterator and move_iterator.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/24_iterators/move_iterator/dr3265.cc: Fix test to
+	account for LWG 3435 resolution.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101709
+	* src/filesystem/ops-common.h (get_temp_directory_from_env):
+	Add error_code parameter.
+	* src/c++17/fs_ops.cc (fs::temp_directory_path): Pass error_code
+	argument to get_temp_directory_from_env and check it.
+	* src/filesystem/ops.cc (fs::temp_directory_path): Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105324
+	* src/c++17/floating_from_chars.cc (buffer_resource::do_allocate):
+	Remove assertion.
+	* testsuite/20_util/from_chars/pr105324.cc: New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/65018
+	* configure.ac: Check for secure_getenv.
+	* config.h.in: Regenerate.
+	* configure: Regenerate.
+	* src/filesystem/ops-common.h (get_temp_directory_from_env): New
+	helper function to obtain path from the environment.
+	* src/c++17/fs_ops.cc (fs::temp_directory_path): Use new helper.
+	* src/filesystem/ops.cc (fs::temp_directory_path): Likewise.
+	* testsuite/27_io/filesystem/operations/temp_directory_path.cc:
+	Print messages if test cannot be run.
+	* testsuite/experimental/filesystem/operations/temp_directory_path.cc:
+	Likewise. Fix incorrect condition. Use "TMP" to work with
+	Windows as well as POSIX.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++20/sstream-inst.cc (_GLIBCXX_USE_CXX11_ABI): Define to
+	select new ABI.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string/cons/char/moveable.cc: Allow
+	moved-from string to be non-empty.
+	* testsuite/21_strings/basic_string/cons/char/moveable2.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc:
+	Construct empty string before setting oom flag.
+	* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc:
+	Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_compiler.tcc (_Compiler::_M_match_token):
+	Use reserved name for parameter.
+	* testsuite/17_intro/names.cc: Check "token".
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/17_intro/names.cc: Check 'sz'.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/ranges (ranges::lazy_split_view::_InnerIter::end()):
+	Add neoxcept (LWG 3593).
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/internet (address): Use std::_Construct
+	to initialize union members.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/cxx11-ios_failure.cc (io_error_category): Define
+	class and virtual functions as 'final'.
+	(io_category_instance): Use constinit union to make the object
+	immortal.
+	* src/c++11/future.cc (future_error_category): Define class and
+	virtual functions as 'final'.
+	(future_category_instance): Use constinit union.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/span (span(Range&&)): Reorder constraints.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_path.cc (path::_M_split_cmpts()): Remove
+	micro-optimization for "/" path.
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Only access
+	the contents of _M_pathname using const member functions.
+
+2022-04-21  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+
+	Backported from master:
+	2022-01-06  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103853
+	* include/bits/forward_list.tcc (forward_list::merge): Check for
+	self-merge.
+	* testsuite/23_containers/forward_list/operations/merge.cc: New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_construct.h (_Construct, _Construct_novalue):
+	Also cast away cv-qualifiers when converting pointer to void.
+	* testsuite/20_util/allocator/void.cc: Test construct function
+	with cv-qualified types.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103911
+	* include/std/charconv (__from_chars_alpha_to_num): Return
+	char instead of unsigned char. Change invalid return value to
+	127 instead of using numeric trait.
+	(__from_chars_alnum): Fix comment. Do not use std::isdigit.
+	Change type of variable to char.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/ranges_base.h (ranges::advance): Avoid signed
+	overflow. Do nothing if already equal to desired result.
+	* testsuite/24_iterators/range_operations/advance_overflow.cc:
+	New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/ext/rope/pthread7-rope.cc: Add dg-timeout-factor.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-03-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/17_intro/names.cc (func): Undef on AIX.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93602
+	* doc/xml/manual/prerequisites.xml: Document libiconv
+	workarounds.
+	* doc/html/manual/setup.html: Regenerate.
+	* src/Makefile.am (CXXLINK): Add $(LTLIBICONV).
+	* src/Makefile.in: Regenerate.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Fix comment.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc:
+	Check correct feature test macro.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR middle-end/104966
+	* include/bits/locale_facets_nonio.tcc
+	(__moneypunct_cache::_M_cache): Store string sizes in local
+	variable that doesn't escape.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103848
+	* include/bits/stl_deque.h (operator-): Do not use 0 as null
+	pointer constant.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libstdc++-v3/config.h.in b/libstdc++-v3/config.h.in
index 61c342681d4..ea88281f438 100644
--- a/libstdc++-v3/config.h.in
+++ b/libstdc++-v3/config.h.in
@@ -310,6 +310,9 @@
 /* Define if readlink is available in <unistd.h>. */
 #undef HAVE_READLINK
 
+/* Define to 1 if you have the `secure_getenv' function. */
+#undef HAVE_SECURE_GETENV
+
 /* Define to 1 if you have the `setenv' function. */
 #undef HAVE_SETENV
 
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 3120d5855f6..1d5ffd8df11 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -28419,6 +28419,17 @@ if test "x$ac_cv_func__wfopen" = xyes; then :
 #define HAVE__WFOPEN 1
 _ACEOF
 
+fi
+done
+
+  for ac_func in secure_getenv
+do :
+  ac_fn_c_check_func "$LINENO" "secure_getenv" "ac_cv_func_secure_getenv"
+if test "x$ac_cv_func_secure_getenv" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SECURE_GETENV 1
+_ACEOF
+
 fi
 done
 
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index fb256bb0287..4d16b094d7f 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -276,6 +276,7 @@ if $GLIBCXX_IS_NATIVE; then
   AC_CHECK_FUNCS(__cxa_thread_atexit_impl __cxa_thread_atexit)
   AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
   AC_CHECK_FUNCS(_wfopen)
+  AC_CHECK_FUNCS(secure_getenv)
 
   # C11 functions for C++17 library
   AC_CHECK_FUNCS(timespec_get)
diff --git a/libstdc++-v3/doc/html/index.html b/libstdc++-v3/doc/html/index.html
index ed1a05f36f7..b118c214b47 100644
--- a/libstdc++-v3/doc/html/index.html
+++ b/libstdc++-v3/doc/html/index.html
@@ -23,7 +23,7 @@
     </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="book"><a href="manual/index.html">The GNU C++ Library Manual</a></span></dt><dd><dl><dt><span class="part"><a href="manual/intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/support.html">4. 
   Support
diff --git a/libstdc++-v3/doc/html/manual/index.html b/libstdc++-v3/doc/html/manual/index.html
index e34210ee5d9..392e416b954 100644
--- a/libstdc++-v3/doc/html/manual/index.html
+++ b/libstdc++-v3/doc/html/manual/index.html
@@ -4,7 +4,7 @@
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="support.html">4. 
   Support
@@ -145,7 +145,7 @@ Support for C++11 dialect.
 	  </a></dt><dt>21.10. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.3.3.23">Non-unique Mapping Containers</a></dt><dt>21.11. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.4.3.5">Point Iterator Hierarchy</a></dt><dt>21.12. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.4.4.5">Invalidation Guarantee Tags Hierarchy</a></dt><dt>21.13. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.5.7.4">Container Tag Hierarchy</a></dt><dt>21.14. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.3">Hash functions, ranged-hash functions, and
 	      range-hashing functions</a></dt><dt>21.15. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.3.4">Insert hash sequence diagram</a></dt><dt>21.16. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.3.6">Insert hash sequence diagram with a null policy</a></dt><dt>21.17. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.5.5">Hash policy class diagram</a></dt><dt>21.18. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.4.7">Balls and bins</a></dt><dt>21.19. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.6">Insert resize sequence diagram</a></dt><dt>21.20. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.9">Standard resize policy trigger sequence
 		diagram</a></dt><dt>21.21. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.10">Standard resize policy size sequence
-		diagram</a></dt><dt>21.22. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.5">Tree node invariants</a></dt><dt>21.23. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>21.24. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>21.25. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>21.26. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>21.27. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.20">Useless update path</a></dt><dt>21.28. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>21.29. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>21.30. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.3">A simple list</a></dt><dt>21.31. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.6">The counter algorithm</a></dt><dt>21.32. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>21.33. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_features">C++ 2017 Library Features</a></dt><dt>1.6. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.7. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.8. <a href="status.html#table.par2ts_simd_support">Support for Extended ABI Tags</a></dt><dt>1.9. <a href="status.html#table.cxx20_features">C++ 2020 Library Features</a></dt><dt>1.10. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.11. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.12. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx98_deprheaders">C++ 1998 Deprecated Library Header</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.6. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.7. <a href="using_headers.html#table.cxx14_headers">C++ 2014 Library Header</a></dt><dt>3.8. <a href="using_headers.html#table.cxx17_headers">C++ 2017 Library Headers</a></dt><dt>3.9. <a href="using_headers.html#table.cxx20_headers">C++ 2020 Library Headers</a></dt><dt>3.10. <a href="using_headers.html#table.cxx20_deprheaders">C++ 2020 Obsolete Headers</a></dt><dt>3.11. <a href="using_headers.html#table.filesystemts_headers">File System TS Header</a></dt><dt>3.12. <a href="using_headers.html#table.libfundts_headers">Library Fundamentals TS Headers</a></dt><dt>3.13. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.14. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.15. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.16. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.17. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.18. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.19. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>20.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>21.1. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>21.2. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>21.3. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>21.4. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>21.5. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.7">
+		diagram</a></dt><dt>21.22. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.5">Tree node invariants</a></dt><dt>21.23. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>21.24. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>21.25. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>21.26. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>21.27. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.20">Useless update path</a></dt><dt>21.28. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>21.29. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>21.30. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.3">A simple list</a></dt><dt>21.31. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.6">The counter algorithm</a></dt><dt>21.32. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>21.33. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_features">C++ 2017 Library Features</a></dt><dt>1.6. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.7. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.8. <a href="status.html#table.par2ts_simd_support">Support for Extended ABI Tags</a></dt><dt>1.9. <a href="status.html#table.cxx20_features">C++ 2020 Library Features</a></dt><dt>1.10. <a href="status.html#table.cxx23_features">C++ 2023 Library Features</a></dt><dt>1.11. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.12. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.13. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx98_deprheaders">C++ 1998 Deprecated Library Header</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.6. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.7. <a href="using_headers.html#table.cxx14_headers">C++ 2014 Library Header</a></dt><dt>3.8. <a href="using_headers.html#table.cxx17_headers">C++ 2017 Library Headers</a></dt><dt>3.9. <a href="using_headers.html#table.cxx20_headers">C++ 2020 Library Headers</a></dt><dt>3.10. <a href="using_headers.html#table.cxx20_deprheaders">C++ 2020 Obsolete Headers</a></dt><dt>3.11. <a href="using_headers.html#table.filesystemts_headers">File System TS Header</a></dt><dt>3.12. <a href="using_headers.html#table.libfundts_headers">Library Fundamentals TS Headers</a></dt><dt>3.13. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.14. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.15. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.16. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.17. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.18. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.19. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>20.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>21.1. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>21.2. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>21.3. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>21.4. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>21.5. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.7">
 		A Standard String Hash Function
 	      </a></dt><dt>21.6. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.12">
 		Only k String DNA Hash
diff --git a/libstdc++-v3/doc/html/manual/intro.html b/libstdc++-v3/doc/html/manual/intro.html
index 3604e0a1d45..1a8234437d9 100644
--- a/libstdc++-v3/doc/html/manual/intro.html
+++ b/libstdc++-v3/doc/html/manual/intro.html
@@ -5,4 +5,4 @@
 </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.intro"></a>Part I. 
   Introduction
   <a id="id-1.3.3.1.1.1" class="indexterm"></a>
-</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
+</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/setup.html b/libstdc++-v3/doc/html/manual/setup.html
index 636a4401602..f27b8d806df 100644
--- a/libstdc++-v3/doc/html/manual/setup.html
+++ b/libstdc++-v3/doc/html/manual/setup.html
@@ -42,6 +42,39 @@
    </p><p>
    Finally, a few system-specific requirements:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">linux</span></dt><dd><p>
+	  The 'gnu' locale model makes use of <code class="function">iconv</code>
+	  for character set conversions. The relevant functions are provided
+	  by Glibc and so are always available, however they can also be
+	  provided by the separate GNU libiconv library. If GNU libiconv is
+	  found when GCC is built (e.g., because its headers are installed
+	  in <code class="filename">/usr/local/include</code>)
+	  then the <code class="filename">libstdc++.so.6</code> library will have a
+	  run-time dependency on <code class="filename">libiconv.so.2</code>.
+	  If you do not want that run-time dependency then you should do
+	  one of the following:
+	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
+	      Uninstall the libiconv headers before building GCC.
+	      Glibc already provides <code class="function">iconv</code> so you should
+	      not need libiconv anyway.
+	    </p></li><li class="listitem"><p>
+	    <a class="link" href="https://www.gnu.org/software/libiconv/#downloading" target="_top">
+	    Download</a> the libiconv sources and extract them into the
+	    top level of the GCC source tree, e.g.,
+	    </p><pre class="programlisting">
+wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz
+tar xf libiconv-1.16.tar.gz
+ln -s libiconv-1.16 libiconv
+</pre><p>
+	      This will build libiconv as part of building GCC and link to
+	      it statically, so there is no <code class="filename">libiconv.so.2</code>
+	      dependency.
+	    </p></li><li class="listitem"><p>
+	      Configure GCC with <code class="option">--with-libiconv-type=static</code>.
+	      This requires the static <code class="filename">libiconv.a</code> library,
+	      which is not installed by default. You might need to reinstall
+	      libiconv using the <code class="option">--enable-static</code> configure
+	      option to get the static library.
+	    </p></li></ul></div><p>
 	  If GCC 3.1.0 or later on is being used on GNU/Linux, an attempt
 	  will be made to use "C" library functionality necessary for
 	  C++ named locale support.  For GCC 4.6.0 and later, this
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index 25c676d2892..3805e9e24f0 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -2,7 +2,7 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 1. Status</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="intro.html" title="Part I.  Introduction" /><link rel="prev" href="intro.html" title="Part I.  Introduction" /><link rel="next" href="license.html" title="License" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 1. Status</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="intro.html">Prev</a> </td><th width="60%" align="center">Part I. 
   Introduction
   
-</th><td width="20%" align="right"> <a accesskey="n" href="license.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.status"></a>Chapter 1. Status</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.iso"></a>Implementation Status</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.1998"></a>C++ 1998/2003</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.1998.status"></a>Implementation Status</h4></div></div></div><p>
+</th><td width="20%" align="right"> <a accesskey="n" href="license.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.status"></a>Chapter 1. Status</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.iso"></a>Implementation Status</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.1998"></a>C++ 1998/2003</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.1998.status"></a>Implementation Status</h4></div></div></div><p>
 This status table is based on the table of contents of ISO/IEC 14882:2003.
 </p><p>
 This section describes the C++ support in the GCC 11 release series.
@@ -1242,8 +1242,8 @@ presence of the required flag.
 This section describes the C++20 and library TS support in the GCC 11
 release series.
 </p><p>
-The following table lists new library features that have been accepted into
-the C++20 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++20 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -1344,10 +1344,10 @@ or any notes about the implementation.
       </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_atomic_float &gt;= 201711L</code> </td></tr><tr><td align="left">  C++ Synchronized Buffered Ostream </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0053r7.pdf" target="_top">
         P0053R7 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201711L</code> </td></tr><tr><td align="left">  Manipulators for C++ Synchronized Buffered Ostream </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201711L</code> </td></tr><tr><td align="left">  Manipulators for C++ Synchronized Buffered Ostream </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0753r2.pdf" target="_top">
         P0753R2 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201803L</code> </td></tr><tr><td align="left">  Make <code class="code">std::memory_order</code> a scoped enumeration </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201803L</code> </td></tr><tr><td align="left">  Make <code class="code">std::memory_order</code> a scoped enumeration </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0439r0.html" target="_top">
         P0439R0 </a>
       </td><td align="center"> 9.1 </td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">  The Curious Case of Padding Bits, Featuring Atomic Compare-and-Exchange </td><td align="left">
@@ -1428,7 +1428,7 @@ or any notes about the implementation.
       </td></tr><tr><td align="left">  <code class="code">string::reserve</code> Should Not Shrink </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0966r1.html" target="_top">
         P0966R1 </a>
-      </td><td align="center"> 11 </td><td align="left"> </td></tr><tr><td align="left">  <code class="code">char8_t</code>: A type for UTF-8 characters and strings </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left">  <code class="code">char8_t</code>: A type for UTF-8 characters and strings </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0482r6.html" target="_top">
         P0482R6 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_char8_t &gt;= 201811L</code> </td></tr><tr><td align="left">  <code class="code">char8_t</code> backward compatibility remediation </td><td align="left">
@@ -1555,7 +1555,7 @@ or any notes about the implementation.
       </td><td align="center"> </td><td align="left"> </td></tr><tr><td align="left">  Bit-casting object representations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0476r2.html" target="_top">
         P0476R2 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_bit_cast &gt;= 201806L</code> </td></tr><tr><td align="left">  Integral power-of-2 operations </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_bit_cast &gt;= 201806L</code> </td></tr><tr><td align="left">  Integral power-of-2 operations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0556r3.html" target="_top">
         P0556R3 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_int_pow2 &gt;= 201806L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left"> On the names of low-level bit manipulation functions </td><td align="left">
@@ -1675,7 +1675,7 @@ or any notes about the implementation.
       </td><td align="center"> 8.1 </td><td align="left"> <code class="code">__cpp_lib_endian &gt;= 201907L</code> </td></tr><tr><td align="left"> Bit operations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html" target="_top">
         P0553R4 </a>
-      </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left">  Well-behaved interpolation for numbers and pointers </td><td align="left">
+      </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left">  Well-behaved interpolation for numbers and pointers </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0811r3.html" target="_top">
         P0811R3 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_interpolate &gt;= 201902L</code> </td></tr><tr><td align="left"> Mathematical constants </td><td align="left">
@@ -1684,16 +1684,105 @@ or any notes about the implementation.
       </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_math_constants &gt;= 201907L</code> </td></tr><tr><td align="left"> std::source_location </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1208r6.pdf" target="_top">
         P1208R6 </a>
-      </td><td align="center"> 11 </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left">
         <code class="code">__cpp_lib_source_location &gt;= 201907L</code>
       </td></tr><tr><td align="left"> Efficient access to std::basic_stringbuf's Buffer </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf" target="_top">
         P0408R7 </a>
-      </td><td align="center"> 11 </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
 Note 1: This feature is supported in older releases but the
 <code class="code">__cpp_lib</code> macro is not defined to the right value
 (or not defined at all) until the version shown in parentheses.
-</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.tr1"></a>C++ TR1</h3></div></div></div><p>
+</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.2023"></a>C++ 2023</h3></div></div></div><p>
+In this implementation the <code class="literal">-std=gnu++23</code> or
+<code class="literal">-std=c++23</code> flag must be used to enable language
+and library
+features. See <a class="link" href="using.html#manual.intro.using.flags" title="Command Options">dialect</a>
+options. The pre-defined symbol
+<code class="constant">__cplusplus</code> is used to check for the
+presence of the required flag.
+</p><p>
+This section describes the C++23 and library TS support in mainline GCC,
+not in any particular release.
+</p><p>
+The following table lists new library features that have been accepted into
+the C++23 working draft. The "Proposal" column provides a link to the
+ISO C++ committee proposal that describes the feature, while the "Status"
+column indicates the first version of GCC that contains an implementation of
+this feature (if it has been implemented).
+A dash (—) in the status column indicates that the changes in the proposal
+either do not affect the code in libstdc++, or the changes are not required for conformance.
+The "SD-6 Feature Test / Notes" column shows the corresponding macro or header from
+<a class="link" href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations" target="_top">SD-6:
+Feature-testing recommendations for C++</a> (where applicable)
+or any notes about the implementation.
+</p><div class="table"><a id="table.cxx23_features"></a><p class="title"><strong>Table 1.10. C++ 2023 Library Features</strong></p><div class="table-contents"><table class="table" summary="C++ 2023 Library Features" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Library Feature</th><th align="left">Proposal</th><th align="left">Status</th><th align="left">SD-6 Feature Test / Notes</th></tr></thead><tbody><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Ranges and Views</strong></span>
+      </td></tr><tr><td align="left"> Range constructor for std::string_view </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf" target="_top">
+        P1989R2
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> <code class="code">join_view</code> should join all views of ranges </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r1.html" target="_top">
+        P2328R1
+        </a>
+      </td><td align="center"> 11.2 </td><td align="left"> </td></tr><tr><td align="left"> Clarifying range adaptor objects </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2281r1.html" target="_top">
+        P2281R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> Views should not be required to be default constructible </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html" target="_top">
+        P2325R3
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> <code class="code">__cpp_lib_ranges &gt;= 202106L</code> </td></tr><tr><td align="left"> Conditionally borrowed ranges </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2017r1.html" target="_top">
+        P2017R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> Require <code class="code">span</code> &amp; <code class="code">basic_string_view</code> to be Trivially Copyable </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf" target="_top">
+        P2251R1
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Compile-time programming</strong></span>
+      </td></tr><tr><td align="left"> A proposal for a type trait to detect scoped enumerations </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1048r1.pdf" target="_top">
+        P1048R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_is_scoped_enum &gt;= 202011L</code> </td></tr><tr><td align="left"> std::to_underlying for enumerations </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r3.html" target="_top">
+        P1682R3
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_to_underlying &gt;= 202102L</code> </td></tr><tr bgcolor="#B0B0B0"><td align="left"> Missing constexpr in std::optional and std::variant </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html" target="_top">
+        P2231R1
+        </a>
+      </td><td align="center"> 11.3 (<code class="code">optional</code> only) </td><td align="left">
+	<div class="informaltable"><table class="informaltable" border="0"><colgroup><col /></colgroup><tbody><tr><td> <code class="code">__cpp_lib_constexpr_optional &gt;= 202106L</code> </td></tr><tr><td> <code class="code">__cpp_lib_variant &gt;= 202106L</code> </td></tr></tbody></table></div>
+      </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Strings and text</strong></span>
+      </td></tr><tr><td align="left"> string contains function </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r3.html" target="_top">
+        P1679R3
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_string_contains &gt;= 202011L</code> </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Miscellaneous</strong></span>
+      </td></tr><tr><td align="left"> Inheriting from <code class="code">std::variant</code> </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2162r2.html" target="_top">
+        P2162R2
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> <code class="code">__cpp_lib_variant &gt;= 202102L</code> </td></tr><tr><td align="left"> Printing <code class="code">volatile</code> Pointers </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1147r1.html" target="_top">
+        P1147R1
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> </td></tr><tr><td align="left"> Clarifying the status of the "C headers" </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r1.html" target="_top">
+        P2340R1
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr><tr><td align="left"> Relax Requirements for time_point::clock </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html" target="_top">
+        P2212R2
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.tr1"></a>C++ TR1</h3></div></div></div><p>
 This table is based on the table of contents of ISO/IEC DTR 19768
 Doc No: N1836=05-0096 Date: 2005-06-24
 Draft Technical Report on C++ Library Extensions
@@ -1703,7 +1792,7 @@ In this implementation the header names are prefixed by
 <code class="code">&lt;tr1/memory&gt;</code>, and so on.
 </p><p>
 This page describes the TR1 support in the GCC 11 release series.
-</p><div class="table"><a id="table.tr1_status"></a><p class="title"><strong>Table 1.10. C++ TR1 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR1 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left"><span class="emphasis"><em>2</em></span></td><td colspan="3" align="left"><span class="emphasis"><em>General Utilities</em></span></td></tr><tr><td align="left">2.1</td><td align="left">Reference wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.1</td><td align="left">Additions to header <code class="code">&lt;functional&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.2.1</td><td align="left"><code class="code">reference_wrapper</code> construct/copy/destroy</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.2</td><td align="left"><code class="code">reference_wrapper</code> assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.3</td><td align="left"><code class="code">reference_wrapper</code> access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.4</td><td align="left"><code class="code">reference_wrapper</code> invocation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.5</td><td align="left"><code class="code">reference_wrapper</code> helper functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.2.1</td><td align="left">Additions to header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.2</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.3</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left"> </td><td align="left">
+</p><div class="table"><a id="table.tr1_status"></a><p class="title"><strong>Table 1.11. C++ TR1 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR1 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left"><span class="emphasis"><em>2</em></span></td><td colspan="3" align="left"><span class="emphasis"><em>General Utilities</em></span></td></tr><tr><td align="left">2.1</td><td align="left">Reference wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.1</td><td align="left">Additions to header <code class="code">&lt;functional&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.2.1</td><td align="left"><code class="code">reference_wrapper</code> construct/copy/destroy</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.2</td><td align="left"><code class="code">reference_wrapper</code> assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.3</td><td align="left"><code class="code">reference_wrapper</code> access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.4</td><td align="left"><code class="code">reference_wrapper</code> invocation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.5</td><td align="left"><code class="code">reference_wrapper</code> helper functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.2.1</td><td align="left">Additions to header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.2</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.3</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left"> </td><td align="left">
 	<p>
 	  Uses code from
 	  <a class="link" href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm" target="_top">boost::shared_ptr</a>.
@@ -1723,7 +1812,7 @@ Extension for the programming language C++ to support
 decimal floating-point arithmetic
 </p><p>
 This page describes the TR 24733 support in the GCC 11 release series.
-</p><div class="table"><a id="table.decfp_status"></a><p class="title"><strong>Table 1.11. C++ TR 24733 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
+</p><div class="table"><a id="table.decfp_status"></a><p class="title"><strong>Table 1.12. C++ TR 24733 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<span class="emphasis"><em>0</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Introduction</em></span>
@@ -1763,7 +1852,7 @@ non-strict modes (i.e. <code class="code">-std=gnu++NN</code> modes) the
 hypergeometric functions and confluent hypergeometric functions
 from TR1 are also provided, defined in namespace
 <code class="code">__gnu_cxx</code>.
-</p><div class="table"><a id="table.specfun_status"></a><p class="title"><strong>Table 1.12. C++ Special Functions Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ Special Functions Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr bgcolor="#B0B0B0"><td align="left">7</td><td align="left">Macro names</td><td align="left">Partial</td><td align="left">No diagnostic for inconsistent definitions of
+</p><div class="table"><a id="table.specfun_status"></a><p class="title"><strong>Table 1.13. C++ Special Functions Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ Special Functions Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr bgcolor="#B0B0B0"><td align="left">7</td><td align="left">Macro names</td><td align="left">Partial</td><td align="left">No diagnostic for inconsistent definitions of
              <code class="code">__STDCPP_WANT_MATH_SPEC_FUNCS__</code></td></tr><tr><td align="left">8</td><td align="left">Mathematical special functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1</td><td align="left">Additions to header <code class="code">&lt;cmath&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.1</td><td align="left">associated Laguerre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.2</td><td align="left">associated Legendre functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.3</td><td align="left">beta function</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.4</td><td align="left">(complete) elliptic integral of the first kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.5</td><td align="left">(complete) elliptic integral of the second kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.6</td><td align="left">(complete) elliptic integral of the third kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.7</td><td align="left">regular modified cylindrical Bessel functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.8</td><td align="left">cylindrical Bessel functions (of the first kind)</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.9</td><td align="left">irregular modified cylindrical Bessel functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.10</td><td align="left">cylindrical Neumann functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.11</td><td align="left">(incomplete) elliptic integral of the first kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.12</td><td align="left">(incomplete) elliptic integral of the second kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.13</td><td align="left">(incomplete) elliptic integral of the third kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.14</td><td align="left">exponential integral</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.15</td><td align="left">Hermite polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.16</td><td align="left">Laguerre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.17</td><td align="left">Legendre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.18</td><td align="left">Riemann zeta function</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.19</td><td align="left">spherical Bessel functions (of the first kind)</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.20</td><td align="left">spherical associated Legendre functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.21</td><td align="left">spherical Neumann functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.2</td><td align="left">Additions to header <code class="code">&lt;math.h&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">8.3</td><td align="left">The header <code class="code">&lt;ctgmath&gt;</code></td><td align="left">Partial</td><td align="left">Conflicts with C++ 2011 requirements.</td></tr><tr bgcolor="#C8B0B0"><td align="left">8.4</td><td align="left">The header <code class="code">&lt;tgmath.h&gt;</code></td><td align="left">N</td><td align="left">Conflicts with C++ 2011 requirements.</td></tr></tbody></table></div></div><br class="table-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.specfun.specific"></a>Implementation Specific Behavior</h4></div></div></div><p>For behaviour which is specified by the 2011 standard,
       see <a class="link" href="status.html#iso.2011.specific" title="Implementation Specific Behavior">C++ 2011 Implementation
       Specific Behavior</a>. This section documents behaviour which
diff --git a/libstdc++-v3/doc/xml/manual/intro.xml b/libstdc++-v3/doc/xml/manual/intro.xml
index 3e7843f58c1..62cab81651e 100644
--- a/libstdc++-v3/doc/xml/manual/intro.xml
+++ b/libstdc++-v3/doc/xml/manual/intro.xml
@@ -47,15 +47,19 @@
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxx2020.xml">
     </xi:include>
 
-    <!-- Section 01.5 : Status C++ TR1 -->
+    <!-- Section 01.5 : Status C++ 2023 -->
+    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxx2023.xml">
+    </xi:include>
+
+    <!-- Section 01.6 : Status C++ TR1 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxtr1.xml">
     </xi:include>
 
-    <!-- Section 01.6 : Status C++ TR24733 -->
+    <!-- Section 01.7 : Status C++ TR24733 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxtr24733.xml">
     </xi:include>
 
-    <!-- Section 01.7 : Status C++ IS 24733 -->
+    <!-- Section 01.8 : Status C++ IS 29124 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxis29124.xml">
     </xi:include>
   </section>
diff --git a/libstdc++-v3/doc/xml/manual/prerequisites.xml b/libstdc++-v3/doc/xml/manual/prerequisites.xml
index 22e90a7e79d..f00979a1afa 100644
--- a/libstdc++-v3/doc/xml/manual/prerequisites.xml
+++ b/libstdc++-v3/doc/xml/manual/prerequisites.xml
@@ -48,6 +48,57 @@
       <varlistentry>
 	<term>linux</term>
 
+	<listitem>
+	<para>
+	  The 'gnu' locale model makes use of <function>iconv</function>
+	  for character set conversions. The relevant functions are provided
+	  by Glibc and so are always available, however they can also be
+	  provided by the separate GNU libiconv library. If GNU libiconv is
+	  found when GCC is built (e.g., because its headers are installed
+	  in <filename class="directory">/usr/local/include</filename>)
+	  then the <filename>libstdc++.so.6</filename> library will have a
+	  run-time dependency on <filename>libiconv.so.2</filename>.
+	  If you do not want that run-time dependency then you should do
+	  one of the following:
+	</para>
+	<itemizedlist>
+	  <listitem>
+	    <para>
+	      Uninstall the libiconv headers before building GCC.
+	      Glibc already provides <function>iconv</function> so you should
+	      not need libiconv anyway.
+	    </para>
+	  </listitem>
+	  <listitem>
+	    <para>
+	    <link xmlns:xlink="http://www.w3.org/1999/xlink"
+	      xlink:href="https://www.gnu.org/software/libiconv/#downloading">
+	    Download</link> the libiconv sources and extract them into the
+	    top level of the GCC source tree, e.g.,
+	    </para>
+<programlisting>
+wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz
+tar xf libiconv-1.16.tar.gz
+ln -s libiconv-1.16 libiconv
+</programlisting>
+	    <para>
+	      This will build libiconv as part of building GCC and link to
+	      it statically, so there is no <filename>libiconv.so.2</filename>
+	      dependency.
+	    </para>
+	  </listitem>
+	  <listitem>
+	    <para>
+	      Configure GCC with <option>--with-libiconv-type=static</option>.
+	      This requires the static <filename>libiconv.a</filename> library,
+	      which is not installed by default. You might need to reinstall
+	      libiconv using the <option>--enable-static</option> configure
+	      option to get the static library.
+	    </para>
+	  </listitem>
+	</itemizedlist>
+	</listitem>
+
 	<listitem>
 	<para>
 	  If GCC 3.1.0 or later on is being used on GNU/Linux, an attempt
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
index 411a337c534..67aac7d64b8 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
@@ -25,8 +25,8 @@ release series.
 </para>
 
 <para>
-The following table lists new library features that have been accepted into
-the C++20 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++20 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -362,7 +362,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0053r7.pdf">
         P0053R7 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_syncbuf &gt;= 201711L</code> </entry>
     </row>
 
@@ -372,7 +372,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0753r2.pdf">
         P0753R2 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_syncbuf &gt;= 201803L</code> </entry>
     </row>
 
@@ -647,7 +647,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0966r1.html">
         P0966R1 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry />
     </row>
 
@@ -1045,7 +1045,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0476r2.html">
         P0476R2 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_bit_cast &gt;= 201806L</code> </entry>
     </row>
 
@@ -1401,7 +1401,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html">
         P0553R4 </link>
       </entry>
-      <entry align="center"> 10.1 </entry>
+      <entry align="center"> 9.1 </entry>
       <entry> <code>__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </entry>
     </row>
 
@@ -1431,7 +1431,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1208r6.pdf">
         P1208R6 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry>
         <code>__cpp_lib_source_location &gt;= 201907L</code>
       </entry>
@@ -1443,7 +1443,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">
         P0408R7 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry />
     </row>
 
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2023.xml b/libstdc++-v3/doc/xml/manual/status_cxx2023.xml
new file mode 100644
index 00000000000..75f31f55aa9
--- /dev/null
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2023.xml
@@ -0,0 +1,249 @@
+<section xmlns="http://docbook.org/ns/docbook" version="5.0"
+   xml:id="status.iso.2023" xreflabel="Status C++ 2023">
+<?dbhtml filename="status_iso_cxx2023.html"?>
+
+<info><title>C++ 2023</title>
+  <keywordset>
+    <keyword>ISO C++</keyword>
+    <keyword>2023</keyword>
+  </keywordset>
+</info>
+
+<para>
+In this implementation the <literal>-std=gnu++23</literal> or
+<literal>-std=c++23</literal> flag must be used to enable language
+and library
+features. See <link linkend="manual.intro.using.flags">dialect</link>
+options. The pre-defined symbol
+<constant>__cplusplus</constant> is used to check for the
+presence of the required flag.
+</para>
+
+<para>
+This section describes the C++23 and library TS support in mainline GCC,
+not in any particular release.
+</para>
+
+<para>
+The following table lists new library features that have been accepted into
+the C++23 working draft. The "Proposal" column provides a link to the
+ISO C++ committee proposal that describes the feature, while the "Status"
+column indicates the first version of GCC that contains an implementation of
+this feature (if it has been implemented).
+A dash (&#x2014;) in the status column indicates that the changes in the proposal
+either do not affect the code in libstdc++, or the changes are not required for conformance.
+The "SD-6 Feature Test / Notes" column shows the corresponding macro or header from
+<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">SD-6:
+Feature-testing recommendations for C++</link> (where applicable)
+or any notes about the implementation.
+</para>
+
+<table frame="all" xml:id="table.cxx23_features">
+<title>C++ 2023 Library Features</title>
+
+<tgroup cols="4" align="left" colsep="0" rowsep="1">
+<colspec colname="c1"/>
+<colspec colname="c2"/>
+<colspec colname="c3"/>
+<colspec colname="c4"/>
+  <thead>
+    <row>
+      <entry>Library Feature</entry>
+      <entry>Proposal</entry>
+      <entry>Status</entry>
+      <entry>SD-6 Feature Test / Notes</entry>
+    </row>
+  </thead>
+
+  <tbody>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Ranges and Views</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> Range constructor for std::string_view </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf">
+        P1989R2
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> <code>join_view</code> should join all views of ranges </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r1.html">
+        P2328R1
+        </link>
+      </entry>
+      <entry align="center"> 11.2 </entry>
+      <entry />
+    </row>
+
+
+    <row>
+      <entry> Clarifying range adaptor objects </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2281r1.html">
+        P2281R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Views should not be required to be default constructible </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html">
+        P2325R3
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry> <code>__cpp_lib_ranges &gt;= 202106L</code> </entry>
+    </row>
+
+    <row>
+      <entry> Conditionally borrowed ranges </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2017r1.html">
+        P2017R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Require <code>span</code> &amp; <code>basic_string_view</code> to be Trivially Copyable </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf">
+        P2251R1
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Compile-time programming</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> A proposal for a type trait to detect scoped enumerations </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1048r1.pdf">
+        P1048R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_is_scoped_enum &gt;= 202011L</code> </entry>
+    </row>
+
+    <row>
+      <entry> std::to_underlying for enumerations </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r3.html">
+        P1682R3
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_to_underlying &gt;= 202102L</code> </entry>
+    </row>
+
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry> Missing constexpr in std::optional and std::variant </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html">
+        P2231R1
+        </link>
+      </entry>
+      <entry align="center"> 11.3 (<code>optional</code> only) </entry>
+      <entry>
+	<informaltable colsep="0" rowsep="0" rowheader="norowheader" frame="none"><tgroup cols="1"><tbody>
+        <row><entry> <code>__cpp_lib_constexpr_optional &gt;= 202106L</code> </entry></row>
+        <row><entry> <code>__cpp_lib_variant &gt;= 202106L</code> </entry></row>
+        </tbody></tgroup></informaltable>
+      </entry>
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Strings and text</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> string contains function </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r3.html">
+        P1679R3
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_string_contains &gt;= 202011L</code> </entry>
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Miscellaneous</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> Inheriting from <code>std::variant</code> </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2162r2.html">
+        P2162R2
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry> <code>__cpp_lib_variant &gt;= 202102L</code> </entry>
+    </row>
+
+    <row>
+      <entry> Printing <code>volatile</code> Pointers </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1147r1.html">
+        P1147R1
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Clarifying the status of the "C headers" </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r1.html">
+        P2340R1
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Relax Requirements for time_point::clock </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html">
+        P2212R2
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+  </tbody>
+</tgroup>
+</table>
+
+</section>
diff --git a/libstdc++-v3/include/bits/atomic_base.h b/libstdc++-v3/include/bits/atomic_base.h
index 60b976bf8d1..2abdc400260 100644
--- a/libstdc++-v3/include/bits/atomic_base.h
+++ b/libstdc++-v3/include/bits/atomic_base.h
@@ -121,6 +121,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       | __memory_order_modifier(__m & __memory_order_modifier_mask));
   }
 
+  constexpr bool
+  __is_valid_cmpexch_failure_order(memory_order __m) noexcept
+  {
+    return (__m & __memory_order_mask) != memory_order_release
+	&& (__m & __memory_order_mask) != memory_order_acq_rel;
+  }
+
   _GLIBCXX_ALWAYS_INLINE void
   atomic_thread_fence(memory_order __m) noexcept
   { __atomic_thread_fence(int(__m)); }
@@ -245,13 +252,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     _GLIBCXX_ALWAYS_INLINE void
-    notify_one() const noexcept
+    notify_one() noexcept
     { std::__atomic_notify_address(&_M_i, false); }
 
     // TODO add const volatile overload
 
     _GLIBCXX_ALWAYS_INLINE void
-    notify_all() const noexcept
+    notify_all() noexcept
     { std::__atomic_notify_address(&_M_i, true); }
 
     // TODO add const volatile overload
@@ -511,13 +518,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(__int_type& __i1, __int_type __i2,
 			    memory_order __m1, memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
 					   int(__m1), int(__m2));
@@ -528,13 +529,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			    memory_order __m1,
 			    memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
 					   int(__m1), int(__m2));
@@ -560,13 +555,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(__int_type& __i1, __int_type __i2,
 			      memory_order __m1, memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
 					   int(__m1), int(__m2));
@@ -577,14 +566,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
 					   int(__m1), int(__m2));
@@ -618,13 +600,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // TODO add const volatile overload
 
       _GLIBCXX_ALWAYS_INLINE void
-      notify_one() const noexcept
+      notify_one() noexcept
       { std::__atomic_notify_address(&_M_i, false); }
 
       // TODO add const volatile overload
 
       _GLIBCXX_ALWAYS_INLINE void
-      notify_all() const noexcept
+      notify_all() noexcept
       { std::__atomic_notify_address(&_M_i, true); }
 
       // TODO add const volatile overload
@@ -869,13 +851,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
 					   int(__m1), int(__m2));
@@ -886,14 +862,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
 					   int(__m1), int(__m2));
@@ -996,6 +965,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			    _Val<_Tp> __desired, memory_order __success,
 			    memory_order __failure) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));
+
 	return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
 					 std::__addressof(__desired), true,
 					 int(__success), int(__failure));
@@ -1007,6 +978,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      _Val<_Tp> __desired, memory_order __success,
 			      memory_order __failure) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));
+
 	return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
 					 std::__addressof(__desired), false,
 					 int(__success), int(__failure));
diff --git a/libstdc++-v3/include/bits/forward_list.tcc b/libstdc++-v3/include/bits/forward_list.tcc
index bd7a859091f..1145230b910 100644
--- a/libstdc++-v3/include/bits/forward_list.tcc
+++ b/libstdc++-v3/include/bits/forward_list.tcc
@@ -367,6 +367,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       forward_list<_Tp, _Alloc>::
       merge(forward_list&& __list, _Comp __comp)
       {
+	// _GLIBCXX_RESOLVE_LIB_DEFECTS
+	// 3088. forward_list::merge behavior unclear when passed *this
+	if (std::__addressof(__list) == this)
+	  return;
+
 	_Node_base* __node = &this->_M_impl._M_head;
 	while (__node->_M_next && __list._M_impl._M_head._M_next)
 	  {
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.tcc b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
index 51c23d8003a..4aef5502032 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.tcc
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
@@ -78,32 +78,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       char* __grouping = 0;
       _CharT* __curr_symbol = 0;
       _CharT* __positive_sign = 0;
-      _CharT* __negative_sign = 0;     
+      _CharT* __negative_sign = 0;
+      size_t __sz;
       __try
 	{
 	  const string& __g = __mp.grouping();
-	  _M_grouping_size = __g.size();
-	  __grouping = new char[_M_grouping_size];
-	  __g.copy(__grouping, _M_grouping_size);
+	  __sz = _M_grouping_size = __g.size();
+	  __grouping = new char[__sz];
+	  __g.copy(__grouping, __sz);
 	  _M_use_grouping = (_M_grouping_size
 			     && static_cast<signed char>(__grouping[0]) > 0
 			     && (__grouping[0]
 				 != __gnu_cxx::__numeric_traits<char>::__max));
 
 	  const basic_string<_CharT>& __cs = __mp.curr_symbol();
-	  _M_curr_symbol_size = __cs.size();
-	  __curr_symbol = new _CharT[_M_curr_symbol_size];
-	  __cs.copy(__curr_symbol, _M_curr_symbol_size);
+	  __sz = _M_curr_symbol_size = __cs.size();
+	  __curr_symbol = new _CharT[__sz];
+	  __cs.copy(__curr_symbol, __sz);
 
 	  const basic_string<_CharT>& __ps = __mp.positive_sign();
-	  _M_positive_sign_size = __ps.size();
-	  __positive_sign = new _CharT[_M_positive_sign_size];
-	  __ps.copy(__positive_sign, _M_positive_sign_size);
+	  __sz = _M_positive_sign_size = __ps.size();
+	  __positive_sign = new _CharT[__sz];
+	  __ps.copy(__positive_sign, __sz);
 
 	  const basic_string<_CharT>& __ns = __mp.negative_sign();
-	  _M_negative_sign_size = __ns.size();
-	  __negative_sign = new _CharT[_M_negative_sign_size];
-	  __ns.copy(__negative_sign, _M_negative_sign_size);
+	  __sz = _M_negative_sign_size = __ns.size();
+	  __negative_sign = new _CharT[__sz];
+	  __ns.copy(__negative_sign, __sz);
 
 	  _M_pos_format = __mp.pos_format();
 	  _M_neg_format = __mp.neg_format();
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
index 22ae1f38ebb..2898f7f17e6 100644
--- a/libstdc++-v3/include/bits/random.tcc
+++ b/libstdc++-v3/include/bits/random.tcc
@@ -1955,7 +1955,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool __saved_avail;
       if (__is >> __mean >> __stddev >> __saved_avail)
 	{
-	  if (__saved_avail && (__is >> __x._M_saved))
+	  if (!__saved_avail || (__is >> __x._M_saved))
 	    {
 	      __x._M_saved_available = __saved_avail;
 	      __x.param(param_type(__mean, __stddev));
diff --git a/libstdc++-v3/include/bits/ranges_base.h b/libstdc++-v3/include/bits/ranges_base.h
index 87283b84028..6d2d5bf939d 100644
--- a/libstdc++-v3/include/bits/ranges_base.h
+++ b/libstdc++-v3/include/bits/ranges_base.h
@@ -728,20 +728,23 @@ namespace ranges
 	  {
 	    const auto __diff = __bound - __it;
 
-	    // n and bound must not lead in opposite directions:
-	    __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));
-	    const auto __absdiff = __diff < 0 ? -__diff : __diff;
-	    const auto __absn = __n < 0 ? -__n : __n;;
-	    if (__absn >= __absdiff)
+	    if (__diff == 0)
+	      return __n;
+	    else if (__diff > 0 ? __n >= __diff : __n <= __diff)
 	      {
 		(*this)(__it, __bound);
 		return __n - __diff;
 	      }
-	    else
+	    else if (__n != 0) [[likely]]
 	      {
+		// n and bound must not lead in opposite directions:
+		__glibcxx_assert(__n < 0 == __diff < 0);
+
 		(*this)(__it, __n);
 		return 0;
 	      }
+	    else
+	      return 0;
 	  }
 	else if (__it == __bound || __n == 0)
 	  return __n;
diff --git a/libstdc++-v3/include/bits/regex_compiler.tcc b/libstdc++-v3/include/bits/regex_compiler.tcc
index 440669debe0..e4f73971bbb 100644
--- a/libstdc++-v3/include/bits/regex_compiler.tcc
+++ b/libstdc++-v3/include/bits/regex_compiler.tcc
@@ -586,9 +586,9 @@ namespace __detail
   template<typename _TraitsT>
     bool
     _Compiler<_TraitsT>::
-    _M_match_token(_TokenT token)
+    _M_match_token(_TokenT __token)
     {
-      if (token == _M_scanner._M_get_token())
+      if (__token == _M_scanner._M_get_token())
 	{
 	  _M_value = _M_scanner._M_get_value();
 	  _M_scanner._M_advance();
diff --git a/libstdc++-v3/include/bits/stl_construct.h b/libstdc++-v3/include/bits/stl_construct.h
index e53ed0d9f91..f14fba0cfb1 100644
--- a/libstdc++-v3/include/bits/stl_construct.h
+++ b/libstdc++-v3/include/bits/stl_construct.h
@@ -116,7 +116,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return;
 	}
 #endif
-      ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...);
+      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
     }
 #else
   template<typename _T1, typename _T2>
@@ -132,7 +132,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _T1>
     inline void
     _Construct_novalue(_T1* __p)
-    { ::new(static_cast<void*>(__p)) _T1; }
+    { ::new((void*)__p) _T1; }
 
   template<typename _ForwardIterator>
     _GLIBCXX20_CONSTEXPR void
diff --git a/libstdc++-v3/include/bits/stl_deque.h b/libstdc++-v3/include/bits/stl_deque.h
index 20c73b4fc3c..8236fe35ce7 100644
--- a/libstdc++-v3/include/bits/stl_deque.h
+++ b/libstdc++-v3/include/bits/stl_deque.h
@@ -353,7 +353,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
       {
 	return difference_type(_S_buffer_size())
-	  * (__x._M_node - __y._M_node - int(__x._M_node != 0))
+	  * (__x._M_node - __y._M_node - bool(__x._M_node))
 	  + (__x._M_cur - __x._M_first)
 	  + (__y._M_last - __y._M_cur);
       }
@@ -365,10 +365,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       template<typename _RefR, typename _PtrR>
 	friend difference_type
 	operator-(const _Self& __x,
-		  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
+		  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
+	_GLIBCXX_NOEXCEPT
 	{
 	  return difference_type(_S_buffer_size())
-	    * (__x._M_node - __y._M_node - int(__x._M_node != 0))
+	    * (__x._M_node - __y._M_node - bool(__x._M_node))
 	    + (__x._M_cur - __x._M_first)
 	    + (__y._M_last - __y._M_cur);
 	}
diff --git a/libstdc++-v3/include/bits/stl_iterator.h b/libstdc++-v3/include/bits/stl_iterator.h
index beeb4ef4c8a..4247bb116c3 100644
--- a/libstdc++-v3/include/bits/stl_iterator.h
+++ b/libstdc++-v3/include/bits/stl_iterator.h
@@ -537,6 +537,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<=>(const reverse_iterator<_IteratorL>& __x,
 		const reverse_iterator<_IteratorR>& __y)
     { return __y.base() <=> __x.base(); }
+
+  // Additional, non-standard overloads to avoid ambiguities with greedy,
+  // unconstrained overloads in associated namespaces.
+
+  template<typename _Iterator>
+    constexpr bool
+    operator==(const reverse_iterator<_Iterator>& __x,
+	       const reverse_iterator<_Iterator>& __y)
+    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
+    { return __x.base() == __y.base(); }
+
+  template<three_way_comparable _Iterator>
+    constexpr compare_three_way_result_t<_Iterator, _Iterator>
+    operator<=>(const reverse_iterator<_Iterator>& __x,
+		const reverse_iterator<_Iterator>& __y)
+    { return __y.base() <=> __x.base(); }
 #endif // C++20
   ///@}
 
@@ -1113,6 +1129,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		const __normal_iterator<_IteratorR, _Container>& __rhs)
     noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
     { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
+
+  template<typename _Iterator, typename _Container>
+    constexpr bool
+    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
+	       const __normal_iterator<_Iterator, _Container>& __rhs)
+    noexcept(noexcept(__lhs.base() == __rhs.base()))
+    requires requires {
+      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
+    }
+    { return __lhs.base() == __rhs.base(); }
+
+  template<typename _Iterator, typename _Container>
+    constexpr std::__detail::__synth3way_t<_Iterator>
+    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
+		const __normal_iterator<_Iterator, _Container>& __rhs)
+    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
+    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
 #else
    // Forward iterator requirements
   template<typename _IteratorL, typename _IteratorR, typename _Container>
@@ -1588,20 +1621,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
     { return !(__x < __y); }
 
-#if ! (__cplusplus > 201703L && __cpp_lib_concepts)
   // Note: See __normal_iterator operators note from Gaby to understand
   // why we have these extra overloads for some move_iterator operators.
 
-  // These extra overloads are not needed in C++20, because the ones above
-  // are constrained with a requires-clause and so overload resolution will
-  // prefer them to greedy unconstrained function templates.
-
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR bool
     operator==(const move_iterator<_Iterator>& __x,
 	       const move_iterator<_Iterator>& __y)
     { return __x.base() == __y.base(); }
 
+#if __cpp_lib_three_way_comparison
+  template<three_way_comparable _Iterator>
+    constexpr compare_three_way_result_t<_Iterator>
+    operator<=>(const move_iterator<_Iterator>& __x,
+		const move_iterator<_Iterator>& __y)
+    { return __x.base() <=> __y.base(); }
+#else
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR bool
     operator!=(const move_iterator<_Iterator>& __x,
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 1cc1b3bf686..a2bc931c696 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -425,8 +425,8 @@ namespace __detail
     class iterator;
     typedef iterator const_iterator;
 
-    iterator begin() const noexcept;
-    iterator end() const noexcept;
+    iterator begin() const;
+    iterator end() const;
 
     /// @cond undocumented
     // Create a basic_string by reading until a null character.
diff --git a/libstdc++-v3/include/experimental/bits/simd.h b/libstdc++-v3/include/experimental/bits/simd.h
index 421c923e7b0..0e58ae01b17 100644
--- a/libstdc++-v3/include/experimental/bits/simd.h
+++ b/libstdc++-v3/include/experimental/bits/simd.h
@@ -2303,17 +2303,23 @@ template <typename _Tp>
   template <>                                                                  \
     struct __intrinsic_type_impl<_Tp> { using type = __vector _Tp; }
 _GLIBCXX_SIMD_PPC_INTRIN(float);
+#ifdef __VSX__
 _GLIBCXX_SIMD_PPC_INTRIN(double);
+#endif
 _GLIBCXX_SIMD_PPC_INTRIN(signed char);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned char);
 _GLIBCXX_SIMD_PPC_INTRIN(signed short);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned short);
 _GLIBCXX_SIMD_PPC_INTRIN(signed int);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned int);
+#if defined __VSX__ || __SIZEOF_LONG__ == 4
 _GLIBCXX_SIMD_PPC_INTRIN(signed long);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned long);
+#endif
+#ifdef __VSX__
 _GLIBCXX_SIMD_PPC_INTRIN(signed long long);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned long long);
+#endif
 #undef _GLIBCXX_SIMD_PPC_INTRIN
 
 template <typename _Tp, size_t _Bytes>
@@ -2323,10 +2329,11 @@ template <typename _Tp, size_t _Bytes>
     static constexpr bool _S_is_ldouble = is_same_v<_Tp, long double>;
     // allow _Tp == long double with -mlong-double-64
     static_assert(!(_S_is_ldouble && sizeof(long double) > sizeof(double)),
-		  "no __intrinsic_type support for long double on PPC");
+		  "no __intrinsic_type support for 128-bit floating point on PowerPC");
 #ifndef __VSX__
-    static_assert(!is_same_v<_Tp, double>,
-		  "no __intrinsic_type support for double on PPC w/o VSX");
+    static_assert(!(is_same_v<_Tp, double>
+		    || (_S_is_ldouble && sizeof(long double) == sizeof(double))),
+		  "no __intrinsic_type support for 64-bit floating point on PowerPC w/o VSX");
 #endif
     using type =
       typename __intrinsic_type_impl<
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index 6ce070ae775..07eb137fb80 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -441,13 +441,15 @@ namespace ip
     // constructors:
     constexpr address() noexcept : _M_v4(), _M_is_v4(true) { }
 
+#if __cpp_constexpr_dynamic_alloc
     constexpr
+#endif
     address(const address& __a) noexcept : _M_uninit(), _M_is_v4(__a._M_is_v4)
     {
       if (_M_is_v4)
-	::new (std::addressof(_M_v4)) address_v4(__a.to_v4());
+	std::_Construct(std::addressof(_M_v4), __a.to_v4());
       else
-	::new (std::addressof(_M_v6)) address_v6(__a.to_v6());
+	std::_Construct(std::addressof(_M_v6), __a.to_v6());
     }
 
     constexpr
@@ -470,7 +472,7 @@ namespace ip
     address&
     operator=(const address_v4& __a) noexcept
     {
-      ::new (std::addressof(_M_v4)) address_v4(__a);
+      std::_Construct(std::addressof(_M_v4), __a);
       _M_is_v4 = true;
       return *this;
     }
@@ -478,7 +480,7 @@ namespace ip
     address&
     operator=(const address_v6& __a) noexcept
     {
-      ::new (std::addressof(_M_v6)) address_v6(__a);
+      std::_Construct(std::addressof(_M_v6), __a);
       _M_is_v4 = false;
       return *this;
     }
diff --git a/libstdc++-v3/include/std/atomic b/libstdc++-v3/include/std/atomic
index fdffacc35df..0d4e3a7396e 100644
--- a/libstdc++-v3/include/std/atomic
+++ b/libstdc++-v3/include/std/atomic
@@ -172,11 +172,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { _M_base.notify_one(); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { _M_base.notify_all(); }
 #endif // __cpp_lib_atomic_wait
   };
@@ -320,6 +320,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
 			    memory_order __f) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -330,6 +332,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
 			    memory_order __f) volatile noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -352,6 +356,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
 			      memory_order __f) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -362,6 +368,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
 			      memory_order __f) volatile noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -391,11 +399,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { std::__atomic_notify_address(&_M_i, false); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { std::__atomic_notify_address(&_M_i, true); }
 #endif // __cpp_lib_atomic_wait 
 
@@ -645,11 +653,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { _M_b.notify_one(); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { _M_b.notify_all(); }
 #endif // __cpp_lib_atomic_wait
       __pointer_type
@@ -1421,12 +1429,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _Tp>
     inline void
-    atomic_notify_one(const atomic<_Tp>* __a) noexcept
+    atomic_notify_one(atomic<_Tp>* __a) noexcept
     { __a->notify_one(); }
 
   template<typename _Tp>
     inline void
-    atomic_notify_all(const atomic<_Tp>* __a) noexcept
+    atomic_notify_all(atomic<_Tp>* __a) noexcept
     { __a->notify_all(); }
 #endif // __cpp_lib_atomic_wait
 
diff --git a/libstdc++-v3/include/std/charconv b/libstdc++-v3/include/std/charconv
index 8572e376c92..65f923993fa 100644
--- a/libstdc++-v3/include/std/charconv
+++ b/libstdc++-v3/include/std/charconv
@@ -39,7 +39,6 @@
 
 #include <type_traits>
 #include <bit>			// for __bit_width
-#include <cctype>		// for isdigit
 #include <bits/charconv.h>	// for __to_chars_len, __to_chars_10_impl
 #include <bits/error_constants.h> // for std::errc
 #include <ext/numeric_traits.h>
@@ -466,7 +465,7 @@ namespace __detail
       return true;
     }
 
-  constexpr unsigned char
+  constexpr char
   __from_chars_alpha_to_num(char __c)
   {
     switch (__c)
@@ -550,10 +549,10 @@ namespace __detail
     case 'Z':
       return 35;
     }
-    return __gnu_cxx::__int_traits<unsigned char>::__max;
+    return 127;
   }
 
-  /// std::from_chars implementation for integers in bases 11 to 26.
+  /// std::from_chars implementation for integers in bases 11 to 36.
   template<typename _Tp>
     bool
     __from_chars_alnum(const char*& __first, const char* __last, _Tp& __val,
@@ -562,8 +561,8 @@ namespace __detail
       bool __valid = true;
       while (__first != __last)
 	{
-	  unsigned char __c = *__first;
-	  if (std::isdigit(__c))
+	  char __c = *__first;
+	  if ('0' <= __c && __c <= '9') // isdigit
 	    __c -= '0';
 	  else
 	    {
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 09e54c3703b..f5d8da472f5 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -1621,6 +1621,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
     };
 
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 3117. Missing packaged_task deduction guides
+#if __cpp_deduction_guides >= 201606
+  template<typename _Res, typename... _ArgTypes>
+    packaged_task(_Res(*)(_ArgTypes...)) -> packaged_task<_Res(_ArgTypes...)>;
+
+  template<typename _Fun, typename _Signature = typename
+	   __function_guide_helper<decltype(&_Fun::operator())>::type>
+    packaged_task(_Fun) -> packaged_task<_Signature>;
+#endif
+
   /// swap
   template<typename _Res, typename... _ArgTypes>
     inline void
diff --git a/libstdc++-v3/include/std/iosfwd b/libstdc++-v3/include/std/iosfwd
index 52fa4b6cccb..610383992fb 100644
--- a/libstdc++-v3/include/std/iosfwd
+++ b/libstdc++-v3/include/std/iosfwd
@@ -207,6 +207,24 @@ _GLIBCXX_END_NAMESPACE_CXX11
   /// Class for @c wchar_t mixed input and output file streams.
   typedef basic_fstream<wchar_t> 	wfstream;
 #endif
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+           typename _Allocator = allocator<_CharT>>
+    class basic_syncbuf;
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+           typename _Allocator = allocator<_CharT>>
+    class basic_osyncstream;
+
+  using syncbuf = basic_syncbuf<char>;
+  using osyncstream = basic_osyncstream<char>;
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  using wsyncbuf = basic_syncbuf<wchar_t>;
+  using wosyncstream = basic_osyncstream<wchar_t>;
+#endif
+#endif // C++20 && CXX11_ABI
+
   /** @}  */
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/std/ranges b/libstdc++-v3/include/std/ranges
index f55ee15e1b1..bbdfb7dbe5c 100644
--- a/libstdc++-v3/include/std/ranges
+++ b/libstdc++-v3/include/std/ranges
@@ -2916,7 +2916,7 @@ namespace views::__adaptor
 	    { return _InnerIter<_Const>{_M_i}; }
 
 	    constexpr default_sentinel_t
-	    end() const
+	    end() const noexcept
 	    { return default_sentinel; }
 	  };
 
diff --git a/libstdc++-v3/include/std/span b/libstdc++-v3/include/std/span
index af0d24b29f2..2adf1ca2e09 100644
--- a/libstdc++-v3/include/std/span
+++ b/libstdc++-v3/include/std/span
@@ -201,11 +201,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{ }
 
       template<typename _Range>
-	requires ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
-	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
-	  && (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
+	requires (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
 	  && (!__detail::__is_std_array<remove_cvref_t<_Range>>::value)
 	  && (!is_array_v<remove_cvref_t<_Range>>)
+	  && ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
+	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
 	  && __is_compatible_ref<ranges::range_reference_t<_Range>>::value
 	constexpr explicit(extent != dynamic_extent)
 	span(_Range&& __range)
diff --git a/libstdc++-v3/include/std/syncstream b/libstdc++-v3/include/std/syncstream
index db6ebd50471..ac39d0f2243 100644
--- a/libstdc++-v3/include/std/syncstream
+++ b/libstdc++-v3/include/std/syncstream
@@ -50,8 +50,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  template<typename _CharT, typename _Traits = char_traits<_CharT>,
-	    typename _Alloc = allocator<_CharT>>
+  template<typename _CharT, typename _Traits, typename _Alloc>
     class basic_syncbuf : public __syncbuf_base<_CharT, _Traits>
     {
     public:
@@ -241,8 +240,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __mutex _M_mtx;
     };
 
-  template <typename _CharT, typename _Traits = char_traits<_CharT>,
-	    typename _Alloc = allocator<_CharT>>
+  template <typename _CharT, typename _Traits, typename _Alloc>
     class basic_osyncstream : public basic_ostream<_CharT, _Traits>
     {
       using __ostream_type = basic_ostream<_CharT, _Traits>;
diff --git a/libstdc++-v3/include/std/tuple b/libstdc++-v3/include/std/tuple
index dcf30bd9a8d..63bd68fbe43 100644
--- a/libstdc++-v3/include/std/tuple
+++ b/libstdc++-v3/include/std/tuple
@@ -553,10 +553,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<bool, typename... _Types>
     struct _TupleConstraints
     {
-      template<typename _Tp, typename _Up> // Workaround for PR 96592
-	using is_constructible
-	  = __bool_constant<__is_constructible(_Tp, _Up)>;
-
       // Constraint for a non-explicit constructor.
       // True iff each Ti in _Types... can be constructed from Ui in _UTypes...
       // and every Ui is implicitly convertible to Ti.
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 16f4cc6eff4..f92a52748c5 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -267,7 +267,9 @@ CXXLINK = \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CXX) \
 	$(VTV_CXXLINKFLAGS) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) \
+	$(LTLDFLAGS) $(LTLIBICONV) \
+	-o $@
 
 # Symbol versioning for shared libraries.
 if ENABLE_SYMVERS
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index 4df5c829a7f..2fff46209ad 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -631,7 +631,9 @@ CXXLINK = \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CXX) \
 	$(VTV_CXXLINKFLAGS) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) \
+	$(LTLDFLAGS) $(LTLIBICONV) \
+	-o $@
 
 @ENABLE_SYMVERS_TRUE@CLEANFILES = libstdc++-symbols.ver $(version_dep)
 @ENABLE_SYMVERS_DARWIN_TRUE@@ENABLE_SYMVERS_TRUE@version_arg = -Wl,-exported_symbols_list,libstdc++-symbols.explist
diff --git a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
index a918ab21015..e40685bf45a 100644
--- a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
+++ b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
@@ -44,14 +44,15 @@
 
 namespace
 {
-  struct io_error_category : std::error_category
+  struct io_error_category final : std::error_category
   {
-    virtual const char*
-    name() const noexcept
+    const char*
+    name() const noexcept final
     { return "iostream"; }
 
     _GLIBCXX_DEFAULT_ABI_TAG
-    virtual std::string message(int __ec) const
+    std::string
+    message(int __ec) const final
     {
       std::string __msg;
       switch (std::io_errc(__ec))
@@ -67,13 +68,17 @@ namespace
     }
   };
 
-  const io_error_category&
-  __io_category_instance() noexcept
+  struct constant_init
   {
-    static const io_error_category __ec{};
-    return __ec;
-  }
+    union {
+      unsigned char unused;
+      io_error_category cat;
+    };
+    constexpr constant_init() : cat() { }
+    ~constant_init() { /* do nothing, union member is not destroyed */ }
+  };
 
+  __constinit constant_init io_category_instance{};
 } // namespace
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -82,7 +87,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   const error_category&
   iostream_category() noexcept
-  { return __io_category_instance(); }
+  { return io_category_instance.cat; }
 
   ios_base::failure::failure(const string& __str)
   : system_error(io_errc::stream, __str) { }
diff --git a/libstdc++-v3/src/c++11/future.cc b/libstdc++-v3/src/c++11/future.cc
index c1a1a828e27..75f832ec1c5 100644
--- a/libstdc++-v3/src/c++11/future.cc
+++ b/libstdc++-v3/src/c++11/future.cc
@@ -27,14 +27,15 @@
 
 namespace
 {
-  struct future_error_category : public std::error_category
+  struct future_error_category final : public std::error_category
   {
-    virtual const char*
-    name() const noexcept
+    const char*
+    name() const noexcept final
     { return "future"; }
 
     _GLIBCXX_DEFAULT_ABI_TAG
-    virtual std::string message(int __ec) const
+    std::string
+    message(int __ec) const final
     {
       std::string __msg;
       switch (std::future_errc(__ec))
@@ -59,12 +60,17 @@ namespace
     }
   };
 
-  const future_error_category&
-  __future_category_instance() noexcept
+  struct constant_init
   {
-    static const future_error_category __fec{};
-    return __fec;
-  }
+    union {
+      unsigned char unused;
+      future_error_category cat;
+    };
+    constexpr constant_init() : cat() { }
+    ~constant_init() { /* do nothing, union member is not destroyed */ }
+  };
+
+  __constinit constant_init future_category_instance{};
 }
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -76,7 +82,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   { _GLIBCXX_THROW_OR_ABORT(future_error(make_error_code(future_errc(__i)))); }
 
   const error_category& future_category() noexcept
-  { return __future_category_instance(); }
+  { return future_category_instance.cat; }
 
   future_error::~future_error() noexcept { }
 
diff --git a/libstdc++-v3/src/c++17/floating_from_chars.cc b/libstdc++-v3/src/c++17/floating_from_chars.cc
index aa074869872..ca1ad84e2ca 100644
--- a/libstdc++-v3/src/c++17/floating_from_chars.cc
+++ b/libstdc++-v3/src/c++17/floating_from_chars.cc
@@ -37,7 +37,6 @@
 #include <cmath>
 #include <cstdlib>
 #include <cstring>
-#include <cctype>
 #include <locale.h>
 #include <bits/functexcept.h>
 #if _GLIBCXX_HAVE_XLOCALE_H
@@ -75,7 +74,6 @@ namespace
 	return m_buf + std::__exchange(m_bytes, m_bytes + bytes);
 
       __glibcxx_assert(m_ptr == nullptr);
-      __glibcxx_assert(alignment != 1);
 
       m_ptr = operator new(bytes);
       m_bytes = bytes;
@@ -116,10 +114,10 @@ namespace
 
   // Find initial portion of [first, last) containing a floating-point number.
   // The string `digits` is either `dec_digits` or `hex_digits`
-  // and `exp` is 'e' or 'p' or '\0'.
+  // and `exp` is "eE", "pP" or NULL.
   const char*
   find_end_of_float(const char* first, const char* last, const char* digits,
-		    char exp)
+		    const char *exp)
   {
     while (first < last && strchr(digits, *first) != nullptr)
       ++first;
@@ -129,7 +127,7 @@ namespace
 	while (first < last && strchr(digits, *first))
 	  ++first;
       }
-    if (first < last && exp != 0 && std::tolower((unsigned char)*first) == exp)
+    if (first < last && exp != nullptr && (*first == exp[0] || *first == exp[1]))
       {
 	++first;
 	if (first < last && (*first == '-' || *first == '+'))
@@ -211,7 +209,7 @@ namespace
 
 	if ((last - first + 2) > buffer_resource::guaranteed_capacity())
 	  {
-	    last = find_end_of_float(first + neg, last, digits, 'p');
+	    last = find_end_of_float(first + neg, last, digits, "pP");
 #ifndef __cpp_exceptions
 	    if ((last - first + 2) > buffer_resource::guaranteed_capacity())
 	      {
@@ -235,7 +233,7 @@ namespace
 	if ((last - first) > buffer_resource::guaranteed_capacity())
 	  {
 	    last = find_end_of_float(first + neg, last, digits,
-				     "e"[fmt == chars_format::fixed]);
+				     fmt == chars_format::fixed ? nullptr : "eE");
 #ifndef __cpp_exceptions
 	    if ((last - first) > buffer_resource::guaranteed_capacity())
 	      {
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index acff0ff926e..481b49d20be 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -27,6 +27,10 @@
 # define NEED_DO_COPY_FILE
 # define NEED_DO_SPACE
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <filesystem>
@@ -404,8 +408,12 @@ fs::copy(const path& from, const path& to, copy_options options,
       // set an unused bit in options to disable further recursion
       if (!is_set(options, copy_options::recursive))
 	options |= static_cast<copy_options>(4096);
-      for (const directory_entry& x : directory_iterator(from))
-	copy(x.path(), to/x.path().filename(), options, ec);
+      for (const directory_entry& x : directory_iterator(from, ec))
+	{
+	  copy(x.path(), to/x.path().filename(), options, ec);
+	  if (ec)
+	    return;
+	}
     }
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2683. filesystem::copy() says "no effects"
@@ -1584,7 +1592,8 @@ fs::symlink_status(const fs::path& p)
   return result;
 }
 
-fs::path fs::temp_directory_path()
+fs::path
+fs::temp_directory_path()
 {
   error_code ec;
   path tmp = temp_directory_path(ec);
@@ -1593,32 +1602,12 @@ fs::path fs::temp_directory_path()
   return tmp;
 }
 
-fs::path fs::temp_directory_path(error_code& ec)
+fs::path
+fs::temp_directory_path(error_code& ec)
 {
-  path p;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  unsigned len = 1024;
-  std::wstring buf;
-  do
-    {
-      buf.resize(len);
-      len = GetTempPathW(buf.size(), buf.data());
-    } while (len > buf.size());
-
-  if (len == 0)
-    {
-      ec.assign((int)GetLastError(), std::system_category());
-      return p;
-    }
-  buf.resize(len);
-  p = std::move(buf);
-#else
-  const char* tmpdir = nullptr;
-  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
-  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
-    tmpdir = ::getenv(*e);
-  p = tmpdir ? tmpdir : "/tmp";
-#endif
+  path p = fs::get_temp_directory_from_env(ec);
+  if (ec)
+    return p;
   auto st = status(p, ec);
   if (ec)
     p.clear();
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index 506ff25f9a6..967d9471134 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -1872,11 +1872,6 @@ path::_M_split_cmpts()
       _M_cmpts.type(_Type::_Filename);
       return;
     }
-  if (_M_pathname.length() == 1 && _M_pathname[0] == preferred_separator)
-    {
-      _M_cmpts.type(_Type::_Root_dir);
-      return;
-    }
 
   _Parser parser(_M_pathname);
 
diff --git a/libstdc++-v3/src/c++20/sstream-inst.cc b/libstdc++-v3/src/c++20/sstream-inst.cc
index b3fbd6ead44..55d1fe5234d 100644
--- a/libstdc++-v3/src/c++20/sstream-inst.cc
+++ b/libstdc++-v3/src/c++20/sstream-inst.cc
@@ -26,7 +26,9 @@
 // ISO C++ 14882:
 //
 
-// Instantiations in this file are only for the new SSO std::string ABI
+// Instantiations in this file are only for the new SSO std::string ABI.
+#define _GLIBCXX_USE_CXX11_ABI 1
+
 #include <sstream>
 
 #if _GLIBCXX_USE_CXX11_ABI
diff --git a/libstdc++-v3/src/filesystem/dir.cc b/libstdc++-v3/src/filesystem/dir.cc
index 06e165b8888..446ddf0d2f2 100644
--- a/libstdc++-v3/src/filesystem/dir.cc
+++ b/libstdc++-v3/src/filesystem/dir.cc
@@ -25,6 +25,10 @@
 #ifndef _GLIBCXX_USE_CXX11_ABI
 # define _GLIBCXX_USE_CXX11_ABI 1
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <experimental/filesystem>
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 529d4e09016..a76a2e6198d 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -567,6 +567,47 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 
 #endif // _GLIBCXX_HAVE_SYS_STAT_H
 
+  // Find OS-specific name of temporary directory from the environment,
+  // Caller must check that the path is an accessible directory.
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  inline wstring
+  get_temp_directory_from_env(error_code& ec)
+  {
+    unsigned len = 1024;
+    std::wstring buf;
+    do
+      {
+	buf.resize(len);
+	len = GetTempPathW(buf.size(), buf.data());
+      } while (len > buf.size());
+
+    if (len == 0)
+      ec.assign((int)GetLastError(), std::system_category());
+    else
+      ec.clear();
+
+    buf.resize(len);
+    return buf;
+  }
+#else
+  inline const char*
+  get_temp_directory_from_env(error_code& ec) noexcept
+  {
+    ec.clear();
+    for (auto env : { "TMPDIR", "TMP", "TEMP", "TEMPDIR" })
+      {
+#if _GLIBCXX_HAVE_SECURE_GETENV
+	auto tmpdir = ::secure_getenv(env);
+#else
+	auto tmpdir = ::getenv(env);
+#endif
+	if (tmpdir)
+	  return tmpdir;
+      }
+    return "/tmp";
+  }
+#endif
+
 _GLIBCXX_END_NAMESPACE_FILESYSTEM
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 3f2290f372d..0eaa4b655a1 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -27,6 +27,10 @@
 # define NEED_DO_COPY_FILE
 # define NEED_DO_SPACE
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <experimental/filesystem>
@@ -344,8 +348,12 @@ fs::copy(const path& from, const path& to, copy_options options,
       // set an unused bit in options to disable further recursion
       if (!is_set(options, copy_options::recursive))
 	options |= static_cast<copy_options>(4096);
-      for (const directory_entry& x : directory_iterator(from))
-	copy(x.path(), to/x.path().filename(), options, ec);
+      for (const directory_entry& x : directory_iterator(from, ec))
+	{
+	  copy(x.path(), to/x.path().filename(), options, ec);
+	  if (ec)
+	    return;
+	}
     }
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2683. filesystem::copy() says "no effects"
@@ -1289,7 +1297,8 @@ fs::system_complete(const path& p, error_code& ec)
 #endif
 }
 
-fs::path fs::temp_directory_path()
+fs::path
+fs::temp_directory_path()
 {
   error_code ec;
   path tmp = temp_directory_path(ec);
@@ -1298,31 +1307,12 @@ fs::path fs::temp_directory_path()
   return tmp;
 }
 
-fs::path fs::temp_directory_path(error_code& ec)
+fs::path
+fs::temp_directory_path(error_code& ec)
 {
-  path p;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  unsigned len = 1024;
-  std::wstring buf;
-  do
-    {
-      buf.resize(len);
-      len = GetTempPathW(buf.size(), buf.data());
-    } while (len > buf.size());
-
-  if (len == 0)
-    {
-      ec.assign((int)GetLastError(), std::system_category());
-      return p;
-    }
-  buf.resize(len);
-  p = std::move(buf);
-#else
-  const char* tmpdir = nullptr;
-  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
-  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
-    tmpdir = ::getenv(*e);
-  p = tmpdir ? tmpdir : "/tmp";
+  path p = fs::get_temp_directory_from_env(ec);
+  if (ec)
+    return p;
   auto st = status(p, ec);
   if (ec)
     p.clear();
@@ -1331,7 +1321,5 @@ fs::path fs::temp_directory_path(error_code& ec)
       p.clear();
       ec = std::make_error_code(std::errc::not_a_directory);
     }
-#endif
   return p;
 }
-
diff --git a/libstdc++-v3/src/filesystem/path.cc b/libstdc++-v3/src/filesystem/path.cc
index a935573740f..8e8806a953f 100644
--- a/libstdc++-v3/src/filesystem/path.cc
+++ b/libstdc++-v3/src/filesystem/path.cc
@@ -337,15 +337,18 @@ path::_M_split_cmpts()
   _M_type = _Type::_Multi;
   _M_cmpts.clear();
 
-  if (_M_pathname.empty())
+  // Use const-reference to access _M_pathname, to avoid "leaking" COW string.
+  const auto& pathname = _M_pathname;
+
+  if (pathname.empty())
     return;
 
   {
     // Approximate count of components, to reserve space in _M_cmpts vector:
     int count = 1;
-    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_sep_last = _S_is_dir_sep(pathname[0]);
     bool saw_non_sep = !saw_sep_last;
-    for (value_type c : _M_pathname)
+    for (value_type c : pathname)
       {
        if (_S_is_dir_sep(c))
          saw_sep_last = true;
@@ -363,13 +366,13 @@ path::_M_split_cmpts()
   }
 
   size_t pos = 0;
-  const size_t len = _M_pathname.size();
+  const size_t len = pathname.size();
 
   // look for root name or root directory
-  if (_S_is_dir_sep(_M_pathname[0]))
+  if (_S_is_dir_sep(pathname[0]))
     {
       // look for root name, such as "//" or "//foo"
-      if (len > 1 && _M_pathname[1] == _M_pathname[0])
+      if (len > 1 && pathname[1] == pathname[0])
 	{
 	  if (len == 2)
 	    {
@@ -378,11 +381,11 @@ path::_M_split_cmpts()
 	      return;
 	    }
 
-	  if (!_S_is_dir_sep(_M_pathname[2]))
+	  if (!_S_is_dir_sep(pathname[2]))
 	    {
 	      // got root name, find its end
 	      pos = 3;
-	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
+	      while (pos < len && !_S_is_dir_sep(pathname[pos]))
 		++pos;
 	      if (pos == len)
 		{
@@ -409,7 +412,7 @@ path::_M_split_cmpts()
       ++pos;
     }
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  else if (len > 1 && _M_pathname[1] == L':')
+  else if (len > 1 && pathname[1] == L':')
     {
       // got disk designator
       if (len == 2)
@@ -418,7 +421,7 @@ path::_M_split_cmpts()
 	  return;
 	}
       _M_add_root_name(2);
-      if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
+      if (len > 2 && _S_is_dir_sep(pathname[2]))
 	_M_add_root_dir(2);
       pos = 2;
     }
@@ -426,9 +429,9 @@ path::_M_split_cmpts()
   else
     {
       size_t n = 1;
-      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+      for (; n < pathname.size() && !_S_is_dir_sep(pathname[n]); ++n)
 	{ }
-      if (n == _M_pathname.size())
+      if (n == pathname.size())
 	{
 	  _M_type = _Type::_Filename;
 	  return;
@@ -438,7 +441,7 @@ path::_M_split_cmpts()
   size_t back = pos;
   while (pos < len)
     {
-      if (_S_is_dir_sep(_M_pathname[pos]))
+      if (_S_is_dir_sep(pathname[pos]))
 	{
 	  if (back != pos)
 	    _M_add_filename(back, pos - back);
@@ -450,7 +453,7 @@ path::_M_split_cmpts()
 
   if (back != pos)
     _M_add_filename(back, pos - back);
-  else if (_S_is_dir_sep(_M_pathname.back()))
+  else if (_S_is_dir_sep(pathname.back()))
     {
       // [path.itr]/8
       // "Dot, if one or more trailing non-root slash characters are present."
diff --git a/libstdc++-v3/testsuite/17_intro/names.cc b/libstdc++-v3/testsuite/17_intro/names.cc
index 226b2d9c24a..554e32162ae 100644
--- a/libstdc++-v3/testsuite/17_intro/names.cc
+++ b/libstdc++-v3/testsuite/17_intro/names.cc
@@ -106,6 +106,8 @@
 #define z (
 
 #define tmp (
+#define sz (
+#define token (
 
 #if __cplusplus < 201103L
 #define uses_allocator  (
@@ -195,6 +197,8 @@
 #undef y
 // <sys/var.h> defines vario::v
 #undef v
+// <sys/timer.h> defines trb::func and cputime_tmr::func
+#undef func
 #endif
 
 #ifdef __APPLE__
diff --git a/libstdc++-v3/testsuite/20_util/allocator/void.cc b/libstdc++-v3/testsuite/20_util/allocator/void.cc
index e3d024d525b..3720774abaf 100644
--- a/libstdc++-v3/testsuite/20_util/allocator/void.cc
+++ b/libstdc++-v3/testsuite/20_util/allocator/void.cc
@@ -87,8 +87,23 @@ static_assert( std::is_same<std::allocator<void>::const_pointer, const void*>(),
     "const_pointer is const void*" );
 #endif // C++20
 
+void
+test02()
+{
+  std::allocator<void> av;
+  int* p = std::allocator<int>().allocate(1);
+  const int* c = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, c, 0);
+  volatile int* v = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, v, 0);
+  const volatile int* cv = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, cv, 0);
+  std::allocator<int>().deallocate(p, 1);
+}
+
 int
 main()
 {
   test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
new file mode 100644
index 00000000000..ef24b4c5c7b
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
@@ -0,0 +1,16 @@
+// { dg-do run { target c++17 } }
+
+#include <charconv>
+#include <string>
+
+int main()
+{
+#if __cpp_lib_to_chars >= 201611L // FP from_char not available otherwise.
+  // PR libstdc++/105324
+  // std::from_chars() assertion at floating_from_chars.cc:78
+  std::string s(512, '1');
+  s[1] = '.';
+  long double d;
+  std::from_chars(s.data(), s.data() + s.size(), d);
+#endif
+}
diff --git a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
index 40180223bae..a98815d932b 100644
--- a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
@@ -238,8 +238,11 @@ test07()
   std::pmr::monotonic_buffer_resource mbr(&cr);
   try
   {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
     // Try to allocate a ridiculous size:
     void* p = mbr.allocate(std::size_t(-2), 1);
+#pragma GCC diagnostic pop
     // Should not reach here!
     VERIFY( !"attempt to allocate SIZE_MAX-1 should not have succeeded" );
     throw p;
diff --git a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
index a76afbe87a2..fe847dadd27 100644
--- a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
@@ -281,10 +281,13 @@ test07()
   std::pmr::unsynchronized_pool_resource upr(&cr);
   try
   {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
     // Try to allocate a ridiculous size (and use a large extended alignment
     // so that careful_resource::do_allocate can distinguish this allocation
     // from any required for the pool resource's internal data structures):
     void* p = upr.allocate(std::size_t(-2), 1024);
+#pragma GCC diagnostic pop
     // Should not reach here!
     VERIFY( !"attempt to allocate SIZE_MAX-1 should not have succeeded" );
     throw p;
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
index 5de2a5f9330..3ba39ec432d 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
@@ -35,7 +35,9 @@ void test01()
 
   std::string c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
index fe91c5ab539..5804ccb6bf8 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
@@ -44,7 +44,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
index 1caedcccfce..59d1d775134 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
@@ -42,7 +42,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
index d05afb7d466..67e25de2916 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
@@ -35,7 +35,9 @@ void test01()
 
   std::wstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
index e301984612d..c72eb9bfddb 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
@@ -44,7 +44,9 @@ void test01()
 
   twstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
index d3e4744ff34..6a2bc2714b5 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
@@ -42,7 +42,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
index 87d8c2f4068..6a3ed55f557 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
@@ -71,8 +71,8 @@ int main()
 
   string s = "PR libstdc++/87749 a string that is longer than a short string";
   const auto ptr = s.c_str();
-  oom = true;
   string ss;
+  oom = true;
   ss = std::move(s); // allocators are equal, should not allocate new storage
   VERIFY( ss.c_str() == ptr );
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
index 4d744f8a411..536ca6153d3 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
@@ -72,8 +72,8 @@ int main()
 
   string s = L"PR libstdc++/87749 a string that is longer than a short string";
   const auto ptr = s.c_str();
-  oom = true;
   string ss;
+  oom = true;
   ss = std::move(s); // allocators are equal, should not allocate new storage
   VERIFY( ss.c_str() == ptr );
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
index f467d114c24..7ae3ccda22f 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
@@ -22,7 +22,7 @@
 
 #ifndef __cpp_lib_constexpr_string_view
 # error "Feature test macro for constexpr copy is missing in <string_view>"
-#elif __cpp_lib_constexpr_iterator < 201811L
+#elif __cpp_lib_constexpr_string_view < 201811L
 # error "Feature test macro for constexpr copy has wrong value in <string_view>"
 #endif
 
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
new file mode 100644
index 00000000000..0f6f520c33b
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
@@ -0,0 +1,48 @@
+// { dg-do run { target c++11 } }
+// C++11 23.3.4.6 Operations [forwardlist.ops]
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+void
+test_stable()
+{
+  std::forward_list<double> a{1.5, 2.0, 3.5, 4.1};
+  std::forward_list<double> b{1.0, 2.5, 3.0, 4.3, 4.2, 5.0};
+
+  a.merge(b, std::less<int>{});
+
+  // result is sorted with respect to std::less<int>, so 1.0 and 1.5 are
+  // equivalent, and stability guarantee means the element from a comes first.
+  const std::forward_list<double> r { 1.5, 1.0,
+				      2.0, 2.5,
+				      3.5, 3.0,
+				      4.1, 4.3, 4.2,
+				      5.0};
+
+  VERIFY(a == r);
+}
+
+void
+test_lwg3088()
+{
+  // LWG 3088: forward_list::merge behavior unclear when passed *this
+  // PR libstdc++/103853
+  std::forward_list<int> c1{ 1, 2, 3 };
+  const std::forward_list<int> c2 = c1;
+  c1.merge(c1);
+  VERIFY( c1 == c2 );
+  c1.merge(c1, std::less<long>{});
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1));
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1), std::less<long>{});
+  VERIFY( c1 == c2 );
+}
+
+int
+main()
+{
+  test_stable();
+  test_lwg3088();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc b/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
index e4219b8c78b..3ce0df5d111 100644
--- a/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
+++ b/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do compile { target c++11 } }
+// { dg-do run { target c++11 } }
 
 #include <iterator>
 
@@ -27,18 +27,18 @@ struct Iter
   using reference = int&;
   using difference_type = std::ptrdiff_t;
 
-  Iter();
+  Iter() { }
 
-  // Construction from int* is not valid:
-  Iter(int*) = delete;
+  // Construction from int* should not be used:
+  Iter(int*) { throw 1; }
 
-  // Assignment from int* is valid:
-  Iter& operator=(int*);
+  // Assignment from int* is OK:
+  Iter& operator=(int*) { return *this; }
 
-  Iter& operator++();
-  Iter operator++(int);
-  int& operator*() const;
-  int* operator->() const;
+  Iter& operator++() { return *this; }
+  Iter operator++(int) { return *this; }
+  int& operator*() const { static int i; return i; }
+  int* operator->() const { return &**this; }
 
   template<int N> friend bool operator==(Iter, Iter);
 };
@@ -49,3 +49,8 @@ void test01()
   int i = 0;
   m = std::make_move_iterator(&i); // Should use assignment not construction
 }
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc b/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc
new file mode 100644
index 00000000000..0fadcd6e99a
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc
@@ -0,0 +1,37 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+// Public domain testcase from Casey Carter, send to LWG list on 2021-07-24.
+//
+// Here's a compile-only test case for which n is INT_MIN, which will overflow
+// if simply negated to get |n|: https://godbolt.org/z/M7Wz1nW58.
+
+#include <cassert>
+#include <iterator>
+#include <limits>
+
+struct I {
+    using difference_type = int;
+    using value_type = int;
+
+    int x;
+
+    constexpr int operator*() const { return x; }
+    constexpr I& operator++() { ++x; return *this; }
+    constexpr I operator++(int) { ++x; return {x - 1}; }
+    constexpr bool operator==(const I&) const = default;
+
+    constexpr int operator-(const I& that) const { return x - that.x; }
+
+    constexpr I& operator--() { --x; return *this; }
+    constexpr I operator--(int) { --x; return {x - 1}; }
+};
+static_assert(std::bidirectional_iterator<I>);
+static_assert(std::sized_sentinel_for<I, I>);
+
+constexpr bool test() {
+    using L = std::numeric_limits<int>;
+    I i{-2};
+    return std::ranges::advance(i, L::min(), I{-4}) == L::min() + 2;
+}
+static_assert(test());
diff --git a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
index f947f8ae848..e8705ca7879 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
@@ -25,6 +25,7 @@
 
 #include <random>
 #include <sstream>
+#include <testsuite_hooks.h>
 
 void
 test01()
@@ -37,10 +38,43 @@ test01()
   str << u;
 
   str >> v;
+  VERIFY( u == v );
+}
+
+void
+test_pr105502()
+{
+  // PR libstdc++/105502 std::normal_distribution deserialization issue
+  std::stringstream str;
+  std::normal_distribution<> d{1, 2}, d2;
+  std::minstd_rand0 g;
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = true
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = false
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
 }
 
 int main()
 {
   test01();
-  return 0;
+  test_pr105502();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
index 1f297a731a3..1c8ea4c9249 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
@@ -28,35 +28,44 @@
 
 int choice;
 
-struct dirent global_dirent;
-
 extern "C" struct dirent* readdir(DIR*)
 {
+  // On some targets dirent::d_name is very small, but the OS allocates
+  // a trailing char array after the dirent struct. Emulate that here.
+  union State
+  {
+    struct dirent d;
+    char buf[sizeof(struct dirent) + 16] = {};
+  };
+
+  static State state;
+  char* d_name = state.buf + offsetof(struct dirent, d_name);
+
   switch (choice)
   {
   case 1:
-    global_dirent.d_ino = 999;
+    state.d.d_ino = 999;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_REG
-    global_dirent.d_type = DT_REG;
+    state.d.d_type = DT_REG;
 #endif
-    global_dirent.d_reclen = 0;
-    std::char_traits<char>::copy(global_dirent.d_name, "file", 5);
+    state.d.d_reclen = 0;
+    std::char_traits<char>::copy(d_name, "file", 5);
     choice = 0;
-    return &global_dirent;
+    return &state.d;
   case 2:
-    global_dirent.d_ino = 111;
+    state.d.d_ino = 111;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_DIR
-    global_dirent.d_type = DT_DIR;
+    state.d.d_type = DT_DIR;
 #endif
-    global_dirent.d_reclen = 60;
-    std::char_traits<char>::copy(global_dirent.d_name, "subdir", 7);
+    state.d.d_reclen = 60;
+    std::char_traits<char>::copy(d_name, "subdir", 7);
     choice = 1;
-    return &global_dirent;
+    return &state.d;
   default:
     errno = EIO;
     return nullptr;
   }
-  return &global_dirent;
+  return &state.d;
 }
 
 void
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
index 761cfc29b13..c00cf85641e 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
@@ -193,6 +193,34 @@ test05()
   VERIFY( !ec );  // Previous value should be cleared (LWG 2683)
 }
 
+void
+test_pr99290()
+{
+  auto dir = __gnu_test::nonexistent_path();
+  auto source = dir/"source";
+  auto dest = dir/"dest";
+  create_directories(source/"emptydir");
+  create_directories(dest/"emptydir");
+  std::ofstream{source/"file"} << 'a';
+  std::ofstream{dest/"file"} << 'b';
+  // PR libstdc++/99290
+  // std::filesystem::copy does not always report errors for recursion
+  std::error_code ec;
+  copy(source, dest, ec);
+  VERIFY( ec == std::errc::file_exists );
+
+#if __cpp_exceptions
+  try {
+    copy(source, dest);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::file_exists );
+  }
+#endif
+
+  remove_all(dir);
+}
+
 int
 main()
 {
@@ -201,4 +229,5 @@ main()
   test03();
   test04();
   test05();
+  test_pr99290();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
index b55cd6c60b6..1cfda583be3 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
@@ -20,6 +20,7 @@
 
 #include <filesystem>
 #include <stdlib.h>
+#include <stdio.h>
 #include <testsuite_hooks.h>
 #include <testsuite_fs.h>
 
@@ -58,7 +59,10 @@ test01()
   clean_env();
 
   if (!fs::exists("/tmp"))
+  {
+    puts("/tmp doesn't exist, not testing it for temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec = make_error_code(std::errc::invalid_argument);
   fs::path p1 = fs::temp_directory_path(ec);
@@ -75,7 +79,10 @@ test02()
   clean_env();
 
   if (!set_env("TMP", __gnu_test::nonexistent_path().string()))
+  {
+    puts("Cannot set environment variables, not testing temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec;
   fs::path p = fs::temp_directory_path(ec);
diff --git a/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc b/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc
new file mode 100644
index 00000000000..48f733bf28a
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc
@@ -0,0 +1,119 @@
+// { dg-do compile }
+
+#include <iosfwd>
+
+namespace std
+{
+  // [iosfwd.syn]
+
+  template<class charT> struct char_traits;
+  template<> struct char_traits<char>;
+#if __cplusplus >= 202002L
+  template<> struct char_traits<char8_t>;
+#endif
+#if __cplusplus >= 201103L
+  template<> struct char_traits<char16_t>;
+  template<> struct char_traits<char32_t>;
+#endif
+  template<> struct char_traits<wchar_t>;
+
+  template<class T> class allocator;
+
+  template<class charT, class traits>
+    class basic_ios;
+  template<class charT, class traits>
+    class basic_streambuf;
+  template<class charT, class traits>
+    class basic_istream;
+  template<class charT, class traits>
+    class basic_ostream;
+  template<class charT, class traits>
+    class basic_iostream;
+
+_GLIBCXX_BEGIN_NAMESPACE_CXX11
+  template<class charT, class traits, class Allocator>
+    class basic_stringbuf;
+  template<class charT, class traits, class Allocator>
+    class basic_istringstream;
+  template<class charT, class traits, class Allocator>
+    class basic_ostringstream;
+  template<class charT, class traits, class Allocator>
+    class basic_stringstream;
+_GLIBCXX_END_NAMESPACE_CXX11
+
+  template<class charT, class traits>
+    class basic_filebuf;
+  template<class charT, class traits>
+    class basic_ifstream;
+  template<class charT, class traits>
+    class basic_ofstream;
+  template<class charT, class traits>
+    class basic_fstream;
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  template<class charT, class traits, class Allocator>
+    class basic_syncbuf;
+  template<class charT, class traits, class Allocator>
+    class basic_osyncstream;
+#endif
+
+  template<class charT, class traits>
+    class istreambuf_iterator;
+  template<class charT, class traits>
+    class ostreambuf_iterator;
+
+  typedef basic_ios<char>    ios;
+  typedef basic_ios<wchar_t> wios;
+
+  typedef basic_streambuf<char> streambuf;
+  typedef basic_istream<char>   istream;
+  typedef basic_ostream<char>   ostream;
+  typedef basic_iostream<char>  iostream;
+
+  typedef basic_stringbuf<char>     stringbuf;
+  typedef basic_istringstream<char> istringstream;
+  typedef basic_ostringstream<char> ostringstream;
+  typedef basic_stringstream<char>  stringstream;
+
+
+  typedef basic_filebuf<char>  filebuf;
+  typedef basic_ifstream<char> ifstream;
+  typedef basic_ofstream<char> ofstream;
+  typedef basic_fstream<char>  fstream;
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  typedef basic_syncbuf<char>     syncbuf;
+  typedef basic_osyncstream<char> osyncstream;
+#endif
+
+  typedef basic_streambuf<wchar_t> wstreambuf;
+  typedef basic_istream<wchar_t>   wistream;
+  typedef basic_ostream<wchar_t>   wostream;
+  typedef basic_iostream<wchar_t>  wiostream;
+
+  typedef basic_stringbuf<wchar_t>     wstringbuf;
+  typedef basic_istringstream<wchar_t> wistringstream;
+  typedef basic_ostringstream<wchar_t> wostringstream;
+  typedef basic_stringstream<wchar_t>  wstringstream;
+
+  typedef basic_filebuf<wchar_t>  wfilebuf;
+  typedef basic_ifstream<wchar_t> wifstream;
+  typedef basic_ofstream<wchar_t> wofstream;
+  typedef basic_fstream<wchar_t>  wfstream;
+
+#if __cplusplus >= 202002L
+  typedef basic_syncbuf<wchar_t>     wsyncbuf;
+  typedef basic_osyncstream<wchar_t> wosyncstream;
+#endif
+
+  template<class state> class fpos;
+  typedef fpos<std::mbstate_t> streampos;
+  typedef fpos<std::mbstate_t> wstreampos;
+#if __cplusplus >= 202002L
+  typedef fpos<std::mbstate_t> u8streampos;
+#endif
+#if __cplusplus >= 201103L
+  typedef fpos<std::mbstate_t> u16streampos;
+  typedef fpos<std::mbstate_t> u32streampos;
+#endif
+}
diff --git a/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc b/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc
new file mode 100644
index 00000000000..e2c9c9b8dfa
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc
@@ -0,0 +1,214 @@
+// { dg-do compile { target c++11 } }
+
+#include <iosfwd>
+
+template<class, class> struct Same { static constexpr bool value = false; };
+template<class T> struct Same<T, T> { static constexpr bool value = true; };
+
+template<class T> using Traits = std::char_traits<T>;
+template<class T> using Alloc = std::allocator<T>;
+
+using std::basic_ios;
+
+static_assert(Same<basic_ios<char>,
+		   basic_ios<char, Traits<char>>
+		   >::value,
+    "std::basic_ios<char> has the correct default template argument");
+
+static_assert(Same<basic_ios<wchar_t>,
+		   basic_ios<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ios<wchar_t> has the correct default template argument");
+
+using std::basic_streambuf;
+
+static_assert(Same<basic_streambuf<char>,
+		   basic_streambuf<char, Traits<char>>
+		   >::value,
+    "std::basic_streambuf<char> has the correct default template argument");
+
+static_assert(Same<basic_streambuf<wchar_t>,
+		   basic_streambuf<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_streambuf<wchar_t> has the correct default template argument");
+
+using std::basic_istream;
+
+static_assert(Same<basic_istream<char>,
+		   basic_istream<char, Traits<char>>
+		   >::value,
+    "std::basic_istream<char> has the correct default template argument");
+
+static_assert(Same<basic_istream<wchar_t>,
+		   basic_istream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_istream<wchar_t> has the correct default template argument");
+
+using std::basic_ostream;
+
+static_assert(Same<basic_ostream<char>,
+		   basic_ostream<char, Traits<char>>
+		   >::value,
+    "std::basic_ostream<char> has the correct default template argument");
+
+static_assert(Same<basic_ostream<wchar_t>,
+		   basic_ostream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ostream<wchar_t> has the correct default template argument");
+
+using std::basic_iostream;
+
+static_assert(Same<basic_iostream<char>,
+		   basic_iostream<char, Traits<char>>>::value,
+    "std::basic_iostream<char> has the correct default template argument");
+
+static_assert(Same<basic_iostream<wchar_t>,
+		   basic_iostream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_iostream<wchar_t> has the correct default template argument");
+
+using std::basic_stringbuf;
+
+static_assert(Same<basic_stringbuf<char>,
+		   basic_stringbuf<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_stringbuf<char> has the correct default template argument");
+
+static_assert(Same<basic_stringbuf<wchar_t>,
+		   basic_stringbuf<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_stringbuf<wchar_t> has the correct default template argument");
+
+using std::basic_istringstream;
+
+static_assert(Same<basic_istringstream<char>,
+		   basic_istringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_istringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_istringstream<wchar_t>,
+		   basic_istringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_istringstream<wchar_t> has the correct default template argument");
+
+using std::basic_ostringstream;
+
+static_assert(Same<basic_ostringstream<char>,
+		   basic_ostringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_ostringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ostringstream<wchar_t>,
+		   basic_ostringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_ostringstream<wchar_t> has the correct default template argument");
+
+using std::basic_stringstream;
+
+static_assert(Same<basic_stringstream<char>,
+		   basic_stringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_stringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_stringstream<wchar_t>,
+		   basic_stringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_stringstream<wchar_t> has the correct default template argument");
+
+using std::basic_filebuf;
+
+static_assert(Same<basic_filebuf<char>,
+		   basic_filebuf<char, Traits<char>>
+		   >::value,
+    "std::basic_filebuf<char> has the correct default template argument");
+
+static_assert(Same<basic_filebuf<wchar_t>,
+		   basic_filebuf<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_filebuf<wchar_t> has the correct default template argument");
+
+using std::basic_ifstream;
+
+static_assert(Same<basic_ifstream<char>,
+		   basic_ifstream<char, Traits<char>>
+		   >::value,
+    "std::basic_ifstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ifstream<wchar_t>,
+		   basic_ifstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ifstream<wchar_t> has the correct default template argument");
+
+using std::basic_ofstream;
+
+static_assert(Same<basic_ofstream<char>,
+		   basic_ofstream<char, Traits<char>>
+		   >::value,
+    "std::basic_ofstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ofstream<wchar_t>,
+		   basic_ofstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ofstream<wchar_t> has the correct default template argument");
+
+using std::basic_fstream;
+
+static_assert(Same<basic_fstream<char>,
+		   basic_fstream<char, Traits<char>>
+		   >::value,
+    "std::basic_fstream<char> has the correct default template argument");
+
+static_assert(Same<basic_fstream<wchar_t>,
+		   basic_fstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_fstream<wchar_t> has the correct default template argument");
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+using std::basic_syncbuf;
+
+static_assert(Same<basic_syncbuf<char>,
+		   basic_syncbuf<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_syncbuf<char> has the correct default template argument");
+
+static_assert(Same<basic_syncbuf<wchar_t>,
+		   basic_syncbuf<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_syncbuf<wchar_t> has the correct default template argument");
+
+using std::basic_osyncstream;
+
+static_assert(Same<basic_osyncstream<char>,
+		   basic_osyncstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_osyncstream<char> has the correct default template argument");
+
+static_assert(Same<basic_osyncstream<wchar_t>,
+		   basic_osyncstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_osyncstream<wchar_t> has the correct default template argument");
+#endif
+
+using std::istreambuf_iterator;
+
+static_assert(Same<istreambuf_iterator<char>,
+		   istreambuf_iterator<char, Traits<char>>
+		   >::value,
+    "std::istreambuf_iterator<char> has the correct default template argument");
+
+static_assert(Same<istreambuf_iterator<wchar_t>,
+		   istreambuf_iterator<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::istreambuf_iterator<wchar_t> has the correct default template argument");
+
+using std::ostreambuf_iterator;
+
+static_assert(Same<ostreambuf_iterator<char>,
+		   ostreambuf_iterator<char, Traits<char>>
+		   >::value,
+    "std::ostreambuf_iterator<char> has the correct default template argument");
+
+static_assert(Same<ostreambuf_iterator<wchar_t>,
+		   ostreambuf_iterator<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::ostreambuf_iterator<wchar_t> has the correct default template argument");
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc b/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
index 7eab17b12e0..dffdaef7afd 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
@@ -1,3 +1,4 @@
+// { dg-options "-O1" }
 // { dg-do link { target c++11 } }
 
 // Copyright (C) 2009-2021 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc b/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
index 9d92ff954f1..f572ce7ef11 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
@@ -5,13 +5,13 @@
 #include <atomic>
 
 void
-test1(const std::atomic<char*>& a, char* p)
+test1(std::atomic<char*>& a, char* p)
 {
   a.wait(p);
 }
 
 void
-test2(const std::atomic<int>* a, int v)
+test2(std::atomic<int>* a, int v)
 {
   std::atomic_wait(a, v);
   std::atomic_notify_one(a);
diff --git a/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc b/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc
new file mode 100644
index 00000000000..0eb69763ab9
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc
@@ -0,0 +1,85 @@
+// // Copyright (C) 2017-2022 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++17 } }
+
+#include <future>
+
+template<typename T, typename U> struct require_same;
+template<typename T> struct require_same<T, T> { using type = void; };
+
+template<typename T, typename U>
+  typename require_same<T, U>::type
+  check_type(U&) { }
+
+void f0v();
+void f0vn() noexcept;
+int f0i();
+int f0in() noexcept;
+long f1l(int&);
+long f1ln(double*) noexcept;
+
+void
+test01()
+{
+  std::packaged_task task1{f0v};
+  check_type<std::packaged_task<void()>>(task1);
+
+  std::packaged_task task2{f0vn};
+  check_type<std::packaged_task<void()>>(task2);
+
+  std::packaged_task task3{f0i};
+  check_type<std::packaged_task<int()>>(task3);
+
+  std::packaged_task task4{f0in};
+  check_type<std::packaged_task<int()>>(task4);
+
+  std::packaged_task task5{f1l};
+  check_type<std::packaged_task<long(int&)>>(task5);
+
+  std::packaged_task task6{f1ln};
+  check_type<std::packaged_task<long(double*)>>(task6);
+
+  std::packaged_task task5a{std::move(task5)};
+  check_type<std::packaged_task<long(int&)>>(task5a);
+
+  std::packaged_task task6a{std::move(task6)};
+  check_type<std::packaged_task<long(double*)>>(task6a);
+}
+
+struct X {
+  int operator()(const short&, void*);
+};
+
+struct Y {
+  void operator()(int) const & noexcept;
+};
+
+void
+test02()
+{
+  X x;
+  std::packaged_task task1{x};
+  check_type<std::packaged_task<int(const short&, void*)>>(task1);
+
+  Y y;
+  std::packaged_task task2{y};
+  check_type<std::packaged_task<void(int)>>(task2);
+
+  std::packaged_task task3{[&x](float) -> X& { return x; }};
+  check_type<std::packaged_task<X&(float)>>(task3);
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
index 947d270e6a4..817e51d2d21 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
@@ -190,6 +190,34 @@ test05()
   VERIFY( !ec );  // Previous value should be cleared (LWG 2683)
 }
 
+void
+test_pr99290()
+{
+  auto dir = __gnu_test::nonexistent_path();
+  auto source = dir/"source";
+  auto dest = dir/"dest";
+  create_directories(source/"emptydir");
+  create_directories(dest/"emptydir");
+  std::ofstream{source/"file"} << 'a';
+  std::ofstream{dest/"file"} << 'b';
+  // PR libstdc++/99290
+  // std::filesystem::copy does not always report errors for recursion
+  std::error_code ec;
+  copy(source, dest, ec);
+  VERIFY( ec == std::errc::file_exists );
+
+#if __cpp_exceptions
+  try {
+    copy(source, dest);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::file_exists );
+  }
+#endif
+
+  remove_all(dir);
+}
+
 int
 main()
 {
@@ -198,4 +226,5 @@ main()
   test03();
   test04();
   test05();
+  test_pr99290();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
index 03e777b0041..badd8a884cc 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
@@ -21,6 +21,7 @@
 
 #include <experimental/filesystem>
 #include <stdlib.h>
+#include <stdio.h>
 #include <testsuite_hooks.h>
 #include <testsuite_fs.h>
 
@@ -59,7 +60,10 @@ test01()
   clean_env();
 
   if (!fs::exists("/tmp"))
+  {
+    puts("/tmp doesn't exist, not testing it for temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec = make_error_code(std::errc::invalid_argument);
   fs::path p1 = fs::temp_directory_path(ec);
@@ -75,8 +79,11 @@ test02()
 {
   clean_env();
 
-  if (set_env("TMPDIR", __gnu_test::nonexistent_path().string()))
+  if (!set_env("TMP", __gnu_test::nonexistent_path().string()))
+  {
+    puts("Cannot set environment variables, not testing temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec;
   fs::path p = fs::temp_directory_path(ec);
diff --git a/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc b/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
index 5df9f330cd4..ed0614e2797 100644
--- a/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
+++ b/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
@@ -20,6 +20,7 @@
 // { dg-do run }
 // { dg-options "-pthread"  }
 // { dg-require-effective-target pthread }
+// { dg-timeout-factor 2 }
 
 #include <ext/rope>
 #include <cstring>
@@ -33,7 +34,7 @@ typedef __gnu_cxx::rope<char, std::allocator<char> > rope_type;
 rope_type foo2;
 rope_type foo4;
 
-void* thread_main(void *) 
+void* thread_main(void *)
 {
   // To see a problem with gcc 3.3 and before, set a break point here.
   // Single step through c_str implementation, call sched_yield after
