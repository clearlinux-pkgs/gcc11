Alexandre Oliva (3):
      testsuite: vect: update unaligned message
      [PR105324] libstdc++: testsuite: pr105324 requires FP from_char
      libstdc++: ppc: conditionalize vsx-only simd intrinsics

Andreas Krebbel (1):
      IBM zSystems/testsuite: PR105147: Skip pr105140.c

David Malcolm (2):
      analyzer: fix ICE comparing VECTOR_CSTs [PR105252]
      analyzer: fix ICEs on complex constants [PR105365,105366]

Eric Botcazou (1):
      Fix internal error with vectorization on SPARC

Fritz Reese (1):
      fortran: Fix conv of UNION constructors [PR105310]

GCC Administrator (172):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Georg-Johann Lay (1):
      Fix PR target/99184: Wrong cast from double to 16-bit and 32-bit ints

H.J. Lu (4):
      x86: Add missing .note.GNU-stack to assembly source
      x86: Add .note.GNU-stack section only for Linux
      x86: Require AVX for F16C and VAES
      i386: Mark XMM4-XMM6 as clobbered by encodekey128/encodekey256

Harald Anlauf (14):
      Fortran: improve error recovery on invalid array section
      Fortran: fix error recovery on invalid array section
      Fortran: fix checking of arguments to UNPACK when MASK is a variable [PR105813]
      Fortran: fix simplification of INDEX(str1,str2) [PR105691]
      Fortran: handle explicit-shape specs with constant bounds [PR105954]
      Fortran: improve error recovery for EXTENDS_TYPE_OF() [PR106121]
      Fortran: error recovery on invalid CLASS(), PARAMETER declarations [PR105243]
      Fortran: error recovery from calculation of storage size of a symbol [PR103504]
      Fortran: catch NULL pointer dereferences while simplifying PACK [PR106857]
      Fortran: error recovery on invalid ARRAY argument to FINDLOC [PR106986]
      Fortran: improve error recovery while simplifying size of bad array [PR103694]
      Fortran: NULL pointer dereference in invalid simplification [PR106985]
      Fortran: fix ICE in generate_coarray_sym_init [PR82868]
      Fortran: error recovery while simplifying intrinsic UNPACK [PR107054]

Hongyu Wang (1):
      AVX512F: Add missing macro for mask(z?)_scalf_s[sd] [PR 105339]

Iain Buclaw (7):
      libphobos: Don't call free on the TLS array in the emutls destroy function.
      libphobos: Give _Unwind_Exception an alignment that best resembles __attribute__((aligned))
      darwin, d: Support outfile substitution for libphobos
      d: Set TYPE_ARTIFICIAL on internal TypeInfo types
      tilegx: Fix infinite loop in gen-mul-tables generator
      d: Fix error: aggregate value used where floating point was expected
      d: Update DIP links in gdc documentation to point at upstream repository

Ian Lance Taylor (1):
      libgo: don't include <linux/fs.h> when building gen-sysinfo.go

Jakub Jelinek (12):
      emit-rtl: Fix -fcompare-debug bug with label references in debug insns [PR105203]
      sparc: Preserve ORIGINAL_REGNO in epilogue_renumber [PR105257]
      rtlanal: Fix up replace_rtx [PR105333]
      asan: Fix up asan_redzone_buffer::emit_redzone_byte [PR105396]
      i386: Fix up ix86_gimplify_va_arg [PR105331]
      c++: Don't emit deprecated warnings on lambda declarations
      isel: Fix up gimple_expand_vec_set_expr [PR105528]
      testsuite: Fix up pr104637 testcase [PR104637]
      libcpp: Ignore CPP_PADDING tokens in _cpp_parse_expr [PR105732]
      fold-const: Fix up -fsanitize=null in C++ [PR105729]
      varasm: Fix up ICE in narrowing_initializer_constant_valid_p [PR105998]
      libstdc++: Tweak source_location for clang trunk [PR105128]

Jan Hubicka (2):
      Fix modref_tree::remap_params
      Fix ipa-cp wrt volatile loads

Jason Merrill (19):
      c++: rodata and defaulted ctor [PR104142]
      c++: low -faligned-new [PR102071]
      c++: local function versioning [PR104669]
      c++: empty base constexpr -fno-elide-ctors [PR105245]
      c++: temp cleanup in new [PR105265]
      c++: lambda and the current instantiation [PR82980]
      c++: constexpr trivial -fno-elide-ctors [PR104646]
      c++: pack init-capture of unresolved overload [PR102629]
      c++: template-id with current inst qualifier [PR102300]
      c++: alignment of local typedef in template [PR65211]
      c++: template conversion op [PR101698]
      c++: NRV and ref-extended temps [PR101442]
      c++: constexpr ref to array of array [PR102307]
      c++: constexpr empty aggr [PR105795]
      c++: redeclared hidden friend [PR105761]
      c++: redeclared hidden friend take 2 [PR105852]
      c++: anon union designated init [PR105925]
      c++: dependent generic lambda template-id [PR106024]
      c++: defaulted friend op== [PR106361]

Jeff Law (1):
      [committed] Fix more problems with new linker warnings

Jonathan Wakely (74):
      libstdc++: Avoid -Wzero-as-null-pointer-constant warning [PR103848]
      libstdc++: Fix warning in __moneypunct_cache::_M_cache [PR104966]
      libstdc++: Fix macro checked by test
      libstdc++: Fix incorrect IS number in doc comment
      libstdc++: Use LTLIBICONV when linking libstdc++.so [PR93602]
      libstdc++: Fix test failure on AIX
      libstdc++: Increase timeout for pthread7-rope.cc test
      libstdc++: Avoid overflow in ranges::advance(i, n, bound)
      libstdc++: Do not use std::isdigit in <charconv> [PR103911]
      libstdc++: Ignore cv-quals when std::allocator<void> constructs
      libstdc++: Avoid unwanted allocations in filesystem::path
      libstdc++: Reorder constraints on std::span::span(Range&&) constructor.
      libstdc++: Improvements to standard error category objects (part deux)
      libstdc++: Use std::construct_at in net::ip::address
      libstdc++: Add missing noexcept to lazy_split_view iterator (LWG 3593)
      libstdc++: Add another non-reserved name to tests
      libstdc++: Fix non-reserved name in <regex> header
      libstdc++: Fix tests that fail with fully-dynamic-string
      libstdc++: Ensure C++20 std::stringstream definitions use correct ABI
      libstdc++: Use secure_getenv for filesystem::temp_directory_path() [PR65018]
      libstdc++: Remove bogus assertion in std::from_chars [PR105324]
      libstdc++: Fix filesystem::temp_directory_path [PR101709]
      libstdc++: Fix test that fails in C++20 mode
      libstdc++: Fix ambiguous comparisons for iterators in C++20
      libstdc++: Fix test failures at -O0
      libstdc++: Remove "no stronger" assertion in compare exchange [PR102177]
      libstdc++: Remove workaround for FE bug in std::tuple [PR96592]
      libstdc++: Add deduction guides for std::packaged_task [PR105375]
      libstdc++: Fix error reporting in filesystem::copy [PR99290]
      libstdc++: Fix test that fails on Solaris [PR104731]
      libstdc++: Fix deserialization for std::normal_distribution [PR105502]
      libstdc++: Define _GNU_SOURCE for secure_getenv on Cygwin [PR104217]
      libstdc++: Add <syncstream> declarations to <iosfwd> [PR105284]
      libstdc++: Fix status docs for <bit> support
      libstdc++: Add C++23 status docs
      libstdc++: Fix hyperlink in docs
      libstdc++: Document support for constexpr optional (P2231R1)
      libstdc++: Partially revert r11-9772-g6f8133689f4397 [PR105915]
      libstdc++: Use type_identity_t for non-deducible std::atomic_xxx args
      libstdc++: Define std::hash<std::filesystem::path> (LWG 3657)
      libstdc++: Fix cast in source_location::current() [PR104602]
      libstdc++: Remove unused functions in std::variant implementation
      libstdc++: std::basic_regex should treat '\0' as an ordinary char [PR84110]
      libstdc++: Implement std::regex_constants::multiline (LWG 2503)
      libstdc++: Fix preprocessor check for C++17
      libstdc++: Define basic_regex::multiline for non-strict modes
      libstdc++: Replace try-catch in std::list::merge to avoid O(N) size
      libstdc++: Remove try/catch overhead in std::variant::emplace
      libstdc++: Fix std::regex_replace for strings with embedded null [PR103664]
      libstdc++: Simplify std::basic_regex construction and assignment
      libstdc++: Add dg-timeout-factor to some more regex tests
      libstdc++: Tweaks to <regex> to avoid warnings
      libstdc++: Check for invalid syntax_option_type values in <regex>
      libstdc++: Fix handling of invalid ranges in std::regex [PR102447]
      libstdc++: Add noexcept to functions in <regex>
      libstdc++: Remove obfuscating typedefs in <regex>
      libstdc++: Make ranges::size and ranges::empty check for unbounded arrays
      libstdc++: Add noexcept to std::launch operators
      libstdc++: Mark non-exported function always_inline [PR105671]
      libstdc++: Add constexpr to std::counted_iterator post-increment (LWG 3643)
      libstdc++: Properly remove temporary directories in filesystem tests
      libstdc++: Add missing prerequisite to generated header [PR106162]
      libstdc++: Fix experimental::filesystem::status on Windows [PR88881]
      libstdc++: testsuite: Guard use of C99 std::log2
      libstdc++: Make std::common_iterator completely constexpr-able (LWG 3574)
      libstdc++: Use std::construct_at in std::common_iterator [PR103992]
      libstdc++: Fix minor bugs in std::common_iterator
      libstdc++: Fix std::common_iterator assignment [PR100823]
      libstdc++: Make std::string_view(Range&&) constructor explicit
      libstdc++: Tweak common_iterator::operator-> return type [PR104443]
      libstdc++: Check for EOF if extraction avoids buffer overflow [PR106248]
      libstdc++: Fix for explicit copy ctors in <thread> and <future> [PR106695]
      libstdc++: Check for overflow in regex back-reference [PR106607]
      libstdc++: Fix feature test macros in <version> for freestanding

José Rui Faustino de Sousa (4):
      Fortran: Fix ICE with -fcheck=pointer [PR100136]
      Fortran: Fix ICE with automatic reallocation [PR100245]
      Fortran: Fix function attributes [PR100132]
      Fortran: Fix ICE and wrong code for assumed-rank arrays [PR100029, PR100040]

Kewen Lin (3):
      testsuite: Skip pr105250.c for powerpc and s390 [PR105266]
      rs6000: Preserve REG_EH_REGION when replacing load/store [PR106091]
      rs6000/test: Fix empty TU in some cases of effective targets [PR106345]

Kewen.Lin (1):
      rs6000: Adjust mov optabs for opaque modes [PR103353]

Kito Cheng (1):
      RISC-V: Fix wrong expansion for arch-canonicalize

Kyrylo Tkachov (1):
      aarch64: Add support for -mcpu=neoverse-v2

Lewis Hyatt (1):
      c: Fix location for _Pragma tokens [PR97498]

Maciej W. Rozycki (1):
      RISC-V: Remove duplicate backslashes from `stack_protect_set_<mode>'

Marek Polacek (4):
      c++: ambiguous call not diagnosed after DR2352 [PR97296]
      c++: wrong error with constexpr COMPOUND_EXPR [PR105321]
      c++: enum in generic lambda at global scope [PR105398]
      c++: global-namespace-qualified var after class def [PR90107]

Mark Mentovai (1):
      libstdc++: Rename __null_terminated to avoid collision with Apple SDK

Martin Jambor (2):
      ipa: Release body of clone_of when removing its last clone (PR 100413)
      tree-sra: Fix union handling in build_reconstructed_reference

Martin Liska (2):
      ipa-icf: skip variables with body_removed
      libsanitizer: cherry-pick 9cf13067cb5088626ba7 from upstream

Matthias Kretz (1):
      c++: don't ICE on NAMESPACE_DECL inside FUNCTION_DECL

Max Filippov (1):
      gcc: xtensa: fix PR target/105879

Michael Meissner (3):
      rs6000: Ignore fusion option flags for inlining test [PR102059]
      [BACKPORT] Disable generating load/store vector pairs for block copies.
      Do not enable -mblock-ops-vector-pair.

Mikael Morin (3):
      fortran: Move the clobber generation code
      fortran: Fix invalid function decl clobber ICE [PR105012]
      fortran: Move clobbers after evaluation of all arguments [PR106817]

Patrick Palka (6):
      c++: partial ordering with dependent NTTP type [PR105289]
      c++: ICE with requires-expr and -Wsequence-point [PR105304]
      c++: decltype of non-dependent call of class type [PR105386]
      libstdc++: Don't use std::tolower in <charconv> [PR103911]
      c++: deduction guides and ttp rewriting [PR102479]
      libstdc++: Fix backward compatibility of P2325R3 backport [PR106320]

Paul A. Clarke (1):
      rs6000: __Uglify non-uglified local variables in headers

Pavel I. Kryukov (1):
      libstdc++: Add self-merge check to std::forward_list::merge [PR103853]

Peter Bergner (5):
      rs6000: Adjust -mdejagnu-cpu to filter out -mtune [PR106345]
      rs6000: Update testsuite to use -mdejagnu-cpu= and -mdejagnu-tune= options
      c: Handle initializations of opaque types [PR106016]
      rs6000: Allow conversions of MMA pointer types [PR106017]
      rs6000: Don't ICE when we disassemble an MMA variable [PR101322]

Qing Zhao (1):
      i386: Adjust -fzero-call-used-regs to always use XOR [PR101891]

Rainer Orth (1):
      libstdc++: Fix 28_regex/basic_regex/84110.cc on Solaris

Richard Biener (23):
      Update BASE-VER to 11.3.1
      ipa/105598 - testcase for PR105598
      middle-end/105140 - fix bogus recursion in fold_convertible_p
      tree-optimization/105250 - adjust fold_convertible_p PR105140 fix
      tree-optimization/105148 - fix IVOPTs recording uses
      tree-optimization/105163 - abnormal SSA coalescing and reassoc
      tree-optimization/105173 - fix insertion logic in reassoc
      tree-optimization/105263 - reassoc and DFP
      tree-optimization/105312 - fix ISEL VCOND expansion
      tree-optimization/105368 - avoid overflow in powi_cost
      tree-optimization/105431 - another overflow in powi handling
      rtl-optimization/105559 - avoid quadratic behavior in delete_insn_and_edges
      tree-optimization/105437 - BB vect with extern defs of throwing stmts
      tree-optimization/105726 - adjust array bound heuristic
      tree-optimization/103116 - SLP permutes and peeling for gaps
      middle-end/103193 - avoid canonicalizing <= and >= to == for floats
      tree-optimization/105618 - restore load sinking
      middle-end/106027 - fix types in needle folding
      tree-optimization/106112 - fix CSE from wider operation
      tree-optimization/106131 - wrong code with FRE rewriting
      middle-end/106331 - fix mem attributes for string op arguments
      tree-optimization/106513 - fix mistake in bswap symbolic number shifts
      lto/106540 - fix LTO tree input wrt dwarf2out_register_external_die

Richard Earnshaw (3):
      arm: big-endian issue in gen_cpymem_ldrd_strd [PR105981]
      arm: correctly handle misaligned MEMs on MVE [PR105463]
      cselib: add function to check if SET is redundant [PR106187]

Richard Sandiford (2):
      rtl-ssa: Fix prev/next_def confusion [PR104869]
      aarch64: Fix GTY markup for arm_sve.h [PR106491]

Sebastian Huber (2):
      RTEMS: Do not define _GNU_SOURCE by default
      RTEMS: Add -mvrsave multilibs

Sebastian Pop (1):
      [AArch64] add barriers to ool __sync builtins

Segher Boessenkool (7):
      rs6000/testsuite: Skip pr105140.c
      rs6000: Improve .machine
      rs6000: Do not use rs6000_cpu for .machine ppc and ppc64 (PR104829)
      rs6000: Disparage lfiwzx and similar
      rs6000/testsuite: xfail bswap-brw.c
      rs6000: Add effective target has_arch_ppc64
      rs6000: Make the has_arch target selectors actually work

Sergei Trofimovich (2):
      gcov-profile: Allow negative counts of indirect calls [PR105282]
      gcc/config/t-i386: add build dependencies on i386-builtin-types.inc

Simon Cook (1):
      RISC-V: Don't unconditionally add m,a,f,d in arch-canonicalize

Steve Kargl (1):
      Fortran: do not generate conflicting results under -ff2c [PR104313]

Surya Kumari Jangala (1):
      regrename: Fix -fcompare-debug issue in check_new_reg_p [PR105041]

Tamar Christina (1):
      testsuite: Backport testsuite changes from GCC 12 to GCC 11

Thomas Rodgers (1):
      libstdc++: Minor codegen improvement for atomic wait spinloop

Thomas Schwinge (1):
      nvptx: Define (dummy) 'TARGET_PTX_6_0'

Thomas W Rodgers (1):
      libstdc++: Make atomic notify_one and notify_all non-const

Tobias Burnus (1):
      OpenMP: Fix folding with simd's linear clause [PR106492]

Tom de Vries (2):
      [nvptx] Add bar.warp.sync
      [nvptx] Add uniform_warp_check insn

Uros Bizjak (2):
      i386: Fix assert in ix86_function_arg [PR105970]
      alpha: Introduce target specific store_data_bypass_p function [PR105209]

Vladimir N. Makarov (1):
      [PR104637] LRA: Split hard regs as many as possible on one subpass

liuhongt (1):
      Fix insn does not satisfy its constraints: sse2_lshrv1ti3

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index f628d2eafc5..0a47c95bb14 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-11.3.0
+11.3.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index a0587d18824..b0bd2b57837 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,707 @@
+2022-10-03  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-10-03  Sergei Trofimovich  <siarheit@google.com>
+
+	PR target/107064
+	* config/i386/t-i386: Add build-time dependencies against
+	i386-builtin-types.inc to i386-builtins.o, i386-expand.o,
+	i386-features.o.
+
+2022-09-29  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-09-28  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107061
+	* config/i386/predicates.md (encodekey128_operation): Check
+	XMM4-XMM6 as clobbered.
+	(encodekey256_operation): Likewise.
+	* config/i386/sse.md (encodekey128u32): Clobber XMM4-XMM6.
+	(encodekey256u32): Likewise.
+
+2022-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-cores.def (neoverse-v2): New entry.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* doc/invoke.texi (AArch64 Options): Document neoverse-v2.
+
+2022-09-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-09-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/106491
+	* config/aarch64/aarch64-sve-builtins.cc (scalar_types)
+	(acle_vector_types, acle_svpattern, acle_svprfop): Add GTY
+	markup to (new) extern declarations instead of to the main
+	definition.
+
+2022-09-14  Tom de Vries  <tdevries@suse.de>
+
+	Backported from master:
+	2022-02-01  Tom de Vries  <tdevries@suse.de>
+
+	* config/nvptx/nvptx.c (nvptx_single): Use nvptx_uniform_warp_check.
+	* config/nvptx/nvptx.md (define_c_enum "unspecv"): Add
+	UNSPECV_UNIFORM_WARP_CHECK.
+	(define_insn "nvptx_uniform_warp_check"): New define_insn.
+
+2022-09-14  Tom de Vries  <tdevries@suse.de>
+
+	Backported from master:
+	2022-02-01  Tom de Vries  <tdevries@suse.de>
+
+	* config/nvptx/nvptx.c (nvptx_single): Use nvptx_warpsync.
+	* config/nvptx/nvptx.md (define_c_enum "unspecv"): Add
+	UNSPECV_WARPSYNC.
+	(define_insn "nvptx_warpsync"): New define_insn.
+
+2022-09-14  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* config/nvptx/nvptx.h (TARGET_PTX_6_0): '#define' to 'false'.
+
+2022-09-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-09-01  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101322
+	* config/rs6000/rs6000-call.c (rs6000_gimple_fold_mma_builtin):
+	Enforce the use of a valid MMA pointer type.
+
+2022-09-08  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/rtems.h (CPP_OS_DEFAULT_SPEC): Define __PPC_VRSAVE__ if
+	-mvrsave is present.
+	* config/rs6000/t-rtems: Add -mvrsave multilib variants for
+	-mcpu=e6500.
+
+2022-09-02  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2022-08-03  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR rtl-optimization/106187
+	* alias.h (mems_same_for_tbaa_p): Declare.
+	* alias.c (mems_same_for_tbaa_p): New function.
+	* dse.c (record_store): Use it instead of open-coding
+	alias check.
+	* cselib.h (cselib_redundant_set_p): Declare.
+	* cselib.c: Include alias.h
+	(cselib_redundant_set_p): New function.
+	* cfgcleanup.c: (mark_effect): Use cselib_redundant_set_p instead
+	of rtx_equal_for_cselib_p.
+	* postreload.c (reload_cse_simplify): Use cselib_redundant_set_p.
+	(reload_cse_noop_set_p): Delete.
+
+2022-09-02  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2022-05-13  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/105463
+	* config/arm/mve.md (*movmisalign<mode>_mve_store): Use
+	mve_memory_operand.
+	(*movmisalign<mode>_mve_load): Likewise.
+	* config/arm/vec-common.md (movmisalign<mode>): Convert to generator
+	form...
+	(@movmisalign<mode>): ... thus.  Use generic predicates and then
+	rework operands if they are not valid.  For MVE rework to a
+	narrower element size if the alignment is not high enough.
+
+2022-08-30  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-08-28  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/106017
+	* config/rs6000/rs6000.c (rs6000_invalid_conversion): Remove handling
+	of MMA pointer conversions.
+
+2022-08-24  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	Backported from master:
+	2022-08-16  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	PR target/103353
+	* config/rs6000/mma.md (define_expand movoo): Move TARGET_MMA condition
+	check to preparation statements and add handlings for !TARGET_MMA.
+	(define_expand movxo): Likewise.
+
+2022-08-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/106492
+	* omp-low.c (lower_rec_input_clauses): Add missing folding
+	to data type of linear-clause list item.
+
+2022-08-16  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/103197
+	PR target/102146
+	* config/rs6000/rs6000.md (zero_extendqi<mode>2 for EXTQI): Disparage
+	the "Z" alternatives in {l,st}{f,xs}iwzx.
+	(zero_extendhi<mode>2 for EXTHI): Ditto.
+	(zero_extendsi<mode>2 for EXTSI): Ditto.
+	(*movsi_internal1): Ditto.
+	(*mov<mode>_internal1 for QHI): Ditto.
+	(movsd_hardfloat): Ditto.
+
+2022-08-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR c/106016
+	* expr.c (count_type_elements): Handle OPAQUE_TYPE.
+
+2022-08-08   Michael Meissner  <meissner@linux.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Remove code
+	setting -mblock-ops-vector-pair.  Patch back ported from trunk, August
+	3rd, 2022.
+
+2022-08-02  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-07-25  Peter Bergner  <bergner@linux.ibm.com>
+		    Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/106345
+	* config/rs6000/rs6000.h (DRIVER_SELF_SPECS): Adjust -mdejagnu-cpu
+	to filter out all -mtune options.
+
+2022-08-02  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106091
+	* config/rs6000/rs6000-p8swap.c (replace_swapped_aligned_store): Copy
+	REG_EH_REGION when replacing one store insn having it.
+	(replace_swapped_aligned_load): Likewise.
+
+2022-07-27  Maciej W. Rozycki  <macro@embecosm.com>
+
+	Backported from master:
+	2022-07-27  Maciej W. Rozycki  <macro@embecosm.com>
+
+	* config/riscv/riscv.md (stack_protect_set_<mode>): Remove
+	duplicate backslashes.
+
+2022-07-25  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backported from master:
+	2022-07-25  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/rtems.h (CPLUSPLUS_CPP_SPEC): Undef.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105618
+	* tree-ssa-sink.c (statement_sink_location): For virtual
+	PHI uses ignore those defining the used virtual operand.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-24  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/103193
+	* match.pd: Avoid canonicalizing (le/ge @0 @0) to (eq @0 @0)
+	with NaNs and -ftrapping-math.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/103116
+	* tree-vect-stmts.c (get_group_load_store_type): Handle the
+	case we need peeling for gaps even though GROUP_GAP is zero.
+
+2022-07-21  Surya Kumari Jangala  <jskumari@linux.vnet.ibm.com>
+
+	Backported from master:
+	2022-06-14  Surya Kumari Jangala  <jskumari@linux.ibm.com>
+
+	PR rtl-optimization/105041
+	* regrename.c (check_new_reg_p): Use nregs value from du chain.
+
+2022-07-14   Michael Meissner  <meissner@linux.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Do
+	not generate block copies with vector pair instructions if we are
+	tuning for power10.  Back port from master branch.
+
+2022-07-12  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-07-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/105860
+	* tree-sra.c (build_reconstructed_reference): Start expr
+	traversal only just below the outermost union.
+
+2022-07-04  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-03-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/104869
+	* rtl-ssa/accesses.h (clobber_group::prev_clobber): Declare.
+	(clobber_group::next_clobber): Likewise.
+	(def_lookup::prev_def): Rename to...
+	(def_lookup::last_def_of_prev_group): ...this.
+	(def_lookup::next_def): Rename to...
+	(def_lookup::first_def_of_next_group): ...this.
+	(def_lookup::matching_or_prev_def): Rename to...
+	(def_lookup::matching_set_or_last_def_of_prev_group): ...this.
+	(def_lookup::matching_or_next_def): Rename to...
+	(def_lookup::matching_set_or_first_def_of_next_group): ...this.
+	(def_lookup::prev_def): New function, taking the lookup insn as
+	argument.
+	(def_lookup::next_def): Likewise.
+	* rtl-ssa/member-fns.inl (def_lookup::prev_def): Rename to...
+	(def_lookup::last_def_of_prev_group): ...this.
+	(def_lookup::next_def): Rename to...
+	(def_lookup::first_def_of_next_group): ...this.
+	(def_lookup::matching_or_prev_def): Rename to...
+	(def_lookup::matching_set_or_last_def_of_prev_group): ...this.
+	(def_lookup::matching_or_next_def): Rename to...
+	(def_lookup::matching_set_or_first_def_of_next_group): ...this.
+	* rtl-ssa/movement.h (restrict_movement_for_dead_range): Update after
+	above renaming.
+	* rtl-ssa/accesses.cc (clobber_group::prev_clobber): New function.
+	(clobber_group::next_clobber): Likewise.
+	(def_lookup::prev_def): Likewise.
+	(def_lookup::next_def): Likewise.
+	(function_info::make_use_available): Pass the lookup insn to
+	def_lookup::prev_def and def_lookup::next_def.
+
+2022-06-24  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-24  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* config/tilepro/gen-mul-tables.cc (tilegx_emit): Adjust loop
+	condition to avoid overflow.
+
+2022-06-23  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-06-23  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/105600
+	* ipa-icf.c (sem_item_optimizer::filter_removed_items):
+	Skip variables with body_removed.
+
+2022-06-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-06-17  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/105209
+	* config/alpha/alpha-protos.h (alpha_store_data_bypass_p): New.
+	* config/alpha/alpha.c (alpha_store_data_bypass_p): New function.
+	(alpha_store_data_bypass_p_1): Ditto.
+	* config/alpha/ev4.md: Use alpha_store_data_bypass_p instead
+	of generic store_data_bypass_p.
+	(ev4_ist_c): Remove insn reservation.
+
+2022-06-20  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-03-12  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/104829
+	* config/rs6000/rs6000.c (rs6000_machine_from_flags): Don't output
+	"ppc" and "ppc64" based on rs6000_cpu.
+
+2022-06-20  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-03-04  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/rs6000.c (rs6000_machine_from_flags): Restructure a
+	bit.  Handle most older CPUs.
+
+2022-06-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-06-17  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/105970
+	* config/i386/i386.c (ix86_function_arg): Assert that
+	the mode of pointer argumet is equal to ptr_mode, not Pmode.
+
+2022-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/105998
+	* varasm.c (narrowing_initializer_constant_valid_p): Check
+	SCALAR_INT_MODE_P instead of INTEGRAL_MODE_P, also break on
+	! INTEGRAL_TYPE_P and do the same check also on op{0,1}'s type.
+
+2022-06-20  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2022-06-14  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/105739
+	* ipa-prop.c (ipa_load_from_parm_agg): Punt on volatile loads.
+
+2022-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105729
+	* fold-const.c (fold_unary_loc): Don't optimize (X &) ((Y *) z + w)
+	to (X &) z + w if -fsanitize=null during GENERIC folding.
+
+2022-06-16  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2022-06-15  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/105981
+	* config/arm/arm.c (gen_cpymem_ldrd_strd): Rename low_reg and hi_reg
+	to first_reg and second_reg respectively.  Initialize them correctly
+	when generating big-endian code.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* common.opt (static-libphobos): Add option.
+	* config/darwin.h (LINK_SPEC): Substitute -lgphobos with libgphobos.a
+	when linking statically.
+	* gcc.c (driver_handle_option): Set -static-libphobos as always valid.
+
+2022-06-15  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105726
+	* gimple-ssa-warn-restrict.c (builtin_memref::set_base_and_offset):
+	Constrain array-of-flexarray case more.
+
+2022-06-14  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/104637
+	* lra-assigns.c (lra_split_hard_reg_for): Split hard regs as many
+	as possible on one subpass.
+
+2022-06-14  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-06-13  H.J. Lu  <hjl.tools@gmail.com>
+
+	* common/config/i386/cpuinfo.h (get_available_features): Require
+	AVX for F16C and VAES.
+
+2022-06-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backported from master:
+	2022-06-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	PR target/105879
+	* config/xtensa/xtensa.md (movdi): Rename 'first' and 'second'
+	to 'lowpart' and 'highpart' so that they match 'gen_lowpart' and
+	'gen_highpart' bitwise semantics and fix order of highpart and
+	lowpart depending on target endianness.
+
+2022-06-08  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/105854
+	* config/i386/sse.md (ssse3_palignrdi): Change alternative 2
+	from Yv to Yw.
+
+2022-06-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105437
+	* tree-vect-slp.c (vect_schedule_slp_node): Handle the
+	case where last_stmt alters control flow.
+
+2022-05-26  Simon Cook  <simon.cook@embecosm.com>
+
+	Backported from master:
+	2022-05-25  Simon Cook  <simon.cook@embecosm.com>
+
+	* config/riscv/arch-canonicalize: Only add mafd extension if
+	base was rv32/rv64g.
+
+2022-05-26  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backported from master:
+	2022-05-09  Kito Cheng  <kito.cheng@sifive.com>
+
+	* config/riscv/arch-canonicalize: Handle g correctly.
+
+2022-05-24  Qing Zhao  <qing.zhao@oracle.com>
+
+	Backported from master:
+	2022-05-09  Qing Zhao  <qing.zhao@oracle.com>
+
+	PR target/101891
+	* config/i386/i386.c (zero_call_used_regno_mode): use V2SImode
+	as a generic MMX mode instead of V4HImode.
+	(zero_all_mm_registers): Use SET to zero instead of MOV for
+	zeroing scratch registers.
+	(ix86_zero_call_used_regs): Likewise.
+
+2022-05-23  Paul A. Clarke  <pc@us.ibm.com>
+
+	PR target/104257
+	* config/rs6000/bmi2intrin.h: Uglify local variables.
+	* config/rs6000/emmintrin.h: Likewise.
+	* config/rs6000/mm_malloc.h: Likewise.
+	* config/rs6000/mmintrin.h: Likewise.
+	* config/rs6000/pmmintrin.h: Likewise.
+	* config/rs6000/smmintrin.h: Likewise.
+	* config/rs6000/tmmintrin.h: Likewise.
+	* config/rs6000/xmmintrin.h: Likewise.
+
+2022-05-19  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2022-05-06  Michael Meissner  <meissner@linux.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/102059
+	* config/rs6000/rs6000.c (rs6000_can_inline_p): Ignore -mpower8-fusion
+	and -mpower10-fusion options for inlining purposes.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/105559
+	* cfgrtl.c (delete_insn_and_edges): Only perform search to BB_END
+	for non-debug insns.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105431
+	* tree-ssa-math-opts.c (powi_as_mults_1): Make n unsigned.
+	(powi_as_mults): Use absu_hwi.
+	(gimple_expand_builtin_powi): Remove now pointless n != -n
+	check.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105368
+	* tree-ssa-math-opts.c (powi_cost): Use absu_hwi.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-20  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105312
+	* gimple-isel.cc (gimple_expand_vec_cond_expr): Query both
+	VCOND and VCONDU for EQ and NE.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105263
+	* tree-ssa-reassoc.c (try_special_add_to_ops): Do not consume
+	negates in multiplication chains with DFP.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105173
+	* tree-ssa-reassoc.c (find_insert_point): Get extra
+	insert_before output argument and compute it.
+	(insert_stmt_before_use): Adjust.
+	(rewrite_expr_tree): Likewise.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105163
+	* tree-ssa-reassoc.c (repropagate_negates): Avoid propagating
+	negated abnormals.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105148
+	* tree-ssa-loop-ivopts.c (idx_record_use): Walk raw operands
+	2 and 3 of ARRAY_REFs.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105250
+	* fold-const.c (fold_convertible_p): Revert
+	r12-7979-geaaf77dd85c333, instead check for size equality
+	of the vector types involved.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105140
+	* fold-const.c (fold_convertible_p): Allow a TYPE_P arg.
+
+2022-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-04-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/100413
+	* cgraph.c (cgraph_node::remove): Release body of the node this
+	is clone_of if appropriate.
+
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* config/aarch64/aarch64-protos.h (atomic_ool_names): Increase dimension
+	of str array.
+	* config/aarch64/aarch64.c (aarch64_atomic_ool_func): Call
+	memmodel_from_int and handle MEMMODEL_SYNC_*.
+	(DEF0): Add __aarch64_*_sync functions.
+
+2022-05-16  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-10  Jan Hubicka  <jh@suse.cz>
+
+	* ipa-modref-tree.h (modref_tree::remap_params): Fix off-by-one error.
+
+2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/105528
+	* gimple-isel.cc (gimple_expand_vec_set_expr): After gsi_remove
+	set *gsi to gsi_for_stmt (ass_stmt).  Fix up function comment.
+
+2022-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/105292
+	* config/sparc/sparc.c (sparc_vectorize_vec_perm_const): Return
+	true only for 8-byte vector modes.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105331
+	* config/i386/i386.c (ix86_gimplify_va_arg): Mark va_arg_tmp
+	temporary TREE_ADDRESSABLE before trying to gimplify ADDR_EXPR
+	of it.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105396
+	* asan.c (asan_redzone_buffer::emit_redzone_byte): Handle the case
+	where offset is bigger than off but smaller than m_prev_offset + 32
+	bits by pushing one or more 0 bytes.  Sink the
+	m_shadow_bytes.safe_push (value); flush_if_full (); statements from
+	all cases to the end of the function.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/105333
+	* rtlanal.c (replace_rtx): Use simplify_subreg or
+	simplify_unary_operation if CONST_SCALAR_INT_P rather than just
+	CONST_INT_P.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* config/i386/avx512fintrin.h (_mm512_scalef_round_pd):
+	Add parentheses for parameters and djust format.
+	(_mm512_mask_scalef_round_pd): Ditto.
+	(_mm512_maskz_scalef_round_pd): Ditto.
+	(_mm512_scalef_round_ps): Ditto.
+	(_mm512_mask_scalef_round_ps): Ditto.
+	(_mm512_maskz_scalef_round_ps): Ditto.
+	(_mm_scalef_round_sd): Use _mm_undefined_pd.
+	(_mm_scalef_round_ss): Use _mm_undefined_ps.
+	(_mm_mask_scalef_round_sd): New macro.
+	(_mm_mask_scalef_round_ss): Ditto.
+	(_mm_maskz_scalef_round_sd): Ditto.
+	(_mm_maskz_scalef_round_ss): Ditto.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* config/sparc/sparc.c (epilogue_renumber): If ORIGINAL_REGNO,
+	use gen_raw_REG instead of gen_rtx_REG and copy over also
+	ORIGINAL_REGNO.  Use return 0; instead of /* fallthrough */.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/105203
+	* emit-rtl.c (emit_copy_of_insn_after): Don't call mark_jump_label
+	on DEBUG_INSNs.
+
+2022-04-21  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-04-19  Sergei Trofimovich  <siarheit@google.com>
+
+	PR gcov-profile/105282
+	* value-prof.c (stream_out_histogram_value): Allow negative counts
+	on HIST_TYPE_INDIR_CALL.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/alias.c b/gcc/alias.c
index 69e1eb89ac6..ba4aa4dc8d9 100644
--- a/gcc/alias.c
+++ b/gcc/alias.c
@@ -389,6 +389,20 @@ refs_same_for_tbaa_p (tree earlier, tree later)
 	  || alias_set_subset_of (later_base_set, earlier_base_set));
 }
 
+/* Similar to refs_same_for_tbaa_p() but for use on MEM rtxs.  */
+bool
+mems_same_for_tbaa_p (rtx earlier, rtx later)
+{
+  gcc_assert (MEM_P (earlier));
+  gcc_assert (MEM_P (later));
+
+  return ((MEM_ALIAS_SET (earlier) == MEM_ALIAS_SET (later)
+	   || alias_set_subset_of (MEM_ALIAS_SET (later),
+				   MEM_ALIAS_SET (earlier)))
+	  && (!MEM_EXPR (earlier)
+	      || refs_same_for_tbaa_p (MEM_EXPR (earlier), MEM_EXPR (later))));
+}
+
 /* Returns a pointer to the alias set entry for ALIAS_SET, if there is
    such an entry, or NULL otherwise.  */
 
diff --git a/gcc/alias.h b/gcc/alias.h
index f427698a8e1..f38da75e040 100644
--- a/gcc/alias.h
+++ b/gcc/alias.h
@@ -40,6 +40,7 @@ tree reference_alias_ptr_type_1 (tree *);
 bool alias_ptr_types_compatible_p (tree, tree);
 int compare_base_decls (tree, tree);
 bool refs_same_for_tbaa_p (tree, tree);
+bool mems_same_for_tbaa_p (rtx, rtx);
 
 /* This alias set can be used to force a memory to conflict with all
    other memories, creating a barrier across which no memory reference
diff --git a/gcc/analyzer/ChangeLog b/gcc/analyzer/ChangeLog
index 7ae3901445e..a051997909c 100644
--- a/gcc/analyzer/ChangeLog
+++ b/gcc/analyzer/ChangeLog
@@ -1,3 +1,20 @@
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105365
+	PR analyzer/105366
+	* svalue.cc
+	(cmp_cst): Rename to...
+	(cmp_csts_same_type): ...this.  Convert all recursive calls to
+	calls to...
+	(cmp_csts_and_types): ....this new function.
+	(svalue::cmp_ptr): Update for renaming of cmp_cst
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105252
+	* svalue.cc (cmp_cst): When comparing VECTOR_CSTs, compare the
+	types of the encoded elements before calling cmp_cst on them.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/analyzer/svalue.cc b/gcc/analyzer/svalue.cc
index a16563d912a..fa33e956d41 100644
--- a/gcc/analyzer/svalue.cc
+++ b/gcc/analyzer/svalue.cc
@@ -59,6 +59,8 @@ along with GCC; see the file COPYING3.  If not see
 
 namespace ana {
 
+static int cmp_csts_and_types (const_tree cst1, const_tree cst2);
+
 /* class svalue and its various subclasses.  */
 
 /* class svalue.  */
@@ -276,7 +278,7 @@ svalue::implicitly_live_p (const svalue_set *, const region_model *) const
    of the same type.  */
 
 static int
-cmp_cst (const_tree cst1, const_tree cst2)
+cmp_csts_same_type (const_tree cst1, const_tree cst2)
 {
   gcc_assert (TREE_TYPE (cst1) == TREE_TYPE (cst2));
   gcc_assert (TREE_CODE (cst1) == TREE_CODE (cst2));
@@ -295,9 +297,10 @@ cmp_cst (const_tree cst1, const_tree cst2)
 		     TREE_REAL_CST_PTR (cst2),
 		     sizeof (real_value));
     case COMPLEX_CST:
-      if (int cmp_real = cmp_cst (TREE_REALPART (cst1), TREE_REALPART (cst2)))
+      if (int cmp_real = cmp_csts_and_types (TREE_REALPART (cst1),
+					     TREE_REALPART (cst2)))
 	return cmp_real;
-      return cmp_cst (TREE_IMAGPART (cst1), TREE_IMAGPART (cst2));
+      return cmp_csts_and_types (TREE_IMAGPART (cst1), TREE_IMAGPART (cst2));
     case VECTOR_CST:
       if (int cmp_log2_npatterns
 	    = ((int)VECTOR_CST_LOG2_NPATTERNS (cst1)
@@ -309,13 +312,29 @@ cmp_cst (const_tree cst1, const_tree cst2)
 	return cmp_nelts_per_pattern;
       unsigned encoded_nelts = vector_cst_encoded_nelts (cst1);
       for (unsigned i = 0; i < encoded_nelts; i++)
-	if (int el_cmp = cmp_cst (VECTOR_CST_ENCODED_ELT (cst1, i),
-				  VECTOR_CST_ENCODED_ELT (cst2, i)))
-	  return el_cmp;
+	{
+	  const_tree elt1 = VECTOR_CST_ENCODED_ELT (cst1, i);
+	  const_tree elt2 = VECTOR_CST_ENCODED_ELT (cst2, i);
+	  if (int el_cmp = cmp_csts_and_types (elt1, elt2))
+	    return el_cmp;
+	}
       return 0;
     }
 }
 
+/* Comparator for imposing a deterministic order on constants that might
+   not be of the same type.  */
+
+static int
+cmp_csts_and_types (const_tree cst1, const_tree cst2)
+{
+  int t1 = TYPE_UID (TREE_TYPE (cst1));
+  int t2 = TYPE_UID (TREE_TYPE (cst2));
+  if (int cmp_type = t1 - t2)
+    return cmp_type;
+  return cmp_csts_same_type (cst1, cst2);
+}
+
 /* Comparator for imposing a deterministic order on svalues.  */
 
 int
@@ -347,7 +366,7 @@ svalue::cmp_ptr (const svalue *sval1, const svalue *sval2)
 	const constant_svalue *constant_sval2 = (const constant_svalue *)sval2;
 	const_tree cst1 = constant_sval1->get_constant ();
 	const_tree cst2 = constant_sval2->get_constant ();
-	return cmp_cst (cst1, cst2);
+	return cmp_csts_same_type (cst1, cst2);
       }
       break;
     case SK_UNKNOWN:
diff --git a/gcc/asan.c b/gcc/asan.c
index ca036767134..3884f111d82 100644
--- a/gcc/asan.c
+++ b/gcc/asan.c
@@ -1497,10 +1497,14 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,
   HOST_WIDE_INT off
     = m_prev_offset + ASAN_SHADOW_GRANULARITY * m_shadow_bytes.length ();
   if (off == offset)
+    /* Consecutive shadow memory byte.  */;
+  else if (offset < m_prev_offset + (HOST_WIDE_INT) (ASAN_SHADOW_GRANULARITY
+						     * RZ_BUFFER_SIZE)
+	   && !m_shadow_bytes.is_empty ())
     {
-      /* Consecutive shadow memory byte.  */
-      m_shadow_bytes.safe_push (value);
-      flush_if_full ();
+      /* Shadow memory byte with a small gap.  */
+      for (; off < offset; off += ASAN_SHADOW_GRANULARITY)
+	m_shadow_bytes.safe_push (0);
     }
   else
     {
@@ -1521,9 +1525,9 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,
       m_shadow_mem = adjust_address (m_shadow_mem, VOIDmode,
 				     diff >> ASAN_SHADOW_SHIFT);
       m_prev_offset = offset;
-      m_shadow_bytes.safe_push (value);
-      flush_if_full ();
     }
+  m_shadow_bytes.safe_push (value);
+  flush_if_full ();
 }
 
 /* Emit RTX emission of the content of the buffer.  */
diff --git a/gcc/builtins.c b/gcc/builtins.c
index 64f4999ab07..627a89b3c45 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -2110,7 +2110,7 @@ expand_builtin_prefetch (tree exp)
 static rtx
 get_memory_rtx (tree exp, tree len)
 {
-  tree orig_exp = exp;
+  tree orig_exp = exp, base;
   rtx addr, mem;
 
   /* When EXP is not resolved SAVE_EXPR, MEM_ATTRS can be still derived
@@ -2141,10 +2141,11 @@ get_memory_rtx (tree exp, tree len)
   if (is_gimple_mem_ref_addr (TREE_OPERAND (exp, 0)))
     set_mem_attributes (mem, exp, 0);
   else if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR
-	   && (exp = get_base_address (TREE_OPERAND (TREE_OPERAND (exp, 0),
-						     0))))
+	   && (base = get_base_address (TREE_OPERAND (TREE_OPERAND (exp, 0),
+						      0))))
     {
-      exp = build_fold_addr_expr (exp);
+      unsigned int align = get_pointer_alignment (TREE_OPERAND (exp, 0));
+      exp = build_fold_addr_expr (base);
       exp = fold_build2 (MEM_REF,
 			 build_array_type (char_type_node,
 					   build_range_type (sizetype,
@@ -2152,6 +2153,10 @@ get_memory_rtx (tree exp, tree len)
 							     NULL)),
 			 exp, build_int_cst (ptr_type_node, 0));
       set_mem_attributes (mem, exp, 0);
+      /* Since we stripped parts make sure the offset is unknown and the
+	 alignment is computed from the original address.  */
+      clear_mem_offset (mem);
+      set_mem_align (mem, align);
     }
   set_mem_alias_set (mem, 0);
   return mem;
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index dff48ba4655..65de3d901d3 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,12 @@
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105304
+	* c-common.c (verify_tree) [restart]: Move up to before the
+	NULL test.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 7b8f49d78dc..16fc52302e5 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -1854,12 +1854,12 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,
   enum tree_code code;
   enum tree_code_class cl;
 
+ restart:
   /* X may be NULL if it is the operand of an empty statement expression
      ({ }).  */
   if (x == NULL)
     return;
 
- restart:
   code = TREE_CODE (x);
   cl = TREE_CODE_CLASS (code);
 
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index 8d0dffcaa10..b64ceda32ef 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,12 @@
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* c-parser.c (c_parser_pragma): Set input_location to the
+	location of the pragma, rather than the start of the line.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index 7690977f6b8..407c22afa6f 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -12289,6 +12289,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)
   unsigned int id;
   const char *construct = NULL;
 
+  input_location = c_parser_peek_token (parser)->location;
   id = c_parser_peek_token (parser)->pragma_kind;
   gcc_assert (id != PRAGMA_NONE);
 
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 4086b647585..06586ddf083 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -208,7 +208,7 @@ mark_effect (rtx exp, regset nonequal)
       return false;
 
     case SET:
-      if (rtx_equal_for_cselib_p (SET_DEST (exp), SET_SRC (exp)))
+      if (cselib_redundant_set_p (exp))
 	return false;
       dest = SET_DEST (exp);
       if (dest == pc_rtx)
diff --git a/gcc/cfgrtl.c b/gcc/cfgrtl.c
index 8fd128b471c..4fb145ee4c4 100644
--- a/gcc/cfgrtl.c
+++ b/gcc/cfgrtl.c
@@ -233,7 +233,7 @@ delete_insn_and_edges (rtx_insn *insn)
 {
   bool purge = false;
 
-  if (INSN_P (insn) && BLOCK_FOR_INSN (insn))
+  if (NONDEBUG_INSN_P (insn) && BLOCK_FOR_INSN (insn))
     {
       basic_block bb = BLOCK_FOR_INSN (insn);
       if (BB_END (bb) == insn)
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index d7c78d518bc..4e3e348513b 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -1906,7 +1906,11 @@ cgraph_node::remove (void)
   if (prev_sibling_clone)
     prev_sibling_clone->next_sibling_clone = next_sibling_clone;
   else if (clone_of)
-    clone_of->clones = next_sibling_clone;
+    {
+      clone_of->clones = next_sibling_clone;
+      if (!clone_of->analyzed && !clone_of->clones && !clones)
+	clone_of->release_body ();
+    }
   if (next_sibling_clone)
     next_sibling_clone->prev_sibling_clone = prev_sibling_clone;
   if (clones)
diff --git a/gcc/common.opt b/gcc/common.opt
index a75b44ee47e..4a3f09d9e1f 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -3446,6 +3446,10 @@ static-libgfortran
 Driver
 ; Documented for Fortran, but always accepted by driver.
 
+static-libphobos
+Driver
+; Documented for D, but always accepted by driver.
+
 static-libstdc++
 Driver
 
diff --git a/gcc/common/config/i386/cpuinfo.h b/gcc/common/config/i386/cpuinfo.h
index 58294b7d7ac..18ff71ac5ad 100644
--- a/gcc/common/config/i386/cpuinfo.h
+++ b/gcc/common/config/i386/cpuinfo.h
@@ -606,8 +606,6 @@ get_available_features (struct __processor_model *cpu_model,
     set_feature (FEATURE_MOVBE);
   if (ecx & bit_AES)
     set_feature (FEATURE_AES);
-  if (ecx & bit_F16C)
-    set_feature (FEATURE_F16C);
   if (ecx & bit_RDRND)
     set_feature (FEATURE_RDRND);
   if (ecx & bit_XSAVE)
@@ -618,6 +616,8 @@ get_available_features (struct __processor_model *cpu_model,
 	set_feature (FEATURE_AVX);
       if (ecx & bit_FMA)
 	set_feature (FEATURE_FMA);
+      if (ecx & bit_F16C)
+	set_feature (FEATURE_F16C);
     }
 
   /* Get Advanced Features at level 7 (eax = 7, ecx = 0/1). */
@@ -638,6 +638,8 @@ get_available_features (struct __processor_model *cpu_model,
 	    set_feature (FEATURE_AVX2);
 	  if (ecx & bit_VPCLMULQDQ)
 	    set_feature (FEATURE_VPCLMULQDQ);
+	  if (ecx & bit_VAES)
+	    set_feature (FEATURE_VAES);
 	}
       if (ebx & bit_BMI2)
 	set_feature (FEATURE_BMI2);
@@ -660,8 +662,6 @@ get_available_features (struct __processor_model *cpu_model,
 	set_feature (FEATURE_PKU);
       if (ecx & bit_RDPID)
 	set_feature (FEATURE_RDPID);
-      if (ecx & bit_VAES)
-	set_feature (FEATURE_VAES);
       if (ecx & bit_GFNI)
 	set_feature (FEATURE_GFNI);
       if (ecx & bit_MOVDIRI)
diff --git a/gcc/config/aarch64/aarch64-cores.def b/gcc/config/aarch64/aarch64-cores.def
index 4643e0e2795..911cd1be449 100644
--- a/gcc/config/aarch64/aarch64-cores.def
+++ b/gcc/config/aarch64/aarch64-cores.def
@@ -147,6 +147,7 @@ AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_
 
 /* Armv8.5-A Architecture Processors.  */
 AARCH64_CORE("neoverse-n2", neoversen2, cortexa57, 8_5A, AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG, neoversen2, 0x41, 0xd49, -1)
+AARCH64_CORE("neoverse-v2", neoversev2, cortexa57, 8_5A, AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG, neoverse512tvb, 0x41, 0xd4f, -1)
 
 /* ARMv8-A big.LITTLE implementations.  */
 
diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index b91eeeba101..ad62da81d31 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -1034,7 +1034,7 @@ bool aarch64_high_bits_all_ones_p (HOST_WIDE_INT);
 
 struct atomic_ool_names
 {
-    const char *str[5][4];
+    const char *str[5][5];
 };
 
 rtx aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
diff --git a/gcc/config/aarch64/aarch64-sve-builtins.cc b/gcc/config/aarch64/aarch64-sve-builtins.cc
index f44f81f1375..fcc458af3d6 100644
--- a/gcc/config/aarch64/aarch64-sve-builtins.cc
+++ b/gcc/config/aarch64/aarch64-sve-builtins.cc
@@ -530,7 +530,8 @@ static CONSTEXPR const function_group_info function_groups[] = {
 };
 
 /* The scalar type associated with each vector type.  */
-GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
+extern GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
+tree scalar_types[NUM_VECTOR_TYPES];
 
 /* The single-predicate and single-vector types, with their built-in
    "__SV..._t" name.  Allow an index of NUM_VECTOR_TYPES, which always
@@ -538,13 +539,16 @@ GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
 static GTY(()) tree abi_vector_types[NUM_VECTOR_TYPES + 1];
 
 /* Same, but with the arm_sve.h "sv..._t" name.  */
-GTY(()) tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
+extern GTY(()) tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
+tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
 
 /* The svpattern enum type.  */
-GTY(()) tree acle_svpattern;
+extern GTY(()) tree acle_svpattern;
+tree acle_svpattern;
 
 /* The svprfop enum type.  */
-GTY(()) tree acle_svprfop;
+extern GTY(()) tree acle_svprfop;
+tree acle_svprfop;
 
 /* The list of all registered function decls, indexed by code.  */
 static GTY(()) vec<registered_function *, va_gc> *registered_functions;
diff --git a/gcc/config/aarch64/aarch64-tune.md b/gcc/config/aarch64/aarch64-tune.md
index 2beac8c8353..85fb0fdf064 100644
--- a/gcc/config/aarch64/aarch64-tune.md
+++ b/gcc/config/aarch64/aarch64-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from aarch64-cores.def
 (define_attr "tune"
-	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,ampere1,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa78,cortexa78ae,cortexa78c,cortexa65,cortexa65ae,cortexx1,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55,cortexr82"
+	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,ampere1,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa78,cortexa78ae,cortexa78c,cortexa65,cortexa65ae,cortexx1,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,neoversev2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55,cortexr82"
 	(const (symbol_ref "((enum attr_tune) aarch64_tune)")))
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index c155f4883cf..7e6f9d08ea3 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -21627,14 +21627,14 @@ aarch64_emit_unlikely_jump (rtx insn)
   add_reg_br_prob_note (jump, profile_probability::very_unlikely ());
 }
 
-/* We store the names of the various atomic helpers in a 5x4 array.
+/* We store the names of the various atomic helpers in a 5x5 array.
    Return the libcall function given MODE, MODEL and NAMES.  */
 
 rtx
 aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
 			const atomic_ool_names *names)
 {
-  memmodel model = memmodel_base (INTVAL (model_rtx));
+  memmodel model = memmodel_from_int (INTVAL (model_rtx));
   int mode_idx, model_idx;
 
   switch (mode)
@@ -21674,6 +21674,11 @@ aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
     case MEMMODEL_SEQ_CST:
       model_idx = 3;
       break;
+    case MEMMODEL_SYNC_ACQUIRE:
+    case MEMMODEL_SYNC_RELEASE:
+    case MEMMODEL_SYNC_SEQ_CST:
+      model_idx = 4;
+      break;
     default:
       gcc_unreachable ();
     }
@@ -21686,7 +21691,8 @@ aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
   { "__aarch64_" #B #N "_relax", \
     "__aarch64_" #B #N "_acq", \
     "__aarch64_" #B #N "_rel", \
-    "__aarch64_" #B #N "_acq_rel" }
+    "__aarch64_" #B #N "_acq_rel", \
+    "__aarch64_" #B #N "_sync" }
 
 #define DEF4(B)  DEF0(B, 1), DEF0(B, 2), DEF0(B, 4), DEF0(B, 8), \
 		 { NULL, NULL, NULL, NULL }
diff --git a/gcc/config/alpha/alpha-protos.h b/gcc/config/alpha/alpha-protos.h
index b2fa3d2fc11..13faf53fb05 100644
--- a/gcc/config/alpha/alpha-protos.h
+++ b/gcc/config/alpha/alpha-protos.h
@@ -73,6 +73,8 @@ extern void alpha_end_function (FILE *, const char *, tree);
 
 extern bool alpha_find_lo_sum_using_gp (rtx);
 
+extern int alpha_store_data_bypass_p (rtx_insn *, rtx_insn *);
+
 #ifdef REAL_VALUE_TYPE
 extern int check_float_value (machine_mode, REAL_VALUE_TYPE *, int);
 #endif
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
index 335f1db5335..9c05ce5a804 100644
--- a/gcc/config/alpha/alpha.c
+++ b/gcc/config/alpha/alpha.c
@@ -7564,6 +7564,75 @@ alpha_does_function_need_gp (void)
   return 0;
 }
 
+/* Helper function for alpha_store_data_bypass_p, handle just a single SET
+   IN_SET.  */
+
+static bool
+alpha_store_data_bypass_p_1 (rtx_insn *out_insn, rtx in_set)
+{
+  if (!MEM_P (SET_DEST (in_set)))
+    return false;
+
+  rtx out_set = single_set (out_insn);
+  if (out_set)
+    return !reg_mentioned_p (SET_DEST (out_set), SET_DEST (in_set));
+
+  rtx out_pat = PATTERN (out_insn);
+  if (GET_CODE (out_pat) != PARALLEL)
+    return false;
+
+  for (int i = 0; i < XVECLEN (out_pat, 0); i++)
+    {
+      rtx out_exp = XVECEXP (out_pat, 0, i);
+
+      if (GET_CODE (out_exp) == CLOBBER || GET_CODE (out_exp) == USE
+	  || GET_CODE (out_exp) == TRAP_IF)
+	continue;
+
+      gcc_assert (GET_CODE (out_exp) == SET);
+
+      if (reg_mentioned_p (SET_DEST (out_exp), SET_DEST (in_set)))
+	return false;
+    }
+
+  return true;
+}
+
+/* True if the dependency between OUT_INSN and IN_INSN is on the store
+   data not the address operand(s) of the store.  IN_INSN and OUT_INSN
+   must be either a single_set or a PARALLEL with SETs inside.
+
+   This alpha-specific version of store_data_bypass_p ignores TRAP_IF
+   that would result in assertion failure (and internal compiler error)
+   in the generic store_data_bypass_p function.  */
+
+int
+alpha_store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)
+{
+  rtx in_set = single_set (in_insn);
+  if (in_set)
+    return alpha_store_data_bypass_p_1 (out_insn, in_set);
+
+  rtx in_pat = PATTERN (in_insn);
+  if (GET_CODE (in_pat) != PARALLEL)
+    return false;
+
+  for (int i = 0; i < XVECLEN (in_pat, 0); i++)
+    {
+      rtx in_exp = XVECEXP (in_pat, 0, i);
+
+      if (GET_CODE (in_exp) == CLOBBER || GET_CODE (in_exp) == USE
+	  || GET_CODE (in_exp) == TRAP_IF)
+	continue;
+
+      gcc_assert (GET_CODE (in_exp) == SET);
+
+      if (!alpha_store_data_bypass_p_1 (out_insn, in_exp))
+	return false;
+    }
+
+  return true;
+}
 
 /* Helper function to set RTX_FRAME_RELATED_P on instructions, including
    sequences.  */
diff --git a/gcc/config/alpha/ev4.md b/gcc/config/alpha/ev4.md
index c22d0ba2903..2f70f1a6ffc 100644
--- a/gcc/config/alpha/ev4.md
+++ b/gcc/config/alpha/ev4.md
@@ -44,14 +44,7 @@
 ; Stores can issue before the data (but not address) is ready.
 (define_insn_reservation "ev4_ist" 1
   (and (eq_attr "tune" "ev4")
-       (eq_attr "type" "ist"))
-  "ev4_ib1+ev4_abox")
-
-; ??? Separate from ev4_ist because store_data_bypass_p can't handle
-; the patterns with multiple sets, like store-conditional.
-(define_insn_reservation "ev4_ist_c" 1
-  (and (eq_attr "tune" "ev4")
-       (eq_attr "type" "st_c"))
+       (eq_attr "type" "ist,st_c"))
   "ev4_ib1+ev4_abox")
 
 (define_insn_reservation "ev4_fst" 1
@@ -110,7 +103,7 @@
 (define_bypass 0
   "ev4_iaddlog,ev4_shiftcm,ev4_icmp"
   "ev4_ist"
-  "store_data_bypass_p")
+  "alpha_store_data_bypass_p")
 
 ; Multiplies use a non-pipelined imul unit.  Also, "no [ebox] insn can
 ; be issued exactly three cycles before an integer multiply completes".
@@ -121,7 +114,7 @@
 	    (eq_attr "opsize" "si")))
   "ev4_ib0+ev4_imul,ev4_imul*18,ev4_ebox")
 
-(define_bypass 20 "ev4_imulsi" "ev4_ist" "store_data_bypass_p")
+(define_bypass 20 "ev4_imulsi" "ev4_ist" "alpha_store_data_bypass_p")
 
 (define_insn_reservation "ev4_imuldi" 23
   (and (eq_attr "tune" "ev4")
@@ -129,7 +122,7 @@
 	    (eq_attr "opsize" "!si")))
   "ev4_ib0+ev4_imul,ev4_imul*20,ev4_ebox")
 
-(define_bypass 22 "ev4_imuldi" "ev4_ist" "store_data_bypass_p")
+(define_bypass 22 "ev4_imuldi" "ev4_ist" "alpha_store_data_bypass_p")
 
 ; Most FP insns have a 6 cycle latency, but with a 4 cycle bypass back in.
 (define_insn_reservation "ev4_fpop" 6
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 9e549285d0c..730b1fe0071 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -15546,13 +15546,21 @@ gen_cpymem_ldrd_strd (rtx *operands)
     {
       len -= 8;
       reg0 = gen_reg_rtx (DImode);
-      rtx low_reg = NULL_RTX;
-      rtx hi_reg = NULL_RTX;
+      rtx first_reg = NULL_RTX;
+      rtx second_reg = NULL_RTX;
 
       if (!src_aligned || !dst_aligned)
 	{
-	  low_reg = gen_lowpart (SImode, reg0);
-	  hi_reg = gen_highpart_mode (SImode, DImode, reg0);
+	  if (BYTES_BIG_ENDIAN)
+	    {
+	      second_reg = gen_lowpart (SImode, reg0);
+	      first_reg = gen_highpart_mode (SImode, DImode, reg0);
+	    }
+	  else
+	    {
+	      first_reg = gen_lowpart (SImode, reg0);
+	      second_reg = gen_highpart_mode (SImode, DImode, reg0);
+	    }
 	}
       if (MEM_ALIGN (src) >= 2 * BITS_PER_WORD)
 	emit_move_insn (reg0, src);
@@ -15560,9 +15568,9 @@ gen_cpymem_ldrd_strd (rtx *operands)
 	emit_insn (gen_unaligned_loaddi (reg0, src));
       else
 	{
-	  emit_insn (gen_unaligned_loadsi (low_reg, src));
+	  emit_insn (gen_unaligned_loadsi (first_reg, src));
 	  src = next_consecutive_mem (src);
-	  emit_insn (gen_unaligned_loadsi (hi_reg, src));
+	  emit_insn (gen_unaligned_loadsi (second_reg, src));
 	}
 
       if (MEM_ALIGN (dst) >= 2 * BITS_PER_WORD)
@@ -15571,9 +15579,9 @@ gen_cpymem_ldrd_strd (rtx *operands)
 	emit_insn (gen_unaligned_storedi (dst, reg0));
       else
 	{
-	  emit_insn (gen_unaligned_storesi (dst, low_reg));
+	  emit_insn (gen_unaligned_storesi (dst, first_reg));
 	  dst = next_consecutive_mem (dst);
-	  emit_insn (gen_unaligned_storesi (dst, hi_reg));
+	  emit_insn (gen_unaligned_storesi (dst, second_reg));
 	}
 
       src = next_consecutive_mem (src);
diff --git a/gcc/config/arm/mve.md b/gcc/config/arm/mve.md
index 5c11885fb73..c9313744a16 100644
--- a/gcc/config/arm/mve.md
+++ b/gcc/config/arm/mve.md
@@ -10822,7 +10822,7 @@
 )
 
 (define_insn "*movmisalign<mode>_mve_store"
-  [(set (match_operand:MVE_VLD_ST 0 "neon_permissive_struct_operand"	     "=Ux")
+  [(set (match_operand:MVE_VLD_ST 0 "mve_memory_operand"	     "=Ux")
 	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "s_register_operand" " w")]
 	 UNSPEC_MISALIGNED_ACCESS))]
   "((TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))
@@ -10835,7 +10835,7 @@
 
 (define_insn "*movmisalign<mode>_mve_load"
   [(set (match_operand:MVE_VLD_ST 0 "s_register_operand"				 "=w")
-	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "neon_permissive_struct_operand" " Ux")]
+	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "mve_memory_operand" " Ux")]
 	 UNSPEC_MISALIGNED_ACCESS))]
   "((TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))
     || (TARGET_HAVE_MVE_FLOAT && VALID_MVE_SF_MODE (<MODE>mode)))
diff --git a/gcc/config/arm/vec-common.md b/gcc/config/arm/vec-common.md
index 9212937380f..581b05f845e 100644
--- a/gcc/config/arm/vec-common.md
+++ b/gcc/config/arm/vec-common.md
@@ -280,29 +280,81 @@
   DONE;
 })
 
-(define_expand "movmisalign<mode>"
- [(set (match_operand:VDQX 0 "neon_perm_struct_or_reg_operand")
-	(unspec:VDQX [(match_operand:VDQX 1 "neon_perm_struct_or_reg_operand")]
+(define_expand "@movmisalign<mode>"
+ [(set (match_operand:VDQX 0 "nonimmediate_operand")
+	(unspec:VDQX [(match_operand:VDQX 1 "general_operand")]
 	 UNSPEC_MISALIGNED_ACCESS))]
  "ARM_HAVE_<MODE>_LDST && !BYTES_BIG_ENDIAN
   && unaligned_access && !TARGET_REALLY_IWMMXT"
 {
- rtx adjust_mem;
- /* This pattern is not permitted to fail during expansion: if both arguments
-    are non-registers (e.g. memory := constant, which can be created by the
-    auto-vectorizer), force operand 1 into a register.  */
- if (!s_register_operand (operands[0], <MODE>mode)
-     && !s_register_operand (operands[1], <MODE>mode))
-   operands[1] = force_reg (<MODE>mode, operands[1]);
-
- if (s_register_operand (operands[0], <MODE>mode))
-   adjust_mem = operands[1];
- else
-   adjust_mem = operands[0];
-
- /* Legitimize address.  */
- if (!neon_vector_mem_operand (adjust_mem, 2, true))
-   XEXP (adjust_mem, 0) = force_reg (Pmode, XEXP (adjust_mem, 0));
+  rtx *memloc;
+  bool for_store = false;
+  /* This pattern is not permitted to fail during expansion: if both arguments
+     are non-registers (e.g. memory := constant, which can be created by the
+     auto-vectorizer), force operand 1 into a register.  */
+  if (!s_register_operand (operands[0], <MODE>mode)
+      && !s_register_operand (operands[1], <MODE>mode))
+    operands[1] = force_reg (<MODE>mode, operands[1]);
+
+  if (s_register_operand (operands[0], <MODE>mode))
+    memloc = &operands[1];
+  else
+    {
+      memloc = &operands[0];
+      for_store = true;
+    }
+
+  /* For MVE, vector loads/stores must be aligned to the element size.  If the
+     alignment is less than that convert the load/store to a suitable mode.  */
+  if (TARGET_HAVE_MVE
+      && (MEM_ALIGN (*memloc)
+	  < GET_MODE_ALIGNMENT (GET_MODE_INNER (<MODE>mode))))
+    {
+      scalar_mode new_smode;
+      switch (MEM_ALIGN (*memloc))
+	{
+	case 64:
+	case 32:
+	  new_smode = SImode;
+	  break;
+	case 16:
+	  new_smode = HImode;
+	  break;
+	default:
+	  new_smode = QImode;
+	  break;
+	}
+      machine_mode new_mode
+	= mode_for_vector (new_smode,
+			   GET_MODE_SIZE (<MODE>mode)
+			   / GET_MODE_SIZE (new_smode)).require ();
+      rtx new_mem = adjust_address (*memloc, new_mode, 0);
+
+      if (!for_store)
+	{
+	  rtx reg = gen_reg_rtx (new_mode);
+	  emit_insn (gen_movmisalign (new_mode, reg, new_mem));
+	  emit_move_insn (operands[0], gen_lowpart (<MODE>mode, reg));
+	  DONE;
+	}
+      emit_insn (gen_movmisalign (new_mode, new_mem,
+				  gen_lowpart (new_mode, operands[1])));
+      DONE;
+    }
+
+  /* Legitimize address.  */
+  if ((TARGET_HAVE_MVE
+       && !mve_vector_mem_operand (<MODE>mode, XEXP (*memloc, 0), false))
+      || (!TARGET_HAVE_MVE
+	  && !neon_vector_mem_operand (*memloc, 2, false)))
+    {
+      rtx new_mem
+	= replace_equiv_address (*memloc,
+				 force_reg (Pmode, XEXP (*memloc, 0)),
+				 false);
+      gcc_assert (MEM_ALIGN (new_mem) == MEM_ALIGN (*memloc));
+      *memloc = new_mem;
+    }
 })
 
 (define_insn "mve_vshlq_<supf><mode>"
diff --git a/gcc/config/darwin.h b/gcc/config/darwin.h
index 3206b70c7c2..d390635409d 100644
--- a/gcc/config/darwin.h
+++ b/gcc/config/darwin.h
@@ -445,6 +445,7 @@ extern GTY(()) int darwin_ms_struct;
                      %:replace-outfile(-lobjc libobjc-gnu.a%s); \
                     :%:replace-outfile(-lobjc -lobjc-gnu )}}\
    %{static|static-libgcc|static-libgfortran:%:replace-outfile(-lgfortran libgfortran.a%s)}\
+   %{static|static-libgcc|static-libphobos:%:replace-outfile(-lgphobos libgphobos.a%s)}\
    %{static|static-libgcc|static-libstdc++|static-libgfortran:%:replace-outfile(-lgomp libgomp.a%s)}\
    %{static|static-libgcc|static-libstdc++:%:replace-outfile(-lstdc++ libstdc++.a%s)}\
    %{force_cpusubtype_ALL:-arch %(darwin_arch)} \
diff --git a/gcc/config/i386/avx512fintrin.h b/gcc/config/i386/avx512fintrin.h
index 515ee0c1728..1ce6bade1b4 100644
--- a/gcc/config/i386/avx512fintrin.h
+++ b/gcc/config/i386/avx512fintrin.h
@@ -3244,31 +3244,67 @@ _mm_maskz_scalef_round_ss (__mmask8 __U, __m128 __A, __m128 __B, const int __R)
 						      (__mmask8) __U, __R);
 }
 #else
-#define _mm512_scalef_round_pd(A, B, C)            \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_undefined_pd(), -1, C)
-
-#define _mm512_mask_scalef_round_pd(W, U, A, B, C) \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, W, U, C)
-
-#define _mm512_maskz_scalef_round_pd(U, A, B, C)   \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_setzero_pd(), U, C)
+#define _mm512_scalef_round_pd(A, B, C)					\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_undefined_pd(),	\
+				   -1, (C)))
+
+#define _mm512_mask_scalef_round_pd(W, U, A, B, C)			\
+  ((__m512d) __builtin_ia32_scalefpd512_mask((A), (B), (W), (U), (C)))
+
+#define _mm512_maskz_scalef_round_pd(U, A, B, C)			\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_setzero_pd(),	\
+				   (U), (C)))
+
+#define _mm512_scalef_round_ps(A, B, C)					\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_undefined_ps(),	\
+				   -1, (C)))
+
+#define _mm512_mask_scalef_round_ps(W, U, A, B, C)			\
+  ((__m512) __builtin_ia32_scalefps512_mask((A), (B), (W), (U), (C)))
+
+#define _mm512_maskz_scalef_round_ps(U, A, B, C)			\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_setzero_ps(),	\
+				   (U), (C)))
+
+#define _mm_scalef_round_sd(A, B, C)					\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_undefined_pd (),	\
+				       -1, (C)))
 
-#define _mm512_scalef_round_ps(A, B, C)            \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_undefined_ps(), -1, C)
+#define _mm_scalef_round_ss(A, B, C)					\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_undefined_ps (),	\
+				       -1, (C)))
 
-#define _mm512_mask_scalef_round_ps(W, U, A, B, C) \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, W, U, C)
+#define _mm_mask_scalef_round_sd(W, U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B), (W), (U), (C)))
 
-#define _mm512_maskz_scalef_round_ps(U, A, B, C)   \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_setzero_ps(), U, C)
+#define _mm_mask_scalef_round_ss(W, U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B), (W), (U), (C)))
 
-#define _mm_scalef_round_sd(A, B, C)            \
-    (__m128d)__builtin_ia32_scalefsd_mask_round (A, B, \
-	(__v2df)_mm_setzero_pd (), -1, C)
+#define _mm_maskz_scalef_round_sd(U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_setzero_pd (),	\
+				       (U), (C)))
 
-#define _mm_scalef_round_ss(A, B, C)            \
-    (__m128)__builtin_ia32_scalefss_mask_round (A, B, \
-	(__v4sf)_mm_setzero_ps (), -1, C)
+#define _mm_maskz_scalef_round_ss(U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_setzero_ps (),	\
+				       (U), (C)))
 #endif
 
 #define _mm_mask_scalef_sd(W, U, A, B) \
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 48300af9a09..1623bbcbd2d 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -3249,7 +3249,7 @@ ix86_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)
       if (POINTER_TYPE_P (arg.type))
 	{
 	  /* This is the pointer argument.  */
-	  gcc_assert (TYPE_MODE (arg.type) == Pmode);
+	  gcc_assert (TYPE_MODE (arg.type) == ptr_mode);
 	  /* It is at -WORD(AP) in the current frame in interrupt and
 	     exception handlers.  */
 	  reg = plus_constant (Pmode, arg_pointer_rtx, -UNITS_PER_WORD);
@@ -3607,7 +3607,7 @@ zero_call_used_regno_mode (const unsigned int regno)
   else if (MASK_REGNO_P (regno))
     return HImode;
   else if (MMX_REGNO_P (regno))
-    return V4HImode;
+    return V2SImode;
   else
     gcc_unreachable ();
 }
@@ -3726,19 +3726,12 @@ zero_all_mm_registers (HARD_REG_SET need_zeroed_hardregs,
   if (!need_zero_all_mm)
     return false;
 
-  rtx zero_mmx = NULL_RTX;
-  machine_mode mode = V4HImode;
+  machine_mode mode = V2SImode;
   for (unsigned int regno = FIRST_MMX_REG; regno <= LAST_MMX_REG; regno++)
     if (regno != ret_mmx_regno)
       {
 	rtx reg = gen_rtx_REG (mode, regno);
-	if (zero_mmx == NULL_RTX)
-	  {
-	    zero_mmx = reg;
-	    emit_insn (gen_rtx_SET (reg, CONST0_RTX (mode)));
-	  }
-	else
-	  emit_move_insn (reg, zero_mmx);
+	emit_insn (gen_rtx_SET (reg, CONST0_RTX (mode)));
       }
   return true;
 }
@@ -3800,11 +3793,6 @@ ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)
 
   /* Now, generate instructions to zero all the other registers.  */
 
-  rtx zero_gpr = NULL_RTX;
-  rtx zero_vector = NULL_RTX;
-  rtx zero_mask = NULL_RTX;
-  rtx zero_mmx = NULL_RTX;
-
   for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
     {
       if (!TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))
@@ -3815,59 +3803,34 @@ ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)
 
       SET_HARD_REG_BIT (zeroed_hardregs, regno);
 
-      rtx reg, tmp, zero_rtx;
       machine_mode mode = zero_call_used_regno_mode (regno);
 
-      reg = gen_rtx_REG (mode, regno);
-      zero_rtx = CONST0_RTX (mode);
+      rtx reg = gen_rtx_REG (mode, regno);
+      rtx tmp = gen_rtx_SET (reg, CONST0_RTX (mode));
 
-      if (mode == SImode)
-	if (zero_gpr == NULL_RTX)
-	  {
-	    zero_gpr = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    if (!TARGET_USE_MOV0 || optimize_insn_for_size_p ())
-	      {
-		rtx clob = gen_rtx_CLOBBER (VOIDmode,
-					    gen_rtx_REG (CCmode,
-							 FLAGS_REG));
-		tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
-							     tmp,
-							     clob));
-	      }
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_gpr);
-      else if (mode == V4SFmode)
-	if (zero_vector == NULL_RTX)
-	  {
-	    zero_vector = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_vector);
-      else if (mode == HImode)
-	if (zero_mask == NULL_RTX)
-	  {
-	    zero_mask = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_mask);
-      else if (mode == V4HImode)
-	if (zero_mmx == NULL_RTX)
-	  {
-	    zero_mmx = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_mmx);
-      else
-	gcc_unreachable ();
+      switch (mode)
+	{
+	case E_SImode:
+	  if (!TARGET_USE_MOV0 || optimize_insn_for_size_p ())
+	    {
+	      rtx clob = gen_rtx_CLOBBER (VOIDmode,
+					  gen_rtx_REG (CCmode,
+						       FLAGS_REG));
+	      tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
+							   tmp,
+							   clob));
+	    }
+	  /* FALLTHRU.  */
+
+	case E_V4SFmode:
+	case E_HImode:
+	case E_V2SImode:
+	  emit_insn (tmp);
+	  break;
+
+	default:
+	  gcc_unreachable ();
+	}
     }
   return zeroed_hardregs;
 }
@@ -4754,6 +4717,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
 	{
 	  int i, prev_size = 0;
 	  tree temp = create_tmp_var (type, "va_arg_tmp");
+	  TREE_ADDRESSABLE (temp) = 1;
 
 	  /* addr = &temp; */
 	  t = build1 (ADDR_EXPR, build_pointer_type (type), temp);
diff --git a/gcc/config/i386/predicates.md b/gcc/config/i386/predicates.md
index b815aca0da7..58aebd416f4 100644
--- a/gcc/config/i386/predicates.md
+++ b/gcc/config/i386/predicates.md
@@ -1851,11 +1851,11 @@
   for(i = 4; i < 7; i++)
     {
       elt = XVECEXP (op, 0, i);
-      if (GET_CODE (elt) != SET
-	  || GET_CODE (SET_DEST (elt)) != REG
-	  || GET_MODE (SET_DEST (elt)) != V2DImode
-	  || REGNO (SET_DEST (elt)) != GET_SSE_REGNO (i)
-	  || SET_SRC (elt) != CONST0_RTX (V2DImode))
+      if (GET_CODE (elt) != CLOBBER
+	  || GET_MODE (elt) != VOIDmode
+	  || GET_CODE (XEXP (elt, 0)) != REG
+	  || GET_MODE (XEXP (elt, 0)) != V2DImode
+	  || REGNO (XEXP (elt, 0)) != GET_SSE_REGNO (i))
 	return false;
     }
 
@@ -1901,11 +1901,11 @@
   for(i = 4; i < 7; i++)
     {
       elt = XVECEXP (op, 0, i + 1);
-      if (GET_CODE (elt) != SET
-	  || GET_CODE (SET_DEST (elt)) != REG
-	  || GET_MODE (SET_DEST (elt)) != V2DImode
-	  || REGNO (SET_DEST (elt)) != GET_SSE_REGNO (i)
-	  || SET_SRC (elt) != CONST0_RTX (V2DImode))
+      if (GET_CODE (elt) != CLOBBER
+	  || GET_MODE (elt) != VOIDmode
+	  || GET_CODE (XEXP (elt, 0)) != REG
+	  || GET_MODE (XEXP (elt, 0)) != V2DImode
+	  || REGNO (XEXP (elt, 0)) != GET_SSE_REGNO (i))
 	return false;
     }
 
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index fcfcba0134d..2334d0e7c63 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -17256,9 +17256,9 @@
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn_and_split "ssse3_palignrdi"
-  [(set (match_operand:DI 0 "register_operand" "=y,x,Yv")
-	(unspec:DI [(match_operand:DI 1 "register_operand" "0,0,Yv")
-		    (match_operand:DI 2 "register_mmxmem_operand" "ym,x,Yv")
+  [(set (match_operand:DI 0 "register_operand" "=y,x,Yw")
+	(unspec:DI [(match_operand:DI 1 "register_operand" "0,0,Yw")
+		    (match_operand:DI 2 "register_mmxmem_operand" "ym,x,Yw")
 		    (match_operand:SI 3 "const_0_to_255_mul_8_operand" "n,n,n")]
 		   UNSPEC_PALIGNR))]
   "(TARGET_MMX || TARGET_MMX_WITH_SSE) && TARGET_SSSE3"
@@ -24127,7 +24127,7 @@
 
   for (i = 4; i < 7; i++)
     XVECEXP (operands[2], 0, i)
-      = gen_rtx_SET (xmm_regs[i], CONST0_RTX (V2DImode));
+      = gen_rtx_CLOBBER (VOIDmode, xmm_regs[i]);
 
   XVECEXP (operands[2], 0, 7)
     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));
@@ -24184,7 +24184,7 @@
 
   for (i = 4; i < 7; i++)
     XVECEXP (operands[2], 0, i + 1)
-      = gen_rtx_SET (xmm_regs[i], CONST0_RTX (V2DImode));
+      = gen_rtx_CLOBBER (VOIDmode, xmm_regs[i]);
 
   XVECEXP (operands[2], 0, 8)
     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));
diff --git a/gcc/config/i386/t-i386 b/gcc/config/i386/t-i386
index 66d5a8cd79b..04b54252222 100644
--- a/gcc/config/i386/t-i386
+++ b/gcc/config/i386/t-i386
@@ -61,7 +61,12 @@ i386-features.o: $(srcdir)/config/i386/i386-features.c
 	$(COMPILE) $<
 	$(POSTCOMPILE)
 
+# i386-builtin-types.inc is included into i386-builtins.h.
+# Below are direct users of i386-builtins.h:
 i386.o: i386-builtin-types.inc
+i386-builtins.o: i386-builtin-types.inc
+i386-expand.o: i386-builtin-types.inc
+i386-features.o: i386-builtin-types.inc
 
 i386-builtin-types.inc: s-i386-bt ; @true
 s-i386-bt: $(srcdir)/config/i386/i386-builtin-types.awk \
diff --git a/gcc/config/nvptx/nvptx.c b/gcc/config/nvptx/nvptx.c
index 7a7a9130e84..d25ddf45408 100644
--- a/gcc/config/nvptx/nvptx.c
+++ b/gcc/config/nvptx/nvptx.c
@@ -4503,6 +4503,7 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
   rtx_insn *neuter_start = NULL;
   rtx_insn *worker_label = NULL, *vector_label = NULL;
   rtx_insn *worker_jump = NULL, *vector_jump = NULL;
+  rtx_insn *warp_sync = NULL;
   for (mode = GOMP_DIM_WORKER; mode <= GOMP_DIM_VECTOR; mode++)
     if (GOMP_DIM_MASK (mode) & skip_mask)
       {
@@ -4535,11 +4536,29 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
 	if (tail_branch)
 	  {
 	    label_insn = emit_label_before (label, before);
+	    if (mode == GOMP_DIM_VECTOR)
+	      {
+		if (TARGET_PTX_6_0)
+		  warp_sync = emit_insn_after (gen_nvptx_warpsync (),
+					       label_insn);
+		else
+		  warp_sync = emit_insn_after (gen_nvptx_uniform_warp_check (),
+					       label_insn);
+	      }
 	    before = label_insn;
 	  }
 	else
 	  {
 	    label_insn = emit_label_after (label, tail);
+	    if (mode == GOMP_DIM_VECTOR)
+	      {
+		if (TARGET_PTX_6_0)
+		  warp_sync = emit_insn_after (gen_nvptx_warpsync (),
+					       label_insn);
+		else
+		  warp_sync = emit_insn_after (gen_nvptx_uniform_warp_check (),
+					       label_insn);
+	      }
 	    if ((mode == GOMP_DIM_VECTOR || mode == GOMP_DIM_WORKER)
 		&& CALL_P (tail) && find_reg_note (tail, REG_NORETURN, NULL))
 	      emit_insn_after (gen_exit (), label_insn);
@@ -4607,6 +4626,8 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
 		 setp.ne.u32 %rcond,%rcondu32,0;
 	  */
 	  rtx_insn *label = PREV_INSN (tail);
+	  if (label == warp_sync)
+	    label = PREV_INSN (label);
 	  gcc_assert (label && LABEL_P (label));
 	  rtx tmp = gen_reg_rtx (BImode);
 	  emit_insn_before (gen_movbi (tmp, const0_rtx),
diff --git a/gcc/config/nvptx/nvptx.h b/gcc/config/nvptx/nvptx.h
index 2451703e77f..3273ad86673 100644
--- a/gcc/config/nvptx/nvptx.h
+++ b/gcc/config/nvptx/nvptx.h
@@ -98,6 +98,9 @@
 
 #define TARGET_SM35 (ptx_isa_option >= PTX_ISA_SM35)
 
+/* 'TARGET_PTX_*' not applicable before GCC 12.  */
+#define TARGET_PTX_6_0 false
+
 /* Registers.  Since ptx is a virtual target, we just define a few
    hard registers for special purposes and leave pseudos unallocated.
    We have to have some available hard registers, to keep gcc setup
diff --git a/gcc/config/nvptx/nvptx.md b/gcc/config/nvptx/nvptx.md
index 0f15609ee4b..f1b32e285d7 100644
--- a/gcc/config/nvptx/nvptx.md
+++ b/gcc/config/nvptx/nvptx.md
@@ -55,6 +55,8 @@
    UNSPECV_CAS
    UNSPECV_XCHG
    UNSPECV_BARSYNC
+   UNSPECV_WARPSYNC
+   UNSPECV_UNIFORM_WARP_CHECK
    UNSPECV_MEMBAR
    UNSPECV_MEMBAR_CTA
    UNSPECV_DIM_POS
@@ -1718,6 +1720,29 @@
   }
   [(set_attr "predicable" "false")])
 
+(define_insn "nvptx_warpsync"
+  [(unspec_volatile [(const_int 0)] UNSPECV_WARPSYNC)]
+  "TARGET_PTX_6_0"
+  "\\tbar.warp.sync\\t0xffffffff;"
+  [(set_attr "predicable" "false")])
+
+(define_insn "nvptx_uniform_warp_check"
+  [(unspec_volatile [(const_int 0)] UNSPECV_UNIFORM_WARP_CHECK)]
+  ""
+  {
+    output_asm_insn ("{", NULL);
+    output_asm_insn ("\\t"	 ".reg.b32"	   "\\t" "act;", NULL);
+    output_asm_insn ("\\t"	 "vote.ballot.b32" "\\t" "act,1;", NULL);
+    output_asm_insn ("\\t"	 ".reg.pred"	   "\\t" "uni;", NULL);
+    output_asm_insn ("\\t"	 "setp.eq.b32"	   "\\t" "uni,act,0xffffffff;",
+		     NULL);
+    output_asm_insn ("@ !uni\\t" "trap;", NULL);
+    output_asm_insn ("@ !uni\\t" "exit;", NULL);
+    output_asm_insn ("}", NULL);
+    return "";
+  }
+  [(set_attr "predicable" "false")])
+
 (define_expand "memory_barrier"
   [(set (match_dup 0)
 	(unspec_volatile:BLK [(match_dup 0)] UNSPECV_MEMBAR))]
diff --git a/gcc/config/riscv/arch-canonicalize b/gcc/config/riscv/arch-canonicalize
index 3a91cfe687f..0bdf6aafe35 100755
--- a/gcc/config/riscv/arch-canonicalize
+++ b/gcc/config/riscv/arch-canonicalize
@@ -45,9 +45,11 @@ def arch_canonicalize(arch, isa_spec):
   is_isa_spec_2p2 = isa_spec == '2.2'
   new_arch = ""
   extra_long_ext = []
+  std_exts = []
   if arch[:5] in ['rv32e', 'rv32i', 'rv32g', 'rv64i', 'rv64g']:
-    new_arch = arch[:5].replace("g", "imafd")
+    new_arch = arch[:5].replace("g", "i")
     if arch[:5] in ['rv32g', 'rv64g']:
+      std_exts = ['m', 'a', 'f', 'd']
       if not is_isa_spec_2p2:
         extra_long_ext = ['zicsr', 'zifencei']
   else:
@@ -61,10 +63,10 @@ def arch_canonicalize(arch, isa_spec):
   if long_ext_prefixes_idx:
     first_long_ext_idx = min(long_ext_prefixes_idx)
     long_exts = arch[first_long_ext_idx:].split("_")
-    std_exts = list(arch[5:first_long_ext_idx])
+    std_exts += list(arch[5:first_long_ext_idx])
   else:
     long_exts = []
-    std_exts = list(arch[5:])
+    std_exts += list(arch[5:])
 
   long_exts += extra_long_ext
 
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index c3687d57047..3af34de063c 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -2558,7 +2558,7 @@
 	 UNSPEC_SSP_SET))
    (set (match_scratch:GPR 2 "=&r") (const_int 0))]
   ""
-  "<load>\\t%2, %1\;<store>\\t%2, %0\;li\t%2, 0"
+  "<load>\t%2, %1\;<store>\t%2, %0\;li\t%2, 0"
   [(set_attr "length" "12")])
 
 (define_expand "stack_protect_test"
diff --git a/gcc/config/rs6000/bmi2intrin.h b/gcc/config/rs6000/bmi2intrin.h
index 5b7b761b9d5..03299e6cccd 100644
--- a/gcc/config/rs6000/bmi2intrin.h
+++ b/gcc/config/rs6000/bmi2intrin.h
@@ -77,39 +77,39 @@ extern __inline unsigned long long
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _pdep_u64 (unsigned long long __X, unsigned long long __M)
 {
-  unsigned long result = 0x0UL;
-  const unsigned long mask = 0x8000000000000000UL;
-  unsigned long m = __M;
-  unsigned long c, t;
-  unsigned long p;
+  unsigned long __result = 0x0UL;
+  const unsigned long __mask = 0x8000000000000000UL;
+  unsigned long __m = __M;
+  unsigned long __c, __t;
+  unsigned long __p;
 
   /* The pop-count of the mask gives the number of the bits from
    source to process.  This is also needed to shift bits from the
    source into the correct position for the result.  */
-  p = 64 - __builtin_popcountl (__M);
+  __p = 64 - __builtin_popcountl (__M);
 
   /* The loop is for the number of '1' bits in the mask and clearing
    each mask bit as it is processed.  */
-  while (m != 0)
+  while (__m != 0)
     {
-      c = __builtin_clzl (m);
-      t = __X << (p - c);
-      m ^= (mask >> c);
-      result |= (t & (mask >> c));
-      p++;
+      __c = __builtin_clzl (__m);
+      __t = __X << (__p - __c);
+      __m ^= (__mask >> __c);
+      __result |= (__t & (__mask >> __c));
+      __p++;
     }
-  return (result);
+  return __result;
 }
 
 extern __inline unsigned long long
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _pext_u64 (unsigned long long __X, unsigned long long __M)
 {
-  unsigned long p = 0x4040404040404040UL; // initial bit permute control
-  const unsigned long mask = 0x8000000000000000UL;
-  unsigned long m = __M;
-  unsigned long c;
-  unsigned long result;
+  unsigned long __p = 0x4040404040404040UL; // initial bit permute control
+  const unsigned long __mask = 0x8000000000000000UL;
+  unsigned long __m = __M;
+  unsigned long __c;
+  unsigned long __result;
 
   /* if the mask is constant and selects 8 bits or less we can use
    the Power8 Bit permute instruction.  */
@@ -118,34 +118,34 @@ _pext_u64 (unsigned long long __X, unsigned long long __M)
       /* Also if the pext mask is constant, then the popcount is
        constant, we can evaluate the following loop at compile
        time and use a constant bit permute vector.  */
-      for (long i = 0; i < __builtin_popcountl (__M); i++)
+      for (long __i = 0; __i < __builtin_popcountl (__M); __i++)
 	{
-	  c = __builtin_clzl (m);
-	  p = (p << 8) | c;
-	  m ^= (mask >> c);
+	  __c = __builtin_clzl (__m);
+	  __p = (__p << 8) | __c;
+	  __m ^= (__mask >> __c);
 	}
-      result = __builtin_bpermd (p, __X);
+      __result = __builtin_bpermd (__p, __X);
     }
   else
     {
-      p = 64 - __builtin_popcountl (__M);
-      result = 0;
+      __p = 64 - __builtin_popcountl (__M);
+      __result = 0;
       /* We could a use a for loop here, but that combined with
        -funroll-loops can expand to a lot of code.  The while
        loop avoids unrolling and the compiler commons the xor
-       from clearing the mask bit with the (m != 0) test.  The
+       from clearing the mask bit with the (__m != 0) test.  The
        result is a more compact loop setup and body.  */
-      while (m != 0)
+      while (__m != 0)
 	{
-	  unsigned long t;
-	  c = __builtin_clzl (m);
-	  t = (__X & (mask >> c)) >> (p - c);
-	  m ^= (mask >> c);
-	  result |= (t);
-	  p++;
+	  unsigned long __t;
+	  __c = __builtin_clzl (__m);
+	  __t = (__X & (__mask >> __c)) >> (__p - __c);
+	  __m ^= (__mask >> __c);
+	  __result |= (__t);
+	  __p++;
 	}
     }
-  return (result);
+  return __result;
 }
 
 /* these 32-bit implementations depend on 64-bit pdep/pext
diff --git a/gcc/config/rs6000/emmintrin.h b/gcc/config/rs6000/emmintrin.h
index ce1287edf78..991368095dd 100644
--- a/gcc/config/rs6000/emmintrin.h
+++ b/gcc/config/rs6000/emmintrin.h
@@ -141,9 +141,9 @@ _mm_setzero_pd (void)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_move_sd (__m128d __A, __m128d __B)
 {
-  __v2df result = (__v2df) __A;
-  result [0] = ((__v2df) __B)[0];
-  return (__m128d) result;
+  __v2df __result = (__v2df) __A;
+  __result [0] = ((__v2df) __B)[0];
+  return (__m128d) __result;
 }
 
 /* Load two DPFP values from P.  The address must be 16-byte aligned.  */
@@ -329,9 +329,9 @@ _mm_sqrt_pd (__m128d __A)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sqrt_sd (__m128d __A, __m128d __B)
 {
-  __v2df c;
-  c = vec_sqrt ((__v2df) _mm_set1_pd (__B[0]));
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __c;
+  __c = vec_sqrt ((__v2df) _mm_set1_pd (__B[0]));
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -343,11 +343,11 @@ _mm_min_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_sd (__m128d __A, __m128d __B)
 {
-  __v2df a, b, c;
-  a = vec_splats (__A[0]);
-  b = vec_splats (__B[0]);
-  c = vec_min (a, b);
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __a, __b, __c;
+  __a = vec_splats (__A[0]);
+  __b = vec_splats (__B[0]);
+  __c = vec_min (__a, __b);
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -359,11 +359,11 @@ _mm_max_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_sd (__m128d __A, __m128d __B)
 {
-  __v2df a, b, c;
-  a = vec_splats (__A[0]);
-  b = vec_splats (__B[0]);
-  c = vec_max (a, b);
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __a, __b, __c;
+  __a = vec_splats (__A[0]);
+  __b = vec_splats (__B[0]);
+  __c = vec_max (__a, __b);
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -399,8 +399,8 @@ _mm_cmpge_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_pd (__m128d __A, __m128d __B)
 {
-  __v2df temp = (__v2df) vec_cmpeq ((__v2df) __A, (__v2df)__B);
-  return ((__m128d)vec_nor (temp, temp));
+  __v2df __temp = (__v2df) vec_cmpeq ((__v2df) __A, (__v2df)__B);
+  return ((__m128d)vec_nor (__temp, __temp));
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -427,26 +427,18 @@ _mm_cmpnge_pd (__m128d __A, __m128d __B)
   return ((__m128d)vec_cmplt ((__v2df) __A, (__v2df) __B));
 }
 
+#if _ARCH_PWR8
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_pd (__m128d __A, __m128d __B)
 {
-#if _ARCH_PWR8
   __v2du c, d;
   /* Compare against self will return false (0's) if NAN.  */
   c = (__v2du)vec_cmpeq (__A, __A);
   d = (__v2du)vec_cmpeq (__B, __B);
-#else
-  __v2du a, b;
-  __v2du c, d;
-  const __v2du double_exp_mask  = {0x7ff0000000000000, 0x7ff0000000000000};
-  a = (__v2du)vec_abs ((__v2df)__A);
-  b = (__v2du)vec_abs ((__v2df)__B);
-  c = (__v2du)vec_cmpgt (double_exp_mask, a);
-  d = (__v2du)vec_cmpgt (double_exp_mask, b);
-#endif
   /* A != NAN and B != NAN.  */
   return ((__m128d)vec_and(c, d));
 }
+#endif
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_pd (__m128d __A, __m128d __B)
@@ -583,6 +575,7 @@ _mm_cmpnge_sd (__m128d __A, __m128d __B)
   return (__m128d) _mm_setr_pd (c[0], __A[1]);
 }
 
+#if _ARCH_PWR8
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_sd (__m128d __A, __m128d __B)
 {
@@ -590,6 +583,7 @@ _mm_cmpord_sd (__m128d __A, __m128d __B)
   r = (__v2df)_mm_cmpord_pd (vec_splats (__A[0]), vec_splats (__B[0]));
   return (__m128d) _mm_setr_pd (r[0], ((__v2df)__A)[1]);
 }
+#endif
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_sd (__m128d __A, __m128d __B)
@@ -855,12 +849,12 @@ _mm_setzero_si128 (void)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtepi32_pd (__m128i __A)
 {
-  __v2di val;
+  __v2di __val;
   /* For LE need to generate Vector Unpack Low Signed Word.
      Which is generated from unpackh.  */
-  val = (__v2di)vec_unpackh ((__v4si)__A);
+  __val = (__v2di)vec_unpackh ((__v4si)__A);
 
-  return (__m128d)vec_ctf (val, 0);
+  return (__m128d)vec_ctf (__val, 0);
 }
 #endif
 
@@ -873,116 +867,116 @@ _mm_cvtepi32_ps (__m128i __A)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_epi32 (__m128d __A)
 {
-  __v2df rounded = vec_rint (__A);
-  __v4si result, temp;
-  const __v4si vzero =
+  __v2df __rounded = vec_rint (__A);
+  __v4si __result, __temp;
+  const __v4si __vzero =
     { 0, 0, 0, 0 };
 
   /* VSX Vector truncate Double-Precision to integer and Convert to
    Signed Integer Word format with Saturate.  */
   __asm__(
       "xvcvdpsxws %x0,%x1"
-      : "=wa" (temp)
-      : "wa" (rounded)
+      : "=wa" (__temp)
+      : "wa" (__rounded)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4si) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4si) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4si) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4si) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_pi32 (__m128d __A)
 {
-  __m128i result = _mm_cvtpd_epi32(__A);
+  __m128i __result = _mm_cvtpd_epi32(__A);
 
-  return (__m64) result[0];
+  return (__m64) __result[0];
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_ps (__m128d __A)
 {
-  __v4sf result;
-  __v4si temp;
-  const __v4si vzero = { 0, 0, 0, 0 };
+  __v4sf __result;
+  __v4si __temp;
+  const __v4si __vzero = { 0, 0, 0, 0 };
 
   __asm__(
       "xvcvdpsp %x0,%x1"
-      : "=wa" (temp)
+      : "=wa" (__temp)
       : "wa" (__A)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4sf) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4sf) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4sf) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4sf) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
-  return ((__m128)result);
+  return ((__m128)__result);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttpd_epi32 (__m128d __A)
 {
-  __v4si result;
-  __v4si temp;
-  const __v4si vzero = { 0, 0, 0, 0 };
+  __v4si __result;
+  __v4si __temp;
+  const __v4si __vzero = { 0, 0, 0, 0 };
 
   /* VSX Vector truncate Double-Precision to integer and Convert to
    Signed Integer Word format with Saturate.  */
   __asm__(
       "xvcvdpsxws %x0,%x1"
-      : "=wa" (temp)
+      : "=wa" (__temp)
       : "wa" (__A)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4si) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4si) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4si) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4si) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
 
-  return ((__m128i) result);
+  return ((__m128i) __result);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttpd_pi32 (__m128d __A)
 {
-  __m128i result = _mm_cvttpd_epi32 (__A);
+  __m128i __result = _mm_cvttpd_epi32 (__A);
 
-  return (__m64) result[0];
+  return (__m64) __result[0];
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -995,35 +989,35 @@ _mm_cvtsi128_si32 (__m128i __A)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32_pd (__m64 __A)
 {
-  __v4si temp;
-  __v2di tmp2;
-  __v2df result;
+  __v4si __temp;
+  __v2di __tmp2;
+  __v2df __result;
 
-  temp = (__v4si)vec_splats (__A);
-  tmp2 = (__v2di)vec_unpackl (temp);
-  result = vec_ctf ((__vector signed long long) tmp2, 0);
-  return (__m128d)result;
+  __temp = (__v4si)vec_splats (__A);
+  __tmp2 = (__v2di)vec_unpackl (__temp);
+  __result = vec_ctf ((__vector signed long long) __tmp2, 0);
+  return (__m128d)__result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_epi32 (__m128 __A)
 {
-  __v4sf rounded;
-  __v4si result;
+  __v4sf __rounded;
+  __v4si __result;
 
-  rounded = vec_rint((__v4sf) __A);
-  result = vec_cts (rounded, 0);
-  return (__m128i) result;
+  __rounded = vec_rint((__v4sf) __A);
+  __result = vec_cts (__rounded, 0);
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttps_epi32 (__m128 __A)
 {
-  __v4si result;
+  __v4si __result;
 
-  result = vec_cts ((__v4sf) __A, 0);
-  return (__m128i) result;
+  __result = vec_cts ((__v4sf) __A, 0);
+  return (__m128i) __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1035,48 +1029,48 @@ _mm_cvtps_pd (__m128 __A)
 #else
   /* Otherwise the compiler is not current and so need to generate the
      equivalent code.  */
-  __v4sf a = (__v4sf)__A;
-  __v4sf temp;
-  __v2df result;
+  __v4sf __a = (__v4sf)__A;
+  __v4sf __temp;
+  __v2df __result;
 #ifdef __LITTLE_ENDIAN__
   /* The input float values are in elements {[0], [1]} but the convert
      instruction needs them in elements {[1], [3]}, So we use two
      shift left double vector word immediates to get the elements
      lined up.  */
-  temp = __builtin_vsx_xxsldwi (a, a, 3);
-  temp = __builtin_vsx_xxsldwi (a, temp, 2);
+  __temp = __builtin_vsx_xxsldwi (__a, __a, 3);
+  __temp = __builtin_vsx_xxsldwi (__a, __temp, 2);
 #else
   /* The input float values are in elements {[0], [1]} but the convert
      instruction needs them in elements {[0], [2]}, So we use two
      shift left double vector word immediates to get the elements
      lined up.  */
-  temp = vec_vmrghw (a, a);
+  __temp = vec_vmrghw (__a, __a);
 #endif
   __asm__(
       " xvcvspdp %x0,%x1"
-      : "=wa" (result)
-      : "wa" (temp)
+      : "=wa" (__result)
+      : "wa" (__temp)
       : );
-  return (__m128d) result;
+  return (__m128d) __result;
 #endif
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_si32 (__m128d __A)
 {
-  __v2df rounded = vec_rint((__v2df) __A);
-  int result = ((__v2df)rounded)[0];
+  __v2df __rounded = vec_rint((__v2df) __A);
+  int __result = ((__v2df)__rounded)[0];
 
-  return result;
+  return __result;
 }
 /* Intel intrinsic.  */
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_si64 (__m128d __A)
 {
-  __v2df rounded = vec_rint ((__v2df) __A );
-  long long result = ((__v2df) rounded)[0];
+  __v2df __rounded = vec_rint ((__v2df) __A );
+  long long __result = ((__v2df) __rounded)[0];
 
-  return result;
+  return __result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1089,18 +1083,18 @@ _mm_cvtsd_si64x (__m128d __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttsd_si32 (__m128d __A)
 {
-  int result = ((__v2df)__A)[0];
+  int __result = ((__v2df)__A)[0];
 
-  return result;
+  return __result;
 }
 
 /* Intel intrinsic.  */
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttsd_si64 (__m128d __A)
 {
-  long long result = ((__v2df)__A)[0];
+  long long __result = ((__v2df)__A)[0];
 
-  return result;
+  return __result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1113,46 +1107,46 @@ _mm_cvttsd_si64x (__m128d __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_ss (__m128 __A, __m128d __B)
 {
-  __v4sf result = (__v4sf)__A;
+  __v4sf __result = (__v4sf)__A;
 
 #ifdef __LITTLE_ENDIAN__
-  __v4sf temp_s;
+  __v4sf __temp_s;
   /* Copy double element[0] to element [1] for conversion.  */
-  __v2df temp_b = vec_splat((__v2df)__B, 0);
+  __v2df __temp_b = vec_splat((__v2df)__B, 0);
 
   /* Pre-rotate __A left 3 (logically right 1) elements.  */
-  result = __builtin_vsx_xxsldwi (result, result, 3);
+  __result = __builtin_vsx_xxsldwi (__result, __result, 3);
   /* Convert double to single float scalar in a vector.  */
   __asm__(
       "xscvdpsp %x0,%x1"
-      : "=wa" (temp_s)
-      : "wa" (temp_b)
+      : "=wa" (__temp_s)
+      : "wa" (__temp_b)
       : );
   /* Shift the resulting scalar into vector element [0].  */
-  result = __builtin_vsx_xxsldwi (result, temp_s, 1);
+  __result = __builtin_vsx_xxsldwi (__result, __temp_s, 1);
 #else
-  result [0] = ((__v2df)__B)[0];
+  __result [0] = ((__v2df)__B)[0];
 #endif
-  return (__m128) result;
+  return (__m128) __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi32_sd (__m128d __A, int __B)
 {
-  __v2df result = (__v2df)__A;
-  double db = __B;
-  result [0] = db;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  double __db = __B;
+  __result [0] = __db;
+  return (__m128d)__result;
 }
 
 /* Intel intrinsic.  */
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi64_sd (__m128d __A, long long __B)
 {
-  __v2df result = (__v2df)__A;
-  double db = __B;
-  result [0] = db;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  double __db = __B;
+  __result [0] = __db;
+  return (__m128d)__result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1167,45 +1161,45 @@ _mm_cvtss_sd (__m128d __A, __m128 __B)
 {
 #ifdef __LITTLE_ENDIAN__
   /* Use splat to move element [0] into position for the convert. */
-  __v4sf temp = vec_splat ((__v4sf)__B, 0);
-  __v2df res;
+  __v4sf __temp = vec_splat ((__v4sf)__B, 0);
+  __v2df __res;
   /* Convert single float scalar to double in a vector.  */
   __asm__(
       "xscvspdp %x0,%x1"
-      : "=wa" (res)
-      : "wa" (temp)
+      : "=wa" (__res)
+      : "wa" (__temp)
       : );
-  return (__m128d) vec_mergel (res, (__v2df)__A);
+  return (__m128d) vec_mergel (__res, (__v2df)__A);
 #else
-  __v2df res = (__v2df)__A;
-  res [0] = ((__v4sf)__B) [0];
-  return (__m128d) res;
+  __v2df __res = (__v2df)__A;
+  __res [0] = ((__v4sf)__B) [0];
+  return (__m128d) __res;
 #endif
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_pd(__m128d __A, __m128d __B, const int __mask)
 {
-  __vector double result;
-  const int litmsk = __mask & 0x3;
+  __vector double __result;
+  const int __litmsk = __mask & 0x3;
 
-  if (litmsk == 0)
-    result = vec_mergeh (__A, __B);
+  if (__litmsk == 0)
+    __result = vec_mergeh (__A, __B);
 #if __GNUC__ < 6
-  else if (litmsk == 1)
-    result = vec_xxpermdi (__B, __A, 2);
-  else if (litmsk == 2)
-    result = vec_xxpermdi (__B, __A, 1);
+  else if (__litmsk == 1)
+    __result = vec_xxpermdi (__B, __A, 2);
+  else if (__litmsk == 2)
+    __result = vec_xxpermdi (__B, __A, 1);
 #else
-  else if (litmsk == 1)
-    result = vec_xxpermdi (__A, __B, 2);
-  else if (litmsk == 2)
-    result = vec_xxpermdi (__A, __B, 1);
+  else if (__litmsk == 1)
+    __result = vec_xxpermdi (__A, __B, 2);
+  else if (__litmsk == 2)
+    __result = vec_xxpermdi (__A, __B, 1);
 #endif
   else
-    result = vec_mergel (__A, __B);
+    __result = vec_mergel (__A, __B);
 
-  return result;
+  return __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1223,17 +1217,17 @@ _mm_unpacklo_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_loadh_pd (__m128d __A, double const *__B)
 {
-  __v2df result = (__v2df)__A;
-  result [1] = *__B;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  __result [1] = *__B;
+  return (__m128d)__result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_loadl_pd (__m128d __A, double const *__B)
 {
-  __v2df result = (__v2df)__A;
-  result [0] = *__B;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  __result [0] = *__B;
+  return (__m128d)__result;
 }
 
 #ifdef _ARCH_PWR8
@@ -1243,8 +1237,8 @@ _mm_loadl_pd (__m128d __A, double const *__B)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_pd (__m128d  __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned int perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned int __perm_mask =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x80800040, 0x80808080, 0x80808080, 0x80808080
@@ -1253,14 +1247,14 @@ _mm_movemask_pd (__m128d  __A)
 #endif
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -1432,17 +1426,17 @@ _mm_subs_epu16 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_madd_epi16 (__m128i __A, __m128i __B)
 {
-  __vector signed int zero = {0, 0, 0, 0};
+  __vector signed int __zero = {0, 0, 0, 0};
 
-  return (__m128i) vec_vmsumshm ((__v8hi)__A, (__v8hi)__B, zero);
+  return (__m128i) vec_vmsumshm ((__v8hi)__A, (__v8hi)__B, __zero);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_epi16 (__m128i __A, __m128i __B)
 {
-  __vector signed int w0, w1;
+  __vector signed int __w0, __w1;
 
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1452,9 +1446,9 @@ _mm_mulhi_epi16 (__m128i __A, __m128i __B)
 #endif
     };
 
-  w0 = vec_vmulesh ((__v8hi)__A, (__v8hi)__B);
-  w1 = vec_vmulosh ((__v8hi)__A, (__v8hi)__B);
-  return (__m128i) vec_perm (w0, w1, xform1);
+  __w0 = vec_vmulesh ((__v8hi)__A, (__v8hi)__B);
+  __w1 = vec_vmulosh ((__v8hi)__A, (__v8hi)__B);
+  return (__m128i) vec_perm (__w0, __w1, __xform1);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1466,34 +1460,34 @@ _mm_mullo_epi16 (__m128i __A, __m128i __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mul_su32 (__m64 __A, __m64 __B)
 {
-  unsigned int a = __A;
-  unsigned int b = __B;
+  unsigned int __a = __A;
+  unsigned int __b = __B;
 
-  return ((__m64)a * (__m64)b);
+  return ((__m64)__a * (__m64)__b);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mul_epu32 (__m128i __A, __m128i __B)
 {
-#if __GNUC__ < 8
-  __v2du result;
+#if __GNUC__ < 8 || !defined (_ARCH_PWR8)
+  __v2du __result;
 
 #ifdef __LITTLE_ENDIAN__
   /* VMX Vector Multiply Odd Unsigned Word.  */
   __asm__(
       "vmulouw %0,%1,%2"
-      : "=v" (result)
+      : "=v" (__result)
       : "v" (__A), "v" (__B)
       : );
 #else
   /* VMX Vector Multiply Even Unsigned Word.  */
   __asm__(
       "vmuleuw %0,%1,%2"
-      : "=v" (result)
+      : "=v" (__result)
       : "v" (__A), "v" (__B)
       : );
 #endif
-  return (__m128i) result;
+  return (__m128i) __result;
 #else
   return (__m128i) vec_mule ((__v4su)__A, (__v4su)__B);
 #endif
@@ -1502,122 +1496,122 @@ _mm_mul_epu32 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi16 (__m128i __A, int __B)
 {
-  __v8hu lshift;
-  __v8hi result = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v8hu __lshift;
+  __v8hi __result = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__B >= 0 && __B < 16)
     {
       if (__builtin_constant_p(__B))
-	lshift = (__v8hu) vec_splat_s16(__B);
+	__lshift = (__v8hu) vec_splat_s16(__B);
       else
-	lshift = vec_splats ((unsigned short) __B);
+	__lshift = vec_splats ((unsigned short) __B);
 
-      result = vec_sl ((__v8hi) __A, lshift);
+      __result = vec_sl ((__v8hi) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi32 (__m128i __A, int __B)
 {
-  __v4su lshift;
-  __v4si result = { 0, 0, 0, 0 };
+  __v4su __lshift;
+  __v4si __result = { 0, 0, 0, 0 };
 
   if (__B >= 0 && __B < 32)
     {
       if (__builtin_constant_p(__B) && __B < 16)
-	lshift = (__v4su) vec_splat_s32(__B);
+	__lshift = (__v4su) vec_splat_s32(__B);
       else
-	lshift = vec_splats ((unsigned int) __B);
+	__lshift = vec_splats ((unsigned int) __B);
 
-      result = vec_sl ((__v4si) __A, lshift);
+      __result = vec_sl ((__v4si) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi64 (__m128i __A, int __B)
 {
-  __v2du lshift;
-  __v2di result = { 0, 0 };
+  __v2du __lshift;
+  __v2di __result = { 0, 0 };
 
   if (__B >= 0 && __B < 64)
     {
       if (__builtin_constant_p(__B) && __B < 16)
-	lshift = (__v2du) vec_splat_s32(__B);
+	__lshift = (__v2du) vec_splat_s32(__B);
       else
-	lshift = (__v2du) vec_splats ((unsigned int) __B);
+	__lshift = (__v2du) vec_splats ((unsigned int) __B);
 
-      result = vec_sl ((__v2di) __A, lshift);
+      __result = vec_sl ((__v2di) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srai_epi16 (__m128i __A, int __B)
 {
-  __v8hu rshift = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hi result;
+  __v8hu __rshift = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hi __result;
 
   if (__B < 16)
     {
       if (__builtin_constant_p(__B))
-	rshift = (__v8hu) vec_splat_s16(__B);
+	__rshift = (__v8hu) vec_splat_s16(__B);
       else
-	rshift = vec_splats ((unsigned short) __B);
+	__rshift = vec_splats ((unsigned short) __B);
     }
-  result = vec_sra ((__v8hi) __A, rshift);
+  __result = vec_sra ((__v8hi) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srai_epi32 (__m128i __A, int __B)
 {
-  __v4su rshift = { 31, 31, 31, 31 };
-  __v4si result;
+  __v4su __rshift = { 31, 31, 31, 31 };
+  __v4si __result;
 
   if (__B < 32)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v4su) vec_splat_s32(__B);
+	      __rshift = (__v4su) vec_splat_s32(__B);
 	    else
-	      rshift = (__v4su) vec_splats((unsigned int)__B);
+	      __rshift = (__v4su) vec_splats((unsigned int)__B);
 	}
       else
-	rshift = vec_splats ((unsigned int) __B);
+	__rshift = vec_splats ((unsigned int) __B);
     }
-  result = vec_sra ((__v4si) __A, rshift);
+  __result = vec_sra ((__v4si) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_bslli_si128 (__m128i __A, const int __N)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__N < 16)
-    result = vec_sld ((__v16qu) __A, zeros, __N);
+    __result = vec_sld ((__v16qu) __A, __zeros, __N);
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_bsrli_si128 (__m128i __A, const int __N)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__N < 16)
 #ifdef __LITTLE_ENDIAN__
@@ -1625,21 +1619,21 @@ _mm_bsrli_si128 (__m128i __A, const int __N)
       /* Would like to use Vector Shift Left Double by Octet
 	 Immediate here to use the immediate form and avoid
 	 load of __N * 8 value into a separate VR.  */
-      result = vec_sld (zeros, (__v16qu) __A, (16 - __N));
+      __result = vec_sld (__zeros, (__v16qu) __A, (16 - __N));
     else
 #endif
       {
-	__v16qu shift = vec_splats((unsigned char)(__N*8));
+	__v16qu __shift = vec_splats((unsigned char)(__N*8));
 #ifdef __LITTLE_ENDIAN__
-	result = vec_sro ((__v16qu)__A, shift);
+	__result = vec_sro ((__v16qu)__A, __shift);
 #else
-	result = vec_slo ((__v16qu)__A, shift);
+	__result = vec_slo ((__v16qu)__A, __shift);
 #endif
       }
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1651,239 +1645,239 @@ _mm_srli_si128 (__m128i __A, const int __N)
 extern __inline  __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_si128 (__m128i __A, const int _imm5)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (_imm5 < 16)
 #ifdef __LITTLE_ENDIAN__
-    result = vec_sld ((__v16qu) __A, zeros, _imm5);
+    __result = vec_sld ((__v16qu) __A, __zeros, _imm5);
 #else
-    result = vec_sld (zeros, (__v16qu) __A, (16 - _imm5));
+    __result = vec_sld (__zeros, (__v16qu) __A, (16 - _imm5));
 #endif
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 
 _mm_srli_epi16 (__m128i  __A, int __B)
 {
-  __v8hu rshift;
-  __v8hi result = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v8hu __rshift;
+  __v8hi __result = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__B < 16)
     {
       if (__builtin_constant_p(__B))
-	rshift = (__v8hu) vec_splat_s16(__B);
+	__rshift = (__v8hu) vec_splat_s16(__B);
       else
-	rshift = vec_splats ((unsigned short) __B);
+	__rshift = vec_splats ((unsigned short) __B);
 
-      result = vec_sr ((__v8hi) __A, rshift);
+      __result = vec_sr ((__v8hi) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srli_epi32 (__m128i __A, int __B)
 {
-  __v4su rshift;
-  __v4si result = { 0, 0, 0, 0 };
+  __v4su __rshift;
+  __v4si __result = { 0, 0, 0, 0 };
 
   if (__B < 32)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v4su) vec_splat_s32(__B);
+	      __rshift = (__v4su) vec_splat_s32(__B);
 	    else
-	      rshift = (__v4su) vec_splats((unsigned int)__B);
+	      __rshift = (__v4su) vec_splats((unsigned int)__B);
 	}
       else
-	rshift = vec_splats ((unsigned int) __B);
+	__rshift = vec_splats ((unsigned int) __B);
 
-      result = vec_sr ((__v4si) __A, rshift);
+      __result = vec_sr ((__v4si) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srli_epi64 (__m128i __A, int __B)
 {
-  __v2du rshift;
-  __v2di result = { 0, 0 };
+  __v2du __rshift;
+  __v2di __result = { 0, 0 };
 
   if (__B < 64)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v2du) vec_splat_s32(__B);
+	      __rshift = (__v2du) vec_splat_s32(__B);
 	    else
-	      rshift = (__v2du) vec_splats((unsigned long long)__B);
+	      __rshift = (__v2du) vec_splats((unsigned long long)__B);
 	}
       else
-	rshift = (__v2du) vec_splats ((unsigned int) __B);
+	__rshift = (__v2du) vec_splats ((unsigned int) __B);
 
-      result = vec_sr ((__v2di) __A, rshift);
+      __result = vec_sr ((__v2di) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi16 (__m128i __A, __m128i __B)
 {
-  __v8hu lshift;
-  __vector __bool short shmask;
-  const __v8hu shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu result;
+  __v8hu __lshift;
+  __vector __bool short __shmask;
+  const __v8hu __shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __result;
 
 #ifdef __LITTLE_ENDIAN__
-  lshift = vec_splat ((__v8hu) __B, 0);
+  __lshift = vec_splat ((__v8hu) __B, 0);
 #else
-  lshift = vec_splat ((__v8hu) __B, 3);
+  __lshift = vec_splat ((__v8hu) __B, 3);
 #endif
-  shmask = vec_cmple (lshift, shmax);
-  result = vec_sl ((__v8hu) __A, lshift);
-  result = vec_sel ((__v8hu) shmask, result, shmask);
+  __shmask = vec_cmple (__lshift, __shmax);
+  __result = vec_sl ((__v8hu) __A, __lshift);
+  __result = vec_sel ((__v8hu) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi32 (__m128i __A, __m128i __B)
 {
-  __v4su lshift;
-  __vector __bool int shmask;
-  const __v4su shmax = { 32, 32, 32, 32 };
-  __v4su result;
+  __v4su __lshift;
+  __vector __bool int __shmask;
+  const __v4su __shmax = { 32, 32, 32, 32 };
+  __v4su __result;
 #ifdef __LITTLE_ENDIAN__
-  lshift = vec_splat ((__v4su) __B, 0);
+  __lshift = vec_splat ((__v4su) __B, 0);
 #else
-  lshift = vec_splat ((__v4su) __B, 1);
+  __lshift = vec_splat ((__v4su) __B, 1);
 #endif
-  shmask = vec_cmplt (lshift, shmax);
-  result = vec_sl ((__v4su) __A, lshift);
-  result = vec_sel ((__v4su) shmask, result, shmask);
+  __shmask = vec_cmplt (__lshift, __shmax);
+  __result = vec_sl ((__v4su) __A, __lshift);
+  __result = vec_sel ((__v4su) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi64 (__m128i __A, __m128i __B)
 {
-  __v2du lshift;
-  __vector __bool long long shmask;
-  const __v2du shmax = { 64, 64 };
-  __v2du result;
+  __v2du __lshift;
+  __vector __bool long long __shmask;
+  const __v2du __shmax = { 64, 64 };
+  __v2du __result;
 
-  lshift = vec_splat ((__v2du) __B, 0);
-  shmask = vec_cmplt (lshift, shmax);
-  result = vec_sl ((__v2du) __A, lshift);
-  result = vec_sel ((__v2du) shmask, result, shmask);
+  __lshift = vec_splat ((__v2du) __B, 0);
+  __shmask = vec_cmplt (__lshift, __shmax);
+  __result = vec_sl ((__v2du) __A, __lshift);
+  __result = vec_sel ((__v2du) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_epi16 (__m128i __A, __m128i __B)
 {
-  const __v8hu rshmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu rshift;
-  __v8hi result;
+  const __v8hu __rshmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __rshift;
+  __v8hi __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v8hu)__B, 0);
+  __rshift = vec_splat ((__v8hu)__B, 0);
 #else
-  rshift = vec_splat ((__v8hu)__B, 3);
+  __rshift = vec_splat ((__v8hu)__B, 3);
 #endif
-  rshift = vec_min (rshift, rshmax);
-  result = vec_sra ((__v8hi) __A, rshift);
+  __rshift = vec_min (__rshift, __rshmax);
+  __result = vec_sra ((__v8hi) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_epi32 (__m128i __A, __m128i __B)
 {
-  const __v4su rshmax = { 31, 31, 31, 31 };
-  __v4su rshift;
-  __v4si result;
+  const __v4su __rshmax = { 31, 31, 31, 31 };
+  __v4su __rshift;
+  __v4si __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v4su)__B, 0);
+  __rshift = vec_splat ((__v4su)__B, 0);
 #else
-  rshift = vec_splat ((__v4su)__B, 1);
+  __rshift = vec_splat ((__v4su)__B, 1);
 #endif
-  rshift = vec_min (rshift, rshmax);
-  result = vec_sra ((__v4si) __A, rshift);
+  __rshift = vec_min (__rshift, __rshmax);
+  __result = vec_sra ((__v4si) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi16 (__m128i __A, __m128i __B)
 {
-  __v8hu rshift;
-  __vector __bool short shmask;
-  const __v8hu shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu result;
+  __v8hu __rshift;
+  __vector __bool short __shmask;
+  const __v8hu __shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v8hu) __B, 0);
+  __rshift = vec_splat ((__v8hu) __B, 0);
 #else
-  rshift = vec_splat ((__v8hu) __B, 3);
+  __rshift = vec_splat ((__v8hu) __B, 3);
 #endif
-  shmask = vec_cmple (rshift, shmax);
-  result = vec_sr ((__v8hu) __A, rshift);
-  result = vec_sel ((__v8hu) shmask, result, shmask);
+  __shmask = vec_cmple (__rshift, __shmax);
+  __result = vec_sr ((__v8hu) __A, __rshift);
+  __result = vec_sel ((__v8hu) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi32 (__m128i __A, __m128i __B)
 {
-  __v4su rshift;
-  __vector __bool int shmask;
-  const __v4su shmax = { 32, 32, 32, 32 };
-  __v4su result;
+  __v4su __rshift;
+  __vector __bool int __shmask;
+  const __v4su __shmax = { 32, 32, 32, 32 };
+  __v4su __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v4su) __B, 0);
+  __rshift = vec_splat ((__v4su) __B, 0);
 #else
-  rshift = vec_splat ((__v4su) __B, 1);
+  __rshift = vec_splat ((__v4su) __B, 1);
 #endif
-  shmask = vec_cmplt (rshift, shmax);
-  result = vec_sr ((__v4su) __A, rshift);
-  result = vec_sel ((__v4su) shmask, result, shmask);
+  __shmask = vec_cmplt (__rshift, __shmax);
+  __result = vec_sr ((__v4su) __A, __rshift);
+  __result = vec_sel ((__v4su) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi64 (__m128i __A, __m128i __B)
 {
-  __v2du rshift;
-  __vector __bool long long shmask;
-  const __v2du shmax = { 64, 64 };
-  __v2du result;
+  __v2du __rshift;
+  __vector __bool long long __shmask;
+  const __v2du __shmax = { 64, 64 };
+  __v2du __result;
 
-  rshift = vec_splat ((__v2du) __B, 0);
-  shmask = vec_cmplt (rshift, shmax);
-  result = vec_sr ((__v2du) __A, rshift);
-  result = vec_sel ((__v2du) shmask, result, shmask);
+  __rshift = vec_splat ((__v2du) __B, 0);
+  __shmask = vec_cmplt (__rshift, __shmax);
+  __result = vec_sr ((__v2du) __A, __rshift);
+  __result = vec_sel ((__v2du) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
@@ -1998,11 +1992,11 @@ _mm_extract_epi16 (__m128i const __A, int const __N)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi16 (__m128i const __A, int const __D, int const __N)
 {
-  __v8hi result = (__v8hi)__A;
+  __v8hi __result = (__v8hi)__A;
 
-  result [(__N & 7)] = __D;
+  __result [(__N & 7)] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -2038,21 +2032,21 @@ _mm_min_epu8 (__m128i __A, __m128i __B)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_epi8 (__m128i __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned char perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned char __perm_mask =
     {
 	0x78, 0x70, 0x68, 0x60, 0x58, 0x50, 0x48, 0x40,
 	0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x08, 0x00
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -2060,8 +2054,8 @@ _mm_movemask_epi8 (__m128i __A)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_epu16 (__m128i __A, __m128i __B)
 {
-  __v4su w0, w1;
-  __v16qu xform1 = {
+  __v4su __w0, __w1;
+  __v16qu __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -2071,19 +2065,19 @@ _mm_mulhi_epu16 (__m128i __A, __m128i __B)
 #endif
     };
 
-  w0 = vec_vmuleuh ((__v8hu)__A, (__v8hu)__B);
-  w1 = vec_vmulouh ((__v8hu)__A, (__v8hu)__B);
-  return (__m128i) vec_perm (w0, w1, xform1);
+  __w0 = vec_vmuleuh ((__v8hu)__A, (__v8hu)__B);
+  __w1 = vec_vmulouh ((__v8hu)__A, (__v8hu)__B);
+  return (__m128i) vec_perm (__w0, __w1, __xform1);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shufflehi_epi16 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_98 = __mask & 0x03;
-  unsigned long element_selector_BA = (__mask >> 2) & 0x03;
-  unsigned long element_selector_DC = (__mask >> 4) & 0x03;
-  unsigned long element_selector_FE = (__mask >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_98 = __mask & 0x03;
+  unsigned long __element_selector_BA = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_DC = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_FE = (__mask >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0908, 0x0B0A, 0x0D0C, 0x0F0E
@@ -2091,33 +2085,33 @@ _mm_shufflehi_epi16 (__m128i __A, const int __mask)
 	      0x0809, 0x0A0B, 0x0C0D, 0x0E0F
 #endif
     };
-  __v2du pmask =
+  __v2du __pmask =
 #ifdef __LITTLE_ENDIAN__
       { 0x1716151413121110UL,  0UL};
 #else
       { 0x1011121314151617UL,  0UL};
 #endif
-  __m64_union t;
-  __v2du a, r;
+  __m64_union __t;
+  __v2du __a, __r;
 
-  t.as_short[0] = permute_selectors[element_selector_98];
-  t.as_short[1] = permute_selectors[element_selector_BA];
-  t.as_short[2] = permute_selectors[element_selector_DC];
-  t.as_short[3] = permute_selectors[element_selector_FE];
-  pmask[1] = t.as_m64;
-  a = (__v2du)__A;
-  r = vec_perm (a, a, (__vector unsigned char)pmask);
-  return (__m128i) r;
+  __t.as_short[0] = __permute_selectors[__element_selector_98];
+  __t.as_short[1] = __permute_selectors[__element_selector_BA];
+  __t.as_short[2] = __permute_selectors[__element_selector_DC];
+  __t.as_short[3] = __permute_selectors[__element_selector_FE];
+  __pmask[1] = __t.as_m64;
+  __a = (__v2du)__A;
+  __r = vec_perm (__a, __a, (__vector unsigned char)__pmask);
+  return (__m128i) __r;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shufflelo_epi16 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0100, 0x0302, 0x0504, 0x0706
@@ -2125,32 +2119,32 @@ _mm_shufflelo_epi16 (__m128i __A, const int __mask)
 	      0x0001, 0x0203, 0x0405, 0x0607
 #endif
     };
-  __v2du pmask =
+  __v2du __pmask =
 #ifdef __LITTLE_ENDIAN__
                  { 0UL,  0x1f1e1d1c1b1a1918UL};
 #else
                  { 0UL,  0x18191a1b1c1d1e1fUL};
 #endif
-  __m64_union t;
-  __v2du a, r;
-  t.as_short[0] = permute_selectors[element_selector_10];
-  t.as_short[1] = permute_selectors[element_selector_32];
-  t.as_short[2] = permute_selectors[element_selector_54];
-  t.as_short[3] = permute_selectors[element_selector_76];
-  pmask[0] = t.as_m64;
-  a = (__v2du)__A;
-  r = vec_perm (a, a, (__vector unsigned char)pmask);
-  return (__m128i) r;
+  __m64_union __t;
+  __v2du __a, __r;
+  __t.as_short[0] = __permute_selectors[__element_selector_10];
+  __t.as_short[1] = __permute_selectors[__element_selector_32];
+  __t.as_short[2] = __permute_selectors[__element_selector_54];
+  __t.as_short[3] = __permute_selectors[__element_selector_76];
+  __pmask[0] = __t.as_m64;
+  __a = (__v2du)__A;
+  __r = vec_perm (__a, __a, (__vector unsigned char)__pmask);
+  return (__m128i) __r;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_epi32 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned int permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned int __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C
@@ -2158,26 +2152,26 @@ _mm_shuffle_epi32 (__m128i __A, const int __mask)
       0x00010203, 0x04050607, 0x08090A0B, 0x0C0D0E0F
 #endif
     };
-  __v4su t;
+  __v4su __t;
 
-  t[0] = permute_selectors[element_selector_10];
-  t[1] = permute_selectors[element_selector_32];
-  t[2] = permute_selectors[element_selector_54] + 0x10101010;
-  t[3] = permute_selectors[element_selector_76] + 0x10101010;
-  return (__m128i)vec_perm ((__v4si) __A, (__v4si)__A, (__vector unsigned char)t);
+  __t[0] = __permute_selectors[__element_selector_10];
+  __t[1] = __permute_selectors[__element_selector_32];
+  __t[2] = __permute_selectors[__element_selector_54] + 0x10101010;
+  __t[3] = __permute_selectors[__element_selector_76] + 0x10101010;
+  return (__m128i)vec_perm ((__v4si) __A, (__v4si)__A, (__vector unsigned char)__t);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)
 {
-  __v2du hibit = { 0x7f7f7f7f7f7f7f7fUL, 0x7f7f7f7f7f7f7f7fUL};
-  __v16qu mask, tmp;
-  __m128i_u *p = (__m128i_u*)__C;
+  __v2du __hibit = { 0x7f7f7f7f7f7f7f7fUL, 0x7f7f7f7f7f7f7f7fUL};
+  __v16qu __mask, __tmp;
+  __m128i_u *__p = (__m128i_u*)__C;
 
-  tmp = (__v16qu)_mm_loadu_si128(p);
-  mask = (__v16qu)vec_cmpgt ((__v16qu)__B, (__v16qu)hibit);
-  tmp = vec_sel (tmp, (__v16qu)__A, mask);
-  _mm_storeu_si128 (p, (__m128i)tmp);
+  __tmp = (__v16qu)_mm_loadu_si128(__p);
+  __mask = (__v16qu)vec_cmpgt ((__v16qu)__B, (__v16qu)__hibit);
+  __tmp = vec_sel (__tmp, (__v16qu)__A, __mask);
+  _mm_storeu_si128 (__p, (__m128i)__tmp);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -2196,29 +2190,29 @@ _mm_avg_epu16 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sad_epu8 (__m128i __A, __m128i __B)
 {
-  __v16qu a, b;
-  __v16qu vmin, vmax, vabsdiff;
-  __v4si vsum;
-  const __v4su zero = { 0, 0, 0, 0 };
-  __v4si result;
-
-  a = (__v16qu) __A;
-  b = (__v16qu) __B;
-  vmin = vec_min (a, b);
-  vmax = vec_max (a, b);
-  vabsdiff = vec_sub (vmax, vmin);
+  __v16qu __a, __b;
+  __v16qu __vmin, __vmax, __vabsdiff;
+  __v4si __vsum;
+  const __v4su __zero = { 0, 0, 0, 0 };
+  __v4si __result;
+
+  __a = (__v16qu) __A;
+  __b = (__v16qu) __B;
+  __vmin = vec_min (__a, __b);
+  __vmax = vec_max (__a, __b);
+  __vabsdiff = vec_sub (__vmax, __vmin);
   /* Sum four groups of bytes into integers.  */
-  vsum = (__vector signed int) vec_sum4s (vabsdiff, zero);
+  __vsum = (__vector signed int) vec_sum4s (__vabsdiff, __zero);
   /* Sum across four integers with two integer results.  */
-  result = vec_sum2s (vsum, (__vector signed int) zero);
+  __result = vec_sum2s (__vsum, (__vector signed int) __zero);
   /* Rotate the sums into the correct position.  */
 #ifdef __LITTLE_ENDIAN__
-  result = vec_sld (result, result, 4);
+  __result = vec_sld (__result, __result, 4);
 #else
-  result = vec_sld (result, result, 6);
+  __result = vec_sld (__result, __result, 6);
 #endif
   /* Rotate the sums into the correct position.  */
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/mm_malloc.h b/gcc/config/rs6000/mm_malloc.h
index c04348068e0..4503e75ce18 100644
--- a/gcc/config/rs6000/mm_malloc.h
+++ b/gcc/config/rs6000/mm_malloc.h
@@ -35,28 +35,28 @@ extern "C" int posix_memalign (void **, size_t, size_t) throw ();
 #endif
 
 static __inline void *
-_mm_malloc (size_t size, size_t alignment)
+_mm_malloc (size_t __size, size_t __alignment)
 {
   /* PowerPC64 ELF V2 ABI requires quadword alignment.  */
-  size_t vec_align = sizeof (__vector float);
+  size_t __vec_align = sizeof (__vector float);
   /* Linux GLIBC malloc alignment is at least 2 X ptr size.  */
-  size_t malloc_align = (sizeof (void *) + sizeof (void *));
-  void *ptr;
-
-  if (alignment == malloc_align && alignment == vec_align)
-    return malloc (size);
-  if (alignment < vec_align)
-    alignment = vec_align;
-  if (posix_memalign (&ptr, alignment, size) == 0)
-    return ptr;
+  size_t __malloc_align = (sizeof (void *) + sizeof (void *));
+  void *__ptr;
+
+  if (__alignment == __malloc_align && __alignment == __vec_align)
+    return malloc (__size);
+  if (__alignment < __vec_align)
+    __alignment = __vec_align;
+  if (posix_memalign (&__ptr, __alignment, __size) == 0)
+    return __ptr;
   else
     return NULL;
 }
 
 static __inline void
-_mm_free (void * ptr)
+_mm_free (void * __ptr)
 {
-  free (ptr);
+  free (__ptr);
 }
 
 #endif /* _MM_MALLOC_H_INCLUDED */
diff --git a/gcc/config/rs6000/mma.md b/gcc/config/rs6000/mma.md
index fa081608c4c..59822d47dfc 100644
--- a/gcc/config/rs6000/mma.md
+++ b/gcc/config/rs6000/mma.md
@@ -267,10 +267,25 @@
 (define_expand "movoo"
   [(set (match_operand:OO 0 "nonimmediate_operand")
 	(match_operand:OO 1 "input_operand"))]
-  "TARGET_MMA"
+  ""
 {
-  rs6000_emit_move (operands[0], operands[1], OOmode);
-  DONE;
+  if (TARGET_MMA)
+    {
+      rs6000_emit_move (operands[0], operands[1], OOmode);
+      DONE;
+    }
+  else if (currently_expanding_to_rtl && seen_error ())
+    {
+      /* PR103353 shows we may want to continue to expand the __builtin_vsx_lxvp
+	 built-in function, even if we have already emitted error messages about
+	 some missing required conditions.  As shown in that PR, without one
+	 explicit mov optab on OOmode provided, it would call emit_move_insn
+	 recursively.  So we allow this pattern to be generated when we are
+	 expanding to RTL and have seen errors.  It would not cause further ICEs
+	 as the compilation would stop soon after expanding.  */
+    }
+  else
+    gcc_unreachable ();
 })
 
 (define_insn_and_split "*movoo"
@@ -299,10 +314,22 @@
 (define_expand "movxo"
   [(set (match_operand:XO 0 "nonimmediate_operand")
 	(match_operand:XO 1 "input_operand"))]
-  "TARGET_MMA"
+  ""
 {
-  rs6000_emit_move (operands[0], operands[1], XOmode);
-  DONE;
+  if (TARGET_MMA)
+    {
+      rs6000_emit_move (operands[0], operands[1], XOmode);
+      DONE;
+    }
+  else if (currently_expanding_to_rtl && seen_error ())
+    {
+      /* PR103353 shows we may want to continue to expand the __builtin_vsx_lxvp
+	 built-in function, even if we have already emitted error messages about
+	 some missing required conditions.  So do the same handlings for XOmode
+	 as OOmode here.  */
+    }
+  else
+    gcc_unreachable ();
 })
 
 (define_insn_and_split "*movxo"
diff --git a/gcc/config/rs6000/mmintrin.h b/gcc/config/rs6000/mmintrin.h
index 0bd929c5afe..a826fdd0c7f 100644
--- a/gcc/config/rs6000/mmintrin.h
+++ b/gcc/config/rs6000/mmintrin.h
@@ -170,17 +170,17 @@ _mm_cvtsi64_si64x (__m64 __i)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short vm1;
-  __vector signed char vresult;
+  __vector signed short __vm1;
+  __vector signed char __vresult;
 
-  vm1 = (__vector signed short) (__vector unsigned long long)
+  __vm1 = (__vector signed short) (__vector unsigned long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
-  vresult = vec_packs (vm1, vm1);
-  return (__m64) ((__vector long long) vresult)[0];
+  __vresult = vec_packs (__vm1, __vm1);
+  return (__m64) ((__vector long long) __vresult)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -195,17 +195,17 @@ _m_packsswb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pi32 (__m64 __m1, __m64 __m2)
 {
-  __vector signed int vm1;
-  __vector signed short vresult;
+  __vector signed int __vm1;
+  __vector signed short __vresult;
 
-  vm1 = (__vector signed int) (__vector unsigned long long)
+  __vm1 = (__vector signed int) (__vector unsigned long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
-  vresult = vec_packs (vm1, vm1);
-  return (__m64) ((__vector long long) vresult)[0];
+  __vresult = vec_packs (__vm1, __vm1);
+  return (__m64) ((__vector long long) __vresult)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -220,19 +220,19 @@ _m_packssdw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char r;
-  __vector signed short vm1 = (__vector signed short) (__vector long long)
+  __vector unsigned char __r;
+  __vector signed short __vm1 = (__vector signed short) (__vector long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
   const __vector signed short __zero = { 0 };
-  __vector __bool short __select = vec_cmplt (vm1, __zero);
-  r = vec_packs ((__vector unsigned short) vm1, (__vector unsigned short) vm1);
-  __vector __bool char packsel = vec_pack (__select, __select);
-  r = vec_sel (r, (const __vector unsigned char) __zero, packsel);
-  return (__m64) ((__vector long long) r)[0];
+  __vector __bool short __select = vec_cmplt (__vm1, __zero);
+  __r = vec_packs ((__vector unsigned short) __vm1, (__vector unsigned short) __vm1);
+  __vector __bool char __packsel = vec_pack (__select, __select);
+  __r = vec_sel (__r, (const __vector unsigned char) __zero, __packsel);
+  return (__m64) ((__vector long long) __r)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -248,28 +248,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_mergel (a, b);
-  return (__m64) ((__vector long long) c)[1];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_mergel (__a, __b);
+  return (__m64) ((__vector long long) __c)[1];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[4];
-  res.as_char[1] = m2.as_char[4];
-  res.as_char[2] = m1.as_char[5];
-  res.as_char[3] = m2.as_char[5];
-  res.as_char[4] = m1.as_char[6];
-  res.as_char[5] = m2.as_char[6];
-  res.as_char[6] = m1.as_char[7];
-  res.as_char[7] = m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[4];
+  __res.as_char[1] = __mu2.as_char[4];
+  __res.as_char[2] = __mu1.as_char[5];
+  __res.as_char[3] = __mu2.as_char[5];
+  __res.as_char[4] = __mu1.as_char[6];
+  __res.as_char[5] = __mu2.as_char[6];
+  __res.as_char[6] = __mu1.as_char[7];
+  __res.as_char[7] = __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -284,17 +284,17 @@ _m_punpckhbw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[2];
-  res.as_short[1] = m2.as_short[2];
-  res.as_short[2] = m1.as_short[3];
-  res.as_short[3] = m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[2];
+  __res.as_short[1] = __mu2.as_short[2];
+  __res.as_short[2] = __mu1.as_short[3];
+  __res.as_short[3] = __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -307,15 +307,15 @@ _m_punpckhwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[1];
-  res.as_int[1] = m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[1];
+  __res.as_int[1] = __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -329,28 +329,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_mergel (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_mergel (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0];
-  res.as_char[1] = m2.as_char[0];
-  res.as_char[2] = m1.as_char[1];
-  res.as_char[3] = m2.as_char[1];
-  res.as_char[4] = m1.as_char[2];
-  res.as_char[5] = m2.as_char[2];
-  res.as_char[6] = m1.as_char[3];
-  res.as_char[7] = m2.as_char[3];
+  __res.as_char[0] = __mu1.as_char[0];
+  __res.as_char[1] = __mu2.as_char[0];
+  __res.as_char[2] = __mu1.as_char[1];
+  __res.as_char[3] = __mu2.as_char[1];
+  __res.as_char[4] = __mu1.as_char[2];
+  __res.as_char[5] = __mu2.as_char[2];
+  __res.as_char[6] = __mu1.as_char[3];
+  __res.as_char[7] = __mu2.as_char[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -364,17 +364,17 @@ _m_punpcklbw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0];
-  res.as_short[1] = m2.as_short[0];
-  res.as_short[2] = m1.as_short[1];
-  res.as_short[3] = m2.as_short[1];
+  __res.as_short[0] = __mu1.as_short[0];
+  __res.as_short[1] = __mu2.as_short[0];
+  __res.as_short[2] = __mu1.as_short[1];
+  __res.as_short[3] = __mu2.as_short[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -388,15 +388,15 @@ _m_punpcklwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0];
-  res.as_int[1] = m2.as_int[0];
+  __res.as_int[0] = __mu1.as_int[0];
+  __res.as_int[1] = __mu2.as_int[0];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -410,28 +410,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0] + m2.as_char[0];
-  res.as_char[1] = m1.as_char[1] + m2.as_char[1];
-  res.as_char[2] = m1.as_char[2] + m2.as_char[2];
-  res.as_char[3] = m1.as_char[3] + m2.as_char[3];
-  res.as_char[4] = m1.as_char[4] + m2.as_char[4];
-  res.as_char[5] = m1.as_char[5] + m2.as_char[5];
-  res.as_char[6] = m1.as_char[6] + m2.as_char[6];
-  res.as_char[7] = m1.as_char[7] + m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[0] + __mu2.as_char[0];
+  __res.as_char[1] = __mu1.as_char[1] + __mu2.as_char[1];
+  __res.as_char[2] = __mu1.as_char[2] + __mu2.as_char[2];
+  __res.as_char[3] = __mu1.as_char[3] + __mu2.as_char[3];
+  __res.as_char[4] = __mu1.as_char[4] + __mu2.as_char[4];
+  __res.as_char[5] = __mu1.as_char[5] + __mu2.as_char[5];
+  __res.as_char[6] = __mu1.as_char[6] + __mu2.as_char[6];
+  __res.as_char[7] = __mu1.as_char[7] + __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -446,24 +446,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0] + m2.as_short[0];
-  res.as_short[1] = m1.as_short[1] + m2.as_short[1];
-  res.as_short[2] = m1.as_short[2] + m2.as_short[2];
-  res.as_short[3] = m1.as_short[3] + m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[0] + __mu2.as_short[0];
+  __res.as_short[1] = __mu1.as_short[1] + __mu2.as_short[1];
+  __res.as_short[2] = __mu1.as_short[2] + __mu2.as_short[2];
+  __res.as_short[3] = __mu1.as_short[3] + __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -478,22 +478,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0] + m2.as_int[0];
-  res.as_int[1] = m1.as_int[1] + m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[0] + __mu2.as_int[0];
+  __res.as_int[1] = __mu1.as_int[1] + __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -508,28 +508,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0] - m2.as_char[0];
-  res.as_char[1] = m1.as_char[1] - m2.as_char[1];
-  res.as_char[2] = m1.as_char[2] - m2.as_char[2];
-  res.as_char[3] = m1.as_char[3] - m2.as_char[3];
-  res.as_char[4] = m1.as_char[4] - m2.as_char[4];
-  res.as_char[5] = m1.as_char[5] - m2.as_char[5];
-  res.as_char[6] = m1.as_char[6] - m2.as_char[6];
-  res.as_char[7] = m1.as_char[7] - m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[0] - __mu2.as_char[0];
+  __res.as_char[1] = __mu1.as_char[1] - __mu2.as_char[1];
+  __res.as_char[2] = __mu1.as_char[2] - __mu2.as_char[2];
+  __res.as_char[3] = __mu1.as_char[3] - __mu2.as_char[3];
+  __res.as_char[4] = __mu1.as_char[4] - __mu2.as_char[4];
+  __res.as_char[5] = __mu1.as_char[5] - __mu2.as_char[5];
+  __res.as_char[6] = __mu1.as_char[6] - __mu2.as_char[6];
+  __res.as_char[7] = __mu1.as_char[7] - __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -544,24 +544,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0] - m2.as_short[0];
-  res.as_short[1] = m1.as_short[1] - m2.as_short[1];
-  res.as_short[2] = m1.as_short[2] - m2.as_short[2];
-  res.as_short[3] = m1.as_short[3] - m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[0] - __mu2.as_short[0];
+  __res.as_short[1] = __mu1.as_short[1] - __mu2.as_short[1];
+  __res.as_short[2] = __mu1.as_short[2] - __mu2.as_short[2];
+  __res.as_short[3] = __mu1.as_short[3] - __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -576,22 +576,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0] - m2.as_int[0];
-  res.as_int[1] = m1.as_int[1] - m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[0] - __mu2.as_int[0];
+  __res.as_int[1] = __mu1.as_int[1] - __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -729,30 +729,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)
 {
 #if defined(_ARCH_PWR6) && defined(__powerpc64__)
-  __m64 res;
+  __m64 __res;
   __asm__(
       "cmpb %0,%1,%2;\n"
-      : "=r" (res)
+      : "=r" (__res)
       : "r" (__m1),
 	"r" (__m2)
       : );
-  return (res);
+  return (__res);
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = (m1.as_char[0] == m2.as_char[0])? -1: 0;
-  res.as_char[1] = (m1.as_char[1] == m2.as_char[1])? -1: 0;
-  res.as_char[2] = (m1.as_char[2] == m2.as_char[2])? -1: 0;
-  res.as_char[3] = (m1.as_char[3] == m2.as_char[3])? -1: 0;
-  res.as_char[4] = (m1.as_char[4] == m2.as_char[4])? -1: 0;
-  res.as_char[5] = (m1.as_char[5] == m2.as_char[5])? -1: 0;
-  res.as_char[6] = (m1.as_char[6] == m2.as_char[6])? -1: 0;
-  res.as_char[7] = (m1.as_char[7] == m2.as_char[7])? -1: 0;
+  __res.as_char[0] = (__mu1.as_char[0] == __mu2.as_char[0])? -1: 0;
+  __res.as_char[1] = (__mu1.as_char[1] == __mu2.as_char[1])? -1: 0;
+  __res.as_char[2] = (__mu1.as_char[2] == __mu2.as_char[2])? -1: 0;
+  __res.as_char[3] = (__mu1.as_char[3] == __mu2.as_char[3])? -1: 0;
+  __res.as_char[4] = (__mu1.as_char[4] == __mu2.as_char[4])? -1: 0;
+  __res.as_char[5] = (__mu1.as_char[5] == __mu2.as_char[5])? -1: 0;
+  __res.as_char[6] = (__mu1.as_char[6] == __mu2.as_char[6])? -1: 0;
+  __res.as_char[7] = (__mu1.as_char[7] == __mu2.as_char[7])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -766,28 +766,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = (__vector signed char)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = (__vector signed char)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = (m1.as_char[0] > m2.as_char[0])? -1: 0;
-  res.as_char[1] = (m1.as_char[1] > m2.as_char[1])? -1: 0;
-  res.as_char[2] = (m1.as_char[2] > m2.as_char[2])? -1: 0;
-  res.as_char[3] = (m1.as_char[3] > m2.as_char[3])? -1: 0;
-  res.as_char[4] = (m1.as_char[4] > m2.as_char[4])? -1: 0;
-  res.as_char[5] = (m1.as_char[5] > m2.as_char[5])? -1: 0;
-  res.as_char[6] = (m1.as_char[6] > m2.as_char[6])? -1: 0;
-  res.as_char[7] = (m1.as_char[7] > m2.as_char[7])? -1: 0;
+  __res.as_char[0] = (__mu1.as_char[0] > __mu2.as_char[0])? -1: 0;
+  __res.as_char[1] = (__mu1.as_char[1] > __mu2.as_char[1])? -1: 0;
+  __res.as_char[2] = (__mu1.as_char[2] > __mu2.as_char[2])? -1: 0;
+  __res.as_char[3] = (__mu1.as_char[3] > __mu2.as_char[3])? -1: 0;
+  __res.as_char[4] = (__mu1.as_char[4] > __mu2.as_char[4])? -1: 0;
+  __res.as_char[5] = (__mu1.as_char[5] > __mu2.as_char[5])? -1: 0;
+  __res.as_char[6] = (__mu1.as_char[6] > __mu2.as_char[6])? -1: 0;
+  __res.as_char[7] = (__mu1.as_char[7] > __mu2.as_char[7])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -803,24 +803,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = (__vector signed short)vec_cmpeq (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = (__vector signed short)vec_cmpeq (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = (m1.as_short[0] == m2.as_short[0])? -1: 0;
-  res.as_short[1] = (m1.as_short[1] == m2.as_short[1])? -1: 0;
-  res.as_short[2] = (m1.as_short[2] == m2.as_short[2])? -1: 0;
-  res.as_short[3] = (m1.as_short[3] == m2.as_short[3])? -1: 0;
+  __res.as_short[0] = (__mu1.as_short[0] == __mu2.as_short[0])? -1: 0;
+  __res.as_short[1] = (__mu1.as_short[1] == __mu2.as_short[1])? -1: 0;
+  __res.as_short[2] = (__mu1.as_short[2] == __mu2.as_short[2])? -1: 0;
+  __res.as_short[3] = (__mu1.as_short[3] == __mu2.as_short[3])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -834,24 +834,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = (__vector signed short)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = (__vector signed short)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = (m1.as_short[0] > m2.as_short[0])? -1: 0;
-  res.as_short[1] = (m1.as_short[1] > m2.as_short[1])? -1: 0;
-  res.as_short[2] = (m1.as_short[2] > m2.as_short[2])? -1: 0;
-  res.as_short[3] = (m1.as_short[3] > m2.as_short[3])? -1: 0;
+  __res.as_short[0] = (__mu1.as_short[0] > __mu2.as_short[0])? -1: 0;
+  __res.as_short[1] = (__mu1.as_short[1] > __mu2.as_short[1])? -1: 0;
+  __res.as_short[2] = (__mu1.as_short[2] > __mu2.as_short[2])? -1: 0;
+  __res.as_short[3] = (__mu1.as_short[3] > __mu2.as_short[3])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -867,22 +867,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = (__vector signed int)vec_cmpeq (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = (__vector signed int)vec_cmpeq (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = (m1.as_int[0] == m2.as_int[0])? -1: 0;
-  res.as_int[1] = (m1.as_int[1] == m2.as_int[1])? -1: 0;
+  __res.as_int[0] = (__mu1.as_int[0] == __mu2.as_int[0])? -1: 0;
+  __res.as_int[1] = (__mu1.as_int[1] == __mu2.as_int[1])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -896,22 +896,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = (__vector signed int)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = (__vector signed int)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = (m1.as_int[0] > m2.as_int[0])? -1: 0;
-  res.as_int[1] = (m1.as_int[1] > m2.as_int[1])? -1: 0;
+  __res.as_int[0] = (__mu1.as_int[0] > __mu2.as_int[0])? -1: 0;
+  __res.as_int[1] = (__mu1.as_int[1] > __mu2.as_int[1])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -927,12 +927,12 @@ _m_pcmpgtd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pi8 (__m64 __m1, __m64 __m2)
 {
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -945,12 +945,12 @@ _m_paddsb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -963,12 +963,12 @@ _m_paddsw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pu8 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -982,12 +982,12 @@ _m_paddusb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__m1);
-  b = (__vector unsigned short)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__m1);
+  __b = (__vector unsigned short)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1001,12 +1001,12 @@ _m_paddusw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pi8 (__m64 __m1, __m64 __m2)
 {
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1020,12 +1020,12 @@ _m_psubsb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1039,12 +1039,12 @@ _m_psubsw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pu8 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1058,12 +1058,12 @@ _m_psubusb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__m1);
-  b = (__vector unsigned short)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__m1);
+  __b = (__vector unsigned short)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1078,14 +1078,14 @@ _m_psubusw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_madd_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b;
-  __vector signed int c;
-  __vector signed int zero = {0, 0, 0, 0};
+  __vector signed short __a, __b;
+  __vector signed int __c;
+  __vector signed int __zero = {0, 0, 0, 0};
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_vmsumshm (a, b, zero);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_vmsumshm (__a, __b, __zero);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1098,10 +1098,10 @@ _m_pmaddwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b;
-  __vector signed short c;
-  __vector signed int w0, w1;
-  __vector unsigned char xform1 = {
+  __vector signed short __a, __b;
+  __vector signed short __c;
+  __vector signed int __w0, __w1;
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1111,14 +1111,14 @@ _mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
 #endif
     };
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
 
-  w0 = vec_vmulesh (a, b);
-  w1 = vec_vmulosh (a, b);
-  c = (__vector signed short)vec_perm (w0, w1, xform1);
+  __w0 = vec_vmulesh (__a, __b);
+  __w1 = vec_vmulosh (__a, __b);
+  __c = (__vector signed short)vec_perm (__w0, __w1, __xform1);
 
-  return (__m64) ((__vector long long) c)[0];
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1132,12 +1132,12 @@ _m_pmulhw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mullo_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = a * b;
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = __a * __b;
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1150,15 +1150,15 @@ _m_pmullw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_pi16 (__m64 __m, __m64 __count)
 {
-  __vector signed short m, r;
-  __vector unsigned short c;
+  __vector signed short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-      m = (__vector signed short)vec_splats (__m);
-      c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-      r = vec_sl (m, (__vector unsigned short)c);
-      return (__m64) ((__vector long long) r)[0];
+      __r = (__vector signed short)vec_splats (__m);
+      __c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+      __r = vec_sl (__r, (__vector unsigned short)__c);
+      return (__m64) ((__vector long long) __r)[0];
     }
   else
   return (0);
@@ -1187,13 +1187,13 @@ _m_psllwi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = m.as_int[0] << __count;
-  res.as_int[1] = m.as_int[1] << __count;
-  return (res.as_m64);
+  __res.as_int[0] = __res.as_int[0] << __count;
+  __res.as_int[1] = __res.as_int[1] << __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1219,15 +1219,15 @@ _m_pslldi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_pi16 (__m64 __m, __m64 __count)
 {
-  __vector signed short m, r;
-  __vector unsigned short c;
+  __vector signed short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-	m = (__vector signed short)vec_splats (__m);
-	c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-	r = vec_sra (m, (__vector unsigned short)c);
-        return (__m64) ((__vector long long) r)[0];
+	__r = (__vector signed short)vec_splats (__m);
+	__c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+	__r = vec_sra (__r, (__vector unsigned short)__c);
+        return (__m64) ((__vector long long) __r)[0];
     }
   else
   return (0);
@@ -1256,13 +1256,13 @@ _m_psrawi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = m.as_int[0] >> __count;
-  res.as_int[1] = m.as_int[1] >> __count;
-  return (res.as_m64);
+  __res.as_int[0] = __res.as_int[0] >> __count;
+  __res.as_int[1] = __res.as_int[1] >> __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1288,15 +1288,15 @@ _m_psradi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_pi16 (__m64 __m, __m64 __count)
 {
-  __vector unsigned short m, r;
-  __vector unsigned short c;
+  __vector unsigned short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-	m = (__vector unsigned short)vec_splats (__m);
-	c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-	r = vec_sr (m, (__vector unsigned short)c);
-        return (__m64) ((__vector long long) r)[0];
+	__r = (__vector unsigned short)vec_splats (__m);
+	__c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+	__r = vec_sr (__r, (__vector unsigned short)__c);
+        return (__m64) ((__vector long long) __r)[0];
     }
   else
     return (0);
@@ -1325,13 +1325,13 @@ _m_psrlwi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = (unsigned int)m.as_int[0] >> __count;
-  res.as_int[1] = (unsigned int)m.as_int[1] >> __count;
-  return (res.as_m64);
+  __res.as_int[0] = (unsigned int)__res.as_int[0] >> __count;
+  __res.as_int[1] = (unsigned int)__res.as_int[1] >> __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1358,24 +1358,24 @@ _m_psrldi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set_pi32 (int __i1, int __i0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i0;
-  res.as_int[1] = __i1;
-  return (res.as_m64);
+  __res.as_int[0] = __i0;
+  __res.as_int[1] = __i1;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of four 16-bit values; W0 is least significant.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_short[0] = __w0;
-  res.as_short[1] = __w1;
-  res.as_short[2] = __w2;
-  res.as_short[3] = __w3;
-  return (res.as_m64);
+  __res.as_short[0] = __w0;
+  __res.as_short[1] = __w1;
+  __res.as_short[2] = __w2;
+  __res.as_short[3] = __w3;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of eight 8-bit values; B0 is least significant.  */
@@ -1383,28 +1383,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,
 	     char __b3, char __b2, char __b1, char __b0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_char[0] = __b0;
-  res.as_char[1] = __b1;
-  res.as_char[2] = __b2;
-  res.as_char[3] = __b3;
-  res.as_char[4] = __b4;
-  res.as_char[5] = __b5;
-  res.as_char[6] = __b6;
-  res.as_char[7] = __b7;
-  return (res.as_m64);
+  __res.as_char[0] = __b0;
+  __res.as_char[1] = __b1;
+  __res.as_char[2] = __b2;
+  __res.as_char[3] = __b3;
+  __res.as_char[4] = __b4;
+  __res.as_char[5] = __b5;
+  __res.as_char[6] = __b6;
+  __res.as_char[7] = __b7;
+  return (__res.as_m64);
 }
 
 /* Similar, but with the arguments in reverse order.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_setr_pi32 (int __i0, int __i1)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i0;
-  res.as_int[1] = __i1;
-  return (res.as_m64);
+  __res.as_int[0] = __i0;
+  __res.as_int[1] = __i1;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1424,11 +1424,11 @@ _mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set1_pi32 (int __i)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i;
-  res.as_int[1] = __i;
-  return (res.as_m64);
+  __res.as_int[0] = __i;
+  __res.as_int[1] = __i;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of four 16-bit values, all elements containing W.  */
@@ -1441,13 +1441,13 @@ _mm_set1_pi16 (short __w)
   w = (__vector signed short)vec_splats (__w);
   return (__m64) ((__vector long long) w)[0];
 #else
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_short[0] = __w;
-  res.as_short[1] = __w;
-  res.as_short[2] = __w;
-  res.as_short[3] = __w;
-  return (res.as_m64);
+  __res.as_short[0] = __w;
+  __res.as_short[1] = __w;
+  __res.as_short[2] = __w;
+  __res.as_short[3] = __w;
+  return (__res.as_m64);
 #endif
 }
 
@@ -1456,22 +1456,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_set1_pi8 (signed char __b)
 {
 #if _ARCH_PWR8
-  __vector signed char b;
+  __vector signed char __res;
 
-  b = (__vector signed char)vec_splats (__b);
-  return (__m64) ((__vector long long) b)[0];
+  __res = (__vector signed char)vec_splats (__b);
+  return (__m64) ((__vector long long) __res)[0];
 #else
-  __m64_union res;
-
-  res.as_char[0] = __b;
-  res.as_char[1] = __b;
-  res.as_char[2] = __b;
-  res.as_char[3] = __b;
-  res.as_char[4] = __b;
-  res.as_char[5] = __b;
-  res.as_char[6] = __b;
-  res.as_char[7] = __b;
-  return (res.as_m64);
+  __m64_union __res;
+
+  __res.as_char[0] = __b;
+  __res.as_char[1] = __b;
+  __res.as_char[2] = __b;
+  __res.as_char[3] = __b;
+  __res.as_char[4] = __b;
+  __res.as_char[5] = __b;
+  __res.as_char[6] = __b;
+  __res.as_char[7] = __b;
+  return (__res.as_m64);
 #endif
 }
 #endif /* _MMINTRIN_H_INCLUDED */
diff --git a/gcc/config/rs6000/pmmintrin.h b/gcc/config/rs6000/pmmintrin.h
index eab712fdfa6..4d7e14f312a 100644
--- a/gcc/config/rs6000/pmmintrin.h
+++ b/gcc/config/rs6000/pmmintrin.h
@@ -58,55 +58,55 @@
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_addsub_ps (__m128 __X, __m128 __Y)
 {
-  const __v4sf even_n0 = {-0.0, 0.0, -0.0, 0.0};
-  __v4sf even_neg_Y = vec_xor(__Y, even_n0);
-  return (__m128) vec_add (__X, even_neg_Y);
+  const __v4sf __even_n0 = {-0.0, 0.0, -0.0, 0.0};
+  __v4sf __even_neg_Y = vec_xor(__Y, __even_n0);
+  return (__m128) vec_add (__X, __even_neg_Y);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_addsub_pd (__m128d __X, __m128d __Y)
 {
-  const __v2df even_n0 = {-0.0, 0.0};
-  __v2df even_neg_Y = vec_xor(__Y, even_n0);
-  return (__m128d) vec_add (__X, even_neg_Y);
+  const __v2df __even_n0 = {-0.0, 0.0};
+  __v2df __even_neg_Y = vec_xor(__Y, __even_n0);
+  return (__m128d) vec_add (__X, __even_neg_Y);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_hadd_ps (__m128 __X, __m128 __Y)
 {
-  __vector unsigned char xform2 = {
+  __vector unsigned char __xform2 = {
       0x00, 0x01, 0x02, 0x03,
       0x08, 0x09, 0x0A, 0x0B,
       0x10, 0x11, 0x12, 0x13,
       0x18, 0x19, 0x1A, 0x1B
     };
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
       0x04, 0x05, 0x06, 0x07,
       0x0C, 0x0D, 0x0E, 0x0F,
       0x14, 0x15, 0x16, 0x17,
       0x1C, 0x1D, 0x1E, 0x1F
     };
-  return (__m128) vec_add (vec_perm ((__v4sf) __X, (__v4sf) __Y, xform2),
-			   vec_perm ((__v4sf) __X, (__v4sf) __Y, xform1));
+  return (__m128) vec_add (vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform2),
+			   vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform1));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_hsub_ps (__m128 __X, __m128 __Y)
 {
-  __vector unsigned char xform2 = {
+  __vector unsigned char __xform2 = {
       0x00, 0x01, 0x02, 0x03,
       0x08, 0x09, 0x0A, 0x0B,
       0x10, 0x11, 0x12, 0x13,
       0x18, 0x19, 0x1A, 0x1B
     };
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
       0x04, 0x05, 0x06, 0x07,
       0x0C, 0x0D, 0x0E, 0x0F,
       0x14, 0x15, 0x16, 0x17,
       0x1C, 0x1D, 0x1E, 0x1F
     };
-  return (__m128) vec_sub (vec_perm ((__v4sf) __X, (__v4sf) __Y, xform2),
-			   vec_perm ((__v4sf) __X, (__v4sf) __Y, xform1));
+  return (__m128) vec_sub (vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform2),
+			   vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform1));
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/rs6000-call.c b/gcc/config/rs6000/rs6000-call.c
index ef20cb30388..e58b149d022 100644
--- a/gcc/config/rs6000/rs6000-call.c
+++ b/gcc/config/rs6000/rs6000-call.c
@@ -11877,7 +11877,12 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)
       unsigned nvec = (fncode == MMA_BUILTIN_DISASSEMBLE_ACC) ? 4 : 2;
       tree dst_ptr = gimple_call_arg (stmt, 0);
       tree src_ptr = gimple_call_arg (stmt, 1);
-      tree src_type = TREE_TYPE (src_ptr);
+      tree src_type = (fncode == MMA_BUILTIN_DISASSEMBLE_ACC)
+		      ? build_pointer_type (vector_quad_type_node)
+		      : build_pointer_type (vector_pair_type_node);
+      if (TREE_TYPE (src_ptr) != src_type)
+	src_ptr = build1 (NOP_EXPR, src_type, src_ptr);
+
       tree src = create_tmp_reg_or_ssa_name (TREE_TYPE (src_type));
       gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);
 
diff --git a/gcc/config/rs6000/rs6000-p8swap.c b/gcc/config/rs6000/rs6000-p8swap.c
index 903002a4576..4741d14d99f 100644
--- a/gcc/config/rs6000/rs6000-p8swap.c
+++ b/gcc/config/rs6000/rs6000-p8swap.c
@@ -1668,7 +1668,15 @@ replace_swapped_aligned_store (swap_web_entry *insn_entry,
   gcc_assert ((GET_CODE (new_body) == SET)
 	      && MEM_P (SET_DEST (new_body)));
 
-  set_block_for_insn (new_insn, BLOCK_FOR_INSN (store_insn));
+  basic_block bb = BLOCK_FOR_INSN (store_insn);
+  set_block_for_insn (new_insn, bb);
+  /* Handle REG_EH_REGION note.  */
+  if (cfun->can_throw_non_call_exceptions && BB_END (bb) == store_insn)
+    {
+      rtx note = find_reg_note (store_insn, REG_EH_REGION, NULL_RTX);
+      if (note)
+	add_reg_note (new_insn, REG_EH_REGION, XEXP (note, 0));
+    }
   df_insn_rescan (new_insn);
 
   df_insn_delete (store_insn);
@@ -1761,7 +1769,15 @@ replace_swapped_aligned_load (swap_web_entry *insn_entry, rtx swap_insn)
   gcc_assert ((GET_CODE (new_body) == SET)
 	      && MEM_P (SET_SRC (new_body)));
 
-  set_block_for_insn (new_insn, BLOCK_FOR_INSN (def_insn));
+  basic_block bb = BLOCK_FOR_INSN (def_insn);
+  set_block_for_insn (new_insn, bb);
+  /* Handle REG_EH_REGION note.  */
+  if (cfun->can_throw_non_call_exceptions && BB_END (bb) == def_insn)
+    {
+      rtx note = find_reg_note (def_insn, REG_EH_REGION, NULL_RTX);
+      if (note)
+	add_reg_note (new_insn, REG_EH_REGION, XEXP (note, 0));
+    }
   df_insn_rescan (new_insn);
 
   df_insn_delete (def_insn);
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 0421dc7adb3..4352e8fd259 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -4147,14 +4147,6 @@ rs6000_option_override_internal (bool global_init_p)
 	rs6000_isa_flags &= ~OPTION_MASK_BLOCK_OPS_UNALIGNED_VSX;
     }
 
-  if (!(rs6000_isa_flags_explicit & OPTION_MASK_BLOCK_OPS_VECTOR_PAIR))
-    {
-      if (TARGET_MMA && TARGET_EFFICIENT_UNALIGNED_VSX)
-	rs6000_isa_flags |= OPTION_MASK_BLOCK_OPS_VECTOR_PAIR;
-      else
-	rs6000_isa_flags &= ~OPTION_MASK_BLOCK_OPS_VECTOR_PAIR;
-    }
-
   /* Use long double size to select the appropriate long double.  We use
      TYPE_PRECISION to differentiate the 3 different long double types.  We map
      128 into the precision used for TFmode.  */
@@ -5742,33 +5734,68 @@ const char *rs6000_machine;
 const char *
 rs6000_machine_from_flags (void)
 {
-  /* For some CPUs, the machine cannot be determined by ISA flags.  We have to
-     check them first.  */
-  switch (rs6000_cpu)
-    {
-    case PROCESSOR_PPC8540:
-    case PROCESSOR_PPC8548:
-      return "e500";
-
-    case PROCESSOR_PPCE300C2:
-    case PROCESSOR_PPCE300C3:
-      return "e300";
-
-    case PROCESSOR_PPCE500MC:
-      return "e500mc";
+  /* e300 and e500 */
+  if (rs6000_cpu == PROCESSOR_PPCE300C2 || rs6000_cpu == PROCESSOR_PPCE300C3)
+    return "e300";
+  if (rs6000_cpu == PROCESSOR_PPC8540 || rs6000_cpu == PROCESSOR_PPC8548)
+    return "e500";
+  if (rs6000_cpu == PROCESSOR_PPCE500MC)
+    return "e500mc";
+  if (rs6000_cpu == PROCESSOR_PPCE500MC64)
+    return "e500mc64";
+  if (rs6000_cpu == PROCESSOR_PPCE5500)
+    return "e5500";
+  if (rs6000_cpu == PROCESSOR_PPCE6500)
+    return "e6500";
+
+  /* 400 series */
+  if (rs6000_cpu == PROCESSOR_PPC403)
+    return "\"403\"";
+  if (rs6000_cpu == PROCESSOR_PPC405)
+    return "\"405\"";
+  if (rs6000_cpu == PROCESSOR_PPC440)
+    return "\"440\"";
+  if (rs6000_cpu == PROCESSOR_PPC476)
+    return "\"476\"";
+
+  /* A2 */
+  if (rs6000_cpu == PROCESSOR_PPCA2)
+    return "a2";
+
+  /* Cell BE */
+  if (rs6000_cpu == PROCESSOR_CELL)
+    return "cell";
+
+  /* Titan */
+  if (rs6000_cpu == PROCESSOR_TITAN)
+    return "titan";
+
+  /* 500 series and 800 series */
+  if (rs6000_cpu == PROCESSOR_MPCCORE)
+    return "\"821\"";
 
-    case PROCESSOR_PPCE500MC64:
-      return "e500mc64";
-
-    case PROCESSOR_PPCE5500:
-      return "e5500";
+#if 0
+  /* This (and ppc64 below) are disabled here (for now at least) because
+     PROCESSOR_POWERPC, PROCESSOR_POWERPC64, and PROCESSOR_COMMON
+     are #define'd as some of these.  Untangling that is a job for later.  */
+
+  /* 600 series and 700 series, "classic" */
+  if (rs6000_cpu == PROCESSOR_PPC601 || rs6000_cpu == PROCESSOR_PPC603
+      || rs6000_cpu == PROCESSOR_PPC604 || rs6000_cpu == PROCESSOR_PPC604e
+      || rs6000_cpu == PROCESSOR_PPC750)
+    return "ppc";
+#endif
 
-    case PROCESSOR_PPCE6500:
-      return "e6500";
+  /* Classic with AltiVec, "G4" */
+  if (rs6000_cpu == PROCESSOR_PPC7400 || rs6000_cpu == PROCESSOR_PPC7450)
+    return "\"7450\"";
 
-    default:
-      break;
-    }
+#if 0
+  /* The older 64-bit CPUs */
+  if (rs6000_cpu == PROCESSOR_PPC620 || rs6000_cpu == PROCESSOR_PPC630
+      || rs6000_cpu == PROCESSOR_RS64A)
+    return "ppc64";
+#endif
 
   HOST_WIDE_INT flags = rs6000_isa_flags;
 
@@ -25074,6 +25101,11 @@ rs6000_can_inline_p (tree caller, tree callee)
       else
 	caller_isa = rs6000_isa_flags;
 
+      /* Ignore -mpower8-fusion and -mpower10-fusion options for inlining
+	 purposes.  */
+      callee_isa &= ~(OPTION_MASK_P8_FUSION | OPTION_MASK_P10_FUSION);
+      explicit_isa &= ~(OPTION_MASK_P8_FUSION | OPTION_MASK_P10_FUSION);
+
       /* The callee's options must be a subset of the caller's options, i.e.
 	 a vsx function may inline an altivec function, but a no-vsx function
 	 must not inline a vsx function.  However, for those options that the
@@ -28000,28 +28032,6 @@ rs6000_invalid_conversion (const_tree fromtype, const_tree totype)
       if (tomode == OOmode)
 	return N_("invalid conversion to type %<__vector_pair%>");
     }
-  else if (POINTER_TYPE_P (fromtype) && POINTER_TYPE_P (totype))
-    {
-      /* We really care about the modes of the base types.  */
-      frommode = TYPE_MODE (TREE_TYPE (fromtype));
-      tomode = TYPE_MODE (TREE_TYPE (totype));
-
-      /* Do not allow conversions to/from XOmode and OOmode pointer
-	 types, except to/from void pointers.  */
-      if (frommode != tomode
-	  && frommode != VOIDmode
-	  && tomode != VOIDmode)
-	{
-	  if (frommode == XOmode)
-	    return N_("invalid conversion from type %<* __vector_quad%>");
-	  if (tomode == XOmode)
-	    return N_("invalid conversion to type %<* __vector_quad%>");
-	  if (frommode == OOmode)
-	    return N_("invalid conversion from type %<* __vector_pair%>");
-	  if (tomode == OOmode)
-	    return N_("invalid conversion to type %<* __vector_pair%>");
-	}
-    }
 
   /* Conversion allowed.  */
   return NULL;
diff --git a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
index 4ca6372435d..3b3dea5114a 100644
--- a/gcc/config/rs6000/rs6000.h
+++ b/gcc/config/rs6000/rs6000.h
@@ -81,12 +81,15 @@
 # define SUBTARGET_DRIVER_SELF_SPECS ""
 #endif
 
-/* Only for use in the testsuite: -mdejagnu-cpu= simply overrides -mcpu=.
+/* Only for use in the testsuite: -mdejagnu-cpu=<value> filters out all
+   -mcpu= as well as -mtune= options then simply adds -mcpu=<value>,
+   while -mdejagnu-tune=<value> filters out all -mtune= options then
+   simply adds -mtune=<value>.
    With older versions of Dejagnu the command line arguments you set in
-   RUNTESTFLAGS override those set in the testcases; with this option,
-   the testcase will always win.  Ditto for -mdejagnu-tune=.  */
+   RUNTESTFLAGS override those set in the testcases; with these options,
+   the testcase will always win.  */
 #define DRIVER_SELF_SPECS \
-  "%{mdejagnu-cpu=*: %<mcpu=* -mcpu=%*}", \
+  "%{mdejagnu-cpu=*: %<mcpu=* %<mtune=* -mcpu=%*}", \
   "%{mdejagnu-tune=*: %<mtune=* -mtune=%*}", \
   "%{mdejagnu-*: %<mdejagnu-*}", \
    SUBTARGET_DRIVER_SELF_SPECS
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index a4a7d105f5e..4ef392ebe7b 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -835,8 +835,8 @@
 ;; complex forms.  Basic data transfer is done later.
 
 (define_insn "zero_extendqi<mode>2"
-  [(set (match_operand:EXTQI 0 "gpc_reg_operand" "=r,r,^wa,^v")
-	(zero_extend:EXTQI (match_operand:QI 1 "reg_or_mem_operand" "m,r,Z,v")))]
+  [(set (match_operand:EXTQI 0 "gpc_reg_operand" "=r,r,wa,^v")
+	(zero_extend:EXTQI (match_operand:QI 1 "reg_or_mem_operand" "m,r,?Z,v")))]
   ""
   "@
    lbz%U1%X1 %0,%1
@@ -889,8 +889,8 @@
 
 
 (define_insn "zero_extendhi<mode>2"
-  [(set (match_operand:EXTHI 0 "gpc_reg_operand" "=r,r,^wa,^v")
-	(zero_extend:EXTHI (match_operand:HI 1 "reg_or_mem_operand" "m,r,Z,v")))]
+  [(set (match_operand:EXTHI 0 "gpc_reg_operand" "=r,r,wa,^v")
+	(zero_extend:EXTHI (match_operand:HI 1 "reg_or_mem_operand" "m,r,?Z,v")))]
   ""
   "@
    lhz%U1%X1 %0,%1
@@ -944,7 +944,7 @@
 
 (define_insn "zero_extendsi<mode>2"
   [(set (match_operand:EXTSI 0 "gpc_reg_operand" "=r,r,d,wa,wa,r,wa")
-	(zero_extend:EXTSI (match_operand:SI 1 "reg_or_mem_operand" "m,r,Z,Z,r,wa,wa")))]
+	(zero_extend:EXTSI (match_operand:SI 1 "reg_or_mem_operand" "m,r,?Z,?Z,r,wa,wa")))]
   ""
   "@
    lwz%U1%X1 %0,%1
@@ -7312,7 +7312,7 @@
   [(set (match_operand:SI 0 "nonimmediate_operand"
 	  "=r,         r,
 	   r,          d,          v,
-	   m,          Z,          Z,
+	   m,          ?Z,         ?Z,
 	   r,          r,          r,          r,
 	   wa,         wa,         wa,         v,
 	   wa,         v,          v,
@@ -7320,7 +7320,7 @@
 	   r,          *h,         *h")
 	(match_operand:SI 1 "input_operand"
 	  "r,          U,
-	   m,          Z,          Z,
+	   m,          ?Z,         ?Z,
 	   r,          d,          v,
 	   I,          L,          eI,         n,
 	   wa,         O,          wM,         wB,
@@ -7601,11 +7601,11 @@
 ;;		MTVSRWZ     MF%1       MT%1       NOP
 (define_insn "*mov<mode>_internal"
   [(set (match_operand:QHI 0 "nonimmediate_operand"
-		"=r,        r,         wa,        m,         Z,         r,
+		"=r,        r,         wa,        m,         ?Z,        r,
 		 wa,        wa,        wa,        v,         ?v,        r,
 		 wa,        r,         *c*l,      *h")
 	(match_operand:QHI 1 "input_operand"
-		"r,         m,         Z,         r,         wa,        i,
+		"r,         m,         ?Z,        r,         wa,        i,
 		 wa,        O,         wM,        wB,        wS,        wa,
 		 r,         *h,        r,         0"))]
   "gpc_reg_operand (operands[0], <MODE>mode)
@@ -7784,10 +7784,10 @@
 ;;	FMR          MR         MT%0       MF%1       NOP
 (define_insn "movsd_hardfloat"
   [(set (match_operand:SD 0 "nonimmediate_operand"
-	 "=!r,       d,         m,         Z,         ?d,        ?r,
+	 "=!r,       d,         m,         ?Z,        ?d,        ?r,
 	  f,         !r,        *c*l,      !r,        *h")
 	(match_operand:SD 1 "input_operand"
-	 "m,         Z,         r,         wx,        r,         d,
+	 "m,         ?Z,        r,         wx,        r,         d,
 	  f,         r,         r,         *h,        0"))]
   "(register_operand (operands[0], SDmode)
    || register_operand (operands[1], SDmode))
diff --git a/gcc/config/rs6000/rtems.h b/gcc/config/rs6000/rtems.h
index 872cc2849af..2a064bfad19 100644
--- a/gcc/config/rs6000/rtems.h
+++ b/gcc/config/rs6000/rtems.h
@@ -23,6 +23,9 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
+/* Undef gnu-user.h macro we don't want.  */
+#undef CPLUSPLUS_CPP_SPEC
+
 /* Copy and paste from linux64.h and freebsd64.h */
 #ifdef IN_LIBGCC2
 #undef TARGET_64BIT
@@ -252,7 +255,8 @@
 %{mcpu=821:  %{!Dppc*: %{!Dmpc*: -Dmpc821}  } } \
 %{mcpu=860:  %{!Dppc*: %{!Dmpc*: -Dmpc860}  } } \
 %{mcpu=8540: %{!Dppc*: %{!Dmpc*: -Dppc8540}  } } \
-%{mcpu=e6500: -D__PPC_CPU_E6500__}"
+%{mcpu=e6500: -D__PPC_CPU_E6500__} \
+%{mvrsave: -D__PPC_VRSAVE__}"
 
 #undef	ASM_SPEC
 #define	ASM_SPEC "%{!m64:%(asm_spec32)}%{m64:%(asm_spec64)} %(asm_spec_common)"
diff --git a/gcc/config/rs6000/smmintrin.h b/gcc/config/rs6000/smmintrin.h
index bdf6eb365d8..9d9df7842ba 100644
--- a/gcc/config/rs6000/smmintrin.h
+++ b/gcc/config/rs6000/smmintrin.h
@@ -45,31 +45,31 @@
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi8 (__m128i const __A, int const __D, int const __N)
 {
-  __v16qi result = (__v16qi)__A;
+  __v16qi __result = (__v16qi)__A;
 
-  result [__N & 0xf] = __D;
+  __result [__N & 0xf] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi32 (__m128i const __A, int const __D, int const __N)
 {
-  __v4si result = (__v4si)__A;
+  __v4si __result = (__v4si)__A;
 
-  result [__N & 3] = __D;
+  __result [__N & 3] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi64 (__m128i const __A, long long const __D, int const __N)
 {
-  __v2di result = (__v2di)__A;
+  __v2di __result = (__v2di)__A;
 
-  result [__N & 1] = __D;
+  __result [__N & 1] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/t-rtems b/gcc/config/rs6000/t-rtems
index 1ca3f0b1599..041d455ebb8 100644
--- a/gcc/config/rs6000/t-rtems
+++ b/gcc/config/rs6000/t-rtems
@@ -36,6 +36,9 @@ MULTILIB_DIRNAMES += nof
 MULTILIB_OPTIONS += mno-altivec
 MULTILIB_DIRNAMES += noaltivec
 
+MULTILIB_OPTIONS += mvrsave
+MULTILIB_DIRNAMES += vrsave
+
 MULTILIB_MATCHES  	+= ${MULTILIB_MATCHES_ENDIAN}
 MULTILIB_MATCHES	+= ${MULTILIB_MATCHES_SYSV}
 # Map 405 to 403
@@ -70,5 +73,7 @@ MULTILIB_REQUIRED += mcpu=7400/msoft-float
 MULTILIB_REQUIRED += mcpu=8540/msoft-float
 MULTILIB_REQUIRED += mcpu=860
 MULTILIB_REQUIRED += mcpu=e6500/m32
+MULTILIB_REQUIRED += mcpu=e6500/m32/mvrsave
 MULTILIB_REQUIRED += mcpu=e6500/m32/msoft-float/mno-altivec
 MULTILIB_REQUIRED += mcpu=e6500/m64
+MULTILIB_REQUIRED += mcpu=e6500/m64/mvrsave
diff --git a/gcc/config/rs6000/tmmintrin.h b/gcc/config/rs6000/tmmintrin.h
index 971511260b7..63e3f8a8262 100644
--- a/gcc/config/rs6000/tmmintrin.h
+++ b/gcc/config/rs6000/tmmintrin.h
@@ -112,8 +112,8 @@ _mm_alignr_epi8 (__m128i __A, __m128i __B, const unsigned int __count)
     {
       if (__count >= 32)
 	{
-	  const __v16qu zero = { 0 };
-	  return (__m128i) zero;
+	  const __v16qu __zero = { 0 };
+	  return (__m128i) __zero;
 	}
       else
 	{
diff --git a/gcc/config/rs6000/xmmintrin.h b/gcc/config/rs6000/xmmintrin.h
index ae1a33e8d95..ba311cbf2df 100644
--- a/gcc/config/rs6000/xmmintrin.h
+++ b/gcc/config/rs6000/xmmintrin.h
@@ -127,14 +127,14 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_loadr_ps (float const *__P)
 {
   __v4sf   __tmp;
-  __m128 result;
-  static const __vector unsigned char permute_vector =
+  __m128 __result;
+  static const __vector unsigned char __permute_vector =
     { 0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B, 0x14, 0x15, 0x16,
 	0x17, 0x10, 0x11, 0x12, 0x13 };
 
   __tmp = vec_ld (0, (__v4sf *) __P);
-  result = (__m128) vec_perm (__tmp, __tmp, permute_vector);
-  return result;
+  __result = (__m128) vec_perm (__tmp, __tmp, __permute_vector);
+  return __result;
 }
 
 /* Create a vector with all four elements equal to F.  */
@@ -184,11 +184,11 @@ extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artific
 _mm_storer_ps (float *__P, __m128 __A)
 {
   __v4sf   __tmp;
-  static const __vector unsigned char permute_vector =
+  static const __vector unsigned char __permute_vector =
     { 0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B, 0x14, 0x15, 0x16,
 	0x17, 0x10, 0x11, 0x12, 0x13 };
 
-  __tmp = (__m128) vec_perm (__A, __A, permute_vector);
+  __tmp = (__m128) vec_perm (__A, __A, __permute_vector);
 
   _mm_store_ps (__P, __tmp);
 }
@@ -218,9 +218,9 @@ _mm_set_ss (float __F)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_move_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
 
-  return (vec_sel ((__v4sf)__A, (__v4sf)__B, mask));
+  return (vec_sel ((__v4sf)__A, (__v4sf)__B, __mask));
 }
 
 /* Create a vector with element 0 as *P and the rest zero.  */
@@ -245,18 +245,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_add_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a + b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a + __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] + __B[0];
   return (__A);
@@ -267,18 +267,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_sub_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a - b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a - __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] - __B[0];
   return (__A);
@@ -289,18 +289,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_mul_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a * b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a * __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] * __B[0];
   return (__A);
@@ -311,18 +311,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_div_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a / b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a / __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] / __B[0];
   return (__A);
@@ -332,17 +332,17 @@ _mm_div_ss (__m128 __A, __m128 __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sqrt_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = vec_sqrt (a);
+  __a = vec_splat (__A, 0);
+  __c = vec_sqrt (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 /* Perform the respective operation on the four SPFP values in A and B.  */
@@ -391,81 +391,81 @@ _mm_rsqrt_ps (__m128 __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_rcp_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = _mm_rcp_ps (a);
+  __a = vec_splat (__A, 0);
+  __c = _mm_rcp_ps (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_rsqrt_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = vec_rsqrte (a);
+  __a = vec_splat (__A, 0);
+  __c = vec_rsqrte (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_ss (__m128 __A, __m128 __B)
 {
-  __v4sf a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __v4sf __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower float)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper float values) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf)__A, 0);
-  b = vec_splat ((__v4sf)__B, 0);
-  c = vec_min (a, b);
+  __a = vec_splat ((__v4sf)__A, 0);
+  __b = vec_splat ((__v4sf)__B, 0);
+  __c = vec_min (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel ((__v4sf)__A, c, mask));
+  return (vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_ss (__m128 __A, __m128 __B)
 {
-  __v4sf a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __v4sf __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower float)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper float values) we splat the lower float
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = vec_max (a, b);
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = vec_max (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel ((__v4sf)__A, c, mask));
+  return (vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_ps (__m128 __A, __m128 __B)
 {
-  __vector __bool int m = vec_cmpgt ((__v4sf) __B, (__v4sf) __A);
-  return vec_sel (__B, __A, m);
+  __vector __bool int __m = vec_cmpgt ((__v4sf) __B, (__v4sf) __A);
+  return vec_sel (__B, __A, __m);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_ps (__m128 __A, __m128 __B)
 {
-  __vector __bool int m = vec_cmpgt ((__v4sf) __A, (__v4sf) __B);
-  return vec_sel (__B, __A, m);
+  __vector __bool int __m = vec_cmpgt ((__v4sf) __A, (__v4sf) __B);
+  return vec_sel (__B, __A, __m);
 }
 
 /* Perform logical bit-wise operations on 128-bit values.  */
@@ -530,8 +530,8 @@ _mm_cmpge_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_ps (__m128  __A, __m128  __B)
 {
-  __v4sf temp = (__v4sf ) vec_cmpeq ((__v4sf) __A, (__v4sf)__B);
-  return ((__m128)vec_nor (temp, temp));
+  __v4sf __temp = (__v4sf ) vec_cmpeq ((__v4sf) __A, (__v4sf)__B);
+  return ((__m128)vec_nor (__temp, __temp));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -561,31 +561,31 @@ _mm_cmpnge_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_ps (__m128  __A, __m128  __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (float_exp_mask, a);
-  d = (__vector unsigned int) vec_cmpgt (float_exp_mask, b);
-  return ((__m128 ) vec_and (c, d));
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __a);
+  __d = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __b);
+  return ((__m128 ) vec_and (__c, __d));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_ps (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (a, float_exp_mask);
-  d = (__vector unsigned int) vec_cmpgt (b, float_exp_mask);
-  return ((__m128 ) vec_or (c, d));
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__a, __float_exp_mask);
+  __d = (__vector unsigned int) vec_cmpgt (__b, __float_exp_mask);
+  return ((__m128 ) vec_or (__c, __d));
 }
 
 /* Perform a comparison on the lower SPFP values of A and B.  If the
@@ -594,222 +594,222 @@ _mm_cmpunord_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpeq_ss (__m128  __A, __m128  __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpeq(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpeq (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmplt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmplt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmplt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmple_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmple(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmple(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpgt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpgt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpgt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpge_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpge(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpge(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpeq(a, b);
-  c = vec_nor (c, c);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpeq(__a, __b);
+  __c = vec_nor (__c, __c);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnlt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpge(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpge(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnle_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpgt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpgt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpngt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmple(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmple(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnge_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we do the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmplt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmplt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_ss (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (float_exp_mask, a);
-  d = (__vector unsigned int) vec_cmpgt (float_exp_mask, b);
-  c = vec_and (c, d);
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __a);
+  __d = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __b);
+  __c = vec_and (__c, __d);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)__c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_ss (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (a, float_exp_mask);
-  d = (__vector unsigned int) vec_cmpgt (b, float_exp_mask);
-  c = vec_or (c, d);
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__a, __float_exp_mask);
+  __d = (__vector unsigned int) vec_cmpgt (__b, __float_exp_mask);
+  __c = vec_or (__c, __d);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)__c, __mask));
 }
 
 /* Compare the lower SPFP values of A and B and return 1 if true
@@ -905,9 +905,9 @@ _mm_cvtss_f32 (__m128 __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtss_si32 (__m128 __A)
 {
-  int res;
+  int __res;
 #ifdef _ARCH_PWR8
-  double dtmp;
+  double __dtmp;
   __asm__(
 #ifdef __LITTLE_ENDIAN__
       "xxsldwi %x0,%x0,%x0,3;\n"
@@ -916,13 +916,13 @@ _mm_cvtss_si32 (__m128 __A)
       "fctiw  %2,%2;\n"
       "mfvsrd  %1,%x2;\n"
       : "+wa" (__A),
-        "=r" (res),
-        "=f" (dtmp)
+        "=r" (__res),
+        "=f" (__dtmp)
       : );
 #else
-  res = __builtin_rint(__A[0]);
+  __res = __builtin_rint(__A[0]);
 #endif
-  return (res);
+  return __res;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -938,9 +938,9 @@ _mm_cvt_ss2si (__m128 __A)
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtss_si64 (__m128 __A)
 {
-  long long res;
+  long long __res;
 #if defined (_ARCH_PWR8) && defined (__powerpc64__)
-  double dtmp;
+  double __dtmp;
   __asm__(
 #ifdef __LITTLE_ENDIAN__
       "xxsldwi %x0,%x0,%x0,3;\n"
@@ -949,13 +949,13 @@ _mm_cvtss_si64 (__m128 __A)
       "fctid  %2,%2;\n"
       "mfvsrd  %1,%x2;\n"
       : "+wa" (__A),
-        "=r" (res),
-        "=f" (dtmp)
+        "=r" (__res),
+        "=f" (__dtmp)
       : );
 #else
-  res = __builtin_llrint(__A[0]);
+  __res = __builtin_llrint(__A[0]);
 #endif
-  return (res);
+  return __res;
 }
 
 /* Microsoft intrinsic.  */
@@ -992,15 +992,15 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cvtps_pi32 (__m128 __A)
 {
   /* Splat two lower SPFP values to both halves.  */
-  __v4sf temp, rounded;
-  __vector unsigned long long result;
+  __v4sf __temp, __rounded;
+  __vector unsigned long long __result;
 
   /* Splat two lower SPFP values to both halves.  */
-  temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
-  rounded = vec_rint(temp);
-  result = (__vector unsigned long long) vec_cts (rounded, 0);
+  __temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
+  __rounded = vec_rint (__temp);
+  __result = (__vector unsigned long long) vec_cts (__rounded, 0);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1014,9 +1014,9 @@ extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artifici
 _mm_cvttss_si32 (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1030,9 +1030,9 @@ extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __ar
 _mm_cvttss_si64 (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 /* Microsoft intrinsic.  */
@@ -1040,9 +1040,9 @@ extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __ar
 _mm_cvttss_si64x (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 /* Truncate the two lower SPFP values to 32-bit integers.  Return the
@@ -1050,14 +1050,14 @@ _mm_cvttss_si64x (__m128 __A)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttps_pi32 (__m128 __A)
 {
-  __v4sf temp;
-  __vector unsigned long long result;
+  __v4sf __temp;
+  __vector unsigned long long __result;
 
   /* Splat two lower SPFP values to both halves.  */
-  temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
-  result = (__vector unsigned long long) vec_cts (temp, 0);
+  __temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
+  __result = (__vector unsigned long long) vec_cts (__temp, 0);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1070,8 +1070,8 @@ _mm_cvtt_ps2pi (__m128 __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi32_ss (__m128 __A, int __B)
 {
-  float temp = __B;
-  __A[0] = temp;
+  float __temp = __B;
+  __A[0] = __temp;
 
   return __A;
 }
@@ -1087,8 +1087,8 @@ _mm_cvt_si2ss (__m128 __A, int __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi64_ss (__m128 __A, long long __B)
 {
-  float temp = __B;
-  __A[0] = temp;
+  float __temp = __B;
+  __A[0] = __temp;
 
   return __A;
 }
@@ -1105,14 +1105,14 @@ _mm_cvtsi64x_ss (__m128 __A, long long __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32_ps (__m128        __A, __m64        __B)
 {
-  __vector signed int vm1;
-  __vector float vf1;
+  __vector signed int __vm1;
+  __vector float __vf1;
 
-  vm1 = (__vector signed int) (__vector unsigned long long) {__B, __B};
-  vf1 = (__vector float) vec_ctf (vm1, 0);
+  __vm1 = (__vector signed int) (__vector unsigned long long) {__B, __B};
+  __vf1 = (__vector float) vec_ctf (__vm1, 0);
 
   return ((__m128) (__vector unsigned long long)
-    { ((__vector unsigned long long)vf1) [0],
+    { ((__vector unsigned long long)__vf1) [0],
 	((__vector unsigned long long)__A) [1]});
 }
 
@@ -1126,54 +1126,54 @@ _mm_cvt_pi2ps (__m128 __A, __m64 __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi16_ps (__m64 __A)
 {
-  __vector signed short vs8;
-  __vector signed int vi4;
-  __vector float vf1;
+  __vector signed short __vs8;
+  __vector signed int __vi4;
+  __vector float __vf1;
 
-  vs8 = (__vector signed short) (__vector unsigned long long) { __A, __A };
-  vi4 = vec_vupklsh (vs8);
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vs8 = (__vector signed short) (__vector unsigned long long) { __A, __A };
+  __vi4 = vec_vupklsh (__vs8);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the four unsigned 16-bit values in A to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpu16_ps (__m64 __A)
 {
-  const __vector unsigned short zero =
+  const __vector unsigned short __zero =
     { 0, 0, 0, 0, 0, 0, 0, 0 };
-  __vector unsigned short vs8;
-  __vector unsigned int vi4;
-  __vector float vf1;
+  __vector unsigned short __vs8;
+  __vector unsigned int __vi4;
+  __vector float __vf1;
 
-  vs8 = (__vector unsigned short) (__vector unsigned long long) { __A, __A };
-  vi4 = (__vector unsigned int) vec_mergel
+  __vs8 = (__vector unsigned short) (__vector unsigned long long) { __A, __A };
+  __vi4 = (__vector unsigned int) vec_mergel
 #ifdef __LITTLE_ENDIAN__
-                                           (vs8, zero);
+                                           (__vs8, __zero);
 #else
-                                           (zero, vs8);
+                                           (__zero, __vs8);
 #endif
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the low four signed 8-bit values in A to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi8_ps (__m64 __A)
 {
-  __vector signed char vc16;
-  __vector signed short vs8;
-  __vector signed int vi4;
-  __vector float vf1;
+  __vector signed char __vc16;
+  __vector signed short __vs8;
+  __vector signed int __vi4;
+  __vector float __vf1;
 
-  vc16 = (__vector signed char) (__vector unsigned long long) { __A, __A };
-  vs8 = vec_vupkhsb (vc16);
-  vi4 = vec_vupkhsh (vs8);
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vc16 = (__vector signed char) (__vector unsigned long long) { __A, __A };
+  __vs8 = vec_vupkhsb (__vc16);
+  __vi4 = vec_vupkhsh (__vs8);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the low four unsigned 8-bit values in A to SPFP form.  */
@@ -1181,70 +1181,70 @@ extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __art
 
 _mm_cvtpu8_ps (__m64  __A)
 {
-  const __vector unsigned char zero =
+  const __vector unsigned char __zero =
     { 0, 0, 0, 0, 0, 0, 0, 0 };
-  __vector unsigned char vc16;
-  __vector unsigned short vs8;
-  __vector unsigned int vi4;
-  __vector float vf1;
+  __vector unsigned char __vc16;
+  __vector unsigned short __vs8;
+  __vector unsigned int __vi4;
+  __vector float __vf1;
 
-  vc16 = (__vector unsigned char) (__vector unsigned long long) { __A, __A };
+  __vc16 = (__vector unsigned char) (__vector unsigned long long) { __A, __A };
 #ifdef __LITTLE_ENDIAN__
-  vs8 = (__vector unsigned short) vec_mergel (vc16, zero);
-  vi4 = (__vector unsigned int) vec_mergeh (vs8,
-					    (__vector unsigned short) zero);
+  __vs8 = (__vector unsigned short) vec_mergel (__vc16, __zero);
+  __vi4 = (__vector unsigned int) vec_mergeh (__vs8,
+					    (__vector unsigned short) __zero);
 #else
-  vs8 = (__vector unsigned short) vec_mergel (zero, vc16);
-  vi4 = (__vector unsigned int) vec_mergeh ((__vector unsigned short) zero,
-                                            vs8);
+  __vs8 = (__vector unsigned short) vec_mergel (__zero, __vc16);
+  __vi4 = (__vector unsigned int) vec_mergeh ((__vector unsigned short) __zero,
+                                            __vs8);
 #endif
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the four signed 32-bit values in A and B to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32x2_ps (__m64 __A, __m64 __B)
 {
-  __vector signed int vi4;
-  __vector float vf4;
+  __vector signed int __vi4;
+  __vector float __vf4;
 
-  vi4 = (__vector signed int) (__vector unsigned long long) { __A, __B };
-  vf4 = (__vector float) vec_ctf (vi4, 0);
-  return (__m128) vf4;
+  __vi4 = (__vector signed int) (__vector unsigned long long) { __A, __B };
+  __vf4 = (__vector float) vec_ctf (__vi4, 0);
+  return (__m128) __vf4;
 }
 
 /* Convert the four SPFP values in A to four signed 16-bit integers.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_pi16 (__m128 __A)
 {
-  __v4sf rounded;
-  __vector signed int temp;
-  __vector unsigned long long result;
+  __v4sf __rounded;
+  __vector signed int __temp;
+  __vector unsigned long long __result;
 
-  rounded = vec_rint(__A);
-  temp = vec_cts (rounded, 0);
-  result = (__vector unsigned long long) vec_pack (temp, temp);
+  __rounded = vec_rint(__A);
+  __temp = vec_cts (__rounded, 0);
+  __result = (__vector unsigned long long) vec_pack (__temp, __temp);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 /* Convert the four SPFP values in A to four signed 8-bit integers.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_pi8 (__m128 __A)
 {
-  __v4sf rounded;
-  __vector signed int tmp_i;
-  static const __vector signed int zero = {0, 0, 0, 0};
-  __vector signed short tmp_s;
-  __vector signed char res_v;
+  __v4sf __rounded;
+  __vector signed int __tmp_i;
+  static const __vector signed int __zero = {0, 0, 0, 0};
+  __vector signed short __tmp_s;
+  __vector signed char __res_v;
 
-  rounded = vec_rint(__A);
-  tmp_i = vec_cts (rounded, 0);
-  tmp_s = vec_pack (tmp_i, zero);
-  res_v = vec_pack (tmp_s, tmp_s);
-  return (__m64) ((__vector long long) res_v)[0];
+  __rounded = vec_rint(__A);
+  __tmp_i = vec_cts (__rounded, 0);
+  __tmp_s = vec_pack (__tmp_i, __zero);
+  __res_v = vec_pack (__tmp_s, __tmp_s);
+  return (__m64) ((__vector long long) __res_v)[0];
 }
 
 /* Selects four specific SPFP values from A and B based on MASK.  */
@@ -1252,11 +1252,11 @@ extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __art
 
 _mm_shuffle_ps (__m128  __A, __m128  __B, int const __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned int permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned int __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
       0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C
@@ -1264,13 +1264,13 @@ _mm_shuffle_ps (__m128  __A, __m128  __B, int const __mask)
       0x00010203, 0x04050607, 0x08090A0B, 0x0C0D0E0F
 #endif
     };
-  __vector unsigned int t;
+  __vector unsigned int __t;
 
-  t[0] = permute_selectors[element_selector_10];
-  t[1] = permute_selectors[element_selector_32];
-  t[2] = permute_selectors[element_selector_54] + 0x10101010;
-  t[3] = permute_selectors[element_selector_76] + 0x10101010;
-  return vec_perm ((__v4sf) __A, (__v4sf)__B, (__vector unsigned char)t);
+  __t[0] = __permute_selectors[__element_selector_10];
+  __t[1] = __permute_selectors[__element_selector_32];
+  __t[2] = __permute_selectors[__element_selector_54] + 0x10101010;
+  __t[3] = __permute_selectors[__element_selector_76] + 0x10101010;
+  return vec_perm ((__v4sf) __A, (__v4sf)__B, (__vector unsigned char)__t);
 }
 
 /* Selects and interleaves the upper two SPFP values from A and B.  */
@@ -1352,8 +1352,8 @@ _mm_storel_pi (__m64 *__P, __m128 __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_ps (__m128  __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned int perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned int __perm_mask =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x00204060, 0x80808080, 0x80808080, 0x80808080
@@ -1362,14 +1362,14 @@ _mm_movemask_ps (__m128  __A)
 #endif
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -1391,12 +1391,12 @@ _mm_load_ps1 (float const *__P)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_extract_pi16 (__m64 const __A, int const __N)
 {
-  unsigned int shiftr = __N & 3;
+  unsigned int __shiftr = __N & 3;
 #ifdef __BIG_ENDIAN__
-  shiftr = 3 - shiftr;
+  __shiftr = 3 - __shiftr;
 #endif
 
-  return ((__A >> (shiftr * 16)) & 0xffff);
+  return ((__A >> (__shiftr * 16)) & 0xffff);
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1410,12 +1410,12 @@ _m_pextrw (__m64 const __A, int const __N)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_pi16 (__m64 const __A, int const __D, int const __N)
 {
-  const int shiftl = (__N & 3) * 16;
-  const __m64 shiftD = (const __m64) __D << shiftl;
-  const __m64 mask = 0xffffUL << shiftl;
-  __m64 result = (__A & (~mask)) | (shiftD & mask);
+  const int __shiftl = (__N & 3) * 16;
+  const __m64 __shiftD = (const __m64) __D << __shiftl;
+  const __m64 __mask = 0xffffUL << __shiftl;
+  __m64 __result = (__A & (~__mask)) | (__shiftD & __mask);
 
-  return (result);
+  return __result;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1430,30 +1430,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_max_pi16 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, r;
-  __vector __bool short c;
-
-  a = (__vector signed short)vec_splats (__A);
-  b = (__vector signed short)vec_splats (__B);
-  c = (__vector __bool short)vec_cmpgt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __vector signed short __a, __b, __r;
+  __vector __bool short __c;
+
+  __a = (__vector signed short)vec_splats (__A);
+  __b = (__vector signed short)vec_splats (__B);
+  __c = (__vector __bool short)vec_cmpgt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __m1, __m2, __res;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
-  res.as_short[0] =
-      (m1.as_short[0] > m2.as_short[0]) ? m1.as_short[0] : m2.as_short[0];
-  res.as_short[1] =
-      (m1.as_short[1] > m2.as_short[1]) ? m1.as_short[1] : m2.as_short[1];
-  res.as_short[2] =
-      (m1.as_short[2] > m2.as_short[2]) ? m1.as_short[2] : m2.as_short[2];
-  res.as_short[3] =
-      (m1.as_short[3] > m2.as_short[3]) ? m1.as_short[3] : m2.as_short[3];
+  __res.as_short[0] =
+      (__m1.as_short[0] > __m2.as_short[0]) ? __m1.as_short[0] : __m2.as_short[0];
+  __res.as_short[1] =
+      (__m1.as_short[1] > __m2.as_short[1]) ? __m1.as_short[1] : __m2.as_short[1];
+  __res.as_short[2] =
+      (__m1.as_short[2] > __m2.as_short[2]) ? __m1.as_short[2] : __m2.as_short[2];
+  __res.as_short[3] =
+      (__m1.as_short[3] > __m2.as_short[3]) ? __m1.as_short[3] : __m2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1468,28 +1468,27 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_max_pu8 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, r;
-  __vector __bool char c;
-
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = (__vector __bool char)vec_cmpgt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __vector unsigned char __a, __b, __r;
+  __vector __bool char __c;
+
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = (__vector __bool char)vec_cmpgt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
-  long i;
+  __m64_union __m1, __m2, __res;
+  long __i;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
+  for (__i = 0; __i < 8; __i++)
+    __res.as_char[__i] =
+      ((unsigned char) __m1.as_char[__i] > (unsigned char) __m2.as_char[__i]) ?
+	  __m1.as_char[__i] : __m2.as_char[__i];
 
-  for (i = 0; i < 8; i++)
-  res.as_char[i] =
-      ((unsigned char) m1.as_char[i] > (unsigned char) m2.as_char[i]) ?
-	  m1.as_char[i] : m2.as_char[i];
-
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1504,30 +1503,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_min_pi16 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, r;
-  __vector __bool short c;
-
-  a = (__vector signed short)vec_splats (__A);
-  b = (__vector signed short)vec_splats (__B);
-  c = (__vector __bool short)vec_cmplt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __vector signed short __a, __b, __r;
+  __vector __bool short __c;
+
+  __a = (__vector signed short)vec_splats (__A);
+  __b = (__vector signed short)vec_splats (__B);
+  __c = (__vector __bool short)vec_cmplt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __m1, __m2, __res;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
-  res.as_short[0] =
-      (m1.as_short[0] < m2.as_short[0]) ? m1.as_short[0] : m2.as_short[0];
-  res.as_short[1] =
-      (m1.as_short[1] < m2.as_short[1]) ? m1.as_short[1] : m2.as_short[1];
-  res.as_short[2] =
-      (m1.as_short[2] < m2.as_short[2]) ? m1.as_short[2] : m2.as_short[2];
-  res.as_short[3] =
-      (m1.as_short[3] < m2.as_short[3]) ? m1.as_short[3] : m2.as_short[3];
+  __res.as_short[0] =
+      (__m1.as_short[0] < __m2.as_short[0]) ? __m1.as_short[0] : __m2.as_short[0];
+  __res.as_short[1] =
+      (__m1.as_short[1] < __m2.as_short[1]) ? __m1.as_short[1] : __m2.as_short[1];
+  __res.as_short[2] =
+      (__m1.as_short[2] < __m2.as_short[2]) ? __m1.as_short[2] : __m2.as_short[2];
+  __res.as_short[3] =
+      (__m1.as_short[3] < __m2.as_short[3]) ? __m1.as_short[3] : __m2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1542,28 +1541,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_min_pu8 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, r;
-  __vector __bool char c;
-
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = (__vector __bool char)vec_cmplt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __vector unsigned char __a, __b, __r;
+  __vector __bool char __c;
+
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = (__vector __bool char)vec_cmplt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
-  long i;
+  __m64_union __m1, __m2, __res;
+  long __i;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
 
-  for (i = 0; i < 8; i++)
-  res.as_char[i] =
-      ((unsigned char) m1.as_char[i] < (unsigned char) m2.as_char[i]) ?
-	  m1.as_char[i] : m2.as_char[i];
+  for (__i = 0; __i < 8; __i++)
+    __res.as_char[__i] =
+      ((unsigned char) __m1.as_char[__i] < (unsigned char) __m2.as_char[__i]) ?
+	  __m1.as_char[__i] : __m2.as_char[__i];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1578,24 +1577,24 @@ extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artifici
 _mm_movemask_pi8 (__m64 __A)
 {
 #ifdef __powerpc64__
-  unsigned long long p =
+  unsigned long long __p =
 #ifdef __LITTLE_ENDIAN__
                          0x0008101820283038UL; // permute control for sign bits
 #else
                          0x3830282018100800UL; // permute control for sign bits
 #endif
-  return __builtin_bpermd (p, __A);
+  return __builtin_bpermd (__p, __A);
 #else
 #ifdef __LITTLE_ENDIAN__
-  unsigned int mask = 0x20283038UL;
-  unsigned int r1 = __builtin_bpermd (mask, __A) & 0xf;
-  unsigned int r2 = __builtin_bpermd (mask, __A >> 32) & 0xf;
+  unsigned int __mask = 0x20283038UL;
+  unsigned int __r1 = __builtin_bpermd (__mask, __A) & 0xf;
+  unsigned int __r2 = __builtin_bpermd (__mask, __A >> 32) & 0xf;
 #else
-  unsigned int mask = 0x38302820UL;
-  unsigned int r1 = __builtin_bpermd (mask, __A >> 32) & 0xf;
-  unsigned int r2 = __builtin_bpermd (mask, __A) & 0xf;
+  unsigned int __mask = 0x38302820UL;
+  unsigned int __r1 = __builtin_bpermd (__mask, __A >> 32) & 0xf;
+  unsigned int __r2 = __builtin_bpermd (__mask, __A) & 0xf;
 #endif
-  return (r2 << 4) | r1;
+  return (__r2 << 4) | __r1;
 #endif
 }
 
@@ -1610,10 +1609,10 @@ _m_pmovmskb (__m64 __A)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_pu16 (__m64 __A, __m64 __B)
 {
-  __vector unsigned short a, b;
-  __vector unsigned short c;
-  __vector unsigned int w0, w1;
-  __vector unsigned char xform1 = {
+  __vector unsigned short __a, __b;
+  __vector unsigned short __c;
+  __vector unsigned int __w0, __w1;
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1623,14 +1622,14 @@ _mm_mulhi_pu16 (__m64 __A, __m64 __B)
 #endif
     };
 
-  a = (__vector unsigned short)vec_splats (__A);
-  b = (__vector unsigned short)vec_splats (__B);
+  __a = (__vector unsigned short)vec_splats (__A);
+  __b = (__vector unsigned short)vec_splats (__B);
 
-  w0 = vec_vmuleuh (a, b);
-  w1 = vec_vmulouh (a, b);
-  c = (__vector unsigned short)vec_perm (w0, w1, xform1);
+  __w0 = vec_vmuleuh (__a, __b);
+  __w1 = vec_vmulouh (__a, __b);
+  __c = (__vector unsigned short)vec_perm (__w0, __w1, __xform1);
 
-  return (__m64) ((__vector long long) c)[0];
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1644,11 +1643,11 @@ _m_pmulhuw (__m64 __A, __m64 __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_pi16 (__m64 __A, int const __N)
 {
-  unsigned long element_selector_10 = __N & 0x03;
-  unsigned long element_selector_32 = (__N >> 2) & 0x03;
-  unsigned long element_selector_54 = (__N >> 4) & 0x03;
-  unsigned long element_selector_76 = (__N >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_10 = __N & 0x03;
+  unsigned long __element_selector_32 = (__N >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__N >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__N >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0908, 0x0B0A, 0x0D0C, 0x0F0E
@@ -1656,24 +1655,24 @@ _mm_shuffle_pi16 (__m64 __A, int const __N)
 	      0x0607, 0x0405, 0x0203, 0x0001
 #endif
     };
-  __m64_union t;
-  __vector unsigned long long a, p, r;
+  __m64_union __t;
+  __vector unsigned long long __a, __p, __r;
 
 #ifdef __LITTLE_ENDIAN__
-  t.as_short[0] = permute_selectors[element_selector_10];
-  t.as_short[1] = permute_selectors[element_selector_32];
-  t.as_short[2] = permute_selectors[element_selector_54];
-  t.as_short[3] = permute_selectors[element_selector_76];
+  __t.as_short[0] = __permute_selectors[__element_selector_10];
+  __t.as_short[1] = __permute_selectors[__element_selector_32];
+  __t.as_short[2] = __permute_selectors[__element_selector_54];
+  __t.as_short[3] = __permute_selectors[__element_selector_76];
 #else
-  t.as_short[3] = permute_selectors[element_selector_10];
-  t.as_short[2] = permute_selectors[element_selector_32];
-  t.as_short[1] = permute_selectors[element_selector_54];
-  t.as_short[0] = permute_selectors[element_selector_76];
+  __t.as_short[3] = __permute_selectors[__element_selector_10];
+  __t.as_short[2] = __permute_selectors[__element_selector_32];
+  __t.as_short[1] = __permute_selectors[__element_selector_54];
+  __t.as_short[0] = __permute_selectors[__element_selector_76];
 #endif
-  p = vec_splats (t.as_m64);
-  a = vec_splats (__A);
-  r = vec_perm (a, a, (__vector unsigned char)p);
-  return (__m64) ((__vector long long) r)[0];
+  __p = vec_splats (__t.as_m64);
+  __a = vec_splats (__A);
+  __r = vec_perm (__a, __a, (__vector unsigned char)__p);
+  return (__m64) ((__vector long long) __r)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1688,14 +1687,14 @@ _m_pshufw (__m64 __A, int const __N)
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
 {
-  __m64 hibit = 0x8080808080808080UL;
-  __m64 mask, tmp;
-  __m64 *p = (__m64*)__P;
+  __m64 __hibit = 0x8080808080808080UL;
+  __m64 __mask, __tmp;
+  __m64 *__p = (__m64*)__P;
 
-  tmp = *p;
-  mask = _mm_cmpeq_pi8 ((__N & hibit), hibit);
-  tmp = (tmp & (~mask)) | (__A & mask);
-  *p = tmp;
+  __tmp = *__p;
+  __mask = _mm_cmpeq_pi8 ((__N & __hibit), __hibit);
+  __tmp = (__tmp & (~__mask)) | (__A & __mask);
+  *__p = __tmp;
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1708,12 +1707,12 @@ _m_maskmovq (__m64 __A, __m64 __N, char *__P)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_avg_pu8 (__m64 __A, __m64 __B)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = vec_avg (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = vec_avg (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1726,12 +1725,12 @@ _m_pavgb (__m64 __A, __m64 __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_avg_pu16 (__m64 __A, __m64 __B)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__A);
-  b = (__vector unsigned short)vec_splats (__B);
-  c = vec_avg (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__A);
+  __b = (__vector unsigned short)vec_splats (__B);
+  __c = vec_avg (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1746,26 +1745,26 @@ _m_pavgw (__m64 __A, __m64 __B)
 extern __inline    __m64    __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sad_pu8 (__m64  __A, __m64  __B)
 {
-  __vector unsigned char a, b;
-  __vector unsigned char vmin, vmax, vabsdiff;
-  __vector signed int vsum;
-  const __vector unsigned int zero =
+  __vector unsigned char __a, __b;
+  __vector unsigned char __vmin, __vmax, __vabsdiff;
+  __vector signed int __vsum;
+  const __vector unsigned int __zero =
     { 0, 0, 0, 0 };
-  __m64_union result = {0};
+  __m64_union __result = {0};
 
-  a = (__vector unsigned char) (__vector unsigned long long) { 0UL, __A };
-  b = (__vector unsigned char) (__vector unsigned long long) { 0UL, __B };
-  vmin = vec_min (a, b);
-  vmax = vec_max (a, b);
-  vabsdiff = vec_sub (vmax, vmin);
+  __a = (__vector unsigned char) (__vector unsigned long long) { 0UL, __A };
+  __b = (__vector unsigned char) (__vector unsigned long long) { 0UL, __B };
+  __vmin = vec_min (__a, __b);
+  __vmax = vec_max (__a, __b);
+  __vabsdiff = vec_sub (__vmax, __vmin);
   /* Sum four groups of bytes into integers.  */
-  vsum = (__vector signed int) vec_sum4s (vabsdiff, zero);
+  __vsum = (__vector signed int) vec_sum4s (__vabsdiff, __zero);
   /* Sum across four integers with integer result.  */
-  vsum = vec_sums (vsum, (__vector signed int) zero);
+  __vsum = vec_sums (__vsum, (__vector signed int) __zero);
   /* The sum is in the right most 32-bits of the vector result.
      Transfer to a GPR and truncate to 16 bits.  */
-  result.as_short[0] = vsum[3];
-  return result.as_m64;
+  __result.as_short[0] = __vsum[3];
+  return __result.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 7c8a1f18c39..e4fe2f065c9 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -8956,8 +8956,20 @@ epilogue_renumber (rtx *where, int test)
       if (REGNO (*where) >= 8 && REGNO (*where) < 24)      /* oX or lX */
 	return 1;
       if (! test && REGNO (*where) >= 24 && REGNO (*where) < 32)
-	*where = gen_rtx_REG (GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));
-      /* fallthrough */
+	{
+	  if (ORIGINAL_REGNO (*where))
+	    {
+	      rtx n = gen_raw_REG (GET_MODE (*where),
+				   OUTGOING_REGNO (REGNO (*where)));
+	      ORIGINAL_REGNO (n) = ORIGINAL_REGNO (*where);
+	      *where = n;
+	    }
+	  else
+	    *where = gen_rtx_REG (GET_MODE (*where),
+				  OUTGOING_REGNO (REGNO (*where)));
+	}
+      return 0;
+
     case SCRATCH:
     case CC0:
     case PC:
@@ -13074,9 +13086,9 @@ sparc_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,
   if (!TARGET_VIS2)
     return false;
 
-  /* All permutes are supported.  */
+  /* All 8-byte permutes are supported.  */
   if (!target)
-    return true;
+    return GET_MODE_SIZE (vmode) == 8;
 
   /* Force target-independent code to convert constant permutations on other
      modes down to V8QI.  Rely on this to avoid the complexity of the byte
diff --git a/gcc/config/tilepro/gen-mul-tables.cc b/gcc/config/tilepro/gen-mul-tables.cc
index 03c0cfd5a8b..227bf086e8c 100644
--- a/gcc/config/tilepro/gen-mul-tables.cc
+++ b/gcc/config/tilepro/gen-mul-tables.cc
@@ -1190,11 +1190,11 @@ tilegx_emit (long long multiplier, int num_ops)
     long long next_pow10;
 
     while (((j * 10) < abs_multiplier)
-	   && (j < (INTMAX_MAX / 10)))
+	   && (j < (j * 10)))
       j = j * 10;
 
     prev_pow10 = j;
-    next_pow10 = (j > (INTMAX_MAX / 10)) ? 0 : j * 10;
+    next_pow10 = j * 10;
 
     if ((abs_multiplier - prev_pow10 <= 100)
 	|| (next_pow10
diff --git a/gcc/config/xtensa/xtensa.md b/gcc/config/xtensa/xtensa.md
index cdf22f14b94..fabc313197a 100644
--- a/gcc/config/xtensa/xtensa.md
+++ b/gcc/config/xtensa/xtensa.md
@@ -754,11 +754,14 @@
 	 because of offering further optimization opportunities.  */
       if (register_operand (operands[0], DImode))
 	{
-	  rtx first, second;
-
-	  split_double (operands[1], &first, &second);
-	  emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), first));
-	  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), second));
+	  rtx lowpart, highpart;
+
+	  if (TARGET_BIG_ENDIAN)
+	    split_double (operands[1], &highpart, &lowpart);
+	  else
+	    split_double (operands[1], &lowpart, &highpart);
+	  emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), lowpart));
+	  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), highpart));
 	  DONE;
 	}
 
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 85c8fdd38cd..92eb8fc1672 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,207 @@
+2022-07-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106361
+	* decl.c (move_fn_p): Remove assert.
+
+2022-07-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106024
+	* parser.c (cp_parser_lookup_name): Don't look in dependent lambda.
+
+2022-06-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105925
+	* decl.c (reshape_init_array_1): Set
+	CONSTRUCTOR_IS_DESIGNATED_INIT here.
+	(reshape_init_class): And here.
+
+2022-06-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105852
+	PR c++/105761
+	* decl.c (duplicate_decls): Avoid copying template info
+	from non-templated friend even if newdecl isn't a definition.
+	Correct handling of DECL_UNIQUE_FRIEND_P on templates.
+	* pt.c (non_templated_friend_p): New.
+	* cp-tree.h (non_templated_friend_p): Declare it.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105761
+	* decl.c (duplicate_decls): Don't copy DECL_TEMPLATE_INFO
+	from a hidden friend.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105795
+	* constexpr.c (cxx_eval_bare_aggregate): Always call
+	init_subob_ctx.
+
+2022-05-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102307
+	* decl.c (check_initializer): Use build_cplus_new in case of
+	constexpr failure.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101442
+	* decl.c (cp_finish_decl): Don't pass decl to push_cleanup.
+	* init.c (perform_member_init): Likewise.
+	* semantics.c (push_cleanup): Adjust comment.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101698
+	* pt.c (tsubst_baselink): Also check dependent optype.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65211
+	* pt.c (tsubst_decl) [TYPE_DECL]: Copy TYPE_ALIGN.
+
+2022-05-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-09-27  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102479
+	* pt.c (rewrite_template_parm): Handle single-level tsubst_args.
+	Avoid a tree cycle when assigning the DECL_TEMPLATE_PARMS for a
+	rewritten ttp.
+	(alias_ctad_tweaks): Set current_template_parms accordingly.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102300
+	* parser.c (cp_parser_template_name): Use dependent_scope_p.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102629
+	* pt.c (gen_elem_of_pack_expansion_instantiation): Clear
+	TEMPLATE_TYPE_PARAMETER_PACK on auto.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104646
+	* constexpr.c (maybe_save_constexpr_fundef): Don't do extra
+	checks for defaulted ctors.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82980
+	* lambda.c (type_deducible_expression_p): New.
+	(lambda_capture_field_type): Check it.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105265
+	PR c++/100838
+	* call.c (build_user_type_conversion_1): Drop
+	flag_elide_constructors check.
+	(convert_like_internal): Likewise.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105245
+	PR c++/100111
+	* constexpr.c (cxx_eval_store_expression): Build a CONSTRUCTOR
+	as needed in empty base handling.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104669
+	* decl.c (decls_match): Compare versions even if not recording.
+	(duplicate_decls): Propagate attributes to alias.
+	* decl2.c (find_last_decl): Give up if versioned.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102071
+	* init.c (build_new_1): Include cookie in alignment.  Omit
+	constexpr wrapper from alloc_call.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104142
+	* decl.c (check_initializer): Check TREE_SIDE_EFFECTS.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* lambda.c: Include decl.h.
+	(maybe_add_lambda_conv_op): Temporarily override deprecated_state to
+	DEPRECATED_SUPPRESS.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105386
+	* semantics.c (finish_decltype_type): Pass tf_decltype to
+	instantiate_non_dependent_expr_sfinae.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105289
+	PR c++/86193
+	* pt.c (process_partial_specialization): Downgrade "partial
+	specialization isn't more specialized" diagnostic from permerror
+	to an on-by-default pedwarn.
+	(unify) <case TEMPLATE_PARM_INDEX>: When substituting into the
+	NTTP type a second time, use the original type not the
+	substituted type.
+
+2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90107
+	* parser.c (cp_parser_class_specifier_1): Accept :: after a class
+	definition.
+
+2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105398
+	* pt.c (uses_template_parms): Return false for any NAMESPACE_DECL.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105321
+	* constexpr.c (cxx_eval_logical_expression): Always pass false for lval
+	to cxx_eval_constant_expression.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97296
+	* call.c (direct_reference_binding): strip_top_quals when creating
+	a ck_qual.
+
+2022-04-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2021-12-19  Matthias Kretz  <m.kretz@gsi.de>
+
+	* module.cc (trees_out::get_merge_kind): NAMESPACE_DECLs also
+	cannot have a DECL_TEMPLATE_INFO.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 55bb9c45f8c..46c2a066499 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -1683,8 +1683,19 @@ direct_reference_binding (tree type, conversion *conv)
        because the types "int *" and "const int *const" are
        reference-related and we were binding both directly and they
        had the same rank.  To break it up, we add a ck_qual under the
-       ck_ref_bind so that conversion sequence ranking chooses #1.  */
-    conv = build_conv (ck_qual, t, conv);
+       ck_ref_bind so that conversion sequence ranking chooses #1.
+
+       We strip_top_quals here which is also what standard_conversion
+       does.  Failure to do so would confuse comp_cv_qual_signature
+       into thinking that in
+
+	 void f(const int * const &); // #1
+	 void f(const int *); // #2
+	 int *x;
+	 f(x);
+
+       #2 is a better match than #1 even though they're ambiguous (97296).  */
+    conv = build_conv (ck_qual, strip_top_quals (t), conv);
 
   return build_conv (ck_ref_bind, type, conv);
 }
@@ -4117,7 +4128,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,
 	     We represent this in the conversion sequence with an
 	     rvalue conversion, which means a constructor call.  */
 	  if (!TYPE_REF_P (totype)
-	      && (flag_elide_constructors || (flags & LOOKUP_ONLYCONVERTING))
+	      && cxx_dialect < cxx17
+	      && (flags & LOOKUP_ONLYCONVERTING)
 	      && !(convflags & LOOKUP_NO_TEMP_BIND))
 	    cand->second_conv
 	      = build_conv (ck_rvalue, totype, cand->second_conv);
@@ -7804,13 +7816,10 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,
       break;
     };
 
-  tsubst_flags_t sub_complain = complain;
-  if (!flag_elide_constructors)
-    sub_complain &= ~tf_no_cleanup;
   expr = convert_like (next_conversion (convs), expr, fn, argnum,
 		       convs->kind == ck_ref_bind
 		       ? issue_conversion_warnings : false,
-		       c_cast_p, sub_complain);
+		       c_cast_p, complain & ~tf_no_cleanup);
   if (expr == error_mark_node)
     return error_mark_node;
 
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index c13c920ade3..7be5f25b10f 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -890,7 +890,7 @@ maybe_save_constexpr_fundef (tree fun)
   if (!potential && !DECL_GENERATED_P (fun))
     require_potential_rvalue_constant_expression (massaged);
 
-  if (DECL_CONSTRUCTOR_P (fun)
+  if (DECL_CONSTRUCTOR_P (fun) && !DECL_DEFAULTED_FN (fun)
       && cx_check_missing_mem_inits (DECL_CONTEXT (fun),
 				     massaged, !DECL_GENERATED_P (fun)))
     potential = false;
@@ -4280,19 +4280,18 @@ cxx_eval_bit_cast (const constexpr_ctx *ctx, tree t, bool *non_constant_p,
 static tree
 cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,
                              tree bailout_value, tree continue_value,
-			     bool lval,
-			     bool *non_constant_p, bool *overflow_p)
+			     bool, bool *non_constant_p, bool *overflow_p)
 {
   tree r;
   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),
-					   lval,
-					   non_constant_p, overflow_p);
+					   /*lval*/false, non_constant_p,
+					   overflow_p);
   VERIFY_CONSTANT (lhs);
   if (tree_int_cst_equal (lhs, bailout_value))
     return lhs;
   gcc_assert (tree_int_cst_equal (lhs, continue_value));
   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),
-				    lval, non_constant_p,
+				    /*lval*/false, non_constant_p,
 				    overflow_p);
   VERIFY_CONSTANT (r);
   return r;
@@ -4468,12 +4467,9 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,
       tree orig_value = value;
       /* Like in cxx_eval_store_expression, omit entries for empty fields.  */
       bool no_slot = TREE_CODE (type) == RECORD_TYPE && is_empty_field (index);
-      if (no_slot)
-	new_ctx = *ctx;
-      else
-	init_subob_ctx (ctx, new_ctx, index, value);
+      init_subob_ctx (ctx, new_ctx, index, value);
       int pos_hint = -1;
-      if (new_ctx.ctor != ctx->ctor)
+      if (new_ctx.ctor != ctx->ctor && !no_slot)
 	{
 	  /* If we built a new CONSTRUCTOR, attach it now so that other
 	     initializers can refer to it.  */
@@ -5579,6 +5575,12 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,
     {
       /* See above on initialization of empty bases.  */
       gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);
+      if (!*valp)
+	{
+	  /* But do make sure we have something in *valp.  */
+	  *valp = build_constructor (type, nullptr);
+	  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;
+	}
       return init;
     }
   else
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index a2d8c1c77b3..fded2527e5e 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -7242,6 +7242,7 @@ extern bool push_tinst_level_loc                (tree, location_t);
 extern bool push_tinst_level_loc                (tree, tree, location_t);
 extern void pop_tinst_level                     (void);
 extern struct tinst_level *outermost_tinst_level(void);
+extern bool non_templated_friend_p		(tree);
 extern void init_template_processing		(void);
 extern void print_template_statistics		(void);
 bool template_template_parameter_p		(const_tree);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index bffbd004167..514d4c1bc20 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -1059,11 +1059,14 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)
       if (types_match
 	  && !DECL_EXTERN_C_P (newdecl)
 	  && !DECL_EXTERN_C_P (olddecl)
-	  && record_versions
-	  && maybe_version_functions (newdecl, olddecl,
-				      (!DECL_FUNCTION_VERSIONED (newdecl)
-				       || !DECL_FUNCTION_VERSIONED (olddecl))))
-	return 0;
+	  && targetm.target_option.function_versions (newdecl, olddecl))
+	{
+	  if (record_versions)
+	    maybe_version_functions (newdecl, olddecl,
+				     (!DECL_FUNCTION_VERSIONED (newdecl)
+				      || !DECL_FUNCTION_VERSIONED (olddecl)));
+	  return 0;
+	}
     }
   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)
     {
@@ -2221,8 +2224,8 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
 	      check_no_redeclaration_friend_default_args
 		(old_result, new_result);
 	    }
-	  if (!DECL_UNIQUE_FRIEND_P (old_result))
-	    DECL_UNIQUE_FRIEND_P (new_result) = false;
+	  if (!DECL_UNIQUE_FRIEND_P (new_result))
+	    DECL_UNIQUE_FRIEND_P (old_result) = false;
 
 	  check_default_args (newdecl);
 
@@ -2523,7 +2526,12 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
       else
 	{
 	  retrofit_lang_decl (newdecl);
-	  DECL_LOCAL_DECL_ALIAS (newdecl) = DECL_LOCAL_DECL_ALIAS (olddecl);
+	  tree alias = DECL_LOCAL_DECL_ALIAS (newdecl)
+	    = DECL_LOCAL_DECL_ALIAS (olddecl);
+	  DECL_ATTRIBUTES (alias)
+	    = (*targetm.merge_decl_attributes) (alias, newdecl);
+	  if (TREE_CODE (newdecl) == FUNCTION_DECL)
+	    merge_attribute_bits (newdecl, alias);
 	}
     }
 
@@ -2581,7 +2589,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
 		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
 		  = TINFO_USED_TEMPLATE_ID (new_template_info);
 	    }
-	  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);
+
+	  if (non_templated_friend_p (olddecl))
+	    /* Don't copy tinfo from a non-templated friend (PR105761).  */;
+	  else
+	    DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);
 	}
 
       if (DECL_DECLARES_FUNCTION_P (newdecl))
@@ -6283,6 +6295,8 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,
       tree elt_init;
       constructor_elt *old_cur = d->cur;
 
+      if (d->cur->index)
+	CONSTRUCTOR_IS_DESIGNATED_INIT (new_init) = true;
       check_array_designated_initializer (d->cur, index);
       elt_init = reshape_init_r (elt_type, d,
 				 /*first_initializer_p=*/NULL_TREE,
@@ -6435,6 +6449,7 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,
 	    }
 	  else if (TREE_CODE (d->cur->index) == IDENTIFIER_NODE)
 	    {
+	      CONSTRUCTOR_IS_DESIGNATED_INIT (new_init) = true;
 	      field = get_class_binding (type, d->cur->index);
 	      direct_desig = true;
 	    }
@@ -7167,12 +7182,19 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)
 	      /* Declared constexpr or constinit, but no suitable initializer;
 		 massage init appropriately so we can pass it into
 		 store_init_value for the error.  */
-	      if (CLASS_TYPE_P (type)
-		  && (!init || TREE_CODE (init) == TREE_LIST))
+	      tree new_init = NULL_TREE;
+	      if (!processing_template_decl
+		  && TREE_CODE (init_code) == CALL_EXPR)
+		new_init = build_cplus_new (type, init_code, tf_none);
+	      else if (CLASS_TYPE_P (type)
+		       && (!init || TREE_CODE (init) == TREE_LIST))
+		new_init = build_functional_cast (input_location, type,
+						  init, tf_none);
+	      if (new_init)
 		{
-		  init = build_functional_cast (input_location, type,
-						init, tf_none);
-		  if (TREE_CODE (init) == TARGET_EXPR)
+		  init = new_init;
+		  if (TREE_CODE (init) == TARGET_EXPR
+		      && !(flags & LOOKUP_ONLYCONVERTING))
 		    TARGET_EXPR_DIRECT_INIT_P (init) = true;
 		}
 	      init_code = NULL_TREE;
@@ -7227,6 +7249,10 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)
   if (init && init != error_mark_node)
     init_code = build2 (INIT_EXPR, type, decl, init);
 
+  if (init_code && !TREE_SIDE_EFFECTS (init_code)
+      && init_code != error_mark_node)
+    init_code = NULL_TREE;
+
   if (init_code)
     {
       /* We might have set these in cp_finish_decl.  */
@@ -8300,7 +8326,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
     {
       unsigned i; tree t;
       FOR_EACH_VEC_ELT (*cleanups, i, t)
-	push_cleanup (decl, t, false);
+	push_cleanup (NULL_TREE, t, false);
       release_tree_vector (cleanups);
     }
 
@@ -14663,8 +14689,6 @@ copy_fn_p (const_tree d)
 bool
 move_fn_p (const_tree d)
 {
-  gcc_assert (DECL_FUNCTION_MEMBER_P (d));
-
   if (cxx_dialect == cxx98)
     /* There are no move constructors if we are in C++98 mode.  */
     return false;
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 885c4749989..c00508103e9 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -1531,8 +1531,16 @@ find_last_decl (tree decl)
 	  if (TREE_CODE (*iter) == OVERLOAD)
 	    continue;
 
-	  if (decls_match (decl, *iter, /*record_decls=*/false))
-	    return *iter;
+	  tree d = *iter;
+
+	  /* We can't compare versions in the middle of processing the
+	     attribute that has the version.  */
+	  if (TREE_CODE (d) == FUNCTION_DECL
+	      && DECL_FUNCTION_VERSIONED (d))
+	    return NULL_TREE;
+
+	  if (decls_match (decl, d, /*record_decls=*/false))
+	    return d;
 	}
       return NULL_TREE;
     }
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index bd27c92324b..f694c9a5776 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -911,7 +911,7 @@ perform_member_init (tree member, tree init)
       init = build2 (INIT_EXPR, type, decl, init);
       finish_expr_stmt (init);
       FOR_EACH_VEC_ELT (*cleanups, i, t)
-	push_cleanup (decl, t, false);
+	push_cleanup (NULL_TREE, t, false);
     }
   else if (type_build_ctor_call (type)
 	   || (init && CLASS_TYPE_P (strip_array_types (type))))
@@ -3079,7 +3079,13 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
 
   tree align_arg = NULL_TREE;
   if (type_has_new_extended_alignment (elt_type))
-    align_arg = build_int_cst (align_type_node, TYPE_ALIGN_UNIT (elt_type));
+    {
+      unsigned align = TYPE_ALIGN_UNIT (elt_type);
+      /* Also consider the alignment of the cookie, if any.  */
+      if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))
+	align = MAX (align, TYPE_ALIGN_UNIT (size_type_node));
+      align_arg = build_int_cst (align_type_node, align);
+    }
 
   alloc_fn = NULL_TREE;
 
@@ -3261,18 +3267,19 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
 	}
     }
 
+  alloc_expr = alloc_call;
   if (cookie_size)
-    alloc_call = maybe_wrap_new_for_constexpr (alloc_call, type,
+    alloc_expr = maybe_wrap_new_for_constexpr (alloc_call, type,
 					       cookie_size);
 
   /* In the simple case, we can stop now.  */
   pointer_type = build_pointer_type (type);
   if (!cookie_size && !is_initialized)
-    return build_nop (pointer_type, alloc_call);
+    return build_nop (pointer_type, alloc_expr);
 
   /* Store the result of the allocation call in a variable so that we can
      use it more than once.  */
-  alloc_expr = get_target_expr (alloc_call);
+  alloc_expr = get_target_expr (alloc_expr);
   alloc_node = TARGET_EXPR_SLOT (alloc_expr);
 
   /* Strip any COMPOUND_EXPRs from ALLOC_CALL.  */
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index d8efe91d9fe..1508e232091 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "toplev.h"
 #include "gimplify.h"
 #include "target.h"
+#include "decl.h"
 
 /* Constructor for a lambda expression.  */
 
@@ -202,6 +203,24 @@ lambda_function (tree lambda)
   return lambda;
 }
 
+/* True if EXPR is an expression whose type can be used directly in lambda
+   capture.  Not to be used for 'auto'.  */
+
+static bool
+type_deducible_expression_p (tree expr)
+{
+  if (!type_dependent_expression_p (expr))
+    return true;
+  if (BRACE_ENCLOSED_INITIALIZER_P (expr)
+      || TREE_CODE (expr) == EXPR_PACK_EXPANSION)
+    return false;
+  tree t = non_reference (TREE_TYPE (expr));
+  if (!t) return false;
+  while (TREE_CODE (t) == POINTER_TYPE)
+    t = TREE_TYPE (t);
+  return currently_open_class (t);
+}
+
 /* Returns the type to use for the FIELD_DECL corresponding to the
    capture of EXPR.  EXPLICIT_INIT_P indicates whether this is a
    C++14 init capture, and BY_REFERENCE_P indicates whether we're
@@ -228,7 +247,7 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,
       else
 	type = do_auto_deduction (type, expr, auto_node);
     }
-  else if (!is_this && type_dependent_expression_p (expr))
+  else if (!is_this && !type_deducible_expression_p (expr))
     {
       type = cxx_make_type (DECLTYPE_TYPE);
       DECLTYPE_TYPE_EXPR (type) = expr;
@@ -1177,9 +1196,13 @@ maybe_add_lambda_conv_op (tree type)
 	}
     }
   else
-    call = build_call_a (callop,
-			 direct_argvec->length (),
-			 direct_argvec->address ());
+    {
+      /* Don't warn on deprecated lambda declarations, unless
+	 the lambda is actually called.  */
+      auto du = make_temp_override (deprecated_state, DEPRECATED_SUPPRESS);
+      call = build_call_a (callop, direct_argvec->length (),
+			   direct_argvec->address ());
+    }
 
   CALL_FROM_THUNK_P (call) = 1;
   SET_EXPR_LOCATION (call, UNKNOWN_LOCATION);
diff --git a/gcc/cp/module.cc b/gcc/cp/module.cc
index b97b1bcb2f8..6cb926c044a 100644
--- a/gcc/cp/module.cc
+++ b/gcc/cp/module.cc
@@ -10059,9 +10059,10 @@ trees_out::get_merge_kind (tree decl, depset *dep)
       tree ctx = CP_DECL_CONTEXT (decl);
       if (TREE_CODE (ctx) == FUNCTION_DECL)
 	{
-	  /* USING_DECLs cannot have DECL_TEMPLATE_INFO -- this isn't
-	     permitting them to have one.   */
+	  /* USING_DECLs and NAMESPACE_DECLs cannot have DECL_TEMPLATE_INFO --
+	     this isn't permitting them to have one.   */
 	  gcc_checking_assert (TREE_CODE (decl) == USING_DECL
+			       || TREE_CODE (decl) == NAMESPACE_DECL
 			       || !DECL_LANG_SPECIFIC (decl)
 			       || !DECL_TEMPLATE_INFO (decl));
 
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 90d119eaa28..94b10922b90 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -17728,7 +17728,7 @@ cp_parser_template_name (cp_parser* parser,
 			: parser->context->object_type);
 	  if (scope && TYPE_P (scope)
 	      && (!CLASS_TYPE_P (scope)
-		  || (check_dependency_p && dependent_type_p (scope))))
+		  || (check_dependency_p && dependent_scope_p (scope))))
 	    {
 	      /* We're optimizing away the call to cp_parser_lookup_name, but
 		 we still need to do this.  */
@@ -17739,8 +17739,8 @@ cp_parser_template_name (cp_parser* parser,
     }
 
   /* cp_parser_lookup_name clears OBJECT_TYPE.  */
-  const bool scoped_p = ((parser->scope ? parser->scope
-			  : parser->context->object_type) != NULL_TREE);
+  tree scope = (parser->scope ? parser->scope
+		: parser->context->object_type);
 
   /* Look up the name.  */
   decl = cp_parser_lookup_name (parser, identifier,
@@ -17753,6 +17753,19 @@ cp_parser_template_name (cp_parser* parser,
 
   decl = strip_using_decl (decl);
 
+  /* 13.3 [temp.names] A < is interpreted as the delimiter of a
+    template-argument-list if it follows a name that is not a
+    conversion-function-id and
+    - that follows the keyword template or a ~ after a nested-name-specifier or
+    in a class member access expression, or
+    - for which name lookup finds the injected-class-name of a class template
+    or finds any declaration of a template, or
+    - that is an unqualified name for which name lookup either finds one or
+    more functions or finds nothing, or
+    - that is a terminal name in a using-declarator (9.9), in a declarator-id
+    (9.3.4), or in a type-only context other than a nested-name-specifier
+    (13.8).  */
+
   /* If DECL is a template, then the name was a template-name.  */
   if (TREE_CODE (decl) == TEMPLATE_DECL)
     {
@@ -17772,11 +17785,7 @@ cp_parser_template_name (cp_parser* parser,
     }
   else
     {
-      /* The standard does not explicitly indicate whether a name that
-	 names a set of overloaded declarations, some of which are
-	 templates, is a template-name.  However, such a name should
-	 be a template-name; otherwise, there is no way to form a
-	 template-id for the overloaded templates.  */
+      /* Look through an overload set for any templates.  */
       bool found = false;
 
       for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (decl));
@@ -17784,16 +17793,14 @@ cp_parser_template_name (cp_parser* parser,
 	if (TREE_CODE (*iter) == TEMPLATE_DECL)
 	  found = true;
 
+      /* "an unqualified name for which name lookup either finds one or more
+	 functions or finds nothing".  */
       if (!found
 	  && (cxx_dialect > cxx17)
-	  && !scoped_p
+	  && !scope
 	  && cp_lexer_next_token_is (parser->lexer, CPP_LESS)
 	  && tag_type == none_type)
 	{
-	  /* [temp.names] says "A name is also considered to refer to a template
-	     if it is an unqualified-id followed by a < and name lookup finds
-	     either one or more functions or finds nothing."  */
-
 	  /* The "more functions" case.  Just use the OVERLOAD as normally.
 	     We don't use is_overloaded_fn here to avoid considering
 	     BASELINKs.  */
@@ -17806,6 +17813,13 @@ cp_parser_template_name (cp_parser* parser,
 	    return identifier;
 	}
 
+      /* "that follows the keyword template"..."in a type-only context" */
+      if (!found && scope
+	  && (template_keyword_p || tag_type != none_type)
+	  && TYPE_P (scope) && dependent_type_p (scope)
+	  && cp_parser_nth_token_starts_template_argument_list_p (parser, 1))
+	return identifier;
+
       if (!found)
 	{
 	  /* The name does not name a template.  */
@@ -24967,6 +24981,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)
       case CPP_OPEN_PAREN:
       case CPP_CLOSE_PAREN:
       case CPP_COMMA:
+      case CPP_SCOPE:
         want_semicolon = false;
         break;
 
@@ -29419,9 +29434,12 @@ cp_parser_lookup_name (cp_parser *parser, tree name,
     }
   else if (object_type)
     {
+      bool dep = dependent_scope_p (object_type);
+
       /* Look up the name in the scope of the OBJECT_TYPE, unless the
 	 OBJECT_TYPE is not a class.  */
-      if (CLASS_TYPE_P (object_type))
+      if (CLASS_TYPE_P (object_type)
+	  && !(dep && LAMBDA_TYPE_P (object_type)))
 	/* If the OBJECT_TYPE is a template specialization, it may
 	   be instantiated during name lookup.  In that case, errors
 	   may be issued.  Even if we rollback the current tentative
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 318d42d800d..588c46504b4 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -5200,8 +5200,9 @@ process_partial_specialization (tree decl)
 	   && !get_partial_spec_bindings (maintmpl, maintmpl, specargs))
     {
       auto_diagnostic_group d;
-      if (permerror (input_location, "partial specialization %qD is not "
-		     "more specialized than", decl))
+      if (pedwarn (input_location, 0,
+		   "partial specialization %qD is not more specialized than",
+		   decl))
 	inform (DECL_SOURCE_LOCATION (maintmpl), "primary template %qD",
 		maintmpl);
     }
@@ -10889,7 +10890,7 @@ uses_template_parms (tree t)
 		   || uses_template_parms (TREE_CHAIN (t)));
   else if (TREE_CODE (t) == TYPE_DECL)
     dependent_p = dependent_type_p (TREE_TYPE (t));
-  else if (t == error_mark_node)
+  else if (t == error_mark_node || TREE_CODE (t) == NAMESPACE_DECL)
     dependent_p = false;
   else
     dependent_p = instantiation_dependent_expression_p (t);
@@ -11136,6 +11137,33 @@ outermost_tinst_level (void)
   return level;
 }
 
+/* True iff T is a friend function declaration that is not itself a template
+   and is not defined in a class template.  */
+
+bool
+non_templated_friend_p (tree t)
+{
+  if (t && TREE_CODE (t) == FUNCTION_DECL
+      && DECL_UNIQUE_FRIEND_P (t))
+    {
+      tree ti = DECL_TEMPLATE_INFO (t);
+      if (!ti)
+	return true;
+      /* DECL_FRIEND_CONTEXT is set for a friend defined in class.  */
+      if (DECL_FRIEND_CONTEXT (t))
+	return false;
+      /* Non-templated friends in a class template are still represented with a
+	 TEMPLATE_DECL; check that its primary template is the befriending
+	 class.  Note that DECL_PRIMARY_TEMPLATE is null for
+	 template <class T> friend A<T>::f(); */
+      tree tmpl = TI_TEMPLATE (ti);
+      tree primary = DECL_PRIMARY_TEMPLATE (tmpl);
+      return (primary && primary != tmpl);
+    }
+  else
+    return false;
+}
+
 /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the
    vector of template arguments, as for tsubst.
 
@@ -12641,7 +12669,13 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,
     t = tsubst_expr (pattern, args, complain, in_decl,
 		     /*integral_constant_expression_p=*/false);
   else
-    t = tsubst (pattern, args, complain, in_decl);
+    {
+      t = tsubst (pattern, args, complain, in_decl);
+      if (is_auto (t) && !ith_elem_is_expansion)
+	/* When expanding the fake auto... pack expansion from add_capture, we
+	   need to mark that the expansion is no longer a pack.  */
+	TEMPLATE_TYPE_PARAMETER_PACK (t) = false;
+    }
 
   /*  If the Ith argument pack element is a pack expansion, then
       the Ith element resulting from the substituting is going to
@@ -14072,7 +14106,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
       /* This special case arises when we have something like this:
 
 	 template <class T> struct S {
-	 friend void f<int>(int, double);
+	   friend void f<int>(int, double);
 	 };
 
 	 Here, the DECL_TI_TEMPLATE for the friend declaration
@@ -15110,6 +15144,12 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	  {
 	    DECL_ORIGINAL_TYPE (r) = NULL_TREE;
 	    set_underlying_type (r);
+
+	    /* common_handle_aligned_attribute doesn't apply the alignment
+	       to DECL_ORIGINAL_TYPE.  */
+	    if (TYPE_USER_ALIGN (TREE_TYPE (t)))
+	      TREE_TYPE (r) = build_aligned_type (TREE_TYPE (r),
+						  TYPE_ALIGN (TREE_TYPE (t)));
 	  }
 
 	layout_decl (r, 0);
@@ -16404,7 +16444,8 @@ tsubst_baselink (tree baselink, tree object_type,
 
   tree binfo_type = BINFO_TYPE (BASELINK_BINFO (baselink));
   binfo_type = tsubst (binfo_type, args, complain, in_decl);
-  bool dependent_p = binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink));
+  bool dependent_p = (binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink))
+		      || optype != BASELINK_OPTYPE (baselink));
 
   if (dependent_p)
     {
@@ -23928,7 +23969,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,
 	      /* Now check whether the type of this parameter is still
 		 dependent, and give up if so.  */
 	      ++processing_template_decl;
-	      tparm = tsubst (tparm, targs, tf_none, NULL_TREE);
+	      tparm = tsubst (TREE_TYPE (parm), targs, tf_none, NULL_TREE);
 	      --processing_template_decl;
 	      if (uses_template_parms (tparm))
 		return unify_success (explain_p);
@@ -28726,7 +28767,7 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,
 	  const int depth = TMPL_ARGS_DEPTH (tsubst_args);
 	  tree ttargs = make_tree_vec (depth + 1);
 	  for (int i = 0; i < depth; ++i)
-	    TREE_VEC_ELT (ttargs, i) = TREE_VEC_ELT (tsubst_args, i);
+	    TREE_VEC_ELT (ttargs, i) = TMPL_ARGS_LEVEL (tsubst_args, i + 1);
 	  TREE_VEC_ELT (ttargs, depth)
 	    = template_parms_level_to_args (ttparms);
 	  // Substitute ttargs into ttparms to fix references to
@@ -28739,8 +28780,17 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,
 	  ttparms = tsubst_template_parms_level (ttparms, ttargs,
 						 complain);
 	  // Finally, tack the adjusted parms onto tparms.
-	  ttparms = tree_cons (size_int (depth), ttparms,
-			       current_template_parms);
+	  ttparms = tree_cons (size_int (level + 1), ttparms,
+			       copy_node (current_template_parms));
+	  // As with all template template parms, the parameter list captured
+	  // by this template template parm that corresponds to its own level
+	  // should be empty.  This avoids infinite recursion when structurally
+	  // comparing two such rewritten template template parms (PR102479).
+	  gcc_assert (!TREE_VEC_LENGTH
+		      (TREE_VALUE (TREE_CHAIN (DECL_TEMPLATE_PARMS (olddecl)))));
+	  gcc_assert (TMPL_PARMS_DEPTH (TREE_CHAIN (ttparms)) == level);
+	  TREE_VALUE (TREE_CHAIN (ttparms)) = make_tree_vec (0);
+	  // All done.
 	  DECL_TEMPLATE_PARMS (newdecl) = ttparms;
 	}
     }
@@ -29238,6 +29288,11 @@ alias_ctad_tweaks (tree tmpl, tree uguides)
 	      ++ndlen;
 	  tree gtparms = make_tree_vec (natparms + ndlen);
 
+	  /* Set current_template_parms as in build_deduction_guide.  */
+	  auto ctp = make_temp_override (current_template_parms);
+	  current_template_parms = copy_node (DECL_TEMPLATE_PARMS (tmpl));
+	  TREE_VALUE (current_template_parms) = gtparms;
+
 	  /* First copy over the parms of A.  */
 	  for (j = 0; j < natparms; ++j)
 	    TREE_VEC_ELT (gtparms, j) = TREE_VEC_ELT (atparms, j);
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index d447ce80174..baae5a0f1e4 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -655,7 +655,8 @@ do_pushlevel (scope_kind sk)
 
 /* Queue a cleanup.  CLEANUP is an expression/statement to be executed
    when the current scope is exited.  EH_ONLY is true when this is not
-   meant to apply to normal control flow transfer.  */
+   meant to apply to normal control flow transfer.  DECL is the VAR_DECL
+   being cleaned up, if any, or null for temporaries or subobjects.  */
 
 void
 push_cleanup (tree decl, tree cleanup, bool eh_only)
@@ -10220,7 +10221,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,
     }
   else if (processing_template_decl)
     {
-      expr = instantiate_non_dependent_expr_sfinae (expr, complain);
+      expr = instantiate_non_dependent_expr_sfinae (expr, complain|tf_decltype);
       if (expr == error_mark_node)
 	return error_mark_node;
     }
diff --git a/gcc/cselib.c b/gcc/cselib.c
index 779874eeb2d..342c3cfdda8 100644
--- a/gcc/cselib.c
+++ b/gcc/cselib.c
@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dumpfile.h"
 #include "cselib.h"
 #include "function-abi.h"
+#include "alias.h"
 
 /* A list of cselib_val structures.  */
 struct elt_list
@@ -1157,6 +1158,75 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)
   return 1;
 }
 
+/* Wrapper for rtx_equal_for_cselib_p to determine whether a SET is
+   truly redundant, taking into account aliasing information.  */
+bool
+cselib_redundant_set_p (rtx set)
+{
+  gcc_assert (GET_CODE (set) == SET);
+  rtx dest = SET_DEST (set);
+  if (cselib_reg_set_mode (dest) != GET_MODE (dest))
+    return false;
+
+  if (!rtx_equal_for_cselib_p (dest, SET_SRC (set)))
+    return false;
+
+  while (GET_CODE (dest) == SUBREG
+	 || GET_CODE (dest) == ZERO_EXTRACT
+	 || GET_CODE (dest) == STRICT_LOW_PART)
+    dest = XEXP (dest, 0);
+
+  if (!flag_strict_aliasing || !MEM_P (dest))
+    return true;
+
+  /* For a store we need to check that suppressing it will not change
+     the effective alias set.  */
+  rtx dest_addr = XEXP (dest, 0);
+
+  /* Lookup the equivalents to the original dest (rather than just the
+     MEM).  */
+  cselib_val *src_val = cselib_lookup (SET_DEST (set),
+				       GET_MODE (SET_DEST (set)),
+				       0, VOIDmode);
+
+  if (src_val)
+    {
+      /* Walk the list of source equivalents to find the MEM accessing
+	 the same location.  */
+      for (elt_loc_list *l = src_val->locs; l; l = l->next)
+	{
+	  rtx src_equiv = l->loc;
+	  while (GET_CODE (src_equiv) == SUBREG
+		 || GET_CODE (src_equiv) == ZERO_EXTRACT
+		 || GET_CODE (src_equiv) == STRICT_LOW_PART)
+	    src_equiv = XEXP (src_equiv, 0);
+
+	  if (MEM_P (src_equiv))
+	    {
+	      /* Match the MEMs by comparing the addresses.  We can
+		 only remove the later store if the earlier aliases at
+		 least all the accesses of the later one.  */
+	      if (rtx_equal_for_cselib_1 (dest_addr, XEXP (src_equiv, 0),
+					  GET_MODE (dest), 0))
+		return mems_same_for_tbaa_p (src_equiv, dest);
+	    }
+	}
+    }
+
+  /* We failed to find a recorded value in the cselib history, so try
+     the source of this set; this catches cases such as *p = *q when p
+     and q have the same value.  */
+  rtx src = SET_SRC (set);
+  while (GET_CODE (src) == SUBREG)
+    src = XEXP (src, 0);
+
+  if (MEM_P (src)
+      && rtx_equal_for_cselib_1 (dest_addr, XEXP (src, 0), GET_MODE (dest), 0))
+    return mems_same_for_tbaa_p (src, dest);
+
+  return false;
+}
+
 /* Helper function for cselib_hash_rtx.  Arguments like for cselib_hash_rtx,
    except that it hashes (plus:P x c).  */
 
diff --git a/gcc/cselib.h b/gcc/cselib.h
index af112fd0985..14478eec238 100644
--- a/gcc/cselib.h
+++ b/gcc/cselib.h
@@ -83,6 +83,7 @@ extern void cselib_process_insn (rtx_insn *);
 extern bool fp_setter_insn (rtx_insn *);
 extern machine_mode cselib_reg_set_mode (const_rtx);
 extern int rtx_equal_for_cselib_1 (rtx, rtx, machine_mode, int);
+extern bool cselib_redundant_set_p (rtx);
 extern int references_value_p (const_rtx, int);
 extern rtx cselib_expand_value_rtx (rtx, bitmap, int);
 typedef rtx (*cselib_expand_callback)(rtx, bitmap, int, void *);
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index 6021ffdbf78..a32a7f3ea2a 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,45 @@
+2022-08-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-08-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106638
+	* gdc.texi: Update DIP links to point at upstream dlang/DIPs
+	repository.
+
+2022-07-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106139
+	* d-convert.cc (convert_expr): Handle casting from array to vector.
+	(convert_for_rvalue): Rewrite vector to array casts of the same
+	element type into a constructor.
+	(convert_for_assignment): Return calling convert_for_rvalue.
+	* dmd/expressionsem.c (ExpressionSemanticVisitor::visit): Run semantic
+	on vector expression after lowering.
+	* expr.cc (ExprVisitor::visit (VectorExp *)): Handle generating a
+	vector expression from a static array.
+	* toir.cc (IRVisitor::visit (ReturnStatement *)): Call
+	convert_for_rvalue on return value.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* typeinfo.cc (make_internal_typeinfo): Set TYPE_ARTIFICIAL.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* d-spec.cc (lang_specific_driver): Set SKIPOPT on -static-libstdc++
+	and -static-libphobos only when target supports LD_STATIC_DYNAMIC.
+	Remove generate_option to re-add -static-libstdc++.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/d/d-convert.cc b/gcc/d/d-convert.cc
index d43485dca77..cd6551e64f3 100644
--- a/gcc/d/d-convert.cc
+++ b/gcc/d/d-convert.cc
@@ -502,6 +502,15 @@ convert_expr (tree exp, Type *etype, Type *totype)
 	  gcc_assert (totype->size () == etype->size ());
 	  result = build_vconvert (build_ctype (totype), exp);
 	}
+      else if (tbtype->ty == Tvector && tbtype->size () == ebtype->size ())
+	{
+	  /* Allow casting from array to vector as if its an unaligned load.  */
+	  tree type = build_ctype (totype);
+	  tree unaligned_type = build_variant_type_copy (type);
+	  SET_TYPE_ALIGN (unaligned_type, 1 * BITS_PER_UNIT);
+	  TYPE_USER_ALIGN (unaligned_type) = 1;
+	  result = convert (type, build_vconvert (unaligned_type, exp));
+	}
       else
 	{
 	  error ("cannot cast expression of type %qs to type %qs",
@@ -636,6 +645,39 @@ convert_for_rvalue (tree expr, Type *etype, Type *totype)
       break;
     }
 
+  if (tbtype->ty == Tsarray
+      && ebtype->ty == Tsarray
+      && tbtype->nextOf ()->ty == ebtype->nextOf ()->ty
+      && INDIRECT_REF_P (expr)
+      && CONVERT_EXPR_CODE_P (TREE_CODE (TREE_OPERAND (expr, 0)))
+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (expr, 0), 0)) == ADDR_EXPR)
+    {
+      /* If expression is a vector that was casted to an array either by
+	 explicit type cast or by taking the vector's `.array' value, strip the
+	 reinterpret cast and build a constructor instead.  */
+      tree ptr = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);
+
+      if (VECTOR_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))
+	{
+	  /* Rewrite: `*(Array *)&vector'
+		into: `{ vector[0], vector[1], ... }'  */
+	  tree array = d_save_expr (TREE_OPERAND (ptr, 0));
+	  array = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (expr), array);
+
+	  uinteger_t dim = tbtype->isTypeSArray ()->dim->toUInteger ();
+	  vec <constructor_elt, va_gc> *elms = NULL;
+	  for (uinteger_t i = 0; i < dim; i++)
+	    {
+	      tree index = size_int (i);
+	      tree value = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (array)),
+				   array, index, NULL_TREE, NULL_TREE);
+	      CONSTRUCTOR_APPEND_ELT (elms, index, value);
+	    }
+
+	  return build_constructor (build_ctype (totype), elms);
+	}
+    }
+
   return result ? result : convert_expr (expr, etype, totype);
 }
 
@@ -696,7 +738,7 @@ convert_for_assignment (tree expr, Type *etype, Type *totype)
       return expr;
     }
 
-  return convert_expr (expr, etype, totype);
+  return convert_for_rvalue (expr, etype, totype);
 }
 
 /* Return a TREE representation of EXPR converted to represent
diff --git a/gcc/d/d-spec.cc b/gcc/d/d-spec.cc
index b12d28f1047..1304126a675 100644
--- a/gcc/d/d-spec.cc
+++ b/gcc/d/d-spec.cc
@@ -253,13 +253,23 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 
 	case OPT_static_libstdc__:
 	  saw_static_libcxx = true;
+#ifdef HAVE_LD_STATIC_DYNAMIC
+	  /* Remove -static-libstdc++ from the command only if target supports
+	     LD_STATIC_DYNAMIC.  When not supported, it is left in so that a
+	     back-end target can use outfile substitution.  */
 	  args[i] |= SKIPOPT;
+#endif
 	  break;
 
 	case OPT_static_libphobos:
 	  if (phobos_library != PHOBOS_NOLINK)
 	    phobos_library = PHOBOS_STATIC;
+#ifdef HAVE_LD_STATIC_DYNAMIC
+	  /* Remove -static-libphobos from the command only if target supports
+	     LD_STATIC_DYNAMIC.  When not supported, it is left in so that a
+	     back-end target can use outfile substitution.  */
 	  args[i] |= SKIPOPT;
+#endif
 	  break;
 
 	case OPT_shared_libphobos:
@@ -460,7 +470,7 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 #endif
     }
 
-  if (saw_libcxx || need_stdcxx)
+  if (saw_libcxx || saw_static_libcxx || need_stdcxx)
     {
 #ifdef HAVE_LD_STATIC_DYNAMIC
       if (saw_static_libcxx && !static_link)
@@ -468,12 +478,6 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 	  generate_option (OPT_Wl_, LD_STATIC_OPTION, 1, CL_DRIVER,
 			   &new_decoded_options[j++]);
 	}
-#else
-      /* Push the -static-libstdc++ option back onto the command so that
-	 a target without LD_STATIC_DYNAMIC can use outfile substitution.  */
-      if (saw_static_libcxx && !static_link)
-	generate_option (OPT_static_libstdc__, NULL, 1, CL_DRIVER,
-			 &new_decoded_options[j++]);
 #endif
       if (saw_libcxx)
 	new_decoded_options[j++] = *saw_libcxx;
diff --git a/gcc/d/dmd/expressionsem.c b/gcc/d/dmd/expressionsem.c
index 5ae5fe6a717..fe90039d6f0 100644
--- a/gcc/d/dmd/expressionsem.c
+++ b/gcc/d/dmd/expressionsem.c
@@ -6330,6 +6330,7 @@ public:
         if (tob->ty == Tvector && t1b->ty != Tvector)
         {
             result = new VectorExp(exp->loc, exp->e1, exp->to);
+            result = expressionSemantic(result, sc);
             return;
         }
 
diff --git a/gcc/d/expr.cc b/gcc/d/expr.cc
index 85269c6b2be..eb5feffef6a 100644
--- a/gcc/d/expr.cc
+++ b/gcc/d/expr.cc
@@ -3034,14 +3034,13 @@ public:
 
   void visit (VectorExp *e)
   {
-    tree type = build_ctype (e->type);
-
     /* First handle array literal expressions.  */
     if (e->e1->op == TOKarrayliteral)
       {
 	ArrayLiteralExp *ale = e->e1->isArrayLiteralExp ();
 	vec <constructor_elt, va_gc> *elms = NULL;
 	bool constant_p = true;
+	tree type = build_ctype (e->type);
 
 	vec_safe_reserve (elms, ale->elements->length);
 	for (size_t i = 0; i < ale->elements->length; i++)
@@ -3061,9 +3060,16 @@ public:
 	else
 	  this->result_ = build_constructor (type, elms);
       }
+    else if (e->e1->type->toBasetype ()->ty == Tsarray)
+      {
+	/* Build a vector representation from a static array.  */
+	this->result_ = convert_expr (build_expr (e->e1, this->constp_),
+				      e->e1->type, e->type);
+      }
     else
       {
 	/* Build constructor from single value.  */
+	tree type = build_ctype (e->type);
 	tree value = d_convert (TREE_TYPE (type),
 				build_expr (e->e1, this->constp_, true));
 	this->result_ = build_vector_from_val (type, value);
diff --git a/gcc/d/gdc.texi b/gcc/d/gdc.texi
index 095f7ecca41..0976aebd7d4 100644
--- a/gcc/d/gdc.texi
+++ b/gcc/d/gdc.texi
@@ -637,9 +637,11 @@ List information on all language changes.
 @item complex
 List all usages of complex or imaginary types.
 @item dip1000
-Implements @uref{http://wiki.dlang.org/DIP1000} (experimental).
+Implements @uref{https://github.com/dlang/DIPs/blob/master/DIPs/other/DIP1000.md}
+(Scoped pointers).
 @item dip25
-Implements @uref{http://wiki.dlang.org/DIP25} (experimental).
+Implements @uref{https://github.com/dlang/DIPs/blob/master/DIPs/archive/DIP25.md}
+(Sealed references).
 @item field
 List all non-mutable fields which occupy an object instance.
 @item nogc
diff --git a/gcc/d/toir.cc b/gcc/d/toir.cc
index eaee6f7e803..460edc15143 100644
--- a/gcc/d/toir.cc
+++ b/gcc/d/toir.cc
@@ -1090,6 +1090,7 @@ public:
 	    /* Generate: (<retval> = expr, return <retval>);  */
 	    tree expr = build_expr_dtor (s->exp);
 	    tree init = stabilize_expr (&expr);
+	    expr = convert_for_rvalue (expr, s->exp->type, type);
 	    expr = build_assign (INIT_EXPR, this->func_->shidden, expr);
 	    add_stmt (compound_expr (init, expr));
 	  }
diff --git a/gcc/d/typeinfo.cc b/gcc/d/typeinfo.cc
index 9d6464deb07..a10d21e355e 100644
--- a/gcc/d/typeinfo.cc
+++ b/gcc/d/typeinfo.cc
@@ -179,6 +179,7 @@ make_internal_typeinfo (tinfo_kind tk, Identifier *ident, ...)
 
   /* Create the TypeInfo type.  */
   tree type = make_node (RECORD_TYPE);
+  TYPE_ARTIFICIAL (type) = 1;
   finish_builtin_struct (type, ident->toChars (), fields, NULL_TREE);
 
   tinfo_types[tk] = type;
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 35508efb4ef..49b78ef4522 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -18231,7 +18231,7 @@ performance of the code.  Permissible values for this option are:
 @samp{cortex-a78}, @samp{cortex-a78ae}, @samp{cortex-a78c},
 @samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},
 @samp{neoverse-512tvb}, @samp{neoverse-e1}, @samp{neoverse-n1},
-@samp{neoverse-n2}, @samp{neoverse-v1}, @samp{qdf24xx},
+@samp{neoverse-n2}, @samp{neoverse-v1},@samp{neoverse-v2}, @samp{qdf24xx},
 @samp{saphira}, @samp{phecda}, @samp{xgene1}, @samp{vulcan},
 @samp{octeontx}, @samp{octeontx81},  @samp{octeontx83},
 @samp{octeontx2}, @samp{octeontx2t98}, @samp{octeontx2t96}
diff --git a/gcc/dse.c b/gcc/dse.c
index b634429449c..dd99756d151 100644
--- a/gcc/dse.c
+++ b/gcc/dse.c
@@ -1562,12 +1562,7 @@ record_store (rtx body, bb_info_t bb_info)
 					 width)
 	      /* We can only remove the later store if the earlier aliases
 		 at least all accesses the later one.  */
-	      && ((MEM_ALIAS_SET (mem) == MEM_ALIAS_SET (s_info->mem)
-		   || alias_set_subset_of (MEM_ALIAS_SET (mem),
-					   MEM_ALIAS_SET (s_info->mem)))
-		  && (!MEM_EXPR (s_info->mem)
-		      || refs_same_for_tbaa_p (MEM_EXPR (s_info->mem),
-					       MEM_EXPR (mem)))))
+	      && mems_same_for_tbaa_p (s_info->mem, mem))
 	    {
 	      if (GET_MODE (mem) == BLKmode)
 		{
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 07e908624a0..0dc51220682 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -6465,7 +6465,8 @@ emit_copy_of_insn_after (rtx_insn *insn, rtx_insn *after)
     }
 
   /* Update LABEL_NUSES.  */
-  mark_jump_label (PATTERN (new_rtx), new_rtx, 0);
+  if (NONDEBUG_INSN_P (insn))
+    mark_jump_label (PATTERN (new_rtx), new_rtx, 0);
 
   INSN_LOCATION (new_rtx) = INSN_LOCATION (insn);
 
diff --git a/gcc/expr.c b/gcc/expr.c
index 14a25c25450..baf48ea7148 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -6192,13 +6192,13 @@ count_type_elements (const_tree type, bool for_ctor_p)
     case OFFSET_TYPE:
     case REFERENCE_TYPE:
     case NULLPTR_TYPE:
+    case OPAQUE_TYPE:
       return 1;
 
     case ERROR_MARK:
       return 0;
 
     case VOID_TYPE:
-    case OPAQUE_TYPE:
     case METHOD_TYPE:
     case FUNCTION_TYPE:
     case LANG_TYPE:
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 70c5b3886ef..901255a18d6 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -2355,7 +2355,7 @@ build_zero_vector (tree type)
 bool
 fold_convertible_p (const_tree type, const_tree arg)
 {
-  tree orig = TREE_TYPE (arg);
+  const_tree orig = TREE_TYPE (arg);
 
   if (type == orig)
     return true;
@@ -2387,7 +2387,7 @@ fold_convertible_p (const_tree type, const_tree arg)
       return (VECTOR_TYPE_P (orig)
 	      && known_eq (TYPE_VECTOR_SUBPARTS (type),
 			   TYPE_VECTOR_SUBPARTS (orig))
-	      && fold_convertible_p (TREE_TYPE (type), TREE_TYPE (orig)));
+	      && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)));
 
     default:
       return false;
@@ -7508,7 +7508,7 @@ tree_swap_operands_p (const_tree arg0, const_tree arg1)
 static tree
 fold_to_nonsharp_ineq_using_bound (location_t loc, tree ineq, tree bound)
 {
-  tree a, typea, type = TREE_TYPE (ineq), a1, diff, y;
+  tree a, typea, type = TREE_TYPE (bound), a1, diff, y;
 
   if (TREE_CODE (bound) == LT_EXPR)
     a = TREE_OPERAND (bound, 0);
@@ -9488,6 +9488,16 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)
 		  > min_align_of_type (TREE_TYPE (TREE_TYPE (arg00)))))
 	    return NULL_TREE;
 
+	  /* Similarly, avoid this optimization in GENERIC for -fsanitize=null
+	     when type is a reference type and arg00's type is not,
+	     because arg00 could be validly nullptr and if arg01 doesn't return,
+	     we don't want false positive binding of reference to nullptr.  */
+	  if (TREE_CODE (type) == REFERENCE_TYPE
+	      && !in_gimple_form
+	      && sanitize_flags_p (SANITIZE_NULL)
+	      && TREE_CODE (TREE_TYPE (arg00)) != REFERENCE_TYPE)
+	    return NULL_TREE;
+
 	  arg00 = fold_convert_loc (loc, type, arg00);
 	  return fold_build_pointer_plus_loc (loc, arg00, arg01);
 	}
@@ -11987,11 +11997,15 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,
 	{
 	  tem = fold_to_nonsharp_ineq_using_bound (loc, arg0, arg1);
 	  if (tem && !operand_equal_p (tem, arg0, 0))
-	    return fold_build2_loc (loc, code, type, tem, arg1);
+	    return fold_convert (type,
+				 fold_build2_loc (loc, code, TREE_TYPE (arg1),
+						  tem, arg1));
 
 	  tem = fold_to_nonsharp_ineq_using_bound (loc, arg1, arg0);
 	  if (tem && !operand_equal_p (tem, arg1, 0))
-	    return fold_build2_loc (loc, code, type, arg0, tem);
+	    return fold_convert (type,
+				 fold_build2_loc (loc, code, TREE_TYPE (arg0),
+						  arg0, tem));
 	}
 
       if ((tem = fold_truth_andor (loc, code, type, arg0, arg1, op0, op1))
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index ee1c7bb4b31..a3678e0cabe 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,228 @@
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/106817
+	* trans-expr.c (gfc_conv_procedure_call): Collect all clobbers
+	to their own separate block.  Append the block of clobbers to
+	the procedure preliminary block after the argument evaluation
+	codes for all the arguments.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/105012
+	* trans-expr.c (gfc_conv_procedure_call): Retrieve variable
+	from the just calculated variable reference.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	* trans.h (gfc_conv_expr_reference): Remove add_clobber
+	argument.
+	* trans-expr.c (gfc_conv_expr_reference): Ditto. Inline code
+	depending on add_clobber and conditions controlling it ...
+	(gfc_conv_procedure_call): ... to here.
+
+2022-10-08  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100040
+	PR fortran/100029
+	* trans-expr.c (gfc_conv_class_to_class): Add code to have
+	assumed-rank arrays recognized as full arrays and fix the type
+	of the array assignment.
+	(gfc_conv_procedure_call): Change order of code blocks such that
+	the free of ALLOCATABLE dummy arguments with INTENT(OUT) occurs
+	first.
+
+2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-20  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100132
+	* trans-types.c (create_fn_spec): Fix function attributes when
+	passing polymorphic pointers.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107054
+	* simplify.c (gfc_simplify_unpack): Replace assert by condition
+	that terminates simplification when there are not enough elements
+	in the constructor of argument VECTOR.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82868
+	* trans-decl.c (generate_coarray_sym_init): Skip symbol
+	if attr.associate_var.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106985
+	* expr.c (gfc_simplify_expr): Avoid NULL pointer dereference.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103694
+	* simplify.c (simplify_size): The size expression of an array cannot
+	be simplified if an error occurs while resolving the array spec.
+
+2022-09-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106986
+	* simplify.c (gfc_simplify_findloc): Do not try to simplify
+	intrinsic FINDLOC when the ARRAY argument has a NULL shape.
+
+2022-09-24  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-03  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100245
+	* trans-expr.c (trans_class_assignment): Add if clause to handle
+	derived type in the LHS.
+
+2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106857
+	* simplify.c (gfc_simplify_pack): Check for NULL pointer dereferences
+	while walking through constructors (error recovery).
+
+2022-09-05  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-04  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100136
+	* trans-expr.c (gfc_conv_procedure_call): Add handling of pointer
+	expressions.
+
+2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103504
+	* interface.c (get_sym_storage_size): Array bounds and character
+	length can only be of integer type.
+
+2022-07-16  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2022-07-15  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/104313
+	* trans-decl.c (gfc_generate_return): Do not generate conflicting
+	fake results for functions with no result variable under -ff2c.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-30  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103137
+	PR fortran/103138
+	PR fortran/103693
+	PR fortran/105243
+	* decl.c (gfc_match_data_decl): Reject CLASS entity declaration
+	when it is given the PARAMETER attribute.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-29  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/106121
+	* simplify.c (gfc_simplify_extends_type_of): Do not attempt to
+	simplify when one of the arguments is a CLASS variable that was
+	not properly declared.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105954
+	* decl.c (variable_decl): Adjust upper bounds for explicit-shape
+	specs with constant bound expressions to ensure non-negative
+	extents.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105691
+	* simplify.c (gfc_simplify_index): Replace old simplification
+	code by the equivalent of the runtime library implementation.  Use
+	HOST_WIDE_INT instead of int for string index, length variables.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105813
+	* check.c (gfc_check_unpack): Try to simplify MASK argument to
+	UNPACK so that checking of the VECTOR argument can work when MASK
+	is a variable.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-05-11  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105230
+	* expr.c (find_array_section): Correct logic to avoid NULL
+	pointer dereference on invalid array section.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-03-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104849
+	* expr.c (find_array_section): Avoid NULL pointer dereference on
+	invalid array section.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* trans-expr.c (gfc_conv_union_initializer): Pass vec* by reference.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index 1add9436dce..4e2736fef1e 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -6342,6 +6342,8 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)
   if (!same_type_check (vector, 0, field, 2))
     return false;
 
+  gfc_simplify_expr (mask, 0);
+
   if (mask->expr_type == EXPR_ARRAY
       && gfc_array_size (vector, &vector_size))
     {
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 602ad3e59bd..c25b53f9772 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -2696,6 +2696,18 @@ variable_decl (int elem)
 		  else
 		    gfc_free_expr (n);
 		}
+	      /* For an explicit-shape spec with constant bounds, ensure
+		 that the effective upper bound is not lower than the
+		 respective lower bound minus one.  Otherwise adjust it so
+		 that the extent is trivially derived to be zero.  */
+	      if (as->lower[i]->expr_type == EXPR_CONSTANT
+		  && as->upper[i]->expr_type == EXPR_CONSTANT
+		  && as->lower[i]->ts.type == BT_INTEGER
+		  && as->upper[i]->ts.type == BT_INTEGER
+		  && mpz_cmp (as->upper[i]->value.integer,
+			      as->lower[i]->value.integer) < 0)
+		mpz_sub_ui (as->upper[i]->value.integer,
+			    as->lower[i]->value.integer, 1);
 	    }
 	}
     }
@@ -6169,6 +6181,14 @@ gfc_match_data_decl (void)
       goto cleanup;
     }
 
+  /* F2018:C708.  */
+  if (current_ts.type == BT_CLASS && current_attr.flavor == FL_PARAMETER)
+    {
+      gfc_error ("CLASS entity at %C cannot have the PARAMETER attribute");
+      m = MATCH_ERROR;
+      goto cleanup;
+    }
+
   if (current_ts.type == BT_CLASS
 	&& current_ts.u.derived->attr.unlimited_polymorphic)
     goto ok;
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index edacd974a21..64fdd04221f 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -1591,7 +1591,9 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)
 	{
 	  if ((begin && begin->expr_type != EXPR_CONSTANT)
 	      || (finish && finish->expr_type != EXPR_CONSTANT)
-	      || (step && step->expr_type != EXPR_CONSTANT))
+	      || (step && step->expr_type != EXPR_CONSTANT)
+	      || !lower
+	      || !upper)
 	    {
 	      t = false;
 	      goto cleanup;
@@ -2281,7 +2283,8 @@ gfc_simplify_expr (gfc_expr *p, int type)
 	 initialization expression, or we want a subsection.  */
       if (p->symtree->n.sym->attr.flavor == FL_PARAMETER
 	  && (gfc_init_expr_flag || p->ref
-	      || p->symtree->n.sym->value->expr_type != EXPR_ARRAY))
+	      || (p->symtree->n.sym->value
+		  && p->symtree->n.sym->value->expr_type != EXPR_ARRAY)))
 	{
 	  if (!simplify_parameter_variable (p, type))
 	    return false;
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index 9e3e8aa9da9..b7294cbeb4e 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -2760,7 +2760,8 @@ get_sym_storage_size (gfc_symbol *sym)
   if (sym->ts.type == BT_CHARACTER)
     {
       if (sym->ts.u.cl && sym->ts.u.cl->length
-          && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
+	  && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	  && sym->ts.u.cl->length->ts.type == BT_INTEGER)
 	strlen = mpz_get_ui (sym->ts.u.cl->length->value.integer);
       else
 	return 0;
@@ -2777,7 +2778,9 @@ get_sym_storage_size (gfc_symbol *sym)
   for (i = 0; i < sym->as->rank; i++)
     {
       if (sym->as->upper[i]->expr_type != EXPR_CONSTANT
-	  || sym->as->lower[i]->expr_type != EXPR_CONSTANT)
+	  || sym->as->lower[i]->expr_type != EXPR_CONSTANT
+	  || sym->as->upper[i]->ts.type != BT_INTEGER
+	  || sym->as->lower[i]->ts.type != BT_INTEGER)
 	return 0;
 
       elements *= mpz_get_si (sym->as->upper[i]->value.integer)
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 3599e1b3194..f13a8e57c83 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -3092,6 +3092,10 @@ gfc_simplify_extends_type_of (gfc_expr *a, gfc_expr *mold)
   if (UNLIMITED_POLY (a) || UNLIMITED_POLY (mold))
     return NULL;
 
+  if ((a->ts.type == BT_CLASS && !gfc_expr_attr (a).class_ok)
+      || (mold->ts.type == BT_CLASS && !gfc_expr_attr (mold).class_ok))
+    return NULL;
+
   /* Return .false. if the dynamic type can never be an extension.  */
   if ((a->ts.type == BT_CLASS && mold->ts.type == BT_CLASS
        && !gfc_type_is_extension_of
@@ -3502,17 +3506,15 @@ gfc_expr *
 gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)
 {
   gfc_expr *result;
-  int back, len, lensub;
-  int i, j, k, count, index = 0, start;
+  bool back;
+  HOST_WIDE_INT len, lensub, start, last, i, index = 0;
+  int k, delta;
 
   if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT
       || ( b != NULL && b->expr_type !=  EXPR_CONSTANT))
     return NULL;
 
-  if (b != NULL && b->value.logical != 0)
-    back = 1;
-  else
-    back = 0;
+  back = (b != NULL && b->value.logical != 0);
 
   k = get_kind (BT_INTEGER, kind, "INDEX", gfc_default_integer_kind);
   if (k == -1)
@@ -3529,111 +3531,40 @@ gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)
       return result;
     }
 
-  if (back == 0)
+  if (lensub == 0)
     {
-      if (lensub == 0)
-	{
-	  mpz_set_si (result->value.integer, 1);
-	  return result;
-	}
-      else if (lensub == 1)
-	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[i])
-		    {
-		      index = i + 1;
-		      goto done;
-		    }
-		}
-	    }
-	}
+      if (back)
+	index = len + 1;
       else
-	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[i])
-		    {
-		      start = i;
-		      count = 0;
-
-		      for (k = 0; k < lensub; k++)
-			{
-			  if (y->value.character.string[k]
-			      == x->value.character.string[k + start])
-			    count++;
-			}
-
-		      if (count == lensub)
-			{
-			  index = start + 1;
-			  goto done;
-			}
-		    }
-		}
-	    }
-	}
+	index = 1;
+      goto done;
+    }
 
+  if (!back)
+    {
+      last = len + 1 - lensub;
+      start = 0;
+      delta = 1;
     }
   else
     {
-      if (lensub == 0)
-	{
-	  mpz_set_si (result->value.integer, len + 1);
-	  return result;
-	}
-      else if (lensub == 1)
+      last = -1;
+      start = len - lensub;
+      delta = -1;
+    }
+
+  for (; start != last; start += delta)
+    {
+      for (i = 0; i < lensub; i++)
 	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[len - i])
-		    {
-		      index = len - i + 1;
-		      goto done;
-		    }
-		}
-	    }
+	  if (x->value.character.string[start + i]
+	      != y->value.character.string[i])
+	    break;
 	}
-      else
+      if (i == lensub)
 	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[len - i])
-		    {
-		      start = len - i;
-		      if (start <= len - lensub)
-			{
-			  count = 0;
-			  for (k = 0; k < lensub; k++)
-			    if (y->value.character.string[k]
-			        == x->value.character.string[k + start])
-			      count++;
-
-			  if (count == lensub)
-			    {
-			      index = start + 1;
-			      goto done;
-			    }
-			}
-		      else
-			{
-			  continue;
-			}
-		    }
-		}
-	    }
+	  index = start + 1;
+	  goto done;
 	}
     }
 
@@ -5915,6 +5846,7 @@ gfc_simplify_findloc (gfc_expr *array, gfc_expr *value, gfc_expr *dim,
   bool back_val = false;
 
   if (!is_constant_array_expr (array)
+      || array->shape == NULL
       || !gfc_is_constant_expr (dim))
     return NULL;
 
@@ -6451,7 +6383,7 @@ gfc_simplify_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)
       /* Copy only those elements of ARRAY to RESULT whose
 	 MASK equals .TRUE..  */
       mask_ctor = gfc_constructor_first (mask->value.constructor);
-      while (mask_ctor)
+      while (mask_ctor && array_ctor)
 	{
 	  if (mask_ctor->expr->value.logical)
 	    {
@@ -7556,8 +7488,9 @@ simplify_size (gfc_expr *array, gfc_expr *dim, int k)
     }
 
   for (ref = array->ref; ref; ref = ref->next)
-    if (ref->type == REF_ARRAY && ref->u.ar.as)
-      gfc_resolve_array_spec (ref->u.ar.as, 0);
+    if (ref->type == REF_ARRAY && ref->u.ar.as
+	&& !gfc_resolve_array_spec (ref->u.ar.as, 0))
+      return NULL;
 
   if (dim == NULL)
     {
@@ -8476,9 +8409,16 @@ gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)
     {
       if (mask_ctor->expr->value.logical)
 	{
-	  gcc_assert (vector_ctor);
-	  e = gfc_copy_expr (vector_ctor->expr);
-	  vector_ctor = gfc_constructor_next (vector_ctor);
+	  if (vector_ctor)
+	    {
+	      e = gfc_copy_expr (vector_ctor->expr);
+	      vector_ctor = gfc_constructor_next (vector_ctor);
+	    }
+	  else
+	    {
+	      gfc_free_expr (result);
+	      return NULL;
+	    }
 	}
       else if (field->expr_type == EXPR_ARRAY)
 	e = gfc_copy_expr (field_ctor->expr);
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 95af7d93162..68fb19e6f2b 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -5624,6 +5624,7 @@ generate_coarray_sym_init (gfc_symbol *sym)
 
   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension
       || sym->attr.use_assoc || !sym->attr.referenced
+      || sym->attr.associate_var
       || sym->attr.select_type_temporary)
     return;
 
@@ -6564,7 +6565,7 @@ gfc_generate_return (void)
 	     NULL_TREE, and a 'return' is generated without a variable.
 	     The following generates a 'return __result_XXX' where XXX is
 	     the function name.  */
-	  if (sym == sym->result && sym->attr.function)
+	  if (sym == sym->result && sym->attr.function && !flag_f2c)
 	    {
 	      result = gfc_get_fake_result_decl (sym, 0);
 	      result = fold_build2_loc (input_location, MODIFY_EXPR,
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index a5c391d077e..a06dc7bf556 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -1136,8 +1136,10 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
     return;
 
   /* Test for FULL_ARRAY.  */
-  if (e->rank == 0 && gfc_expr_attr (e).codimension
-      && gfc_expr_attr (e).dimension)
+  if (e->rank == 0
+      && ((gfc_expr_attr (e).codimension && gfc_expr_attr (e).dimension)
+	  || (class_ts.u.derived->components->as
+	      && class_ts.u.derived->components->as->type == AS_ASSUMED_RANK)))
     full_array = true;
   else
     gfc_is_class_array_ref (e, &full_array);
@@ -1185,8 +1187,12 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
 	  && e->rank != class_ts.u.derived->components->as->rank)
 	{
 	  if (e->rank == 0)
-	    gfc_add_modify (&parmse->post, gfc_class_data_get (parmse->expr),
-			    gfc_conv_descriptor_data_get (ctree));
+	    {
+	      tmp = gfc_class_data_get (parmse->expr);
+	      gfc_add_modify (&parmse->post, tmp,
+			      fold_convert (TREE_TYPE (tmp),
+					 gfc_conv_descriptor_data_get (ctree)));
+	    }
 	  else
 	    class_array_data_assign (&parmse->post, parmse->expr, ctree, true);
 	}
@@ -5642,7 +5648,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
   gfc_charlen cl;
   gfc_expr *e;
   gfc_symbol *fsym;
-  stmtblock_t post;
   enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};
   gfc_component *comp = NULL;
   int arglen;
@@ -5686,7 +5691,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
   else
     info = NULL;
 
+  stmtblock_t post, clobbers;
   gfc_init_block (&post);
+  gfc_init_block (&clobbers);
   gfc_init_interface_mapping (&mapping);
   if (!comp)
     {
@@ -6023,7 +6030,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				&& e->symtree->n.sym->attr.pointer))
 			&& fsym && fsym->attr.target)
 		/* Make sure the function only gets called once.  */
-		gfc_conv_expr_reference (&parmse, e, false);
+		gfc_conv_expr_reference (&parmse, e);
 	      else if (e->expr_type == EXPR_FUNCTION
 		       && e->symtree->n.sym->result
 		       && e->symtree->n.sym->result != e->symtree->n.sym
@@ -6130,22 +6137,37 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    }
 		  else
 		    {
-		      bool add_clobber;
-		      add_clobber = fsym && fsym->attr.intent == INTENT_OUT
-			&& !fsym->attr.allocatable && !fsym->attr.pointer
-			&& e->symtree && e->symtree->n.sym
-			&& !e->symtree->n.sym->attr.dimension
-			&& !e->symtree->n.sym->attr.pointer
-			&& !e->symtree->n.sym->attr.allocatable
-			/* See PR 41453.  */
-			&& !e->symtree->n.sym->attr.dummy
-			/* FIXME - PR 87395 and PR 41453  */
-			&& e->symtree->n.sym->attr.save == SAVE_NONE
-			&& !e->symtree->n.sym->attr.associate_var
-			&& e->ts.type != BT_CHARACTER && e->ts.type != BT_DERIVED
-			&& e->ts.type != BT_CLASS && !sym->attr.elemental;
-
-		      gfc_conv_expr_reference (&parmse, e, add_clobber);
+		      gfc_conv_expr_reference (&parmse, e);
+
+		      if (fsym
+			  && fsym->attr.intent == INTENT_OUT
+			  && !fsym->attr.allocatable
+			  && !fsym->attr.pointer
+			  && e->expr_type == EXPR_VARIABLE
+			  && e->ref == NULL
+			  && e->symtree
+			  && e->symtree->n.sym
+			  && !e->symtree->n.sym->attr.dimension
+			  && !e->symtree->n.sym->attr.pointer
+			  && !e->symtree->n.sym->attr.allocatable
+			  /* See PR 41453.  */
+			  && !e->symtree->n.sym->attr.dummy
+			  /* FIXME - PR 87395 and PR 41453  */
+			  && e->symtree->n.sym->attr.save == SAVE_NONE
+			  && !e->symtree->n.sym->attr.associate_var
+			  && e->ts.type != BT_CHARACTER
+			  && e->ts.type != BT_DERIVED
+			  && e->ts.type != BT_CLASS
+			  && !sym->attr.elemental)
+			{
+			  tree var;
+			  /* FIXME: This fails if var is passed by reference, see PR
+			     41453.  */
+			  var = build_fold_indirect_ref_loc (input_location,
+							     parmse.expr);
+			  tree clobber = build_clobber (TREE_TYPE (var));
+			  gfc_add_modify (&clobbers, var, clobber);
+			}
 		    }
 		  /* Catch base objects that are not variables.  */
 		  if (e->ts.type == BT_CLASS
@@ -6154,23 +6176,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    base_object = build_fold_indirect_ref_loc (input_location,
 							       parmse.expr);
 
-		  /* A class array element needs converting back to be a
-		     class object, if the formal argument is a class object.  */
-		  if (fsym && fsym->ts.type == BT_CLASS
-			&& e->ts.type == BT_CLASS
-			&& ((CLASS_DATA (fsym)->as
-			     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)
-			    || CLASS_DATA (e)->attr.dimension))
-		    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,
-				     fsym->attr.intent != INTENT_IN
-				     && (CLASS_DATA (fsym)->attr.class_pointer
-					 || CLASS_DATA (fsym)->attr.allocatable),
-				     fsym->attr.optional
-				     && e->expr_type == EXPR_VARIABLE
-				     && e->symtree->n.sym->attr.optional,
-				     CLASS_DATA (fsym)->attr.class_pointer
-				     || CLASS_DATA (fsym)->attr.allocatable);
-
 		  /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is
 		     allocated on entry, it must be deallocated.  */
 		  if (fsym && fsym->attr.intent == INTENT_OUT
@@ -6230,6 +6235,23 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		    }
 
+		  /* A class array element needs converting back to be a
+		     class object, if the formal argument is a class object.  */
+		  if (fsym && fsym->ts.type == BT_CLASS
+			&& e->ts.type == BT_CLASS
+			&& ((CLASS_DATA (fsym)->as
+			     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)
+			    || CLASS_DATA (e)->attr.dimension))
+		    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,
+				     fsym->attr.intent != INTENT_IN
+				     && (CLASS_DATA (fsym)->attr.class_pointer
+					 || CLASS_DATA (fsym)->attr.allocatable),
+				     fsym->attr.optional
+				     && e->expr_type == EXPR_VARIABLE
+				     && e->symtree->n.sym->attr.optional,
+				     CLASS_DATA (fsym)->attr.class_pointer
+				     || CLASS_DATA (fsym)->attr.allocatable);
+
 		  if (fsym && (fsym->ts.type == BT_DERIVED
 			       || fsym->ts.type == BT_ASSUMED)
 		      && e->ts.type == BT_CLASS
@@ -6808,16 +6830,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	      else
 		goto end_pointer_check;
 
+	      tmp = parmse.expr;
 	      if (fsym && fsym->ts.type == BT_CLASS)
 		{
-		  tmp = build_fold_indirect_ref_loc (input_location,
-						      parmse.expr);
+		  if (POINTER_TYPE_P (TREE_TYPE (tmp)))
+		    tmp = build_fold_indirect_ref_loc (input_location, tmp);
 		  tmp = gfc_class_data_get (tmp);
 		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))
 		    tmp = gfc_conv_descriptor_data_get (tmp);
 		}
-	      else
-		tmp = parmse.expr;
 
 	      /* If the argument is passed by value, we need to strip the
 		 INDIRECT_REF.  */
@@ -6973,6 +6994,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 
       vec_safe_push (arglist, parmse.expr);
     }
+  gfc_add_block_to_block (&se->pre, &clobbers);
   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);
 
   if (comp)
@@ -8782,8 +8804,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init, bool coarray)
   return gfc_finish_block (&block);
 }
 
-void
-gfc_conv_union_initializer (vec<constructor_elt, va_gc> *v,
+static void
+gfc_conv_union_initializer (vec<constructor_elt, va_gc> *&v,
                             gfc_component *un, gfc_expr *init)
 {
   gfc_constructor *ctor;
@@ -9066,7 +9088,7 @@ gfc_conv_expr_type (gfc_se * se, gfc_expr * expr, tree type)
    values only.  */
 
 void
-gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
+gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)
 {
   gfc_ss *ss;
   tree var;
@@ -9106,16 +9128,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
 	  gfc_add_block_to_block (&se->pre, &se->post);
 	  se->expr = var;
 	}
-      else if (add_clobber && expr->ref == NULL)
-	{
-	  tree clobber;
-	  tree var;
-	  /* FIXME: This fails if var is passed by reference, see PR
-	     41453.  */
-	  var = expr->symtree->n.sym->backend_decl;
-	  clobber = build_clobber (TREE_TYPE (var));
-	  gfc_add_modify (&se->pre, var, clobber);
-	}
       return;
     }
 
@@ -11021,6 +11033,9 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,
       class_han = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))
 	  ? gfc_class_data_get (lse->expr) : lse->expr;
 
+      if (!POINTER_TYPE_P (TREE_TYPE (class_han)))
+	class_han = gfc_build_addr_expr (NULL_TREE, class_han);
+
       /* Allocate block.  */
       gfc_init_block (&alloc);
       gfc_allocate_using_malloc (&alloc, class_han, size, NULL_TREE);
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index d6520eee5c0..96b8b512749 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -2981,12 +2981,23 @@ create_fn_spec (gfc_symbol *sym, tree fntype)
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
     if (spec_len < sizeof (spec))
       {
-	if (!f->sym || f->sym->attr.pointer || f->sym->attr.target
+	bool is_class = false;
+	bool is_pointer = false;
+
+	if (f->sym)
+	  {
+	    is_class = f->sym->ts.type == BT_CLASS && CLASS_DATA (f->sym)
+	      && f->sym->attr.class_ok;
+	    is_pointer = is_class ? CLASS_DATA (f->sym)->attr.class_pointer
+				  : f->sym->attr.pointer;
+	  }
+
+	if (f->sym == NULL || is_pointer || f->sym->attr.target
 	    || f->sym->attr.external || f->sym->attr.cray_pointer
 	    || (f->sym->ts.type == BT_DERIVED
 		&& (f->sym->ts.u.derived->attr.proc_pointer_comp
 		    || f->sym->ts.u.derived->attr.pointer_comp))
-	    || (f->sym->ts.type == BT_CLASS
+	    || (is_class
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
 		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index 69d3fdcfdac..bc032231d3a 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -500,8 +500,7 @@ tree gfc_build_compare_string (tree, tree, tree, tree, int, enum tree_code);
 void gfc_conv_expr (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_val (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr);
-void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr,
-			      bool add_clobber = false);
+void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);
 
 
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 0af888c7d78..6b208f4680f 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -4487,10 +4487,12 @@ driver_handle_option (struct gcc_options *opts,
     case OPT_static_libgcc:
     case OPT_shared_libgcc:
     case OPT_static_libgfortran:
+    case OPT_static_libphobos:
     case OPT_static_libstdc__:
       /* These are always valid, since gcc.c itself understands the
-	 first two, gfortranspec.c understands -static-libgfortran and
-	 g++spec.c understands -static-libstdc++ */
+	 first two, gfortranspec.c understands -static-libgfortran,
+	 d-spec.cc understands -static-libphobos, and g++spec.c
+	 understands -static-libstdc++ */
       validated = true;
       break;
 
diff --git a/gcc/gimple-isel.cc b/gcc/gimple-isel.cc
index 2c78a08d3f1..3690782eca4 100644
--- a/gcc/gimple-isel.cc
+++ b/gcc/gimple-isel.cc
@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see
 /* Expand all ARRAY_REF(VIEW_CONVERT_EXPR) gimple assignments into calls to
    internal function based on vector type of selected expansion.
    i.e.:
-     VIEW_CONVERT_EXPR<int[4]>(u)[_1] =  = i_4(D);
+     VIEW_CONVERT_EXPR<int[4]>(u)[_1] = i_4(D);
    =>
      _7 = u;
      _8 = .VEC_SET (_7, i_4(D), _1);
@@ -100,6 +100,7 @@ gimple_expand_vec_set_expr (gimple_stmt_iterator *gsi)
 
 	  gimple_move_vops (ass_stmt, stmt);
 	  gsi_remove (gsi, true);
+	  *gsi = gsi_for_stmt (ass_stmt);
 	}
     }
 
@@ -241,6 +242,14 @@ gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,
 			GET_MODE_NUNITS (cmp_op_mode)));
 
   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);
+  /* Some targets do not have vcondeq and only vcond with NE/EQ
+     but not vcondu, so make sure to also try vcond here as
+     vcond_icode_p would canonicalize the optab query to.  */
+  if (icode == CODE_FOR_nothing
+      && (tcode == NE_EXPR || tcode == EQ_EXPR)
+      && ((icode = get_vcond_icode (mode, cmp_op_mode, !unsignedp))
+	  != CODE_FOR_nothing))
+    unsignedp = !unsignedp;
   if (icode == CODE_FOR_nothing)
     {
       if (tcode == LT_EXPR
diff --git a/gcc/gimple-ssa-store-merging.c b/gcc/gimple-ssa-store-merging.c
index 0a74b025d00..6c1b8cdb487 100644
--- a/gcc/gimple-ssa-store-merging.c
+++ b/gcc/gimple-ssa-store-merging.c
@@ -263,7 +263,7 @@ do_shift_rotate (enum tree_code code,
 		 int count)
 {
   int i, size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;
-  unsigned head_marker;
+  uint64_t head_marker;
 
   if (count < 0
       || count >= TYPE_PRECISION (n->type)
diff --git a/gcc/gimple-ssa-warn-restrict.c b/gcc/gimple-ssa-warn-restrict.c
index ad37f20afaa..cfaa2179bb6 100644
--- a/gcc/gimple-ssa-warn-restrict.c
+++ b/gcc/gimple-ssa-warn-restrict.c
@@ -514,7 +514,6 @@ builtin_memref::set_base_and_offset (tree expr)
     {
       tree memrefoff = fold_convert (ptrdiff_type_node, TREE_OPERAND (base, 1));
       extend_offset_range (memrefoff);
-      base = TREE_OPERAND (base, 0);
 
       if (refoff != HOST_WIDE_INT_MIN
       	  && TREE_CODE (expr) == COMPONENT_REF)
@@ -527,14 +526,19 @@ builtin_memref::set_base_and_offset (tree expr)
 	     REFOFF is set to s[1].b - (char*)s.  */
 	  offset_int off = tree_to_shwi (memrefoff);
 	  refoff += off;
-      	}
-
-      if (!integer_zerop (memrefoff))
-	/* A non-zero offset into an array of struct with flexible array
-	   members implies that the array is empty because there is no
-	   way to initialize such a member when it belongs to an array.
-	   This must be some sort of a bug.  */
-	refsize = 0;
+
+	  if (!integer_zerop (memrefoff)
+	      && !COMPLETE_TYPE_P (TREE_TYPE (expr))
+	      && multiple_of_p (sizetype, memrefoff,
+				TYPE_SIZE_UNIT (TREE_TYPE (base))))
+	    /* A non-zero offset into an array of struct with flexible array
+	       members implies that the array is empty because there is no
+	       way to initialize such a member when it belongs to an array.
+	       This must be some sort of a bug.  */
+	    refsize = 0;
+	}
+
+      base = TREE_OPERAND (base, 0);
     }
 
   if (TREE_CODE (ref) == COMPONENT_REF)
diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
index 5dd33a75c3a..44407e1b5cd 100644
--- a/gcc/ipa-icf.c
+++ b/gcc/ipa-icf.c
@@ -2411,10 +2411,11 @@ sem_item_optimizer::filter_removed_items (void)
 	    {
 	      /* Filter out non-readonly variables.  */
 	      tree decl = item->decl;
-	      if (TREE_READONLY (decl))
-		filtered.safe_push (item);
-	      else
+	      varpool_node *vnode = static_cast <sem_variable *>(item)->get_node ();
+	      if (!TREE_READONLY (decl) || vnode->body_removed)
 		remove_item (item);
+	      else
+		filtered.safe_push (item);
 	    }
         }
     }
diff --git a/gcc/ipa-modref-tree.h b/gcc/ipa-modref-tree.h
index d36c28c0470..9927fc0982b 100644
--- a/gcc/ipa-modref-tree.h
+++ b/gcc/ipa-modref-tree.h
@@ -560,7 +560,7 @@ struct GTY((user)) modref_tree
 	    size_t k;
 	    modref_access_node *access_node;
 	    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)
-	      if (access_node->parm_index > 0)
+	      if (access_node->parm_index >= 0)
 		{
 		  if (access_node->parm_index < (int)map->length ())
 		    access_node->parm_index = (*map)[access_node->parm_index];
diff --git a/gcc/ipa-prop.c b/gcc/ipa-prop.c
index b6c6b51612d..c1ddf8ba11e 100644
--- a/gcc/ipa-prop.c
+++ b/gcc/ipa-prop.c
@@ -1109,6 +1109,10 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,
   if (!base)
     return false;
 
+  /* We can not propagate across volatile loads.  */
+  if (TREE_THIS_VOLATILE (op))
+    return false;
+
   if (DECL_P (base))
     {
       int index = ipa_get_param_decl_index_1 (descriptors, base);
diff --git a/gcc/lra-assigns.c b/gcc/lra-assigns.c
index b406096a39c..0ec0a79080a 100644
--- a/gcc/lra-assigns.c
+++ b/gcc/lra-assigns.c
@@ -1775,8 +1775,8 @@ lra_split_hard_reg_for (void)
      iterations.  Either it's an asm and something is wrong with the
      constraints, or we have run out of spill registers; error out in
      either case.  */
-  bool asm_p = false;
-  bitmap_head failed_reload_insns, failed_reload_pseudos;
+  bool asm_p = false, spill_p = false;
+  bitmap_head failed_reload_insns, failed_reload_pseudos, over_split_insns;
   
   if (lra_dump_file != NULL)
     fprintf (lra_dump_file,
@@ -1787,6 +1787,7 @@ lra_split_hard_reg_for (void)
   bitmap_ior (&non_reload_pseudos, &lra_inheritance_pseudos, &lra_split_regs);
   bitmap_ior_into (&non_reload_pseudos, &lra_subreg_reload_pseudos);
   bitmap_ior_into (&non_reload_pseudos, &lra_optional_reload_pseudos);
+  bitmap_initialize (&over_split_insns, &reg_obstack);
   for (i = lra_constraint_new_regno_start; i < max_regno; i++)
     if (reg_renumber[i] < 0 && lra_reg_info[i].nrefs != 0
 	&& (rclass = lra_get_allocno_class (i)) != NO_REGS
@@ -1794,14 +1795,41 @@ lra_split_hard_reg_for (void)
       {
 	if (! find_reload_regno_insns (i, first, last))
 	  continue;
-	if (BLOCK_FOR_INSN (first) == BLOCK_FOR_INSN (last)
-	    && spill_hard_reg_in_range (i, rclass, first, last))
+	if (BLOCK_FOR_INSN (first) == BLOCK_FOR_INSN (last))
 	  {
-	    bitmap_clear (&failed_reload_pseudos);
-	    return true;
+	    /* Check that we are not trying to split over the same insn
+	       requiring reloads to avoid splitting the same hard reg twice or
+	       more.  If we need several hard regs splitting over the same insn
+	       it can be finished on the next iterations.
+
+	       The following loop iteration number is small as we split hard
+	       reg in a very small range.  */
+	    for (insn = first;
+		 insn != NEXT_INSN (last);
+		 insn = NEXT_INSN (insn))
+	      if (bitmap_bit_p (&over_split_insns, INSN_UID (insn)))
+		break;
+	    if (insn != NEXT_INSN (last)
+		|| !spill_hard_reg_in_range (i, rclass, first, last))
+	      {
+		bitmap_set_bit (&failed_reload_pseudos, i);
+	      }
+	    else
+	      {
+		for (insn = first;
+		     insn != NEXT_INSN (last);
+		     insn = NEXT_INSN (insn))
+		  bitmap_set_bit (&over_split_insns, INSN_UID (insn));
+		spill_p = true;
+	      }
 	  }
-	bitmap_set_bit (&failed_reload_pseudos, i);
       }
+  bitmap_clear (&over_split_insns);
+  if (spill_p)
+    {
+      bitmap_clear (&failed_reload_pseudos);
+      return true;
+    }
   bitmap_clear (&non_reload_pseudos);
   bitmap_initialize (&failed_reload_insns, &reg_obstack);
   EXECUTE_IF_SET_IN_BITMAP (&failed_reload_pseudos, 0, u, bi)
diff --git a/gcc/lto-streamer-in.c b/gcc/lto-streamer-in.c
index eb8a7dc57b0..0c5af5cecef 100644
--- a/gcc/lto-streamer-in.c
+++ b/gcc/lto-streamer-in.c
@@ -1699,11 +1699,14 @@ lto_read_tree_1 (class lto_input_block *ib, class data_in *data_in, tree expr)
   /* Read all the pointer fields in EXPR.  */
   streamer_read_tree_body (ib, data_in, expr);
 
-  /* Read any LTO-specific data not read by the tree streamer.  */
+  /* Read any LTO-specific data not read by the tree streamer.  Do not use
+     stream_read_tree here since that flushes the dref_queue in mids of
+     SCC reading.  */
   if (DECL_P (expr)
       && TREE_CODE (expr) != FUNCTION_DECL
       && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)
-    DECL_INITIAL (expr) = stream_read_tree (ib, data_in);
+    DECL_INITIAL (expr)
+      = lto_input_tree_1 (ib, data_in, streamer_read_record_start (ib), 0);
 
   /* Stream references to early generated DIEs.  Keep in sync with the
      trees handled in dwarf2out_register_external_die.  */
diff --git a/gcc/match.pd b/gcc/match.pd
index e89601c0c14..8126f90ee75 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -4114,7 +4114,10 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
   (if (! FLOAT_TYPE_P (TREE_TYPE (@0))
        || ! HONOR_NANS (@0))
    { constant_boolean_node (true, type); }
-   (if (cmp != EQ_EXPR)
+   (if (cmp != EQ_EXPR
+	/* With -ftrapping-math conversion to EQ loses an exception.  */
+	&& (! FLOAT_TYPE_P (TREE_TYPE (@0))
+	    || ! flag_trapping_math))
     (eq @0 @0)))))
 (for cmp (ne gt lt)
  (simplify
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index 962cf886710..a8cabbf8bb3 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -5903,10 +5903,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 			}
 
 		      if (POINTER_TYPE_P (TREE_TYPE (x)))
-			x = fold_build2 (POINTER_PLUS_EXPR,
-					 TREE_TYPE (x), x, t);
+			x = fold_build_pointer_plus (x, t);
 		      else
-			x = fold_build2 (PLUS_EXPR, TREE_TYPE (x), x, t);
+			x = fold_build2 (PLUS_EXPR, TREE_TYPE (x), x,
+					 fold_convert (TREE_TYPE (x), t));
 		    }
 
 		  if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LINEAR
diff --git a/gcc/postreload.c b/gcc/postreload.c
index 60a622dbaf3..ed5f54aaeb0 100644
--- a/gcc/postreload.c
+++ b/gcc/postreload.c
@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see
 #include "function-abi.h"
 #include "rtl-iter.h"
 
-static int reload_cse_noop_set_p (rtx);
 static bool reload_cse_simplify (rtx_insn *, rtx);
 static void reload_cse_regs_1 (void);
 static int reload_cse_simplify_set (rtx, rtx_insn *);
@@ -74,16 +73,6 @@ reload_cse_regs (rtx_insn *first ATTRIBUTE_UNUSED)
     }
 }
 
-/* See whether a single set SET is a noop.  */
-static int
-reload_cse_noop_set_p (rtx set)
-{
-  if (cselib_reg_set_mode (SET_DEST (set)) != GET_MODE (SET_DEST (set)))
-    return 0;
-
-  return rtx_equal_for_cselib_p (SET_DEST (set), SET_SRC (set));
-}
-
 /* Try to simplify INSN.  Return true if the CFG may have changed.  */
 static bool
 reload_cse_simplify (rtx_insn *insn, rtx testreg)
@@ -118,7 +107,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)
          this out, so it's safer to simplify before we delete.  */
       count += reload_cse_simplify_set (body, insn);
 
-      if (!count && reload_cse_noop_set_p (body))
+      if (!count && cselib_redundant_set_p (body))
 	{
 	  if (check_for_inc_dec (insn))
 	    delete_insn_and_edges (insn);
@@ -157,7 +146,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)
 	  rtx part = XVECEXP (body, 0, i);
 	  if (GET_CODE (part) == SET)
 	    {
-	      if (! reload_cse_noop_set_p (part))
+	      if (! cselib_redundant_set_p (part))
 		break;
 	      if (REG_P (SET_DEST (part))
 		  && REG_FUNCTION_VALUE_P (SET_DEST (part)))
diff --git a/gcc/regrename.c b/gcc/regrename.c
index c0d4643f802..0cf93d323d9 100644
--- a/gcc/regrename.c
+++ b/gcc/regrename.c
@@ -324,8 +324,7 @@ static bool
 check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,
 		 class du_head *this_head, HARD_REG_SET this_unavailable)
 {
-  machine_mode mode = GET_MODE (*this_head->first->loc);
-  int nregs = hard_regno_nregs (new_reg, mode);
+  int nregs = this_head->nregs;
   int i;
   struct du_chain *tmp;
 
diff --git a/gcc/rtl-ssa/accesses.cc b/gcc/rtl-ssa/accesses.cc
index de3a29edbeb..af7b568fa98 100644
--- a/gcc/rtl-ssa/accesses.cc
+++ b/gcc/rtl-ssa/accesses.cc
@@ -393,6 +393,28 @@ set_node::print (pretty_printer *pp) const
   pp_access (pp, first_def ());
 }
 
+// See the comment above the declaration.
+clobber_info *
+clobber_group::prev_clobber (insn_info *insn) const
+{
+  auto &tree = const_cast<clobber_tree &> (m_clobber_tree);
+  int comparison = lookup_clobber (tree, insn);
+  if (comparison <= 0)
+    return dyn_cast<clobber_info *> (tree.root ()->prev_def ());
+  return tree.root ();
+}
+
+// See the comment above the declaration.
+clobber_info *
+clobber_group::next_clobber (insn_info *insn) const
+{
+  auto &tree = const_cast<clobber_tree &> (m_clobber_tree);
+  int comparison = lookup_clobber (tree, insn);
+  if (comparison >= 0)
+    return dyn_cast<clobber_info *> (tree.root ()->next_def ());
+  return tree.root ();
+}
+
 // See the comment above the declaration.
 void
 clobber_group::print (pretty_printer *pp) const
@@ -415,6 +437,32 @@ clobber_group::print (pretty_printer *pp) const
   pp_indentation (pp) -= 4;
 }
 
+// See the comment above the declaration.
+def_info *
+def_lookup::prev_def (insn_info *insn) const
+{
+  if (mux && comparison == 0)
+    if (auto *node = mux.dyn_cast<def_node *> ())
+      if (auto *group = dyn_cast<clobber_group *> (node))
+	if (clobber_info *clobber = group->prev_clobber (insn))
+	  return clobber;
+
+  return last_def_of_prev_group ();
+}
+
+// See the comment above the declaration.
+def_info *
+def_lookup::next_def (insn_info *insn) const
+{
+  if (mux && comparison == 0)
+    if (auto *node = mux.dyn_cast<def_node *> ())
+      if (auto *group = dyn_cast<clobber_group *> (node))
+	if (clobber_info *clobber = group->next_clobber (insn))
+	  return clobber;
+
+  return first_def_of_next_group ();
+}
+
 // Return a clobber_group for CLOBBER, creating one if CLOBBER doesn't
 // already belong to a group.
 clobber_group *
@@ -1295,9 +1343,9 @@ function_info::make_use_available (use_info *use, bb_info *bb)
 	  input->m_is_temp = true;
 	  phi->m_is_temp = true;
 	  phi->make_degenerate (input);
-	  if (def_info *prev = dl.prev_def ())
+	  if (def_info *prev = dl.prev_def (phi_insn))
 	    phi->set_prev_def (prev);
-	  if (def_info *next = dl.next_def ())
+	  if (def_info *next = dl.next_def (phi_insn))
 	    phi->set_next_def (next);
 	}
 
diff --git a/gcc/rtl-ssa/accesses.h b/gcc/rtl-ssa/accesses.h
index 91e64f3321f..ed72a3f61f0 100644
--- a/gcc/rtl-ssa/accesses.h
+++ b/gcc/rtl-ssa/accesses.h
@@ -909,6 +909,12 @@ public:
   clobber_info *first_clobber () const;
   clobber_info *last_clobber () const { return m_last_clobber; }
 
+  // Return the last clobber before INSN in the group, or null if none.
+  clobber_info *prev_clobber (insn_info *insn) const;
+
+  // Return the next clobber after INSN in the group, or null if none.
+  clobber_info *next_clobber (insn_info *insn) const;
+
   // Return true if this group has been replaced by new clobber_groups.
   bool has_been_superceded () const { return !m_last_clobber; }
 
@@ -993,25 +999,33 @@ public:
   //
   // Otherwise, return the last definition that occurs before P,
   // or null if none.
-  def_info *prev_def () const;
+  def_info *last_def_of_prev_group () const;
 
   // If we found a clobber_group that spans P, return the definition
   // that follows the end of the group, or null if none.
   //
   // Otherwise, return the first definition that occurs after P,
   // or null if none.
-  def_info *next_def () const;
+  def_info *first_def_of_next_group () const;
 
   // If we found a set_info at P, return that set_info, otherwise return null.
   set_info *matching_set () const;
 
   // If we found a set_info at P, return that set_info, otherwise return
   // prev_def ().
-  def_info *matching_or_prev_def () const;
+  def_info *matching_set_or_last_def_of_prev_group () const;
 
   // If we found a set_info at P, return that set_info, otherwise return
   // next_def ().
-  def_info *matching_or_next_def () const;
+  def_info *matching_set_or_first_def_of_next_group () const;
+
+  // P is the location of INSN.  Return the last definition (of any kind)
+  // that occurs before INSN, or null if none.
+  def_info *prev_def (insn_info *insn) const;
+
+  // P is the location of INSN.  Return the next definition (of any kind)
+  // that occurs after INSN, or null if none.
+  def_info *next_def (insn_info *insn) const;
 
   def_mux mux;
   int comparison;
diff --git a/gcc/rtl-ssa/member-fns.inl b/gcc/rtl-ssa/member-fns.inl
index 0b821ae1a77..2aae89e5a94 100644
--- a/gcc/rtl-ssa/member-fns.inl
+++ b/gcc/rtl-ssa/member-fns.inl
@@ -401,7 +401,7 @@ def_mux::set () const
 }
 
 inline def_info *
-def_lookup::prev_def () const
+def_lookup::last_def_of_prev_group () const
 {
   if (!mux)
     return nullptr;
@@ -413,7 +413,7 @@ def_lookup::prev_def () const
 }
 
 inline def_info *
-def_lookup::next_def () const
+def_lookup::first_def_of_next_group () const
 {
   if (!mux)
     return nullptr;
@@ -433,19 +433,19 @@ def_lookup::matching_set () const
 }
 
 inline def_info *
-def_lookup::matching_or_prev_def () const
+def_lookup::matching_set_or_last_def_of_prev_group () const
 {
   if (set_info *set = matching_set ())
     return set;
-  return prev_def ();
+  return last_def_of_prev_group ();
 }
 
 inline def_info *
-def_lookup::matching_or_next_def () const
+def_lookup::matching_set_or_first_def_of_next_group () const
 {
   if (set_info *set = matching_set ())
     return set;
-  return next_def ();
+  return first_def_of_next_group ();
 }
 
 inline insn_note::insn_note (insn_note_kind kind)
diff --git a/gcc/rtl-ssa/movement.h b/gcc/rtl-ssa/movement.h
index 5e749235840..03e10e52193 100644
--- a/gcc/rtl-ssa/movement.h
+++ b/gcc/rtl-ssa/movement.h
@@ -103,7 +103,7 @@ restrict_movement_for_dead_range (insn_range_info &move_range,
   resource_info resource = full_register (regno);
   def_lookup dl = crtl->ssa->find_def (resource, insn);
 
-  def_info *prev = dl.prev_def ();
+  def_info *prev = dl.last_def_of_prev_group ();
   ebb_info *ebb = insn->ebb ();
   if (!prev || prev->ebb () != ebb)
     {
@@ -143,8 +143,8 @@ restrict_movement_for_dead_range (insn_range_info &move_range,
     }
 
   // Stop the instruction moving beyond the next relevant definition of REGNO.
-  def_info *next = first_def_ignoring (dl.matching_or_next_def (),
-				       ignore_clobbers::YES, ignore);
+  def_info *next = dl.matching_set_or_first_def_of_next_group ();
+  next = first_def_ignoring (next, ignore_clobbers::YES, ignore);
   if (next)
     move_range = move_earlier_than (move_range, next->insn ());
 
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 67a49e65fd8..88b37584f74 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -3405,7 +3405,7 @@ replace_rtx (rtx x, rtx from, rtx to, bool all_regs)
     {
       rtx new_rtx = replace_rtx (SUBREG_REG (x), from, to, all_regs);
 
-      if (CONST_INT_P (new_rtx))
+      if (CONST_SCALAR_INT_P (new_rtx))
 	{
 	  x = simplify_subreg (GET_MODE (x), new_rtx,
 			       GET_MODE (SUBREG_REG (x)),
@@ -3421,7 +3421,7 @@ replace_rtx (rtx x, rtx from, rtx to, bool all_regs)
     {
       rtx new_rtx = replace_rtx (XEXP (x, 0), from, to, all_regs);
 
-      if (CONST_INT_P (new_rtx))
+      if (CONST_SCALAR_INT_P (new_rtx))
 	{
 	  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
 					new_rtx, GET_MODE (XEXP (x, 0)));
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 5fc23605244..ac1f71dd7bc 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,925 @@
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/106817
+	* gfortran.dg/intent_optimize_4.f90: New test.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/105012
+	* gfortran.dg/intent_out_15.f90: New test.
+
+2022-10-08  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100029
+	PR fortran/100040
+	* gfortran.dg/PR100029.f90: New test.
+	* gfortran.dg/PR100040.f90: New test.
+
+2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-20  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100132
+	* gfortran.dg/PR100132.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107054
+	* gfortran.dg/pr107054.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82868
+	* gfortran.dg/associate_26a.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106985
+	* gfortran.dg/pr106985.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103694
+	* gfortran.dg/pr103694.f90: New test.
+
+2022-09-29  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-09-28  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107061
+	* gcc.target/i386/keylocker-encodekey128.c: Don't check
+	XMM4-XMM6.
+	* gcc.target/i386/keylocker-encodekey256.c: Likewise.
+
+2022-09-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106986
+	* gfortran.dg/pr106986.f90: New test.
+
+2022-09-24  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-03  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100245
+	* gfortran.dg/PR100245.f90: New test.
+
+2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106857
+	* gfortran.dg/pr106857.f90: New test.
+
+2022-09-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-07  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/106345
+	* lib/target-supports.exp (check_effective_target_powerpc_sqrt): Add
+	a function definition to avoid pedwarn about empty translation unit.
+	(check_effective_target_has_arch_pwr5): Likewise.
+	(check_effective_target_has_arch_pwr6): Likewise.
+	(check_effective_target_has_arch_pwr7): Likewise.
+	(check_effective_target_has_arch_pwr8): Likewise.
+	(check_effective_target_has_arch_pwr9): Likewise.
+	(check_effective_target_has_arch_pwr10): Likewise.
+	(check_effective_target_has_arch_ppc64): Likewise.
+	(check_effective_target_ppc_float128): Likewise.
+	(check_effective_target_ppc_float128_insns): Likewise.
+	(check_effective_target_powerpc_vsx): Likewise.
+
+2022-09-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-09-01  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101322
+	* g++.target/powerpc/pr101322.C: New test.
+
+2022-09-05  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-04  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100136
+	* gfortran.dg/PR100136.f90: New test.
+
+2022-08-30  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-08-28  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/106017
+	* gcc.target/powerpc/pr106017.c: New test.
+
+2022-08-24  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	Backported from master:
+	2022-08-16  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	PR target/103353
+	* gcc.target/powerpc/pr103353.c: New test.
+
+2022-08-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-26  Segher Boessenkoool  <segher@kernel.crashing.org>
+
+	PR target/105349
+	* lib/target-supports.exp (check_effective_target_has_arch_pwr5): Use
+	the specified dg-options.
+	(check_effective_target_has_arch_pwr6): Ditto.
+	(check_effective_target_has_arch_pwr7): Ditto.
+	(check_effective_target_has_arch_pwr8): Ditto.
+	(check_effective_target_has_arch_pwr9): Ditto.
+	(check_effective_target_has_arch_pwr10): Ditto.
+	(check_effective_target_has_arch_ppc64): Ditto.
+
+2022-08-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* lib/target-supports.exp (check_effective_target_has_arch_ppc64): New.
+
+2022-08-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/106492
+	* g++.dg/gomp/pr106492.C: New test.
+
+2022-08-16  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/103197
+	PR target/102146
+	* gcc.target/powerpc/bswap-brw.c: Add xfail on scan-assembler for -m32.
+
+2022-08-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR c/106016
+	* gcc.target/powerpc/pr106016.c: New test.
+
+2022-08-04  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-03-25  Peter Bergner  <bergner@linux.ibm.com>
+
+	* g++.dg/pr65240-1.C: Use -mdejagnu-cpu=.  Remove dg-skip-if.
+	* g++.dg/pr65240-2.C: Likewise.
+	* g++.dg/pr65240-3.C: Likewise.
+	* g++.dg/pr65240-4.C: Likewise.
+	* g++.dg/pr65242.C: Likewise.
+	* g++.dg/pr67211.C: Likewise.
+	* g++.dg/pr69667.C: Likewise.
+	* g++.dg/pr71294.C: Likewise.
+	* g++.dg/pr84279.C: Likewise.
+	* g++.dg/torture/ppc-ldst-array.C: Likewise.
+	* gfortran.dg/nint_p7.f90: Likewise.
+	* gfortran.dg/pr102860.f90: Likewise.
+	* gcc.target/powerpc/fusion.c: Use -mdejagnu-cpu= and -mdejagnu-tune=.
+	* gcc.target/powerpc/fusion2.c: Likewise.
+	* gcc.target/powerpc/int_128bit-runnable.c: Use -mdejagnu-cpu=.
+	* gcc.target/powerpc/test_mffsl.c: Likewise.
+	* gfortran.dg/pr47614.f: Likewise.
+	* gfortran.dg/pr58968.f: Likewise.
+
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* c-c++-common/pr97498.c: New test.
+	* gcc.dg/pragma-message.c: Adapt for improved warning locations.
+
+2022-08-02  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106091
+	* gcc.target/powerpc/pr106091.c: New test.
+
+2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103504
+	* gfortran.dg/pr103504.f90: New test.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105618
+	* gcc.dg/tree-ssa/ssa-sink-19.c: New testcase.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/103116
+	* gcc.dg/vect/pr103116-1.c: New testcase.
+	* gcc.dg/vect/pr103116-2.c: Likewise.
+
+2022-07-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106361
+	* g++.dg/cpp2a/spaceship-eq14.C: New test.
+
+2022-07-21  Surya Kumari Jangala  <jskumari@linux.vnet.ibm.com>
+
+	Backported from master:
+	2022-06-14  Surya Kumari Jangala  <jskumari@linux.ibm.com>
+
+	PR rtl-optimization/105041
+	* gcc.target/powerpc/pr105041.c: New test.
+
+2022-07-16  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2022-07-15  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/104313
+	* gfortran.dg/pr104313.f: New test.
+
+2022-07-12  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-07-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/105860
+	* gcc.dg/tree-ssa/alias-access-path-13.c: New test.
+	* gcc.dg/tree-ssa/pr105860.c: Likewise.
+
+2022-07-04  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-03-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/104869
+	* g++.dg/pr104869.C: New test.
+
+2022-07-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106139
+	* gdc.dg/pr106139a.d: New test.
+	* gdc.dg/pr106139b.d: New test.
+	* gdc.dg/pr106139c.d: New test.
+	* gdc.dg/pr106139d.d: New test.
+	* gdc.test/fail_compilation/ice20264.d: New test.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-30  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103137
+	PR fortran/103138
+	PR fortran/103693
+	PR fortran/105243
+	* gfortran.dg/class_58.f90: Fix test.
+	* gfortran.dg/class_73.f90: New test.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-29  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/106121
+	* gfortran.dg/extends_type_of_4.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105954
+	* gfortran.dg/pr105954.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105691
+	* gfortran.dg/index_6.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105813
+	* gfortran.dg/unpack_vector_1.f90: New test.
+
+2022-07-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106024
+	* g++.dg/cpp2a/lambda-generic10.C: New test.
+
+2022-06-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105925
+	* g++.dg/cpp2a/desig26.C: New test.
+
+2022-06-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-06-17  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/105209
+	* gcc.target/alpha/pr105209.c: New test.
+
+2022-06-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-06-17  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/105970
+	* gcc.target/i386/pr105970.c: New test.
+
+2022-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/105998
+	* c-c++-common/pr105998.c: New test.
+
+2022-06-20  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2022-06-14  Jan Hubicka  <hubicka@ucw.cz>
+
+	* gcc.dg/ipa/pr105739.c: New test.
+
+2022-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105729
+	* g++.dg/ubsan/pr105729.C: New test.
+
+2022-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/105732
+	* c-c++-common/cpp/va-opt-10.c: New test.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* gdc.dg/Wpadded.d: New test.
+
+2022-06-15  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105726
+	* g++.dg/warn/Warray-bounds-27.C: New testcase.
+
+2022-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/104637
+	* gcc.target/i386/pr104637.c: Don't run on ia32.  Add -Wno-div-by-zero
+	to dg-options.
+	(foo): Remove extraneous initializer.
+
+2022-06-14  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/104637
+	* gcc.target/i386/pr104637.c: New.
+
+2022-06-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105852
+	PR c++/105761
+	* g++.dg/modules/tpl-friend-2_a.C: Adjust expected dump.
+	* g++.dg/template/friend74.C: New test.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105761
+	* g++.dg/cpp1y/auto-fn64.C: New test.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105795
+	* g++.dg/cpp1z/constexpr-aggr-base1.C: New test.
+
+2022-06-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105437
+	* g++.dg/vect/pr105437.cc: New testcase.
+
+2022-05-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102307
+	* g++.dg/cpp1z/constexpr-array2.C: New test.
+
+2022-05-27  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-04-18  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/105266
+	* gcc.dg/pr105250.c: Skip for powerpc*-*-* and s390*-*-*.
+
+2022-05-25  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backported from master:
+	2022-04-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/105147
+	* gcc.dg/pr105140.c: Skip for s390*-*-*.
+
+2022-05-25  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/105147
+	* gcc.dg/pr105140.c: Skip for powerpc*-*-*.
+
+2022-05-24  Qing Zhao  <qing.zhao@oracle.com>
+
+	Backported from master:
+	2022-05-09  Qing Zhao  <qing.zhao@oracle.com>
+
+	* gcc.target/i386/zero-scratch-regs-1.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-10.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-13.c: Add -msse.
+	* gcc.target/i386/zero-scratch-regs-14.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-15.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-16.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-17.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-18.c: Add -fno-stack-protector
+	-fno-PIC, adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-19.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-2.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-20.c: Add -msse.
+	* gcc.target/i386/zero-scratch-regs-21.c: Add -fno-stack-protector
+	-fno-PIC, Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-22.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-23.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-26.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-27.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-28.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-3.c: Add -fno-stack-protector.
+	* gcc.target/i386/zero-scratch-regs-31.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-4.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-5.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-6.c: Add -fno-stack-protector.
+	* gcc.target/i386/zero-scratch-regs-7.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-8.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-9.c: Add -fno-stack-protector.
+
+2022-05-19  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2022-05-06  Michael Meissner  <meissner@linux.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/102059
+	* gcc.target/powerpc/pr102059-4.c: New test.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-20  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105312
+	* gcc.target/arm/pr105312.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105263
+	* gcc.dg/pr105263.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105173
+	* gcc.dg/pr105173.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105163
+	* gcc.dg/torture/pr105163.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105148
+	* gcc.dg/torture/pr105148.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105250
+	* gcc.dg/pr105250.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105140
+	* gcc.dg/pr105140.c: New testcase.
+
+2022-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-04-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/100413
+	* g++.dg/ipa/pr100413.C: New test.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-05-11  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105230
+	* gfortran.dg/pr105230.f90: New test.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-03-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104849
+	* gfortran.dg/pr104849.f90: New test.
+
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* gcc.target/aarch64/sync-comp-swap-ool.c: New.
+	* gcc.target/aarch64/sync-op-acquire-ool.c: New.
+	* gcc.target/aarch64/sync-op-full-ool.c: New.
+	* gcc.target/aarch64/target_attr_20.c: Update check.
+	* gcc.target/aarch64/target_attr_21.c: Same.
+
+2022-05-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-16  Richard Biener  <rguenther@suse.de>
+
+	* gcc.dg/torture/pr105598.c: New testcase.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101442
+	* g++.dg/cpp0x/initlist-nrv1.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101698
+	* g++.dg/template/conv19.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65211
+	* g++.target/i386/vec-tmpl1.C: New test.
+
+2022-05-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-09-27  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102479
+	* g++.dg/cpp1z/class-deduction12.C: Also test alias CTAD in the
+	same way.
+	* g++.dg/cpp1z/class-deduction99.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102300
+	* g++.dg/parse/no-typename1.C: Remove expected error.
+	* g++.dg/template/nested7.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102629
+	* g++.dg/cpp2a/lambda-pack-init7.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104646
+	* g++.dg/cpp0x/constexpr-fno-elide-ctors1.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82980
+	* g++.dg/cpp0x/lambda/lambda-current-inst1.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105265
+	PR c++/100838
+	* g++.dg/cpp0x/initlist-new6.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105245
+	PR c++/100111
+	* g++.dg/cpp1y/constexpr-empty2.C: Add -fno-elide-constructors.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104669
+	* g++.target/i386/mv31.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102071
+	* g++.dg/cpp1z/aligned-new9.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104142
+	* g++.dg/opt/const7.C: New test.
+
+2022-05-10  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-05-10  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/105472
+	* gcc.target/i386/iamcu/asm-support.S: Add .note.GNU-stack section
+	only for Linux.
+	* gcc.target/x86_64/abi/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512f/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/ms-sysv/do-test.S: Likewise.
+
+2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/105528
+	* gcc.dg/pr105528.c: New test.
+
+2022-05-10  Jeff Law  <jeffreyalaw@gmail.com>
+
+	Backported from master:
+	2022-04-28  Jeff Law  <jeffreyalaw@gmail.com>
+
+	* lib/prune.exp (prune_gcc_output): Prune new linker warning.
+
+2022-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20220510-1.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/cpp23/lambda-attr1.C: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105331
+	* gcc.dg/pr105331.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105396
+	* gcc.dg/asan/pr105396.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/105333
+	* gcc.dg/pr105333.c: New test.
+
+2022-05-06  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-05-02  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR testsuite/105433
+	* gcc.target/i386/iamcu/asm-support.S: Add .note.GNU-stack.
+	* gcc.target/x86_64/abi/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512f/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/ms-sysv/do-test.S: Likewise.
+
+2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	* gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c: Update
+	the expected message for the case in which unaligned accesses
+	are not allowed.
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105365
+	PR analyzer/105366
+	* gcc.dg/analyzer/pr105365.c: New test.
+	* gcc.dg/analyzer/pr105366.c: New test.
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105252
+	* gcc.dg/analyzer/pr105252.c: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105386
+	* g++.dg/cpp0x/decltype81.C: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105304
+	* g++.dg/cpp2a/concepts-requires30.C: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105289
+	PR c++/86193
+	* g++.dg/template/partial-specialization11.C: New test.
+	* g++.dg/template/partial-specialization12.C: New test.
+
+2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90107
+	* g++.dg/parse/qualified6.C: New test.
+
+2022-04-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR testsuite/105095
+	* gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c: Update for
+	codegen.
+	* gcc.dg/vect/complex/fast-math-complex-add-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c:
+	Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mla-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-half-float.c: Likewise.
+	* gcc.dg/vect/vect.exp: Add extra letter to filter.
+
+2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105398
+	* g++.dg/cpp1y/lambda-generic-enum2.C: New test.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* gcc.target/i386/sse-14.c: Add tests for new macro.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105321
+	* g++.dg/cpp0x/constexpr-105321.C: New test.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97296
+	* g++.dg/cpp0x/ref-bind4.C: Add dg-error.
+	* g++.dg/cpp0x/ref-bind8.C: New test.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* gfortran.dg/dec_union_12.f90: New test.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* gcc.dg/pr105257.c: New test.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/105203
+	* gfortran.dg/g77/pr105203.f: New test.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/testsuite/c-c++-common/cpp/va-opt-10.c b/gcc/testsuite/c-c++-common/cpp/va-opt-10.c
new file mode 100644
index 00000000000..f810b429dd6
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/va-opt-10.c
@@ -0,0 +1,18 @@
+/* PR preprocessor/105732 */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" { target c } } */
+/* { dg-options "-std=c++20" { target c++ } } */
+
+#define m1(p1, p2, p3) p3
+#define m2(p1, ...) 1##__VA_OPT__(foo)
+#define m3(...) m1(1, 2, m2)
+#define m4(p1, ...) 1 __VA_OPT__()
+#define m5(...) m1(1, 2, m4)
+#if m3(,)(,)
+#else
+#error
+#endif
+#if m5(,)(,)
+#else
+#error
+#endif
diff --git a/gcc/testsuite/c-c++-common/pr105998.c b/gcc/testsuite/c-c++-common/pr105998.c
new file mode 100644
index 00000000000..85277b97007
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr105998.c
@@ -0,0 +1,12 @@
+/* PR middle-end/105998 */
+
+typedef int __attribute__((__vector_size__ (sizeof (long long)))) V;
+
+V v;
+
+long long
+foo (void)
+{
+  long long l = (long long) ((0 | v) - ((V) { } == 0));
+  return l;
+}
diff --git a/gcc/testsuite/c-c++-common/pr97498.c b/gcc/testsuite/c-c++-common/pr97498.c
new file mode 100644
index 00000000000..f5fa420415b
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr97498.c
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-Wunused-function" } */
+#pragma GCC diagnostic ignored "-Wunused-function"
+static void f() {} _Pragma("GCC diagnostic error \"-Wunused-function\"") /* { dg-bogus "-Wunused-function" } */
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C
new file mode 100644
index 00000000000..adb6830ff22
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C
@@ -0,0 +1,18 @@
+// PR c++/105321
+// { dg-do compile { target c++11 } }
+
+bool handle_error();
+
+constexpr int echo(int value, bool yes = true) noexcept
+{
+    return (yes || handle_error()), value;
+}
+
+static_assert(echo(10) == 10, "");
+
+constexpr int echo2(int value, bool no = false) noexcept
+{
+    return (!no || handle_error()), value;
+}
+
+static_assert(echo2(10) == 10, "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C
new file mode 100644
index 00000000000..71c76fa0247
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C
@@ -0,0 +1,89 @@
+// PR c++/104646
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fno-elide-constructors }
+
+template <typename _T1> struct pair {
+  _T1 first;
+  int second;
+};
+template <typename _Iterator> class __normal_iterator {
+  _Iterator __traits_type;
+
+public:
+  constexpr __normal_iterator() {}
+};
+template <typename> class allocator;
+template <typename> struct allocator_traits;
+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
+  using value_type = _Tp;
+  template <typename _Up> using rebind_alloc = allocator<_Up>;
+};
+template <typename _Alloc> struct __alloc_traits {
+  typedef allocator_traits<_Alloc> _Base_type;
+  typedef typename _Base_type::value_type &const_reference;
+  template <typename _Tp> struct rebind {
+    typedef typename _Base_type::template rebind_alloc<_Tp> other;
+  };
+};
+template <typename _Tp, typename _Alloc> struct _Vector_base {
+  typedef typename __alloc_traits<_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;
+};
+template <typename _Tp, typename _Alloc = allocator<_Tp>> class vector {
+public:
+  typename __alloc_traits<
+      typename _Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::const_reference
+  operator[](long);
+};
+enum match_flag_type {};
+template <typename, typename> class Trans_NS___cxx11_basic_regex;
+class Trans_NS___cxx11_match_results;
+enum _RegexExecutorPolicy { _S_auto };
+template <typename, typename, typename _CharT, typename _TraitsT,
+          _RegexExecutorPolicy, bool>
+bool __regex_algo_impl(Trans_NS___cxx11_match_results &,
+                       const Trans_NS___cxx11_basic_regex<_CharT, _TraitsT> &);
+template <typename, typename, typename, bool> class _Executor;
+template <typename _Ch_type, typename = _Ch_type>
+class Trans_NS___cxx11_basic_regex {};
+class Trans_NS___cxx11_match_results : vector<int> {
+  template <typename, typename, typename _Cp, typename _Rp,
+            _RegexExecutorPolicy, bool>
+  friend bool __regex_algo_impl(Trans_NS___cxx11_match_results &,
+                                const Trans_NS___cxx11_basic_regex<_Cp, _Rp> &);
+};
+template <typename _Bi_iter, typename _Alloc, typename _Ch_type,
+          typename _Rx_traits>
+void regex_search(_Bi_iter, _Alloc,
+                  Trans_NS___cxx11_basic_regex<_Ch_type, _Rx_traits>) {
+  __regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits, _S_auto, false>;
+}
+match_flag_type __regex_algo_impl___flags;
+template <typename, typename, typename _CharT, typename _TraitsT,
+          _RegexExecutorPolicy, bool>
+bool __regex_algo_impl(
+    Trans_NS___cxx11_match_results &__m,
+    const Trans_NS___cxx11_basic_regex<_CharT, _TraitsT> &__re) {
+  __normal_iterator<const char *> __e, __s;
+  _Executor<int, int, _TraitsT, false> __executor(__s, __e, __m, __re,
+                                                  __regex_algo_impl___flags);
+  __executor._M_match();
+  return false;
+}
+template <typename, typename, typename, bool> class _Executor {
+public:
+  _Executor(__normal_iterator<const char *>, __normal_iterator<const char *>,
+            vector<int>, Trans_NS___cxx11_basic_regex<char>, match_flag_type);
+  void _M_match() { _M_dfs(); }
+  void _M_dfs();
+  vector<pair<__normal_iterator<char *>>> _M_rep_count;
+};
+long _M_rep_once_more___i;
+template <typename _BiIter, typename _Alloc, typename _TraitsT, bool __dfs_mode>
+void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::_M_dfs() {
+  auto __rep_count = _M_rep_count[_M_rep_once_more___i];
+}
+char main___trans_tmp_1;
+void main___trans_tmp_2() {
+  Trans_NS___cxx11_basic_regex<char> re;
+  regex_search(main___trans_tmp_1, main___trans_tmp_2, re);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype81.C b/gcc/testsuite/g++.dg/cpp0x/decltype81.C
new file mode 100644
index 00000000000..7d25db39d9c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype81.C
@@ -0,0 +1,15 @@
+// PR c++/105386
+// { dg-do compile { target c++11 } }
+
+template<class T> struct NoInst {
+  static_assert(sizeof(T) == 9999, "NoInst instantiated");
+};
+
+template<class T> NoInst<T> f(T);
+
+template<class>
+struct A {
+  using type = decltype(f(0));
+};
+
+A<int> a;
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C b/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C
new file mode 100644
index 00000000000..0ef27806acf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C
@@ -0,0 +1,39 @@
+// PR c++/105265
+// { dg-do run { target c++11 } }
+
+int c;
+
+class Block
+{
+public:
+  Block(int n) : data{new char[n]}, size{n}
+  {
+    ++c;
+  }
+
+  ~Block()
+  {
+    --c;
+    delete[] data;
+  }
+
+private:
+  char* data;
+  int size;
+};
+
+struct Cargo
+{
+  Block const& block;
+};
+
+int main()
+{
+  {
+    Cargo* c = new Cargo{{4000}};
+    delete c;
+  }
+  if (c != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C b/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C
new file mode 100644
index 00000000000..e44dbecfece
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C
@@ -0,0 +1,34 @@
+// PR c++/101442
+// { dg-do run { target c++11 } }
+
+bool destroyed = false;
+
+struct A
+{
+  A() {}
+  A(const A &) = delete;
+  A &operator=(const A &) = delete;
+  ~A() {destroyed = true;}
+};
+
+struct B
+{
+  const A &a;
+  struct string {
+    string(const char*) { }
+    ~string() { }
+  } s;
+};
+
+B foo()
+{
+  B ret{ A{}, "" };
+  return ret;
+}
+
+int main()
+{
+  B b = foo();
+  if (!destroyed)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C
new file mode 100644
index 00000000000..a6631c5ca99
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C
@@ -0,0 +1,18 @@
+// PR c++/82980
+// { dg-do compile { target c++11 } }
+
+template <class T>
+struct Outer
+{
+  template <class U>
+  void f();
+
+  void bar(Outer outer) {
+    [outer](){ outer.f<int>(); };
+  }
+  void baz(Outer *p) {
+    [&](){ p->f<int>(); };
+  }
+};
+
+int main() { }
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C b/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
index 85ac9fbfd79..d296d7c3b72 100644
--- a/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
@@ -51,6 +51,6 @@ g (int *p, const int *pc, const int **q)
      similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-
      qualification signature of type T1 is a proper subset of  the  cv-
      qualification signature of type T2  */
-  f8 (q);
+  f8 (q); // { dg-error "call of overloaded" }
   f9 (q);
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C b/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C
new file mode 100644
index 00000000000..eee78fd5e74
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C
@@ -0,0 +1,10 @@
+// PR c++/97296
+// { dg-do compile }
+
+void f(const int * const &);
+void f(const int *);
+int *x;
+int main()
+{
+  f(x); // { dg-error "call of overloaded" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C b/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C
new file mode 100644
index 00000000000..13f3175da45
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C
@@ -0,0 +1,12 @@
+// PR c++/105761
+// { dg-do compile { target c++14 } }
+// { dg-additional-options -Wno-non-template-friend }
+
+template <class T>
+class X {
+  friend auto f(X);
+};
+
+struct Y : X<long> {
+  friend auto f(X) { return 0L; }
+};
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
index 2acfa98364b..9768b89904e 100644
--- a/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
@@ -1,4 +1,5 @@
 // { dg-do compile { target c++14 } }
+// { dg-additional-options -fno-elide-constructors }
 
 struct A
 {
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C
new file mode 100644
index 00000000000..77cf0bb9d02
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C
@@ -0,0 +1,15 @@
+// PR c++/105398
+// { dg-do compile { target c++14 } }
+
+auto f = [](auto &&m) {
+    enum E { _,e3,e2,e1,C4,C3,C2,C1 };
+    static constexpr int x_coeffs[3][4] = {
+        {e1,C2,C3,C4},
+        {e2,C1,C3,C4},
+        {e3,C1,C2,C4},
+    };
+};
+
+int main() {
+    f(0);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C b/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C
new file mode 100644
index 00000000000..3fa0ed996bd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C
@@ -0,0 +1,30 @@
+// PR c++/102071
+// { dg-do run { target c++17 } }
+// { dg-additional-options -faligned-new=2 }
+
+#include <new>
+
+int nalign;
+void *operator new (std::size_t s, std::align_val_t a)
+{
+  nalign = (int)a;
+  return operator new (s);
+}
+
+struct X { ~X(); int c; };
+
+int align = (alignof (X) > alignof (std::size_t)
+	     ? alignof (X) : alignof (std::size_t));
+
+int n = 4;
+
+int main()
+{
+  X *p = new X[n];
+  if (nalign != align)
+    __builtin_abort ();
+
+  X *p2 = new X;
+  if (nalign != alignof (X))
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
index a31cc1526db..f0d7ea0e16b 100644
--- a/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
@@ -15,3 +15,9 @@ A a(&i,2,B<42>());
 template <class,class> class same;
 template <class T> class same<T,T> {};
 same<decltype(a), A<int*>> s;
+
+#if __cpp_deduction_guides >= 201907
+template <class T> using C = A<const T*>;
+
+same<decltype(C(&i, 2, B<42>())), A<const int*>> t;
+#endif
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C
new file mode 100644
index 00000000000..6daa4b7c55c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C
@@ -0,0 +1,35 @@
+// PR c++/102479
+// { dg-do compile { target c++17 } }
+
+template<class T> struct A;
+
+template<class T>
+struct tuple {
+  tuple(T);
+
+  template<template<class> class Tmpl>
+  tuple(Tmpl<T>);
+
+  template<template<class> class Tmpl, typename A<Tmpl<char>>::type = 0>
+  tuple(Tmpl<T>);
+
+  template<template<class> class Tmpl, typename A<Tmpl<long>>::type = 0>
+  tuple(Tmpl<T>);
+};
+
+template<class T> struct B { };
+
+using ty1 = tuple<int>;
+using ty1 = decltype(tuple(0));
+using ty1 = decltype(tuple(B<int>{}));
+
+#if __cpp_deduction_guides >= 201907
+template<class T> using const_tuple = tuple<const T>;
+
+using ty2 = const_tuple<int>;
+using ty2 = decltype(const_tuple(0));
+using ty2 = decltype(const_tuple(B<const int>{}));
+
+using ty3 = const_tuple<B<int>>;
+using ty3 = decltype(const_tuple(B<int>{}));
+#endif
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C
new file mode 100644
index 00000000000..06acb4a9f78
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C
@@ -0,0 +1,27 @@
+// PR c++/105795
+// { dg-do compile { target c++17 } }
+
+struct empty
+{};
+
+template <typename T>
+struct tuple_holder
+{
+    [[no_unique_address]] T value;
+};
+
+struct tuple : tuple_holder<int>, tuple_holder<empty>
+{};
+
+constexpr auto make_tuple(int&& i, empty&& e)
+{
+    return tuple{i, e};
+}
+
+constexpr int foo()
+{
+    auto tuple = make_tuple(1, empty{});
+    return static_cast<const tuple_holder<int>&>(tuple).value;
+}
+
+static_assert (foo() == 1);
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C
new file mode 100644
index 00000000000..c30e3f2361d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C
@@ -0,0 +1,12 @@
+// PR c++/102307
+// { dg-do compile { target c++11 } }
+
+#include <array>
+template <unsigned N, unsigned M> struct Matrix {
+  constexpr Matrix(double const (&arr)[N][M]); // { dg-warning "never defined" }
+  constexpr Matrix(std::array<std::array<double, M>, N> const &arr);
+};
+int main() {
+  constexpr Matrix<2, 3>
+    mat {{ {1.0, 2.0, 3.0}, {4.0, 5.0, 6.0} }}; // { dg-error "before its definition" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C b/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C
new file mode 100644
index 00000000000..1528f734461
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C
@@ -0,0 +1,29 @@
+// P2173R1 - Attributes on Lambda-Expressions
+// { dg-do compile { target c++11 } }
+
+void
+foo (bool x, bool y)
+{
+  auto a = [][[noreturn]] () {};	// { dg-warning "'noreturn' function does return" }
+  if (x)
+    a ();
+  auto b = [][[noreturn]] {};		// { dg-warning "'noreturn' function does return" }
+  if (y)
+    b ();
+  auto c = [] [[ deprecated ]] () {};	// { dg-bogus "is deprecated" }
+  c ();					// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is deprecated" }
+  auto d = [][[deprecated]] {};		// { dg-bogus "is deprecated" }
+  d ();					// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is deprecated" }
+#if __cpp_generic_lambdas >= 201304
+  auto e = [] [[deprecated]] (auto x) {};	// { dg-bogus "is deprecated" }
+  e (0.0);				// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(auto:1\\\)>\[^\n\r]*' is deprecated" "" { target c++14 } }
+#endif
+#if __cpp_generic_lambdas >= 201707
+  auto f = [] <typename T> [[deprecated]] (T) {};	// { dg-bogus "is deprecated" }
+  f (1);				// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(T\\\)>\[^\n\r]*' is deprecated" "" { target c++20 } }
+#endif
+  auto g = [][[nodiscard]](int) { return 1; };
+  g (1);				// { dg-warning "ignoring return value of 'foo\\\(bool, bool\\\)::<lambda\\\(int\\\)>', declared with attribute 'nodiscard'" }
+  auto h = [] [[nodiscard]] { return 0; };
+  h ();					// { dg-warning "ignoring return value of 'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>', declared with attribute 'nodiscard'" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C b/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C
new file mode 100644
index 00000000000..f500af3f616
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C
@@ -0,0 +1,10 @@
+// PR c++/105304
+// { dg-do compile { target c++20 } }
+// { dg-additional-options "-Wall -Wsequence-point" }
+
+struct A { };
+
+int main() {
+  if (requires { A(); })
+    ;
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/desig26.C b/gcc/testsuite/g++.dg/cpp2a/desig26.C
new file mode 100644
index 00000000000..443fa3d089d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/desig26.C
@@ -0,0 +1,22 @@
+// PR c++/105925
+// { dg-do compile { target c++20 } }
+
+struct V
+{
+    int i;
+    double d;
+};
+
+struct X
+{
+    union
+    {
+        int x;
+        V y;
+    };
+};
+
+X foo()
+{
+    return {.y = {0, 0.0}};
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-generic10.C b/gcc/testsuite/g++.dg/cpp2a/lambda-generic10.C
new file mode 100644
index 00000000000..773fb948cee
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-generic10.C
@@ -0,0 +1,14 @@
+// PR c++/106024
+// { dg-do compile { target c++20 } }
+
+void sink(...);
+template <int... args> void f()
+{
+  sink ([] <int T> (int...) { return 1; }
+        .operator()<args>(args...)...); // { dg-error "" }
+} // { dg-prune-output {expected '\)'} }
+
+int main()
+{
+  f<1,2,3>();
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C
new file mode 100644
index 00000000000..f3c3899e97a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C
@@ -0,0 +1,18 @@
+// PR c++/102629
+// { dg-do compile { target c++20 } }
+
+template <class T> T&& forward(T&);
+template <class T> T&& forward(T&&);
+
+struct S {};
+
+template <typename... Args>
+void foo(Args&&... args) {
+  [...args = forward<Args> /*(args)*/] { // { dg-error "" }
+    [](auto...) { } (forward<Args>(args)...);
+  };
+}
+
+void bar( ) {
+  foo(S{});
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/spaceship-eq14.C b/gcc/testsuite/g++.dg/cpp2a/spaceship-eq14.C
new file mode 100644
index 00000000000..896e5232bf6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/spaceship-eq14.C
@@ -0,0 +1,17 @@
+// PR c++/106361
+// { dg-do compile { target c++20 } }
+
+struct foo {
+  int x;
+};
+
+struct bar {
+  foo f;			// { dg-error "operator==" }
+  friend bool operator==(const bar& a, const bar& b);
+};
+
+bool operator==(const bar& a, const bar& b) = default;
+
+int main() {
+  return bar{} == bar{};	// { dg-error "deleted" }
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr106492.C b/gcc/testsuite/g++.dg/gomp/pr106492.C
new file mode 100644
index 00000000000..f263bb42710
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr106492.C
@@ -0,0 +1,49 @@
+/* PR middle-end/106492 */
+
+template <typename T>
+struct S {
+  T a : 12;
+  S () : a(0)
+  {
+#pragma omp for simd linear(a)
+    for (int k = 0; k < 64; ++k)
+      a++;
+  }
+};
+struct U {
+  int a : 12;
+  U () : a(0)
+  {
+#pragma omp for simd linear(a)
+    for (int k = 0; k < 64; ++k)
+      a++;
+  }
+};
+
+S<int> s;
+U u;
+
+
+template <typename T>
+struct Sptr {
+  T a;
+  Sptr (T init) : a(init)
+  {
+#pragma omp for simd linear(a)
+    for (int k = 0; k < 64; ++k)
+      a++;
+  }
+};
+struct Uptr {
+  int *a;
+  Uptr (int *init) : a(init)
+  {
+#pragma omp for simd linear(a)
+    for (int k = 0; k < 64; ++k)
+      a++;
+  }
+};
+
+int i[1024];
+Sptr<int *> sptr(i);
+Uptr uptr(&i[100]);
diff --git a/gcc/testsuite/g++.dg/ipa/pr100413.C b/gcc/testsuite/g++.dg/ipa/pr100413.C
new file mode 100644
index 00000000000..96d71e7cf35
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr100413.C
@@ -0,0 +1,64 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c++11 -O2 -fno-guess-branch-probability -fno-inline-functions-called-once -fipa-cp-clone -fipa-pta -fnon-call-exceptions --param=ipa-cp-eval-threshold=0" } */
+
+
+template <typename> class allocator {
+public:
+  ~allocator();
+};
+template <typename> struct allocator_traits;
+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
+  using allocator_type = allocator<_Tp>;
+  template <typename _Up> using rebind_alloc = allocator<_Up>;
+  static void deallocate(allocator_type);
+};
+template <typename _ForwardIterator, typename _Tp>
+void _Destroy(_ForwardIterator, _ForwardIterator, _Tp);
+struct __alloc_traits : allocator_traits<allocator<int>> {
+  struct rebind {
+    typedef rebind_alloc<int> other;
+  };
+};
+struct _Vector_base {
+  struct _Vector_impl_data {
+    int _M_start;
+    int _M_finish;
+  };
+  struct _Vector_impl : __alloc_traits::rebind::other, _Vector_impl_data {};
+  __alloc_traits::rebind::other _M_get_Tp_allocator();
+  ~_Vector_base() { _M_deallocate(); }
+  _Vector_impl _M_impl;
+  void _M_deallocate() { __alloc_traits::deallocate(_M_impl); }
+};
+class vector : _Vector_base {
+public:
+  vector() noexcept {
+    allocator<int> __trans_tmp_1 = _M_get_Tp_allocator();
+    _Destroy(_M_impl._M_start, _M_impl._M_finish, __trans_tmp_1);
+  }
+  void size();
+};
+struct HTTPCallback {
+  virtual void OnFailure();
+};
+struct ContentCallback {
+  virtual void OnDownloadProgress();
+};
+class ClientNetworkContentSocketHandler : ContentCallback, HTTPCallback {
+  vector requested;
+  vector infos;
+  vector lastActivity;
+  void OnFailure();
+public:
+  int IDLE_TIMEOUT = 0;
+  ClientNetworkContentSocketHandler();
+  void DownloadSelectedContent();
+} _network_content_client;
+void ClientNetworkContentSocketHandler::DownloadSelectedContent() {
+  vector content;
+  content.size();
+}
+void ClientNetworkContentSocketHandler::OnFailure() {
+  DownloadSelectedContent();
+}
+ClientNetworkContentSocketHandler::ClientNetworkContentSocketHandler() {}
diff --git a/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C b/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
index 3acacf8ee34..c12857fbf69 100644
--- a/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
+++ b/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
@@ -16,5 +16,5 @@ template class TPL<int>;  // instantiate
 void foo (int, void *);
 
 // { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl definition '::template TPL'\n(  \[.\]=[^\n]*'\n)*  \[.\]=decl declaration '::template foo'\n(  \[.\]=[^\n]*'\n)*  \[.\]=binding '::TPL'} module } }
-// { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl declaration '::foo<int>'\n  \[.\]=binding '::foo'} module } }
+// { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl declaration '::foo'\n  \[.\]=binding '::foo'} module } }
 // { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=specialization definition '::TPL<int>'} module } }
diff --git a/gcc/testsuite/g++.dg/opt/const7.C b/gcc/testsuite/g++.dg/opt/const7.C
new file mode 100644
index 00000000000..5bcf94897a8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/const7.C
@@ -0,0 +1,7 @@
+// PR c++/104142
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -Wunused-variable }
+
+struct B { B()=default; };
+static const B b_var;		//  { dg-bogus "" }
+// { dg-final { scan-assembler-symbol-section {b_var} {^\.(const|rodata)|\[RO\]} } }
diff --git a/gcc/testsuite/g++.dg/parse/no-typename1.C b/gcc/testsuite/g++.dg/parse/no-typename1.C
index 711c621e26a..f40ea0ec13c 100644
--- a/gcc/testsuite/g++.dg/parse/no-typename1.C
+++ b/gcc/testsuite/g++.dg/parse/no-typename1.C
@@ -6,6 +6,6 @@ template <typename T> struct A
 {
     template <typename U> struct B
     {
-        A<T>::template B<U> foo(); // { dg-error "" "" { target c++17_down } }
+        A<T>::template B<U> foo();
     };
 };
diff --git a/gcc/testsuite/g++.dg/parse/qualified6.C b/gcc/testsuite/g++.dg/parse/qualified6.C
new file mode 100644
index 00000000000..68b51f771ec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/parse/qualified6.C
@@ -0,0 +1,10 @@
+// PR c++/90107
+// { dg-do compile }
+
+struct A;
+namespace N { extern A a; }
+struct A {} ::N::a;
+
+struct A1;
+struct B { static A1 a1; };
+struct A1 {} ::B::a1;
diff --git a/gcc/testsuite/g++.dg/pr104869.C b/gcc/testsuite/g++.dg/pr104869.C
new file mode 100644
index 00000000000..9a6ef88adbd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr104869.C
@@ -0,0 +1,78 @@
+// PR rtl-optimization/104869
+// { dg-do run }
+// { dg-options "-O2 -fvisibility=hidden -std=c++11" }
+// { dg-require-visibility "" }
+
+struct QBasicAtomicInteger {
+  [[gnu::noipa]] int loadRelaxed() { return 1; }
+};
+struct RefCount {
+  bool deref() {
+    int count = atomic.loadRelaxed();
+    if (count)
+      return false;
+    return deref();
+  }
+  QBasicAtomicInteger atomic;
+};
+struct QArrayData {
+  RefCount ref;
+};
+struct QString {
+  ~QString();
+  QArrayData d;
+};
+int ok;
+QString::~QString() { d.ref.deref(); }
+struct Label {
+  bool isValid() { return generator; }
+  int *generator;
+  int index;
+};
+struct ControlFlow;
+struct Codegen {
+  [[gnu::noipa]] bool visit();
+  ControlFlow *controlFlow;
+};
+struct ControlFlow {
+  enum UnwindType { EE };
+  struct UnwindTarget {
+    Label linkLabel;
+  };
+  ControlFlow *parent;
+  UnwindType unwindTarget_type;
+  UnwindTarget unwindTarget() {
+    QString label;
+    ControlFlow *flow = this;
+    while (flow) {
+      Label l = getUnwindTarget(unwindTarget_type, label);
+      if (l.isValid())
+        return {l};
+      flow = flow->parent;
+    }
+    return UnwindTarget();
+  }
+  [[gnu::noipa]] Label getUnwindTarget(UnwindType, QString &) {
+    Label l = { &ok, 0 };
+    return l;
+  }
+};
+[[gnu::noipa]] void foo(int) {
+  ok = 1;
+}
+[[gnu::noipa]] bool Codegen::visit() {
+  if (!controlFlow)
+    return false;
+  ControlFlow::UnwindTarget target = controlFlow->unwindTarget();
+  if (target.linkLabel.isValid())
+    foo(2);
+  return false;
+}
+int
+main() {
+  ControlFlow cf = { nullptr, ControlFlow::UnwindType::EE };
+  Codegen c = { &cf };
+  c.visit();
+  if (!ok)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/pr65240-1.C b/gcc/testsuite/g++.dg/pr65240-1.C
index d2e25b65fca..ff8910df6a1 100644
--- a/gcc/testsuite/g++.dg/pr65240-1.C
+++ b/gcc/testsuite/g++.dg/pr65240-1.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=small -mno-fp-in-toc -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=small -mno-fp-in-toc -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr65240-2.C b/gcc/testsuite/g++.dg/pr65240-2.C
index 38d5020bd19..bdb7a62d73d 100644
--- a/gcc/testsuite/g++.dg/pr65240-2.C
+++ b/gcc/testsuite/g++.dg/pr65240-2.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=small -mfp-in-toc -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=small -mfp-in-toc -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr65240-3.C b/gcc/testsuite/g++.dg/pr65240-3.C
index e8463c91494..f37db9025d1 100644
--- a/gcc/testsuite/g++.dg/pr65240-3.C
+++ b/gcc/testsuite/g++.dg/pr65240-3.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=medium -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=medium -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr65240-4.C b/gcc/testsuite/g++.dg/pr65240-4.C
index a119752d18e..efb6a6c06e7 100644
--- a/gcc/testsuite/g++.dg/pr65240-4.C
+++ b/gcc/testsuite/g++.dg/pr65240-4.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power7 -O3 -ffast-math -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power7 -O3 -ffast-math -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr65242.C b/gcc/testsuite/g++.dg/pr65242.C
index be2ddaa85b2..662f375015f 100644
--- a/gcc/testsuite/g++.dg/pr65242.C
+++ b/gcc/testsuite/g++.dg/pr65242.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3" } */
 
 class A {
 public:
diff --git a/gcc/testsuite/g++.dg/pr67211.C b/gcc/testsuite/g++.dg/pr67211.C
index cb3d342c122..ac241818ab5 100644
--- a/gcc/testsuite/g++.dg/pr67211.C
+++ b/gcc/testsuite/g++.dg/pr67211.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power7 -mtune=power8 -O3 -w" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3 -w" } */
 
 /* target/67211, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr69667.C b/gcc/testsuite/g++.dg/pr69667.C
index 76f7cb3d40b..422116dd599 100644
--- a/gcc/testsuite/g++.dg/pr69667.C
+++ b/gcc/testsuite/g++.dg/pr69667.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power8 -w -std=c++14" } */
+/* { dg-options "-mdejagnu-cpu=power8 -w -std=c++14" } */
 
 /* target/69667, compiler got
    internal compiler error: Max. number of generated reload insns per insn is achieved (90)  */
diff --git a/gcc/testsuite/g++.dg/pr71294.C b/gcc/testsuite/g++.dg/pr71294.C
index 67675dd7e30..716fa0d44b2 100644
--- a/gcc/testsuite/g++.dg/pr71294.C
+++ b/gcc/testsuite/g++.dg/pr71294.C
@@ -1,7 +1,6 @@
 // { dg-do compile { target { powerpc64*-*-* && lp64 } } }
 // { dg-require-effective-target powerpc_p8vector_ok } */
-// { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } }
-// { dg-options "-mcpu=power8 -O3 -fstack-protector" }
+// { dg-options "-mdejagnu-cpu=power8 -O3 -fstack-protector" }
 
 // PAR target/71294 failed because RELOAD could not figure how create a V2DI
 // vector that auto vectorization created with each element being the same
diff --git a/gcc/testsuite/g++.dg/pr84279.C b/gcc/testsuite/g++.dg/pr84279.C
index b2b5b8eabab..e78201c30db 100644
--- a/gcc/testsuite/g++.dg/pr84279.C
+++ b/gcc/testsuite/g++.dg/pr84279.C
@@ -2,8 +2,7 @@
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-require-effective-target fpic } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-O3 -mcpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
+/* { dg-options "-O3 -mdejagnu-cpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
 
 template <typename, typename T> struct E { T e; };
 struct J {
diff --git a/gcc/testsuite/g++.dg/template/conv19.C b/gcc/testsuite/g++.dg/template/conv19.C
new file mode 100644
index 00000000000..7a3da939c1f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/conv19.C
@@ -0,0 +1,34 @@
+// PR c++/101698
+// { dg-do compile { target c++11 } }
+
+class Base {
+ public:
+  template <class T>
+  operator const T&() const = delete;
+
+  virtual operator const int&() const {
+    static int res;
+    return res;
+  }
+};
+
+template <class T>
+class Derive : public Base {
+ public:
+  operator const T&() const override {
+    using Y = int;
+    //static_assert(__is_same_as(T,Y), "");
+
+    static int res;
+
+    res = Base::operator const Y&(); // OK
+    res = Base::operator const T&(); // { dg-bogus "deleted" }
+    return res;
+  }
+};
+
+int main() {
+  Derive<int> a;
+  const int& b = a;
+  (void)b;
+}
diff --git a/gcc/testsuite/g++.dg/template/friend74.C b/gcc/testsuite/g++.dg/template/friend74.C
new file mode 100644
index 00000000000..51708334d81
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/friend74.C
@@ -0,0 +1,8 @@
+// PR c++/105852
+// { dg-additional-options -w }
+
+template <class> struct Local { friend Local False(int *); };
+Local<int> loc;
+Local<int> False(int *);
+void New() { False; }
+Local<int> False(int *) { return Local<int>(); }
diff --git a/gcc/testsuite/g++.dg/template/nested7.C b/gcc/testsuite/g++.dg/template/nested7.C
new file mode 100644
index 00000000000..3a5930c0f31
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/nested7.C
@@ -0,0 +1,12 @@
+// PR c++/102300
+
+template<typename T>
+struct holder
+{
+  template<typename F> struct fn {};
+
+  struct t1 : fn<T> {};                      // pass
+  struct t2 : holder<T >::fn<T> {};          // fail
+  struct t3 : holder<T >::template fn<T> {}; // fail
+  struct t4 : holder<T*>::template fn<T> {}; // pass
+};
diff --git a/gcc/testsuite/g++.dg/template/partial-specialization11.C b/gcc/testsuite/g++.dg/template/partial-specialization11.C
new file mode 100644
index 00000000000..556224a3104
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/partial-specialization11.C
@@ -0,0 +1,11 @@
+// PR c++/86193
+// CWG 455 (active)
+// { dg-options "" } // clear -pedantic-errors
+
+template<class T> struct value_type;
+
+template<class T, typename value_type<T>::type V>
+struct A;
+
+template<class T, int V>
+struct A<T*, V> { }; // { dg-warning "not more specialized" }
diff --git a/gcc/testsuite/g++.dg/template/partial-specialization12.C b/gcc/testsuite/g++.dg/template/partial-specialization12.C
new file mode 100644
index 00000000000..5f51e8a27de
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/partial-specialization12.C
@@ -0,0 +1,12 @@
+// PR c++/105289
+// CWG 455 (active)
+// { dg-do compile { target c++11 } }
+
+template<class T>
+struct value_type;
+
+template<class List, typename value_type<List>::type Element>
+struct push_front_vlist;
+
+template<template<class X, X...> class XList, class T, T Arg, T... Vs>
+struct push_front_vlist<XList<T, Vs...>, Arg> { }; // { dg-error "not more specialized" }
diff --git a/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C b/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C
index 75862e2b5be..fef69e7cf09 100644
--- a/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C
+++ b/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C
@@ -1,6 +1,5 @@
 /* { dg-do compile { target { powerpc64*-*-* } } } */
-/* { dg-skip-if "do not override mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8" } */
+/* { dg-options "-mdejagnu-cpu=power8" } */
 
 /* When compiled with C++, this code was breaking because of different
    tree representations of arrays between C and C++.  */
diff --git a/gcc/testsuite/g++.dg/torture/pr106131.C b/gcc/testsuite/g++.dg/torture/pr106131.C
new file mode 100644
index 00000000000..e110f4a8fe6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr106131.C
@@ -0,0 +1,34 @@
+// { dg-do run { target c++11 } }
+
+struct Pair {
+    int a, b;
+    Pair(const Pair &) = default;
+    Pair(int _a, int _b) : a(_a), b(_b) {}
+    Pair &operator=(const Pair &z) {
+	a = z.a;
+	b = z.b;
+	return *this;
+    }
+};
+
+const int &max(const int &a, const int &b)
+{
+  return a < b ? b : a;
+}
+
+int foo(Pair x, Pair y)
+{
+  return max(x.b, y.b);
+}
+
+int main()
+{
+  auto f = new Pair[3] {{0, -11}, {0, -8}, {0, 2}};
+  for (int i = 0; i < 1; i++) {
+      f[i] = f[0];
+      if(i == 0)
+	f[i] = f[2];
+      if (foo(f[i], f[1]) != 2)
+	__builtin_abort();
+  }
+}
diff --git a/gcc/testsuite/g++.dg/ubsan/pr105729.C b/gcc/testsuite/g++.dg/ubsan/pr105729.C
new file mode 100644
index 00000000000..fb676630994
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ubsan/pr105729.C
@@ -0,0 +1,29 @@
+// PR sanitizer/105729
+// { dg-do run }
+// { dg-options "-fsanitize=null -fno-sanitize-recover=null" }
+
+int
+foo (int x)
+{
+  throw 0;
+}
+
+struct S {};
+struct T {
+  S *data;
+  T () : data (0) {}
+  const S &bar (int x) const { return data[foo (x)]; }
+};
+
+int
+main ()
+{
+  T t;
+  try
+    {
+      t.bar (-1);
+    }
+  catch (...)
+    {
+    }
+}
diff --git a/gcc/testsuite/g++.dg/vect/pr105437.cc b/gcc/testsuite/g++.dg/vect/pr105437.cc
new file mode 100644
index 00000000000..b3b440debef
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr105437.cc
@@ -0,0 +1,24 @@
+// { dg-do compile }
+
+struct ControlClass
+{
+    virtual ~ControlClass();
+
+    int Width;
+    int Height;
+    unsigned IsToRepaint : 1;
+};
+
+struct SelectClass : ControlClass
+{
+    SelectClass(void);
+};
+
+int Non_Folded_Value();
+
+SelectClass::SelectClass(void)
+{
+    int factor = Non_Folded_Value();
+    Width = 32 << factor;
+    Height = 24 << factor;
+}
diff --git a/gcc/testsuite/g++.dg/warn/Warray-bounds-27.C b/gcc/testsuite/g++.dg/warn/Warray-bounds-27.C
new file mode 100644
index 00000000000..06ce089c4b0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Warray-bounds-27.C
@@ -0,0 +1,16 @@
+// PR105726
+// { dg-do compile }
+// { dg-require-effective-target c++11 }
+// { dg-options "-O2 -Warray-bounds" }
+
+#include <array>
+#include <cstring>
+
+struct X {
+    char pad[4];
+    std::array<char, 1> mField;
+};
+
+void encode(char* aBuffer, const X& aMessage) {
+    strncpy(aBuffer, aMessage.mField.data(), 1); // { dg-bogus "bounds" }
+}
diff --git a/gcc/testsuite/g++.target/i386/mv31.C b/gcc/testsuite/g++.target/i386/mv31.C
new file mode 100644
index 00000000000..5d8fd1ddf75
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/mv31.C
@@ -0,0 +1,10 @@
+// PR c++/104669
+
+void bar()
+{
+  int foo(void);
+  int foo(void) __attribute__((target("sse")));
+  int foo(void) __attribute__((target("default")));
+  int (*p)(void) = &foo;
+  return;
+}
diff --git a/gcc/testsuite/g++.target/i386/vec-tmpl1.C b/gcc/testsuite/g++.target/i386/vec-tmpl1.C
new file mode 100644
index 00000000000..e0865e3515b
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/vec-tmpl1.C
@@ -0,0 +1,17 @@
+// PR c++/65211
+// { dg-additional-options "-Wno-psabi" }
+// { dg-final { scan-assembler-not "movdqa" } }
+
+typedef unsigned v4ui __attribute__ ((vector_size(16), aligned (16)));
+
+template<int I>
+static v4ui t1(unsigned *dest_data)
+{
+  typedef unsigned v4ui_1 __attribute__ ((vector_size (16), aligned (4)));
+  return ((const v4ui_1*)dest_data)[0];
+}
+
+v4ui f(unsigned int *array)
+{
+    return t1<1>(array+7);
+}
diff --git a/gcc/testsuite/g++.target/powerpc/pr101322.C b/gcc/testsuite/g++.target/powerpc/pr101322.C
new file mode 100644
index 00000000000..43eaf3afcd4
--- /dev/null
+++ b/gcc/testsuite/g++.target/powerpc/pr101322.C
@@ -0,0 +1,17 @@
+/* PR target/101322 */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+/* Verify we don't ICE on the following test cases.  */
+
+void
+foo (char *resp, char *vpp)
+{
+  __builtin_vsx_disassemble_pair (resp, (__vector_pair *) vpp);
+}
+
+void
+bar (char *resp, char *vpp)
+{
+  __builtin_mma_disassemble_acc (resp, (__vector_quad *)vpp);
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105252.c b/gcc/testsuite/gcc.dg/analyzer/pr105252.c
new file mode 100644
index 00000000000..a093eababc5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105252.c
@@ -0,0 +1,20 @@
+/* { dg-additional-options "-fnon-call-exceptions -O" } */
+
+typedef unsigned char C;
+typedef unsigned char __attribute__((__vector_size__ (4))) V;
+
+C m;
+
+static inline void
+bar (C c, V v, V *r)
+{
+  v %= (c | v) % m;
+  *r = v;
+}
+
+void
+foo (void)
+{
+  V x;
+  bar (0, (V){2}, &x);
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105365.c b/gcc/testsuite/gcc.dg/analyzer/pr105365.c
new file mode 100644
index 00000000000..aa576d08632
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105365.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target int128 } */
+
+typedef _Float32 f32;
+typedef _Complex _Float32 cf32;
+_Float32 g;
+__int128 i;
+
+extern void bar(int);
+
+void
+foo(_Float32 k) {
+  f32 f = 0;
+  f /= (_Complex char)__builtin_llround(g);
+  k /= (cf32)__builtin_copysignf(0, i);
+  bar(f + k);
+  foo(0);
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105366.c b/gcc/testsuite/gcc.dg/analyzer/pr105366.c
new file mode 100644
index 00000000000..3dba870e4e9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105366.c
@@ -0,0 +1,19 @@
+/* { dg-require-effective-target int128 } */
+/* { dg-additional-options "-O" } */
+
+extern void bar(int);
+extern void baz(void);
+
+typedef unsigned u32;
+
+void
+foo(u32 u, __int128 i) {
+  baz();
+  _Complex int c = i;
+  c /= (u32)(__UINTPTR_TYPE__)foo;
+  short s = (short)(__UINTPTR_TYPE__)foo;
+  u /= (_Complex short)s;
+  u32 r = u + c;
+  bar(r);
+  foo(0, 0);
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr105396.c b/gcc/testsuite/gcc.dg/asan/pr105396.c
new file mode 100644
index 00000000000..d4bd7f12476
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asan/pr105396.c
@@ -0,0 +1,19 @@
+/* PR sanitizer/105396 */
+/* { dg-do run } */
+/* { dg-skip-if "" { *-*-* } { "*" } { "-O0" } } */
+/* { dg-shouldfail "asan" } */
+
+int
+main ()
+{
+  int a;
+  int *b[1];
+  int c[10];
+  int d[1][1];
+  for (a = 0; a < 1; a++)
+    d[1][a] = 0;
+  return 0;
+}
+
+/* { dg-output "ERROR: AddressSanitizer: stack-buffer-overflow on address.*(\n|\r\n|\r)" } */
+/* { dg-output "WRITE of size.*" } */
diff --git a/gcc/testsuite/gcc.dg/ipa/pr105739.c b/gcc/testsuite/gcc.dg/ipa/pr105739.c
new file mode 100644
index 00000000000..8dbe8fc2494
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ipa/pr105739.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+
+__attribute__((noinline))
+static int
+test2(int a)
+{
+        if (__builtin_constant_p (a))
+                __builtin_abort ();
+        return a;
+}
+static int
+test(int *a)
+{
+        int val = *(volatile int *)a;
+        if (__builtin_constant_p (val))
+                __builtin_abort ();
+        if (val)
+          return test2(val);
+        return 0;
+}
+int a;
+int
+main()
+{
+        a = 0;
+        return test (&a);
+}
+/* { dg-final { scan-tree-dump "test2" "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/pr105140.c b/gcc/testsuite/gcc.dg/pr105140.c
new file mode 100644
index 00000000000..7d30985e850
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105140.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -w -Wno-psabi" } */
+/* { dg-skip-if "PR105147" { powerpc*-*-* s390*-*-* } } */
+
+typedef char __attribute__((__vector_size__ (16 * sizeof (char)))) U;
+typedef int __attribute__((__vector_size__ (16 * sizeof (int)))) V;
+
+void bar ();
+
+bar (int i, int j, int k, V v)
+{
+}
+
+void
+foo (void)
+{
+  bar ((V){}, (V){}, (V){}, (U){});
+}
diff --git a/gcc/testsuite/gcc.dg/pr105173.c b/gcc/testsuite/gcc.dg/pr105173.c
new file mode 100644
index 00000000000..3effb2996b0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105173.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-Ofast" } */
+
+int i;
+
+int
+foo(char c, _Decimal32 d)
+{
+  d *= i;
+  d *= -(_Decimal64)c;
+  return d;
+}
diff --git a/gcc/testsuite/gcc.dg/pr105250.c b/gcc/testsuite/gcc.dg/pr105250.c
new file mode 100644
index 00000000000..4683e0e63a2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105250.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-w -Wno-psabi -O2" } */
+/* { dg-skip-if "PR105266" { powerpc*-*-* s390*-*-* } } */
+
+typedef int __attribute__((__vector_size__(4))) T;
+typedef int __attribute__((__vector_size__(8))) U;
+typedef int __attribute__((__vector_size__(16))) V;
+typedef int __attribute__((__vector_size__(32))) W;
+typedef _Float32 __attribute__((__vector_size__(16))) F;
+typedef _Float64 __attribute__((__vector_size__(32))) G;
+void foo();
+
+foo(int, int, int, int, U, U, V, V, W, W, int,
+     T, int, U, U, V, V, W, W, T,
+     T, int, U, U, V, V, W, W, T,
+     T, int, W, W, T, T, int, int, int,
+     int, int, int, W, int, int, int, int, int, int,
+     V, W, T, int, int, U, F, int, int, int,
+     int, int, int, G)
+{
+  foo(0, 0, 0, 0, (U){}, (U){}, (V){}, (V){}, (W){},
+       (W){}, 2, (T){}, 0, 0, 0, 0, (U){}, (U){},
+       (V){}, (V){}, (W){}, (W){}, (T){},
+       (T){}, 0, 0, 0, 0, (U){}, (U){}, (V){},
+       (V){}, (W){}, (W){}, (T){}, (T){}, 0, 0, 0,
+       0, 0, 0, (T){},
+       (T){}, (W){},
+       (W){}, (T){}, (T){}, 0, 0, 0, 0, 0, 0, (W){},
+       (V){}, (W){}, (T){}, 0, 0, (U){}, (F){});
+}
diff --git a/gcc/testsuite/gcc.dg/pr105257.c b/gcc/testsuite/gcc.dg/pr105257.c
new file mode 100644
index 00000000000..4232942d791
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105257.c
@@ -0,0 +1,16 @@
+/* PR target/105257 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+extern int sigsetjmp (void **, int);
+void *buf[32];
+void (*fn) (void);
+
+const char *
+bar (void)
+{
+  sigsetjmp (buf, 0);
+  fn ();
+  return "";
+}
diff --git a/gcc/testsuite/gcc.dg/pr105263.c b/gcc/testsuite/gcc.dg/pr105263.c
new file mode 100644
index 00000000000..5cb7fcd09a2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105263.c
@@ -0,0 +1,15 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-O -ffast-math -w -Wno-psabi" } */
+
+typedef _Decimal64 __attribute__((__vector_size__ (8))) U;
+typedef _Decimal64 __attribute__((__vector_size__ (16))) V;
+
+V v;
+
+U
+foo (U u)
+{
+  u *= u;
+  u *= -(U){ v[1] };
+  return u;
+}
diff --git a/gcc/testsuite/gcc.dg/pr105331.c b/gcc/testsuite/gcc.dg/pr105331.c
new file mode 100644
index 00000000000..06cf6d6d901
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105331.c
@@ -0,0 +1,11 @@
+/* PR target/105331 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+#include <stdarg.h>
+
+int
+foo (va_list *va)
+{
+  return va_arg (*va, double _Complex);	/* { dg-bogus "may be used uninitialized" } */
+}
diff --git a/gcc/testsuite/gcc.dg/pr105333.c b/gcc/testsuite/gcc.dg/pr105333.c
new file mode 100644
index 00000000000..bd8bd4cd56c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105333.c
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/105333 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-Og -fno-tree-coalesce-vars -fno-tree-fre" } */
+
+int g;
+short s;
+
+static inline unsigned short
+bar (short a, __int128 b)
+{
+  b ^= (unsigned long) -a;
+  __builtin_strncpy ((void *) &s, (void *) &a, 1);
+  b *= 14;
+  return b;
+}
+
+void
+foo (void)
+{
+  g *= (__int128) bar (1, 1);
+}
diff --git a/gcc/testsuite/gcc.dg/pr105528.c b/gcc/testsuite/gcc.dg/pr105528.c
new file mode 100644
index 00000000000..e380d56ee06
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105528.c
@@ -0,0 +1,23 @@
+/* PR tree-optimization/105528 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wno-psabi -fcompare-debug" } */
+/* { dg-additional-options "-mavx512f" { target i?86-*-* x86_64-*-* } } */
+
+typedef unsigned V __attribute__((__vector_size__ (64)));
+V g;
+
+V
+bar (V v)
+{
+  V w;
+  v <<= (V){(V){}[53]} >= v & 5;
+  w[w[5]] -= ~0;
+  v %= ~0;
+  return v + w;
+}
+
+void
+foo (void)
+{
+  g -= (V){bar((V){~0})[3]};
+}
diff --git a/gcc/testsuite/gcc.dg/pr106027.c b/gcc/testsuite/gcc.dg/pr106027.c
new file mode 100644
index 00000000000..735205fb252
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr106027.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+int
+foo (unsigned int x, int y)
+{
+  return x <= (((y != y) < 0) ? y < 1 : 0);
+}
diff --git a/gcc/testsuite/gcc.dg/pragma-message.c b/gcc/testsuite/gcc.dg/pragma-message.c
index 2f44b617710..1b7cf09de0a 100644
--- a/gcc/testsuite/gcc.dg/pragma-message.c
+++ b/gcc/testsuite/gcc.dg/pragma-message.c
@@ -42,9 +42,11 @@
 #pragma message ("Okay " THREE)  /* { dg-message "Okay 3" } */
 
 /* Create a TODO() that prints a message on compilation.  */
-#define DO_PRAGMA(x) _Pragma (#x)
-#define TODO(x) DO_PRAGMA(message ("TODO - " #x))
-TODO(Okay 4)                     /* { dg-message "TODO - Okay 4" } */
+#define DO_PRAGMA(x) _Pragma (#x) /* { dg-line pragma_loc1 } */
+#define TODO(x) DO_PRAGMA(message ("TODO - " #x)) /* { dg-line pragma_loc2 } */
+TODO(Okay 4) /* { dg-message "in expansion of macro 'TODO'" } */
+/* { dg-message "TODO - Okay 4" "test4.1" { target *-*-* } pragma_loc1 } */
+/* { dg-message "in expansion of macro 'DO_PRAGMA'" "test4.2" { target *-*-* } pragma_loc2 } */
 
 #if 0
 #pragma message ("Not printed")
diff --git a/gcc/testsuite/gcc.dg/torture/pr105148.c b/gcc/testsuite/gcc.dg/torture/pr105148.c
new file mode 100644
index 00000000000..3338b0f3281
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105148.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+
+extern void foo (void);
+
+static inline int
+bar (int n)
+{
+  for (int i = 0; i < n; i++)
+    {
+      foo ();
+      int y[1][i];
+      y[n][i] = 0;
+    }
+}
+
+int
+baz (void)
+{
+  return bar (5);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105163.c b/gcc/testsuite/gcc.dg/torture/pr105163.c
new file mode 100644
index 00000000000..23e04107f68
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105163.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target nonlocal_goto } */
+
+#include <setjmp.h>
+
+extern int bar (unsigned int *);
+extern jmp_buf *baz (void);
+struct C { int c1; };
+void foo (struct C *x, int *z, int e)
+{
+  unsigned int d = 0;
+  long f;
+  setjmp (*baz());
+  f = 1 + ~d;
+  d = 8;
+  if ((!0) && !e && bar(z)) *z = 1 + f;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105598.c b/gcc/testsuite/gcc.dg/torture/pr105598.c
new file mode 100644
index 00000000000..0a4ea3b0bd1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105598.c
@@ -0,0 +1,32 @@
+/* { dg-do run } */
+
+typedef struct { unsigned int num; } info_t;
+typedef struct { unsigned int flag, type; } block_t;
+info_t info;
+block_t blocks[] = { {2,0}, {3,0}, {1,0}, {1,0} };
+
+static block_t *
+f (info_t *i, block_t *b)
+{
+  while (1) {
+    unsigned int is_last = b->flag & 0x01;
+    i->num++;
+    if (b->flag & 0x02) {
+      if (b->type != 0x1) b->type = b->type;
+      b = f (i, b+1);
+    }
+    if (is_last)
+      break;
+    b++;
+  }
+  return b;
+}
+
+int
+main ()
+{
+  f(&info, &blocks[0]);
+  if (info.num != 4)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106112.c b/gcc/testsuite/gcc.dg/torture/pr106112.c
new file mode 100644
index 00000000000..bd7f63c0935
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106112.c
@@ -0,0 +1,16 @@
+/* { dg-do run } */
+
+__INT32_TYPE__ a = 5, b, c, d;
+__UINT64_TYPE__ e = 20862985922;
+int main()
+{
+  __UINT32_TYPE__ f = 4294967292;
+  e = e | f;
+  c = -1 % ((~f ^ 4294967292) - (e - d));
+  b = ~-~e % ~-d;
+  if (b)
+    a = 0;
+  if (a < 1)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106513.c b/gcc/testsuite/gcc.dg/torture/pr106513.c
new file mode 100644
index 00000000000..aa4f4d513d7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106513.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+
+typedef __INT64_TYPE__ int64_t;
+
+__attribute__((noinline)) int64_t
+swap64 (int64_t n)
+{
+  return (((n & (((int64_t) 0xff) )) << 56) |
+          ((n & (((int64_t) 0xff) << 8)) << 40) |
+          ((n & (((int64_t) 0xff) << 16)) << 24) |
+          ((n & (((int64_t) 0xff) << 24)) << 8) |
+          ((n & (((int64_t) 0xff) << 32)) >> 8) |
+          ((n & (((int64_t) 0xff) << 40)) >> 24) |
+          ((n & (((int64_t) 0xff) << 48)) >> 40) |
+          ((n & ((int64_t)(0xffull << 56))) >> 56));
+}
+
+int main (void)
+{
+  volatile int64_t n = 0x8000000000000000ll;
+
+  if (swap64(n) != 0xffffffffffffff80ll)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-13.c b/gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-13.c
new file mode 100644
index 00000000000..87a94f5bf31
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-13.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-fre1" } */
+
+struct inn
+{
+  int val;
+};
+
+struct biggerstruct
+{
+  int a, b;
+};
+
+union foo
+{
+  struct inn inn;
+  struct biggerstruct baz;
+} *fooptr;
+
+struct bar
+{
+  union foo foo;
+  int val2;
+} *barptr;
+
+int
+test ()
+{
+  union foo foo;
+  foo.inn.val = 0;
+  barptr->val2 = 123;
+  *fooptr = foo;
+  return barptr->val2;
+}
+
+/* { dg-final { scan-tree-dump-times "return 123" 1 "fre1"} } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr105860.c b/gcc/testsuite/gcc.dg/tree-ssa/pr105860.c
new file mode 100644
index 00000000000..77bcb4a6739
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr105860.c
@@ -0,0 +1,63 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+struct S1  {
+        unsigned int _0;
+        unsigned int _1;
+} ;
+struct S2  {
+        struct S1 _s1;
+        unsigned long _x2;
+} ;
+
+struct ufld_type1  {
+        unsigned int _u1t;
+        struct S2 _s2;
+} ;
+
+struct ufld_type2  {
+        unsigned int _u2t;
+        struct S1 _s1;
+} ;
+struct parm_type {
+        union {
+                struct ufld_type1 var_1;
+                struct ufld_type2 var_2;
+        } U;
+};
+
+struct parm_type  bad_function( struct parm_type arg0 )
+{
+        struct parm_type rv;
+        struct S2 var4;
+        switch( arg0.U.var_2._u2t ) {
+        case 4294967041:
+                var4._s1 = arg0.U.var_1._s2._s1;
+                rv.U.var_1._u1t = 4294967041;
+                rv.U.var_1._s2 = var4;
+                break;
+        case 4294967043:
+                rv.U.var_2._u2t = 4294967043;
+                rv.U.var_2._s1 = arg0.U.var_2._s1;
+                break;
+        default:
+                break;
+        }
+        return rv;
+}
+
+int main() {
+        struct parm_type val;
+        struct parm_type out;
+        val.U.var_2._u2t = 4294967043;
+        val.U.var_2._s1._0 = 0x01010101;
+        val.U.var_2._s1._1 = 0x02020202;
+        out = bad_function(val);
+	if (val.U.var_2._u2t != 4294967043)
+	  __builtin_abort ();
+        if (out.U.var_2._s1._0 != 0x01010101)
+	  __builtin_abort ();
+        if (val.U.var_2._s1._1 != 0x02020202 )
+	  __builtin_abort ();
+	return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-19.c b/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-19.c
new file mode 100644
index 00000000000..f3eb0ef3a4e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-19.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-sink-details -fdump-tree-cddce2-details" } */
+
+static int b=4;
+int c;
+
+int
+main()
+{
+  int e[5] = {1,1,1,1,1};
+  for (; b >= 0; b--) {
+    c = e[b];
+  }
+  return 0;
+}
+
+/* We should sink e[b] out of the loop which is possible after
+   applying store motion to c and b.  */
+/* { dg-final { scan-tree-dump "Sinking # VUSE" "sink" } } */
+/* And remove the loop after final value replacement.  */
+/* { dg-final { scan-tree-dump "fix_loop_structure: removing loop" "cddce2" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
index 827687b92fa..8eb8baceb31 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
@@ -1,10 +1,11 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target vect_complex_add_float } */
+/* { dg-additional-options "-fno-tree-loop-vectorize" } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
 #define N 16
 #include "complex-mul-template.c"
 
-/* { dg-final { scan-tree-dump "Found COMPLEX_MUL_CONJ" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_MUL" "vect" } } */
+/* { dg-final { scan-tree-dump "Found COMPLEX_MUL_CONJ" "slp1" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump "Found COMPLEX_MUL" "slp1" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
index f935405e3d9..5cff373b80d 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
@@ -6,7 +6,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_double } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect"  { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect"  { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
index 71f391db7bb..312df88ee68 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
@@ -6,7 +6,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_float } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
index e5b826f1ca7..046f014240b 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
 /* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
@@ -6,5 +7,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_half } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect" { target { vect_complex_add_half } } } } */
+/* Vectorization is failing for these cases.  They should work but for now ignore.  */
+
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
index 5b70d834c24..9c8b99bc003 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
@@ -6,8 +6,7 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
index 3ef05645a2c..ca5f5b257d3 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
@@ -6,8 +6,7 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
index 06a9216add7..c6617f5dad0 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-require-effective-target vect_float } */
+/* { dg-require-effective-target vect_complex_add_half } */
 /* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
@@ -7,10 +7,8 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_half } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_half } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_half } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_half } && ! target { arm*-*-* } } } } */
 
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
index 34146f3d1e7..7beb6b8b5d8 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
@@ -1,5 +1,7 @@
 /* { dg-do compile } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 
 #define TYPE _Float16
 #define N 200
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
index 0982a2b8ead..fc4cd6151c7 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_double } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE double
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
index a069533b22a..43a77ff8591 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
@@ -1,10 +1,10 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_float } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
 #define N 200
 #include "complex-mls-template.c"
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMA" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS_CONJ" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
index 89ac54c2a42..3d1c5755bef 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
@@ -1,9 +1,10 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
 #define TYPE _Float16
 #define N 200
 #include "complex-mls-template.c"
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS_CONJ" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
index 56a8ea4ae02..b6b21529a10 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_double } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE double
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
index 969416d7dc7..aa8efb4c2db 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_float } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
index da1b9213a6b..51331625745 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
@@ -1,4 +1,6 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
 #define TYPE _Float16
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
index 72b4930d9bb..c57f065cccd 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
@@ -46,5 +46,5 @@ int main (void)
   return main1 ();
 } 
 
-/* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 1 "vect" { target { ! vect_hw_misalign } } } } */
+/* { dg-final { scan-tree-dump-times "unsupported unaligned access" 1 "vect" { target { ! vect_hw_misalign } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_hw_misalign } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr103116-1.c b/gcc/testsuite/gcc.dg/vect/pr103116-1.c
new file mode 100644
index 00000000000..d3639fc8cfd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr103116-1.c
@@ -0,0 +1,50 @@
+/* { dg-require-effective-target mmap } */
+
+#include <sys/mman.h>
+#include <stdio.h>
+
+#define COUNT 128
+#define MMAP_SIZE 0x20000
+#define ADDRESS 0x1122000000
+#define TYPE unsigned int
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+void __attribute__((noipa))
+loop (TYPE *restrict x, TYPE *restrict y)
+{
+  for (int i = 0; i < COUNT; ++i)
+    {
+      x[i * 4] = y[i * 2] + 1;
+      x[i * 4 + 1] = y[i * 2] + 2;
+      x[i * 4 + 2] = y[i * 2 + 1] + 3;
+      x[i * 4 + 3] = y[i * 2 + 1] + 4;
+    }
+}
+
+TYPE x[COUNT * 4];
+
+int
+main (void)
+{
+  void *y;
+  TYPE *end_y;
+
+  y = mmap ((void *) ADDRESS, MMAP_SIZE, PROT_READ | PROT_WRITE,
+            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  if (y == MAP_FAILED)
+    {
+      perror ("mmap");
+      return 1;
+    }
+
+  end_y = (TYPE *) ((char *) y + MMAP_SIZE);
+
+  loop (x, end_y - COUNT * 2);
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "Data access with gaps requires scalar epilogue loop" "vect" { target { vect_perm && vect_int } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr103116-2.c b/gcc/testsuite/gcc.dg/vect/pr103116-2.c
new file mode 100644
index 00000000000..2f4ed0f404c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr103116-2.c
@@ -0,0 +1,59 @@
+/* { dg-require-effective-target mmap } */
+/* { dg-additional-options "-mssse3" { target x86_64-*-* i?86-*-* } } */
+
+#include <sys/mman.h>
+#include <stdio.h>
+#include "tree-vect.h"
+
+#define COUNT 128
+#define MMAP_SIZE 0x20000
+#define ADDRESS 0x1122000000
+#define TYPE unsigned short
+#define GROUP_SIZE 2
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+void __attribute__((noipa))
+loop (TYPE *restrict x, TYPE *restrict y)
+{
+  for (int i = 0; i < COUNT; ++i)
+    {
+      x[i * 8] = y[i * GROUP_SIZE] + 1;
+      x[i * 8 + 1] = y[i * GROUP_SIZE] + 2;
+      x[i * 8 + 2] = y[i * GROUP_SIZE + 1] + 3;
+      x[i * 8 + 3] = y[i * GROUP_SIZE + 1] + 4;
+      x[i * 8 + 4] = y[i * GROUP_SIZE] + 5;
+      x[i * 8 + 5] = y[i * GROUP_SIZE] + 6;
+      x[i * 8 + 6] = y[i * GROUP_SIZE + 1] + 7;
+      x[i * 8 + 7] = y[i * GROUP_SIZE + 1] + 8;
+    }
+}
+
+TYPE x[COUNT * 4];
+
+int
+main (void)
+{
+  void *y;
+  TYPE *end_y;
+
+  check_vect ();
+
+  y = mmap ((void *) ADDRESS, MMAP_SIZE, PROT_READ | PROT_WRITE,
+            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  if (y == MAP_FAILED)
+    {
+      perror ("mmap");
+      return 1;
+    }
+
+  end_y = (TYPE *) ((char *) y + MMAP_SIZE);
+
+  loop (x, end_y - COUNT * GROUP_SIZE);
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "peeling for gaps insufficient for access" "vect" { target { vect_perm_short } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/vect.exp b/gcc/testsuite/gcc.dg/vect/vect.exp
index dca9a4db6f6..3c60eff7072 100644
--- a/gcc/testsuite/gcc.dg/vect/vect.exp
+++ b/gcc/testsuite/gcc.dg/vect/vect.exp
@@ -118,7 +118,7 @@ et-dg-runtest dg-runtest [lsort \
 set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS
 lappend DEFAULT_VECTCFLAGS "-ffast-math"
 et-dg-runtest dg-runtest [lsort \
-	[glob -nocomplain $srcdir/$subdir/fast-math-\[ipsv\]*.\[cS\]]] \
+	[glob -nocomplain $srcdir/$subdir/fast-math-\[ipsvc\]*.\[cS\]]] \
 	"" $DEFAULT_VECTCFLAGS
 
 # -ffast-math SLP tests
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c
new file mode 100644
index 00000000000..372f4aa8746
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf -moutline-atomics" } */
+
+#include "sync-comp-swap.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_cas4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c
new file mode 100644
index 00000000000..95d9c56b5e1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -moutline-atomics" } */
+
+#include "sync-op-acquire.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_swp4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c
new file mode 100644
index 00000000000..2f3881d9755
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -moutline-atomics" } */
+
+#include "sync-op-full.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldadd4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldclr4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldeor4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldset4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/target_attr_20.c b/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
index 509fb039e84..c9454fc420b 100644
--- a/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
+++ b/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
@@ -24,4 +24,4 @@ bar (void)
     }
 }
 
-/* { dg-final { scan-assembler-not "bl.*__aarch64_cas2_acq_rel" } } */
+/* { dg-final { scan-assembler-not "bl.*__aarch64_cas2_sync" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/target_attr_21.c b/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
index acace4c8f2a..b8e56223b02 100644
--- a/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
+++ b/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
@@ -24,4 +24,4 @@ bar (void)
     }
 }
 
-/* { dg-final { scan-assembler-times "bl.*__aarch64_cas2_acq_rel" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_cas2_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/alpha/pr105209.c b/gcc/testsuite/gcc.target/alpha/pr105209.c
new file mode 100644
index 00000000000..b89be96dc1d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/alpha/pr105209.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftrapv -mcpu=ev4" } */
+
+typedef struct tnode_t {
+        struct tnode_t *tn_left, *tn_right;
+        int v_quad;
+} tnode_t;
+
+int constant_addr(const tnode_t *, long *);
+int constant_addr(const tnode_t *tn, long *offsp)
+{
+        long offs1 = 0, offs2 = 0;
+
+        if (tn->v_quad > 0) {
+                offs1 = tn->v_quad;
+                return 0;
+        } else if (tn->v_quad > -1) {
+                offs2 = tn->tn_right->v_quad;
+                if (!constant_addr(tn->tn_left, &offs1))
+                        return 0;
+        } else {
+                return 0;
+        }
+        *offsp = offs1 + offs2;
+        return 1;
+}
diff --git a/gcc/testsuite/gcc.target/arm/pr105312.c b/gcc/testsuite/gcc.target/arm/pr105312.c
new file mode 100644
index 00000000000..a02831bcbcf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr105312.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mcpu=cortex-a15" } */
+/* { dg-add-options arm_neon } */
+
+typedef float stress_matrix_type_t;
+typedef unsigned int size_t;
+static void __attribute__((optimize("-O3"))) stress_matrix_xy_identity(
+ const size_t n,
+ stress_matrix_type_t a[restrict n][n],
+ stress_matrix_type_t b[restrict n][n],
+ stress_matrix_type_t r[restrict n][n])
+{
+ register size_t i;
+ (void)a;
+ (void)b;
+ for (i = 0; i < n; i++) {
+  register size_t j;
+  for (j = 0; j < n; j++)
+   r[i][j] = (i == j) ? 1.0 : 0.0;
+   return;
+ }
+}
diff --git a/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S b/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
index b4a4a140e54..9d6be88e7d5 100644
--- a/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
+++ b/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
@@ -300,3 +300,6 @@ iamcu_noprintf:
 	.align 4
 .LCiamcu_noprintf1:
 	.long	1132527616
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c b/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
index 805e0628673..57fa9bdc831 100644
--- a/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
+++ b/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
@@ -6,7 +6,6 @@
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm0,\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm1,\[^\\n\\r\]*16\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm2,\[^\\n\\r\]*32\[^\\n\\r\]*" } } */
-/* { dg-final { scan-assembler "(?:movdqa|movaps)\[ \\t\]+\[^\\n\]*%xmm\[4-6\],\[^\\n\\r\]*" } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c b/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
index 26f04dcf014..a9398b4e7a2 100644
--- a/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
+++ b/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
@@ -8,7 +8,6 @@
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm1,\[^\\n\\r\]*16\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm2,\[^\\n\\r\]*32\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm3,\[^\\n\\r\]*48\[^\\n\\r\]*" } } */
-/* { dg-final { scan-assembler "(?:movdqa|movaps)\[ \\t\]+\[^\\n\]*%xmm\[4-6\],\[^\\n\\r\]*" } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/pr104637.c b/gcc/testsuite/gcc.target/i386/pr104637.c
new file mode 100644
index 00000000000..36e8b6ed97d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr104637.c
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-Og -fno-forward-propagate -mavx -Wno-div-by-zero" } */
+
+typedef short __attribute__((__vector_size__ (64))) U;
+typedef unsigned long long __attribute__((__vector_size__ (32))) V;
+typedef long double __attribute__((__vector_size__ (64))) F;
+
+int i;
+U u;
+F f;
+
+void
+foo (char a, char b, _Complex char c, V v)
+{
+  u = (U) { u[0] / 0, u[1] / 0, u[2] / 0, u[3] / 0, u[4] / 0, u[5] / 0, u[6] / 0, u[7] / 0,
+	    u[8] / 0, u[9] / 0, u[10] / 0, u[11] / 0, u[12] / 0, u[13] / 0, u[14] / 0, u[15] / 0,
+	    u[16] / 0, u[17] / 0, u[18] / 0, u[19] / 0, u[20] / 0, u[21] / 0, u[22] / 0, u[23] / 0,
+	    u[24] / 0, u[25] / 0, u[26] / 0, u[27] / 0, u[28] / 0, u[29] / 0, u[30] / 0, u[31] / 0 };
+  c += i;
+  f = (F) { v[0], v[1], v[2], v[3] };
+  i = (char) (__imag__ c + i);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr105970.c b/gcc/testsuite/gcc.target/i386/pr105970.c
new file mode 100644
index 00000000000..326486faebf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr105970.c
@@ -0,0 +1,6 @@
+/* PR target/105970 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -mgeneral-regs-only -maddress-mode=long" } */
+
+#include "../../gcc.dg/torture/pr68037-1.c"
diff --git a/gcc/testsuite/gcc.target/i386/sse-14.c b/gcc/testsuite/gcc.target/i386/sse-14.c
index 4ce0ffffaf3..4c728f230f7 100644
--- a/gcc/testsuite/gcc.target/i386/sse-14.c
+++ b/gcc/testsuite/gcc.target/i386/sse-14.c
@@ -429,7 +429,9 @@ test_3 (_mm_maskz_mul_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_mul_round_ps, __m512, __mmask16, __m512, __m512, 9)
 test_3 (_mm_maskz_mul_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_scalef_round_pd, __m512d, __mmask8, __m512d, __m512d, 9)
+test_3 (_mm_maskz_scalef_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_scalef_round_ps, __m512, __mmask16, __m512, __m512, 9)
+test_3 (_mm_maskz_scalef_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_shuffle_f32x4, __m512, __mmask16, __m512, __m512, 1)
 test_3 (_mm512_maskz_shuffle_f64x2, __m512d, __mmask8, __m512d, __m512d, 1)
 test_3 (_mm512_maskz_shuffle_i32x4, __m512i, __mmask16, __m512i, __m512i, 1)
@@ -543,7 +545,9 @@ test_4 (_mm_mask_mul_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_mul_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
 test_4 (_mm_mask_mul_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_scalef_round_pd, __m512d, __m512d, __mmask8, __m512d, __m512d, 9)
+test_4 (_mm_mask_scalef_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_scalef_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
+test_4 (_mm_mask_scalef_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_shuffle_f32x4, __m512, __m512, __mmask16, __m512, __m512, 1)
 test_4 (_mm512_mask_shuffle_f64x2, __m512d, __m512d, __mmask8, __m512d, __m512d, 1)
 test_4 (_mm512_mask_shuffle_i32x4, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
index 1ea6de880aa..818a56f1116 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -fno-stack-protector -fno-PIC" } */
 
 void
 foo (void)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
index 389b1142264..01f6857fb56 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
@@ -11,11 +11,11 @@ foo (int x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
-/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
index 07d8de7c66f..4ed036e9f88 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7 -msse" } */
 
 void
 foo (void)
@@ -7,15 +7,28 @@ foo (void)
 }
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 7 { target { ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 15 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm8, %xmm8" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm9, %xmm9" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm10, %xmm10" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm11, %xmm11" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm12, %xmm12" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm13, %xmm13" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm14, %xmm14" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm15, %xmm15" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
index 55a272cc53f..c361c0b3afd 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
@@ -9,11 +9,11 @@ foo (void)
 /* { dg-final { scan-assembler-times "vzeroall" 1 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
index d0e975cb3d3..4d45fa56b2a 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("used")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
index d41a2557d10..fb5e6ddc1cd 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("skip")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
index c79fcd39d7b..10cfa12f9ca 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -fno-stack-protector" } */
 
 int
 foo (int x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
index 6f90723cc8e..0e399d4ebb0 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 float
 foo (float z, float y, float x)
@@ -9,5 +9,5 @@ foo (float z, float y, float x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm1, %xmm2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm2, %xmm2" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-not "xorl\[ \t\]+%" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
index 491d2d56774..cb0d5ebce04 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 float
 foo (float z, float y, float x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
index 52406fc70aa..cb93209a8ba 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
@@ -9,11 +9,11 @@ foo (void)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
index ccd491775c2..123bd05b51e 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7 -msse" } */
 
 float
 foo (float z, float y, float x)
@@ -8,16 +8,28 @@ foo (float z, float y, float x)
 }
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" { target { ia32 } } } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 7 { target { ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm1, %xmm\[0-9\]+" 14 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm8, %xmm8" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm9, %xmm9" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm10, %xmm10" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm11, %xmm11" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm12, %xmm12" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm13, %xmm13" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm14, %xmm14" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm15, %xmm15" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
index b3570f318c1..e8c3d9b5f3d 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 __attribute__ ((zero_call_used_regs("used")))
 float
@@ -10,5 +10,5 @@ foo (float z, float y, float x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm1, %xmm2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm2, %xmm2" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-not "xorl\[ \t\]+%" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
index b25342065e9..63adbb9d356 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
@@ -11,11 +11,11 @@ foo (void)
 /* { dg-final { scan-assembler-times "fstp\[ \t\]+%st\\(0\\)" 8 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
index 69d42d732fd..a3285bed8a0 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
@@ -11,19 +11,19 @@ foo (void)
 /* { dg-final { scan-assembler-times "fstp\[ \t\]+%st\\(0\\)" 8 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "kxorw\[ \t\]+%k0, %k0, %k0" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k2" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k3" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k4" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k5" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k6" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k7" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k1, %k1, %k1" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k2, %k2, %k2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k3, %k3, %k3" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k4, %k4, %k4" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k5, %k5, %k5" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k6, %k6, %k6" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k7, %k7, %k7" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
index 8fb5299be56..3f22375d2fa 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
@@ -8,16 +8,16 @@ foo (int x)
 }
 
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm1" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm2" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm3" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm4" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm5" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm6" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm7" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
index 26ceacf435d..b307d107319 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
@@ -8,8 +8,8 @@ foo (int x)
 }
 
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
index 044e4af10f0..dfa8e01dc38 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
@@ -10,9 +10,9 @@ __v2si ret_mmx (void)
 }
 
 /* { dg-final { scan-assembler "pxor\[ \t\]+%mm1, %mm1" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm2" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm3" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm4" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm5" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm6" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm7" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm2, %mm2" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm3, %mm3" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm4, %mm4" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm5, %mm5" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm6, %mm6" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm7, %mm7" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
index 89e69b8ba72..6cd5c4cb067 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector" } */
 
 void
 foo (void)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
index afa8b337b36..5a0e53110e6 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
@@ -10,5 +10,5 @@ __v2si ret_mmx (void)
 }
 
 /* { dg-final { scan-assembler "pxor\[ \t\]+%mm1, %mm1" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm2" } } */
-/* { dg-final { scan-assembler-not "movq\[ \t\]+%mm1, %mm\[34567\]" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm2, %mm2" } } */
+/* { dg-final { scan-assembler-not "pxor\[ \t\]+%mm\[34567\], %mm\[34567\]" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
index 1e98d17df7f..becc5b8b438 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("used-gpr")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
index 56aecdafad8..4367f96a859 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
@@ -10,11 +10,11 @@ foo (void)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
index fa831857ad8..88e3156b132 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all-gpr" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all-gpr -fno-stack-protector" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("skip")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
index 0444a21f4da..460c301ec12 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used-gpr" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used-gpr -fno-stack-protector" } */
 
 int
 foo (int x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
index 75356db63c3..0eab76933f5 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
@@ -10,10 +10,10 @@ foo (int x)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
index 64755b00c39..42dcaea4988 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector" } */
 
 extern int foo (int) __attribute__ ((zero_call_used_regs("used-gpr")));
 
diff --git a/gcc/testsuite/gcc.target/powerpc/bswap-brw.c b/gcc/testsuite/gcc.target/powerpc/bswap-brw.c
index b3f923eea84..0ed2a7bd1d2 100644
--- a/gcc/testsuite/gcc.target/powerpc/bswap-brw.c
+++ b/gcc/testsuite/gcc.target/powerpc/bswap-brw.c
@@ -17,6 +17,6 @@ bswap_int_dbl (unsigned int a)
   /* Force the value to be loaded into a vector register.  */
   __asm__ (" # %x0" : "+wa" (b));
 
-  /* { dg-final { scan-assembler {\mxxbrw\M} } } */
+  /* { dg-final { scan-assembler {\mxxbrw\M} {xfail {has_arch_pwr10 && {! has_arch_ppc64}}} } } */
   return (double) __builtin_bswap32 (b);
 }
diff --git a/gcc/testsuite/gcc.target/powerpc/fusion.c b/gcc/testsuite/gcc.target/powerpc/fusion.c
index 876b9f54d5a..2a115580439 100644
--- a/gcc/testsuite/gcc.target/powerpc/fusion.c
+++ b/gcc/testsuite/gcc.target/powerpc/fusion.c
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-options "-mdejagnu-cpu=power7 -mtune=power8 -O3 -dp" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3 -dp" } */
 
 #define LARGE 0x12345
 
diff --git a/gcc/testsuite/gcc.target/powerpc/fusion2.c b/gcc/testsuite/gcc.target/powerpc/fusion2.c
index b3f457a28e2..40ca00a7405 100644
--- a/gcc/testsuite/gcc.target/powerpc/fusion2.c
+++ b/gcc/testsuite/gcc.target/powerpc/fusion2.c
@@ -2,7 +2,7 @@
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-skip-if "" { powerpc*le-*-* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-options "-mdejagnu-cpu=power7 -mtune=power8 -O3" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3" } */
 
 vector double fusion_vector (vector double *p) { return p[2]; }
 
diff --git a/gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c b/gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c
index 1255ee9f0ab..41e46d41401 100644
--- a/gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c
+++ b/gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-mcpu=power10 -save-temps" } */
+/* { dg-options "-mdejagnu-cpu=power10 -save-temps" } */
 /* { dg-require-effective-target power10_hw } */
 
 /* Check that the expected 128-bit instructions are generated if the processor
diff --git a/gcc/testsuite/gcc.target/powerpc/pr102059-4.c b/gcc/testsuite/gcc.target/powerpc/pr102059-4.c
new file mode 100644
index 00000000000..4a0ad3daf73
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr102059-4.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+/* { dg-require-effective-target power10_ok } */
+
+/* Verify that power10 can explicity include functions compiled for power8.
+   The issue was -mcpu=power8 enables -mpower8-fusion, but -mcpu=power9 or
+   -mcpu=power10 do not set power8-fusion by default.  Thus when doing this
+   compilation, they would get an error that the inline function failed in its
+   inlining due to having incompatible options.  */
+
+static inline int __attribute__ ((always_inline,target("cpu=power8,no-htm")))
+foo (int *b)
+{
+  *b += 10;
+  return *b;
+}
+
+int
+bar (int *a)
+{
+  *a = foo (a);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr103353.c b/gcc/testsuite/gcc.target/powerpc/pr103353.c
new file mode 100644
index 00000000000..5d519fb1b7b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr103353.c
@@ -0,0 +1,22 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* If the default cpu type is power10 or later, MMA is enabled by default.
+   To keep the test point available all the time, this case specifies
+   -mdejagnu-cpu=power6 to make it be tested without MMA.  */
+/* { dg-options "-maltivec -mdejagnu-cpu=power6" } */
+
+/* Verify there is no ICE and don't check the error messages on MMA
+   requirement since they could be fragile and are not test points
+   of this case.  */
+/* { dg-excess-errors "pr103353" } */
+
+void
+foo (__vector_pair *dst, double *x)
+{
+  dst[0] = __builtin_vsx_lxvp (0, (__vector_pair *)(void *)x);
+}
+
+void
+bar (__vector_pair *src, double *x)
+{
+  __builtin_vsx_stxvp (src[0], 0, (__vector_pair *)(void *)x);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr105041.c b/gcc/testsuite/gcc.target/powerpc/pr105041.c
new file mode 100644
index 00000000000..c52b7a5ef30
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr105041.c
@@ -0,0 +1,22 @@
+/* { dg-options "-mdejagnu-cpu=power4 -O2 -fcompare-debug -frename-registers" } */
+
+double m;
+int n;
+
+unsigned int
+foo (unsigned int x, int y)
+{
+  long long int a = y, b = !a;
+  int c = 0;
+
+  if (b != x)
+    while ((int) m == a)
+      {
+        c = a;
+        a = 0;
+      }
+
+  n = b = y;
+
+  return x + c;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106016.c b/gcc/testsuite/gcc.target/powerpc/pr106016.c
new file mode 100644
index 00000000000..3db8345dcc6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106016.c
@@ -0,0 +1,14 @@
+/* PR target/106016 */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+/* Make sure we do not ICE on the following test case.  */
+
+extern void bar (__vector_quad *);
+
+void
+foo (__vector_quad *a, __vector_quad *b)
+{
+  __vector_quad arr[2] = {*a, *b};
+  bar (&arr[0]);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106017.c b/gcc/testsuite/gcc.target/powerpc/pr106017.c
new file mode 100644
index 00000000000..46d6c7a4a33
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106017.c
@@ -0,0 +1,19 @@
+/* PR target/106017 */
+/* { dg-options "-O1 -mdejagnu-cpu=power10" } */
+/* { dg-require-effective-target power10_ok } */
+
+/* Make sure we do not flag any errors on the following test cases.  */
+
+void takeacc(__vector_quad *);
+void
+foo (void)
+{
+  __vector_quad arr[4];
+  takeacc (arr);
+}
+
+unsigned char *
+bar (__vector_quad *a)
+{
+  return (unsigned char *)a;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106091.c b/gcc/testsuite/gcc.target/powerpc/pr106091.c
new file mode 100644
index 00000000000..61ce8cf4733
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106091.c
@@ -0,0 +1,15 @@
+/* { dg-options "-O -fnon-call-exceptions -fno-tree-dce -fno-tree-forwprop -w" } */
+
+/* Verify there is no ICE.  */
+
+typedef short __attribute__ ((__vector_size__ (64))) V;
+V v, w;
+
+inline V foo (V a, V b);
+
+V
+foo (V a, V b)
+{
+  b &= v < b;
+  return (V){foo (b, w)[3], (V){}[3]};
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/test_mffsl.c b/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
index 41377efba1a..045d0bfa349 100644
--- a/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
+++ b/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
@@ -1,5 +1,6 @@
 /* { dg-do run { target { powerpc*-*-* } } } */
-/* { dg-options "-O2 -std=c99" } */
+/* { dg-options "-O2 -std=c99 -mdejagnu-cpu=power9" } */
+/* { dg-require-effective-target p9vector_hw } */
 
 #ifdef DEBUG
 #include <stdio.h>
diff --git a/gcc/testsuite/gcc.target/sparc/20220510-1.c b/gcc/testsuite/gcc.target/sparc/20220510-1.c
new file mode 100644
index 00000000000..f321cab8482
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20220510-1.c
@@ -0,0 +1,31 @@
+/* PR target/105292 */
+/* Reported by Koakuma <koachan+gccbugs@protonmail.com> */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mvis2" } */
+
+extern void get_vbytes_v2 (unsigned);
+
+typedef struct {
+  unsigned ctt_info;
+  unsigned ctt_size;
+} ctf_type_t;
+
+typedef struct {
+  unsigned short cts_offset;
+  unsigned short cts_bits;
+} ctf_slice_t;
+
+void flip_types_len (ctf_type_t *t, int bsx1, int bsx2)
+{
+  const int kind = t->ctt_info;
+
+  get_vbytes_v2 (t->ctt_size);
+
+  if (kind == 4)
+    {
+      ctf_slice_t *s = (ctf_slice_t *)t;
+      s->cts_offset = __builtin_bswap16(bsx1);
+      s->cts_bits   = __builtin_bswap16(bsx2);
+    }
+}
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
index 7a8ed03d119..b2ad67aef87 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
@@ -82,3 +82,6 @@ snapshot_ret:
 	.comm	xmm_regs,256,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
index 73a59191d6d..24c8b3c9023 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
@@ -79,3 +79,6 @@ snapshot_ret:
 	.comm	ymm_regs,512,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
index 0ef82876dd9..86d54d11c58 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
@@ -95,3 +95,6 @@ snapshot_ret:
 	.comm	zmm_regs,2048,64
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S b/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
index 1d6cd9503e2..ed6f32ea041 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
@@ -30,6 +30,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #ifdef __ELF__
 # define FN_TYPE(fn) .type fn,@function
 # define FN_SIZE(fn) .size fn,.-fn
+# ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+# endif
 #else
 # define FN_TYPE(fn)
 # define FN_SIZE(fn)
diff --git a/gcc/testsuite/gdc.dg/Wpadded.d b/gcc/testsuite/gdc.dg/Wpadded.d
new file mode 100644
index 00000000000..8a9cca7e225
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/Wpadded.d
@@ -0,0 +1,4 @@
+// { dg-do compile }
+// { dg-options "-Wpadded" }
+
+class EmptyClass { }
diff --git a/gcc/testsuite/gdc.dg/pr106139a.d b/gcc/testsuite/gdc.dg/pr106139a.d
new file mode 100644
index 00000000000..f635eabc745
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr106139a.d
@@ -0,0 +1,36 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias A = int[4];
+
+static if (__traits(compiles, __vector(A))):
+
+A vector2array(__vector(A) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(A) v)
+{
+    a = cast(A)v;
+}
+
+__vector(A) array2vector(A a)
+{
+    return cast(__vector(A)) a;
+}
+
+void array2vector(ref __vector(A) v, A a)
+{
+    v = cast(__vector(A))a;
+}
+
+A vector2array_array(__vector(A) v)
+{
+    return v.array;
+}
+
+void vector2array_array(ref A a, __vector(A) v)
+{
+    a = v.array;
+}
diff --git a/gcc/testsuite/gdc.dg/pr106139b.d b/gcc/testsuite/gdc.dg/pr106139b.d
new file mode 100644
index 00000000000..f9caf026f86
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr106139b.d
@@ -0,0 +1,36 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias A = float[4];
+
+static if (__traits(compiles, __vector(A))):
+
+A vector2array(__vector(A) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(A) v)
+{
+    a = cast(A)v;
+}
+
+__vector(A) array2vector(A a)
+{
+    return cast(__vector(A)) a;
+}
+
+void array2vector(ref __vector(A) v, A a)
+{
+    v = cast(__vector(A))a;
+}
+
+A vector2array_array(__vector(A) v)
+{
+    return v.array;
+}
+
+void vector2array_array(ref A a, __vector(A) v)
+{
+    a = v.array;
+}
diff --git a/gcc/testsuite/gdc.dg/pr106139c.d b/gcc/testsuite/gdc.dg/pr106139c.d
new file mode 100644
index 00000000000..3b6b7a83341
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr106139c.d
@@ -0,0 +1,27 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias V = int[4];
+alias A = float[4];
+
+static if (__traits(compiles, __vector(V))):
+
+A vector2array(__vector(V) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(V) v)
+{
+    a = cast(A)v;
+}
+
+__vector(V) array2vector(A a)
+{
+    return cast(__vector(V)) a;
+}
+
+void array2vector(ref __vector(V) v, A a)
+{
+    v = cast(__vector(V))a;
+}
diff --git a/gcc/testsuite/gdc.dg/pr106139d.d b/gcc/testsuite/gdc.dg/pr106139d.d
new file mode 100644
index 00000000000..4c6f0ef3a3a
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr106139d.d
@@ -0,0 +1,27 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias V = float[4];
+alias A = int[4];
+
+static if (__traits(compiles, __vector(V))):
+
+A vector2array(__vector(V) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(V) v)
+{
+    a = cast(A)v;
+}
+
+__vector(V) array2vector(A a)
+{
+    return cast(__vector(V)) a;
+}
+
+void array2vector(ref __vector(V) v, A a)
+{
+    v = cast(__vector(V))a;
+}
diff --git a/gcc/testsuite/gdc.test/fail_compilation/ice20264.d b/gcc/testsuite/gdc.test/fail_compilation/ice20264.d
new file mode 100644
index 00000000000..0d697e22c9f
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/ice20264.d
@@ -0,0 +1,13 @@
+/*
+DISABLED: freebsd32 linux32 osx32 win32
+TEST_OUTPUT:
+---
+fail_compilation/ice20264.d(12): Error: `cast(__vector(float[4]))a` is not an lvalue and cannot be modified
+---
+*/
+
+void foo(float *a)
+{
+    alias float4 = __vector(float[4]);
+    cast(float4)(a) = 1.0f;
+}
diff --git a/gcc/testsuite/gfortran.dg/PR100029.f90 b/gcc/testsuite/gfortran.dg/PR100029.f90
new file mode 100644
index 00000000000..fd7e4c46032
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100029.f90
@@ -0,0 +1,22 @@
+! { dg-do run }
+!
+! Test the fix for PR100029
+!
+
+program foo_p
+  implicit none
+
+  type :: foo_t
+  end type foo_t
+  
+  class(foo_t), allocatable :: pout
+
+  call foo_s(pout)
+
+contains
+
+  subroutine foo_s(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+  end subroutine foo_s
+
+end program foo_p
diff --git a/gcc/testsuite/gfortran.dg/PR100040.f90 b/gcc/testsuite/gfortran.dg/PR100040.f90
new file mode 100644
index 00000000000..0a135ff30a3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100040.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+!
+! Test the fix for PR100040
+!
+
+program foo_p
+  implicit none
+
+  integer, parameter :: n = 11
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+  
+  type(foo_t), parameter :: a = foo_t(n)
+  
+  class(foo_t), allocatable :: pout
+
+  call foo_s(pout)
+  if(.not.allocated(pout)) stop 1
+  if(pout%i/=n) stop 2
+
+contains
+
+  subroutine foo_s(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(0)
+      that = a
+    rank default
+      stop 3
+    end select
+  end subroutine foo_s
+
+end program foo_p
diff --git a/gcc/testsuite/gfortran.dg/PR100132.f90 b/gcc/testsuite/gfortran.dg/PR100132.f90
new file mode 100644
index 00000000000..78ae6702810
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100132.f90
@@ -0,0 +1,75 @@
+! { dg-do run }
+!
+! Test the fix for PR100132
+!
+
+module main_m
+  implicit none
+
+  private
+
+  public :: &
+    foo_t
+
+  public :: &
+    set,    &
+    get
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+
+  type(foo_t), save, pointer :: data => null()
+
+contains
+
+  subroutine set(this)
+    class(foo_t), pointer, intent(in) :: this
+
+    if(associated(data)) stop 1
+    data => this
+  end subroutine set
+
+  subroutine get(this)
+    type(foo_t), pointer, intent(out) :: this
+
+    if(.not.associated(data)) stop 4
+    this => data
+    nullify(data)
+  end subroutine get
+
+end module main_m
+
+program main_p
+
+  use :: main_m, only: &
+    foo_t, set, get
+
+  implicit none
+
+  integer, parameter :: n = 1000
+
+  type(foo_t), pointer :: ps
+  type(foo_t),  target :: s
+  integer              :: i, j, yay, nay
+
+  yay = 0
+  nay = 0
+  do i = 1, n
+    s%i = i
+    call set(s)
+    call get(ps)
+    if(.not.associated(ps)) stop 13
+    j = ps%i
+    if(i/=j) stop 14
+    if(i/=s%i) stop 15
+    if(ps%i/=s%i) stop 16
+    if(associated(ps, s))then
+      yay = yay + 1
+    else
+      nay = nay + 1
+    end if
+  end do
+  if((yay/=n).or.(nay/=0)) stop 17
+
+end program main_p
diff --git a/gcc/testsuite/gfortran.dg/PR100136.f90 b/gcc/testsuite/gfortran.dg/PR100136.f90
new file mode 100644
index 00000000000..922af4aecc3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100136.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+! { dg-options "-fcheck=pointer" }
+! { dg-shouldfail "Argument not allocated" }
+! { dg-output "Fortran runtime error: Allocatable actual argument 'c_init2' is not allocated" }
+!
+! Tests fix for PR100136
+!
+! Test cut down from PR58586
+!
+
+module test_pr58586_mod
+  implicit none
+
+  type :: a
+  end type
+
+  type :: c
+     type(a), allocatable :: a
+  end type
+
+contains
+
+  subroutine add_class_c (d)
+    class(c), value :: d
+  end subroutine
+
+  class(c) function c_init2()
+    allocatable :: c_init2
+  end function
+
+end module test_pr58586_mod
+
+program test_pr58586
+  use test_pr58586_mod
+
+  ! This needs to execute, to see whether the segfault at runtime is resolved
+  call add_class_c(c_init2())
+
+end program
diff --git a/gcc/testsuite/gfortran.dg/PR100245.f90 b/gcc/testsuite/gfortran.dg/PR100245.f90
new file mode 100644
index 00000000000..07c1f7b3a1c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100245.f90
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test the fix for PR100245
+!
+
+program main_p
+
+  implicit none
+
+  type :: foo_t
+    integer :: a
+  end type foo_t
+
+  integer, parameter :: a = 42
+
+  class(foo_t), allocatable :: val
+  class(foo_t), allocatable :: rs1
+  type(foo_t),  allocatable :: rs2
+
+  allocate(val, source=foo_t(42))
+  if (val%a/=a) stop 1
+  rs1 = val
+  if (rs1%a/=a) stop 2
+  rs2 = val
+  if (rs2%a/=a) stop 3
+  deallocate(val, rs1, rs2)
+
+end program main_p
diff --git a/gcc/testsuite/gfortran.dg/associate_26a.f90 b/gcc/testsuite/gfortran.dg/associate_26a.f90
new file mode 100644
index 00000000000..85aebebd4d8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_26a.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+!
+! Test the fix for PR78152 and the followup in PR82868
+!
+! Contributed by <physiker@toast2.net>
+!
+program co_assoc
+  implicit none
+  integer, parameter :: p = 5
+  real, allocatable :: a(:,:)[:,:]
+  allocate (a(p,p)[2,*])
+  associate (i => a(1:p, 1:p))
+  end associate
+end program co_assoc
diff --git a/gcc/testsuite/gfortran.dg/class_58.f90 b/gcc/testsuite/gfortran.dg/class_58.f90
index 20b601a2f51..fceb575432d 100644
--- a/gcc/testsuite/gfortran.dg/class_58.f90
+++ b/gcc/testsuite/gfortran.dg/class_58.f90
@@ -9,5 +9,5 @@ subroutine s
   end type
   class(t), parameter :: x = t()  ! { dg-error "cannot have the PARAMETER attribute" }
   class(t), parameter :: y = x    ! { dg-error "cannot have the PARAMETER attribute" }
-  class(t) :: z = x               ! { dg-error "must be dummy, allocatable or pointer" }
+  class(t) :: z = t()             ! { dg-error "must be dummy, allocatable or pointer" }
 end
diff --git a/gcc/testsuite/gfortran.dg/class_73.f90 b/gcc/testsuite/gfortran.dg/class_73.f90
new file mode 100644
index 00000000000..c11ee38c086
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_73.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! Error recovery on invalid CLASS(), PARAMETER declarations
+! PR fortran/103137
+! PR fortran/103138
+! PR fortran/103693
+! PR fortran/105243
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     character(3) :: c = '(a)'
+  end type
+  class(t), parameter :: x = 1.  ! { dg-error "PARAMETER attribute" }
+  class(*), parameter :: y = t() ! { dg-error "PARAMETER attribute" }
+  class(*), parameter :: z = 1   ! { dg-error "PARAMETER attribute" }
+  print x%c                      ! { dg-error "Syntax error" }
+end
diff --git a/gcc/testsuite/gfortran.dg/dec_union_12.f90 b/gcc/testsuite/gfortran.dg/dec_union_12.f90
new file mode 100755
index 00000000000..26671230b05
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec_union_12.f90
@@ -0,0 +1,43 @@
+! { dg-do compile }
+! { dg-options "-std=legacy -ffree-form -finit-local-zero -finit-derived -fdec-structure" }
+!
+! PR fortran/105310
+!
+! Test that gfc_conv_union_initializer does not cause an ICE when called
+! to build the constructor for a field which triggers a vector resize.
+!
+
+program dec_union_12
+  implicit none
+STRUCTURE /foo8u/
+  ! 8 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo16u/
+  ! 16 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo32u/
+  ! 32 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  INTEGER(4) :: aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+  record /foo8u/ bar8u
+  record /foo16u/ bar16u
+  record /foo32u/ bar32u
+  bar8u.a = 1
+  bar16u.a = 1
+  bar32u.a = 1
+end
diff --git a/gcc/testsuite/gfortran.dg/extends_type_of_4.f90 b/gcc/testsuite/gfortran.dg/extends_type_of_4.f90
new file mode 100644
index 00000000000..64373322387
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/extends_type_of_4.f90
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! PR fortran/106121 - ICE in gfc_simplify_extends_type_of
+! Contributed by G.Steinmetz
+
+program p
+   type t
+   end type
+   type(t)  :: x
+   class(t) :: y               ! { dg-error "dummy, allocatable or pointer" }
+   print *, extends_type_of (x, y)
+end
+
+subroutine s
+   type t
+      integer :: i
+   end type
+   type(t)  :: x
+   class(t) :: y               ! { dg-error "dummy, allocatable or pointer" }
+   stop extends_type_of (x, y) ! { dg-error "STOP code" }
+end
diff --git a/gcc/testsuite/gfortran.dg/g77/pr105203.f b/gcc/testsuite/gfortran.dg/g77/pr105203.f
new file mode 100644
index 00000000000..3b47210fb40
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/g77/pr105203.f
@@ -0,0 +1,20 @@
+C Test case for PR debug/105203
+C Origin: kmccarty@princeton.edu
+C
+C { dg-do compile }
+C { dg-options "-O2 -fcompare-debug -ftracer -w" }
+C { dg-additional-options "-fPIC" { target fpic } }
+      SUBROUTINE FOO (B)
+
+  10  CALL BAR (A)
+      ASSIGN 20 TO M
+      IF (100.LT.A) GOTO 10
+      GOTO 40
+C
+  20  IF (B.LT.ABS(A)) GOTO 10
+      ASSIGN 30 TO M
+      GOTO 40
+C
+  30  ASSIGN 10 TO M
+  40  GOTO M,(10,20,30)
+      END
diff --git a/gcc/testsuite/gfortran.dg/index_6.f90 b/gcc/testsuite/gfortran.dg/index_6.f90
new file mode 100644
index 00000000000..61d492985ad
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/index_6.f90
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/105691 - Incorrect calculation of INDEX(str1,str2) at compile time
+
+program main
+  implicit none
+  integer :: i
+  character(*), parameter :: s1 = "fortran.f90"
+  character(*), parameter :: s2 = "fortran"
+  character(*), parameter :: s3 = s2 // "*"
+  integer, parameter :: i0    = index(s1, s2)
+  integer, parameter :: i1    = index(s1, s2, back= .true.)
+  integer, parameter :: i2(*) = index(s1, s2, back=[.true.,.false.])
+  integer, parameter :: i3(*) = index(s1, s2, back=[(i==1, i=1,2)] )
+  integer, parameter :: i4    = index(s1, s3)
+  integer, parameter :: i5    = index(s1, s3, back= .true.)
+  integer, parameter :: i6(*) = index(s1, s3, back=[.true.,.false.])
+  integer, parameter :: i7(*) = index(s1, s3, back=[(i==1, i=1,2)] )
+  integer, parameter :: i8    = index(s1, "f", back= .true.)
+  if (     i0 /= 1 ) stop 1
+  if (     i1 /= 1 ) stop 2
+  if (any (i2 /= 1)) stop 3
+  if (any (i3 /= 1)) stop 4
+  if (     i4 /= 0 ) stop 5
+  if (     i5 /= 0 ) stop 6
+  if (any (i6 /= 0)) stop 7
+  if (any (i7 /= 0)) stop 8
+  if (i8 /= len(s1)-2) stop 9
+end program
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/intent_optimize_4.f90 b/gcc/testsuite/gfortran.dg/intent_optimize_4.f90
new file mode 100644
index 00000000000..effbaa12a2d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_optimize_4.f90
@@ -0,0 +1,43 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! { dg-final { scan-tree-dump-times "CLOBBER" 2 "original" } }
+!
+! PR fortran/106817
+! Check that for an actual argument whose dummy is INTENT(OUT),
+! the clobber that is emitted in the caller before a procedure call
+! happens after any expression depending on the argument value has been
+! evaluated.
+! 
+
+module m
+  implicit none
+contains
+  subroutine copy1(out, in)
+    integer, intent(in) :: in
+    integer, intent(out) :: out
+    out = in
+  end subroutine copy1
+  subroutine copy2(in, out)
+    integer, intent(in) :: in
+    integer, intent(out) :: out
+    out = in
+  end subroutine copy2
+end module m
+
+program p
+  use m
+  implicit none
+  integer :: a, b
+
+  ! Clobbering of a should happen after a+1 has been evaluated.
+  a = 3
+  call copy1(a, a+1)
+  if (a /= 4) stop 1
+
+  ! Clobbering order does not depend on the order of arguments.
+  ! It should also come last with reversed arguments.
+  b = 12
+  call copy2(b+1, b)
+  if (b /= 13) stop 2
+
+end program p
diff --git a/gcc/testsuite/gfortran.dg/intent_out_15.f90 b/gcc/testsuite/gfortran.dg/intent_out_15.f90
new file mode 100644
index 00000000000..64334e6f038
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_out_15.f90
@@ -0,0 +1,27 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+!
+! PR fortran/105012
+! The following case was triggering an ICE because of a clobber
+! on the DERFC function decl instead of its result.
+
+module error_function
+integer, parameter :: r8 = selected_real_kind(12) ! 8 byte real
+contains
+SUBROUTINE CALERF_r8(ARG, RESULT, JINT)
+   integer, parameter :: rk = r8
+   real(rk), intent(in)  :: arg
+   real(rk), intent(out) :: result
+   IF (Y .LE. THRESH) THEN
+   END IF
+end SUBROUTINE CALERF_r8
+FUNCTION DERFC(X)
+   integer, parameter :: rk = r8 ! 8 byte real
+   real(rk), intent(in) :: X
+   real(rk) :: DERFC
+   CALL CALERF_r8(X, DERFC, JINT)
+END FUNCTION DERFC
+end module error_function
+
+! { dg-final { scan-tree-dump-times "CLOBBER" 1 "original" } }
+! { dg-final { scan-tree-dump "__result_derfc = {CLOBBER};" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/nint_p7.f90 b/gcc/testsuite/gfortran.dg/nint_p7.f90
index 8f3552293c5..2239824a7fb 100644
--- a/gcc/testsuite/gfortran.dg/nint_p7.f90
+++ b/gcc/testsuite/gfortran.dg/nint_p7.f90
@@ -1,8 +1,7 @@
 ! Fortran
 ! { dg-do compile { target { powerpc*-*-* } } }
 ! { dg-require-effective-target powerpc_vsx_ok } 
-! { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } 
-! { dg-options "-O2 -mcpu=power7 -ffast-math" } 
+! { dg-options "-O2 -mdejagnu-cpu=power7 -ffast-math" } 
 ! { dg-final { scan-assembler-times "xsrdpi" 2 } } 
 
 	subroutine test_nint(x4,x8)
diff --git a/gcc/testsuite/gfortran.dg/pr102860.f90 b/gcc/testsuite/gfortran.dg/pr102860.f90
index d0a7356c0f5..6b1feaa9d79 100644
--- a/gcc/testsuite/gfortran.dg/pr102860.f90
+++ b/gcc/testsuite/gfortran.dg/pr102860.f90
@@ -1,8 +1,7 @@
 ! PR middle-end/102860
 ! { dg-do compile { target { powerpc*-*-* } } }
 ! { dg-require-effective-target powerpc_vsx_ok } 
-! { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power10" } } 
-! { dg-options "-O2 -mcpu=power10" } 
+! { dg-options "-O2 -mdejagnu-cpu=power10" } 
 
 function foo(a)
   integer(kind=4) :: a(1024)
diff --git a/gcc/testsuite/gfortran.dg/pr103504.f90 b/gcc/testsuite/gfortran.dg/pr103504.f90
new file mode 100644
index 00000000000..607d1c6c8cc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103504.f90
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! PR fortran/103504 - ICE in get_sym_storage_size, at fortran/interface.c:2800
+! Contributed by G.Steinmetz
+
+program p
+  implicit none
+  real      :: y(1)
+  character :: b
+  call s(y)
+  call t(y)
+  call u(y)
+  call c(b)
+contains
+  subroutine s(x)
+    real :: x(abs(1.):1)        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine t(x)
+    real :: x(abs(1.):1)        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine u(x)
+    real :: x(1:abs(1.))        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine c(z)
+    character(len=abs(1.)) :: z ! { dg-error "must be of INTEGER type" }
+  end subroutine c
+end
+
+! { dg-prune-output "must be of INTEGER type" }
diff --git a/gcc/testsuite/gfortran.dg/pr103694.f90 b/gcc/testsuite/gfortran.dg/pr103694.f90
new file mode 100644
index 00000000000..3ed8b2088da
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103694.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/103694 - ICE in gfc_conv_expr_op
+! Contributed by G.Steinmetz
+
+subroutine s
+  type t
+     integer :: a(2)
+  end type
+  type(t) :: x((0.)/0)
+  integer :: n = size(x(1)%a) ! { dg-error "does not reduce to a constant expression" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr104313.f b/gcc/testsuite/gfortran.dg/pr104313.f
new file mode 100644
index 00000000000..89c8947cb0a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr104313.f
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-additional-options "-ff2c -fdump-tree-original" }
+!
+! PR fortran/104313 - ICE verify_gimple failed with -ff2c
+! Contributed by G.Steinmetz
+
+      function f(a)
+      return
+      end
+
+! { dg-final { scan-tree-dump-times "return" 1 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pr104849.f90 b/gcc/testsuite/gfortran.dg/pr104849.f90
new file mode 100644
index 00000000000..ae221b5ba10
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr104849.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/104849 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1, 2] ! { dg-error "deferred shape" }
+  integer :: x(2)
+  data x /a(:)/                       ! { dg-error "Invalid" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr105230.f90 b/gcc/testsuite/gfortran.dg/pr105230.f90
new file mode 100644
index 00000000000..6c6b42ef9bf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr105230.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/105230 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1, 2] ! { dg-error "deferred shape" }
+  print *, reshape([3, 4], a(1:2))
+end
diff --git a/gcc/testsuite/gfortran.dg/pr105954.f90 b/gcc/testsuite/gfortran.dg/pr105954.f90
new file mode 100644
index 00000000000..89004bf9aa7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr105954.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/105954 - ICE in gfc_element_size, at fortran/target-memory.cc:132
+! Contributed by G.Steinmetz
+
+program p
+  use iso_c_binding, only: c_float, c_sizeof
+  implicit none
+  integer, parameter :: n = -99
+  type t
+     real :: b(3,7:n)
+  end type
+  type, bind(c) :: u
+     real(c_float) :: b(3,7:n)
+  end type
+  type(t) :: d
+  type(u) :: e
+  integer, parameter :: k = storage_size(d)
+  integer, parameter :: m = sizeof(d)
+  integer, parameter :: l = c_sizeof(e)
+  if (k /= 0) stop 1
+  if (m /= 0) stop 2
+  if (l /= 0) stop 3
+end
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pr106331.f90 b/gcc/testsuite/gfortran.dg/pr106331.f90
new file mode 100644
index 00000000000..3873863be48
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106331.f90
@@ -0,0 +1,7 @@
+! { dg-do run }
+! { dg-options "-Og" }
+
+PROGRAM main
+  CHARACTER(LEN=24) :: a(2)
+  a = ''
+END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/pr106857.f90 b/gcc/testsuite/gfortran.dg/pr106857.f90
new file mode 100644
index 00000000000..4b0f86a75a6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106857.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/106857 - ICE in gfc_simplify_pack
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     integer :: n
+  end type
+  type(t), parameter :: a(2,2) = t(1)
+  type(t), parameter :: b(4) = reshape(a, [2])                          ! { dg-error "Different shape" }
+  type(t), parameter :: c(2) = pack(b, [.false.,.true.,.false.,.true.]) ! { dg-error "Different shape" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106985.f90 b/gcc/testsuite/gfortran.dg/pr106985.f90
new file mode 100644
index 00000000000..f4ed92577a3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106985.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/106985 - ICE in gfc_simplify_expr
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(2) = 1
+  integer, parameter :: b = a(2) + b ! { dg-error "before its definition is complete" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106986.f90 b/gcc/testsuite/gfortran.dg/pr106986.f90
new file mode 100644
index 00000000000..a309b25d181
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106986.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/106986 - ICE in simplify_findloc_nodim
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1] ! { dg-error "deferred shape" }
+  print *, findloc (a, 1)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr107054.f90 b/gcc/testsuite/gfortran.dg/pr107054.f90
new file mode 100644
index 00000000000..bbfe646beba
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr107054.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/107054 - ICE in gfc_simplify_unpack
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     integer :: n = 0
+  end type
+  type(t), parameter :: a(4) = t(2)
+  type(t), parameter :: b(4) = reshape(a,[2]) ! { dg-error "Different shape" }
+  type(t), parameter :: c(2) = pack(b,[.false.,.true.,.false.,.true.]) ! { dg-error "Different shape" }
+  type(t), parameter :: d(4) = unpack(c,[.false.,.true.,.false.,.true.],a)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr47614.f b/gcc/testsuite/gfortran.dg/pr47614.f
index 500d210a2a4..d772eef257f 100644
--- a/gcc/testsuite/gfortran.dg/pr47614.f
+++ b/gcc/testsuite/gfortran.dg/pr47614.f
@@ -1,6 +1,7 @@
 ! { dg-do run { target { powerpc*-*-* } } }
 ! { dg-skip-if "" { powerpc*-*-darwin* } }
-! { dg-options "-O3 -funroll-loops -ffast-math -mcpu=power4" }
+! { dg-options "-O3 -funroll-loops -ffast-math -mdejagnu-cpu=power4" }
+! { dg-options "-O3 -funroll-loops -ffast-math" { target powerpc64le*-*-linux* } }
 
 
       SUBROUTINE SFCPAR(ZET,NZ,ZMH,TSL,TMES)
diff --git a/gcc/testsuite/gfortran.dg/pr58968.f b/gcc/testsuite/gfortran.dg/pr58968.f
index b6ea17f4ae2..a7f1e1e710b 100644
--- a/gcc/testsuite/gfortran.dg/pr58968.f
+++ b/gcc/testsuite/gfortran.dg/pr58968.f
@@ -1,6 +1,6 @@
 C PR rtl-optimization/58968.f
 C { dg-do compile { target powerpc*-*-* } }
-C { dg-options "-mcpu=power7 -O3 -w -ffast-math  -funroll-loops" }
+C { dg-options "-mdejagnu-cpu=power7 -O3 -w -ffast-math  -funroll-loops" }
       SUBROUTINE MAKTABS(IW,SOME,LBOX1,LBOX2,LBOX3,NSPACE,NA,NB,
      *            LBST,X,
      *            NX,IAMA,IAMI,IBMA,IBMI,MNUM,IDIM,MSTA,IBO,
diff --git a/gcc/testsuite/gfortran.dg/unpack_vector_1.f90 b/gcc/testsuite/gfortran.dg/unpack_vector_1.f90
new file mode 100644
index 00000000000..5347c111e8f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/unpack_vector_1.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/105813
+! Fix checking of VECTOR argument to UNPACK when MASK is a variable.
+! Contributed by G.Steinmetz
+
+program p
+  logical, parameter :: mask(2,2) = reshape ([.true.,  .true.,  &
+                                              .false., .true.], &
+                                              shape (mask))
+  print *, unpack ([1,2,3], mask, 0) ! OK
+  print *, unpack ([1,2],   mask, 0) ! { dg-error "must provide at least" }
+end
diff --git a/gcc/testsuite/lib/prune.exp b/gcc/testsuite/lib/prune.exp
index 2809f88b16f..25fb98c6bed 100644
--- a/gcc/testsuite/lib/prune.exp
+++ b/gcc/testsuite/lib/prune.exp
@@ -76,6 +76,11 @@ proc prune_gcc_output { text } {
     regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $text "" text
     regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $text "" text
 
+    # Ideally the tests would indicate that executable stacks were needed
+    # to the linker.  But the option for that varies and may not even exist
+    # on some targets.  So we're stuck pruning the warning.
+    regsub -all "(^|\n)(\[^\n\]*: warning:\[^\n\]*requires executable stack\[^\n\]*\n?)+" $text "\\1" text
+
     # Ignore harmless warnings from Xcode 3.2.x.
     regsub -all "(^|\n)\[^\n\]*ld: warning: can't add line info to anonymous symbol\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*warning: DWARFDebugInfoEntry::AppendDependants\[^\n\]*AT_\[^\n\]*FORM_ref4\[^\n\]*" $text "" text
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 857e57218c1..a09606e4497 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -6087,9 +6087,12 @@ proc check_effective_target_powerpc_sqrt { } {
     }
 
     return [check_no_compiler_messages powerpc_sqrt object {
+	void test (void)
+	{
 	#ifndef _ARCH_PPCSQ
 	#error _ARCH_PPCSQ is not defined
 	#endif
+	}
     } {}]
 }
 
@@ -6196,63 +6199,94 @@ proc check_effective_target_powerpc_p9modulo_ok { } {
 # return 1 if our compiler returns the ARCH_PWR defines with the options
 # as provided by the test.
 proc check_effective_target_has_arch_pwr5 { } {
-	return [check_no_compiler_messages arch_pwr5 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr5 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR5
 		#error does not have power5 support.
 		#else
 		/* "has power5 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr6 { } {
-	return [check_no_compiler_messages arch_pwr6 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr6 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR6
 		#error does not have power6 support.
 		#else
 		/* "has power6 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr7 { } {
-	return [check_no_compiler_messages arch_pwr7 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr7 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR7
 		#error does not have power7 support.
 		#else
 		/* "has power7 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr8 { } {
-	return [check_no_compiler_messages arch_pwr8 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr8 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR8
 		#error does not have power8 support.
 		#else
 		/* "has power8 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr9 { } {
-	return [check_no_compiler_messages arch_pwr9 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr9 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR9
 		#error does not have power9 support.
 		#else
 		/* "has power9 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr10 { } {
-	return [check_no_compiler_messages arch_pwr10 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr10 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR10
 		#error does not have power10 support.
 		#else
 		/* "has power10 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
+}
+
+proc check_effective_target_has_arch_ppc64 { } {
+	return [check_no_compiler_messages_nocache arch_ppc64 assembly {
+		void test (void)
+		{
+		#ifndef _ARCH_PPC64
+		#error does not have ppc64 support.
+		#else
+		/* "has ppc64 support" */
+		#endif
+		}
+	} [current_compiler_flags]]
 }
 
 # Return 1 if this is a PowerPC target supporting -mcpu=power10.
@@ -6338,9 +6372,12 @@ proc check_effective_target_powerpc_float128_hw_ok { } {
 
 proc check_effective_target_ppc_float128 { } {
     return [check_no_compiler_messages_nocache ppc_float128 object {
+	void test (void)
+	{
 	#ifndef __FLOAT128__
 	  nope no good
 	#endif
+	}
     }]
 }
 
@@ -6348,9 +6385,12 @@ proc check_effective_target_ppc_float128 { } {
 
 proc check_effective_target_ppc_float128_insns { } {
     return [check_no_compiler_messages_nocache ppc_float128 object {
+	void test (void)
+	{
 	#ifndef __FLOAT128_HARDWARE__
 	  nope no good
 	#endif
+	}
     }]
 }
 
@@ -6358,9 +6398,12 @@ proc check_effective_target_ppc_float128_insns { } {
 
 proc check_effective_target_powerpc_vsx { } {
     return [check_no_compiler_messages_nocache powerpc_vsx object {
+	void test (void)
+	{
 	#ifndef __VSX__
 	  nope no vsx
 	#endif
+	}
     }]
 }
 
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 970ad386873..dea9cf3235c 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -1647,7 +1647,18 @@ build_ref_for_offset (location_t loc, tree base, poly_int64 offset,
 static tree
 build_reconstructed_reference (location_t, tree base, struct access *model)
 {
-  tree expr = model->expr, prev_expr = NULL;
+  tree expr = model->expr;
+  /* We have to make sure to start just below the outermost union.  */
+  tree start_expr = expr;
+  while (handled_component_p (expr))
+    {
+      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == UNION_TYPE)
+	start_expr = expr;
+      expr = TREE_OPERAND (expr, 0);
+    }
+
+  expr = start_expr;
+  tree prev_expr = NULL_TREE;
   while (!types_compatible_p (TREE_TYPE (expr), TREE_TYPE (base)))
     {
       if (!handled_component_p (expr))
diff --git a/gcc/tree-ssa-loop-ivopts.c b/gcc/tree-ssa-loop-ivopts.c
index 4012ae3f19d..913b3ad4258 100644
--- a/gcc/tree-ssa-loop-ivopts.c
+++ b/gcc/tree-ssa-loop-ivopts.c
@@ -2125,8 +2125,10 @@ idx_record_use (tree base, tree *idx,
   find_interesting_uses_op (data, *idx);
   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
     {
-      find_interesting_uses_op (data, array_ref_element_size (base));
-      find_interesting_uses_op (data, array_ref_low_bound (base));
+      if (TREE_OPERAND (base, 2))
+	find_interesting_uses_op (data, TREE_OPERAND (base, 2));
+      if (TREE_OPERAND (base, 3))
+	find_interesting_uses_op (data, TREE_OPERAND (base, 3));
     }
   return true;
 }
diff --git a/gcc/tree-ssa-math-opts.c b/gcc/tree-ssa-math-opts.c
index 94f9cc4d6b6..adeb70fd635 100644
--- a/gcc/tree-ssa-math-opts.c
+++ b/gcc/tree-ssa-math-opts.c
@@ -1459,7 +1459,7 @@ powi_cost (HOST_WIDE_INT n)
     return 0;
 
   /* Ignore the reciprocal when calculating the cost.  */
-  val = (n < 0) ? -n : n;
+  val = absu_hwi (n);
 
   /* Initialize the exponent cache.  */
   memset (cache, 0, POWI_TABLE_SIZE * sizeof (bool));
@@ -1492,7 +1492,7 @@ powi_cost (HOST_WIDE_INT n)
 
 static tree
 powi_as_mults_1 (gimple_stmt_iterator *gsi, location_t loc, tree type,
-		 HOST_WIDE_INT n, tree *cache)
+		 unsigned HOST_WIDE_INT n, tree *cache)
 {
   tree op0, op1, ssa_target;
   unsigned HOST_WIDE_INT digit;
@@ -1545,7 +1545,7 @@ powi_as_mults (gimple_stmt_iterator *gsi, location_t loc,
   memset (cache, 0, sizeof (cache));
   cache[1] = arg0;
 
-  result = powi_as_mults_1 (gsi, loc, type, (n < 0) ? -n : n, cache);
+  result = powi_as_mults_1 (gsi, loc, type, absu_hwi (n), cache);
   if (n >= 0)
     return result;
 
@@ -1569,11 +1569,9 @@ static tree
 gimple_expand_builtin_powi (gimple_stmt_iterator *gsi, location_t loc, 
 			    tree arg0, HOST_WIDE_INT n)
 {
-  /* Avoid largest negative number.  */
-  if (n != -n
-      && ((n >= -1 && n <= 2)
-	  || (optimize_function_for_speed_p (cfun)
-	      && powi_cost (n) <= POWI_MAX_MULTS)))
+  if ((n >= -1 && n <= 2)
+      || (optimize_function_for_speed_p (cfun)
+	  && powi_cost (n) <= POWI_MAX_MULTS))
     return powi_as_mults (gsi, loc, arg0, n);
 
   return NULL_TREE;
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
index 32e1632705b..c8cb7328a63 100644
--- a/gcc/tree-ssa-reassoc.c
+++ b/gcc/tree-ssa-reassoc.c
@@ -5054,17 +5054,26 @@ swap_ops_for_binary_stmt (vec<operand_entry *> ops,
 }
 
 /* If definition of RHS1 or RHS2 dominates STMT, return the later of those
-   two definitions, otherwise return STMT.  */
+   two definitions, otherwise return STMT.  Sets INSERT_BEFORE to indicate
+   whether RHS1 op RHS2 can be inserted before or needs to be inserted
+   after the returned stmt.  */
 
 static inline gimple *
-find_insert_point (gimple *stmt, tree rhs1, tree rhs2)
+find_insert_point (gimple *stmt, tree rhs1, tree rhs2, bool &insert_before)
 {
+  insert_before = true;
   if (TREE_CODE (rhs1) == SSA_NAME
       && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs1)))
-    stmt = SSA_NAME_DEF_STMT (rhs1);
+    {
+      stmt = SSA_NAME_DEF_STMT (rhs1);
+      insert_before = false;
+    }
   if (TREE_CODE (rhs2) == SSA_NAME
       && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs2)))
-    stmt = SSA_NAME_DEF_STMT (rhs2);
+    {
+      stmt = SSA_NAME_DEF_STMT (rhs2);
+      insert_before = false;
+    }
   return stmt;
 }
 
@@ -5076,7 +5085,8 @@ insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)
   gcc_assert (is_gimple_assign (stmt_to_insert));
   tree rhs1 = gimple_assign_rhs1 (stmt_to_insert);
   tree rhs2 = gimple_assign_rhs2 (stmt_to_insert);
-  gimple *insert_point = find_insert_point (stmt, rhs1, rhs2);
+  bool insert_before;
+  gimple *insert_point = find_insert_point (stmt, rhs1, rhs2, insert_before);
   gimple_stmt_iterator gsi = gsi_for_stmt (insert_point);
   gimple_set_uid (stmt_to_insert, gimple_uid (insert_point));
 
@@ -5084,7 +5094,7 @@ insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)
      the point where operand rhs1 or rhs2 is defined. In this case,
      stmt_to_insert has to be inserted afterwards. This would
      only happen when the stmt insertion point is flexible. */
-  if (stmt == insert_point)
+  if (insert_before)
     gsi_insert_before (&gsi, stmt_to_insert, GSI_NEW_STMT);
   else
     insert_stmt_after (stmt_to_insert, insert_point);
@@ -5143,22 +5153,25 @@ rewrite_expr_tree (gimple *stmt, enum tree_code rhs_code, unsigned int opindex,
 	     return lhs), force creation of a new SSA_NAME.  */
 	  if (changed || ((rhs1 != oe2->op || rhs2 != oe1->op) && opindex))
 	    {
+	      bool insert_before;
 	      gimple *insert_point
-		= find_insert_point (stmt, oe1->op, oe2->op);
+		= find_insert_point (stmt, oe1->op, oe2->op, insert_before);
 	      lhs = make_ssa_name (TREE_TYPE (lhs));
 	      stmt
 		= gimple_build_assign (lhs, rhs_code,
 				       oe1->op, oe2->op);
 	      gimple_set_uid (stmt, uid);
 	      gimple_set_visited (stmt, true);
-	      if (insert_point == gsi_stmt (gsi))
+	      if (insert_before)
 		gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
 	      else
 		insert_stmt_after (stmt, insert_point);
 	    }
 	  else
 	    {
-	      gcc_checking_assert (find_insert_point (stmt, oe1->op, oe2->op)
+	      bool insert_before;
+	      gcc_checking_assert (find_insert_point (stmt, oe1->op, oe2->op,
+						      insert_before)
 				   == stmt);
 	      gimple_assign_set_rhs1 (stmt, oe1->op);
 	      gimple_assign_set_rhs2 (stmt, oe2->op);
@@ -5214,21 +5227,25 @@ rewrite_expr_tree (gimple *stmt, enum tree_code rhs_code, unsigned int opindex,
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);
 	  unsigned int uid = gimple_uid (stmt);
-	  gimple *insert_point = find_insert_point (stmt, new_rhs1, oe->op);
+	  bool insert_before;
+	  gimple *insert_point = find_insert_point (stmt, new_rhs1, oe->op,
+						    insert_before);
 
 	  lhs = make_ssa_name (TREE_TYPE (lhs));
 	  stmt = gimple_build_assign (lhs, rhs_code,
 				      new_rhs1, oe->op);
 	  gimple_set_uid (stmt, uid);
 	  gimple_set_visited (stmt, true);
-	  if (insert_point == gsi_stmt (gsi))
+	  if (insert_before)
 	    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
 	  else
 	    insert_stmt_after (stmt, insert_point);
 	}
       else
 	{
-	  gcc_checking_assert (find_insert_point (stmt, new_rhs1, oe->op)
+	  bool insert_before;
+	  gcc_checking_assert (find_insert_point (stmt, new_rhs1, oe->op,
+						  insert_before)
 			       == stmt);
 	  gimple_assign_set_rhs1 (stmt, new_rhs1);
 	  gimple_assign_set_rhs2 (stmt, oe->op);
@@ -5708,7 +5725,9 @@ try_special_add_to_ops (vec<operand_entry *> *ops,
 	   && gimple_assign_rhs_code (def_stmt) == NEGATE_EXPR
 	   && !HONOR_SNANS (TREE_TYPE (op))
 	   && (!HONOR_SIGNED_ZEROS (TREE_TYPE (op))
-	       || !COMPLEX_FLOAT_TYPE_P (TREE_TYPE (op))))
+	       || !COMPLEX_FLOAT_TYPE_P (TREE_TYPE (op)))
+	   && (!FLOAT_TYPE_P (TREE_TYPE (op))
+	       || !DECIMAL_FLOAT_MODE_P (element_mode (op))))
     {
       tree rhs1 = gimple_assign_rhs1 (def_stmt);
       tree cst = build_minus_one_cst (TREE_TYPE (op));
@@ -5838,10 +5857,14 @@ repropagate_negates (void)
   FOR_EACH_VEC_ELT (plus_negates, i, negate)
     {
       gimple *user = get_single_immediate_use (negate);
-
       if (!user || !is_gimple_assign (user))
 	continue;
 
+      tree negateop = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (negate));
+      if (TREE_CODE (negateop) == SSA_NAME
+	  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (negateop))
+	continue;
+
       /* The negate operand can be either operand of a PLUS_EXPR
 	 (it can be the LHS if the RHS is a constant for example).
 
@@ -5864,9 +5887,9 @@ repropagate_negates (void)
 	  if (gimple_assign_rhs2 (user) == negate)
 	    {
 	      tree rhs1 = gimple_assign_rhs1 (user);
-	      tree rhs2 = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (negate));
 	      gimple_stmt_iterator gsi = gsi_for_stmt (user);
-	      gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, rhs1, rhs2);
+	      gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, rhs1,
+					      negateop);
 	      update_stmt (user);
 	    }
 	}
@@ -5875,21 +5898,20 @@ repropagate_negates (void)
 	  if (gimple_assign_rhs1 (user) == negate)
 	    {
 	      /* We have
-	           x = -a
+		   x = -negateop
 		   y = x - b
 		 which we transform into
-		   x = a + b
+		   x = negateop + b
 		   y = -x .
 		 This pushes down the negate which we possibly can merge
 		 into some other operation, hence insert it into the
 		 plus_negates vector.  */
 	      gimple *feed = SSA_NAME_DEF_STMT (negate);
-	      tree a = gimple_assign_rhs1 (feed);
 	      tree b = gimple_assign_rhs2 (user);
 	      gimple_stmt_iterator gsi = gsi_for_stmt (feed);
 	      gimple_stmt_iterator gsi2 = gsi_for_stmt (user);
 	      tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)));
-	      gimple *g = gimple_build_assign (x, PLUS_EXPR, a, b);
+	      gimple *g = gimple_build_assign (x, PLUS_EXPR, negateop, b);
 	      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);
 	      gimple_assign_set_rhs_with_ops (&gsi2, NEGATE_EXPR, x);
 	      user = gsi_stmt (gsi2);
@@ -5900,13 +5922,11 @@ repropagate_negates (void)
 	    }
 	  else
 	    {
-	      /* Transform "x = -a; y = b - x" into "y = b + a", getting
-	         rid of one operation.  */
-	      gimple *feed = SSA_NAME_DEF_STMT (negate);
-	      tree a = gimple_assign_rhs1 (feed);
+	      /* Transform "x = -negateop; y = b - x" into "y = b + negateop",
+		 getting rid of one operation.  */
 	      tree rhs1 = gimple_assign_rhs1 (user);
 	      gimple_stmt_iterator gsi = gsi_for_stmt (user);
-	      gimple_assign_set_rhs_with_ops (&gsi, PLUS_EXPR, rhs1, a);
+	      gimple_assign_set_rhs_with_ops (&gsi, PLUS_EXPR, rhs1, negateop);
 	      update_stmt (gsi_stmt (gsi));
 	    }
 	}
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index eaa97566d35..b4c9fac198b 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -3197,12 +3197,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       poly_int64 extra_off = 0;
       if (j == 0 && i >= 0
 	  && lhs_ops[0].opcode == MEM_REF
-	  && maybe_ne (lhs_ops[0].off, -1))
+	  && known_ne (lhs_ops[0].off, -1))
 	{
 	  if (known_eq (lhs_ops[0].off, vr->operands[i].off))
 	    i--, j--;
 	  else if (vr->operands[i].opcode == MEM_REF
-		   && maybe_ne (vr->operands[i].off, -1))
+		   && known_ne (vr->operands[i].off, -1))
 	    {
 	      extra_off = vr->operands[i].off - lhs_ops[0].off;
 	      i--, j--;
@@ -3229,6 +3229,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       copy_reference_ops_from_ref (rhs1, &rhs);
 
       /* Apply an extra offset to the inner MEM_REF of the RHS.  */
+      bool force_no_tbaa = false;
       if (maybe_ne (extra_off, 0))
 	{
 	  if (rhs.length () < 2)
@@ -3241,6 +3242,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
 	  rhs[ix].op0 = int_const_binop (PLUS_EXPR, rhs[ix].op0,
 					 build_int_cst (TREE_TYPE (rhs[ix].op0),
 							extra_off));
+	  /* When we have offsetted the RHS, reading only parts of it,
+	     we can no longer use the original TBAA type, force alias-set
+	     zero.  */
+	  force_no_tbaa = true;
 	}
 
       /* Save the operands since we need to use the original ones for
@@ -3293,8 +3298,11 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       /* Adjust *ref from the new operands.  */
       ao_ref rhs1_ref;
       ao_ref_init (&rhs1_ref, rhs1);
-      if (!ao_ref_init_from_vn_reference (&r, ao_ref_alias_set (&rhs1_ref),
-					  ao_ref_base_alias_set (&rhs1_ref),
+      if (!ao_ref_init_from_vn_reference (&r,
+					  force_no_tbaa ? 0
+					  : ao_ref_alias_set (&rhs1_ref),
+					  force_no_tbaa ? 0
+					  : ao_ref_base_alias_set (&rhs1_ref),
 					  vr->type, vr->operands))
 	return (void *)-1;
       /* This can happen with bitfields.  */
@@ -4843,7 +4851,7 @@ valueized_wider_op (tree wide_type, tree op, bool allow_truncate)
 
   /* For constants simply extend it.  */
   if (TREE_CODE (op) == INTEGER_CST)
-    return wide_int_to_tree (wide_type, wi::to_wide (op));
+    return wide_int_to_tree (wide_type, wi::to_widest (op));
 
   return NULL_TREE;
 }
diff --git a/gcc/tree-ssa-sink.c b/gcc/tree-ssa-sink.c
index 3c2ed795f85..b3097531203 100644
--- a/gcc/tree-ssa-sink.c
+++ b/gcc/tree-ssa-sink.c
@@ -390,6 +390,9 @@ statement_sink_location (gimple *stmt, basic_block frombb,
 		 with the use.  */
 	      if (gimple_code (use_stmt) == GIMPLE_PHI)
 		{
+		  /* If the PHI defines the virtual operand, ignore it.  */
+		  if (gimple_phi_result (use_stmt) == gimple_vuse (stmt))
+		    continue;
 		  /* In case the PHI node post-dominates the current insert
 		     location we can disregard it.  But make sure it is not
 		     dominating it as well as can happen in a CFG cycle.  */
diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
index 7289656db0f..a034abf9628 100644
--- a/gcc/tree-vect-slp.c
+++ b/gcc/tree-vect-slp.c
@@ -6319,6 +6319,13 @@ vect_schedule_slp_node (vec_info *vinfo,
 	  gcc_assert (seen_vector_def);
 	  si = gsi_after_labels (as_a <bb_vec_info> (vinfo)->bbs[0]);
 	}
+      else if (is_ctrl_altering_stmt (last_stmt))
+	{
+	  /* We split regions to vectorize at control altering stmts
+	     with a definition so this must be an external which
+	     we can insert at the start of the region.  */
+	  si = gsi_after_labels (as_a <bb_vec_info> (vinfo)->bbs[0]);
+	}
       else if (is_a <bb_vec_info> (vinfo)
 	       && gimple_bb (last_stmt) != gimple_bb (stmt_info->stmt)
 	       && gimple_could_trap_p (stmt_info->stmt))
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
index 0d61b0f51d0..973c6dcea18 100644
--- a/gcc/tree-vect-stmts.c
+++ b/gcc/tree-vect-stmts.c
@@ -2207,6 +2207,37 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,
 	      gcc_assert (!loop_vinfo || cmp > 0);
 	      *memory_access_type = VMAT_CONTIGUOUS;
 	    }
+
+	  /* When we have a contiguous access across loop iterations
+	     but the access in the loop doesn't cover the full vector
+	     we can end up with no gap recorded but still excess
+	     elements accessed, see PR103116.  Make sure we peel for
+	     gaps if necessary and sufficient and give up if not.  */
+	  if (loop_vinfo
+	      && *memory_access_type == VMAT_CONTIGUOUS
+	      && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ()
+	      && !multiple_p (group_size * LOOP_VINFO_VECT_FACTOR (loop_vinfo),
+			      nunits))
+	    {
+	      unsigned HOST_WIDE_INT cnunits, cvf;
+	      if (!can_overrun_p
+		  || !nunits.is_constant (&cnunits)
+		  || !LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&cvf)
+		  /* Peeling for gaps assumes that a single scalar iteration
+		     is enough to make sure the last vector iteration doesn't
+		     access excess elements.
+		     ???  Enhancements include peeling multiple iterations
+		     or using masked loads with a static mask.  */
+		  || (group_size * cvf) % cnunits + group_size < cnunits)
+		{
+		  if (dump_enabled_p ())
+		    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+				     "peeling for gaps insufficient for "
+				     "access\n");
+		  return false;
+		}
+	      overrun_p = true;
+	    }
 	}
     }
   else
diff --git a/gcc/value-prof.c b/gcc/value-prof.c
index 42748771192..688089b04d2 100644
--- a/gcc/value-prof.c
+++ b/gcc/value-prof.c
@@ -336,6 +336,10 @@ stream_out_histogram_value (struct output_block *ob, histogram_value hist)
 	/* Note that the IOR counter tracks pointer values and these can have
 	   sign bit set.  */
 	;
+      else if (hist->type == HIST_TYPE_INDIR_CALL && i == 0)
+	/* 'all' counter overflow is stored as a negative value. Individual
+	   counters and values are expected to be non-negative.  */
+	;
       else
 	gcc_assert (value >= 0);
 
diff --git a/gcc/varasm.c b/gcc/varasm.c
index a7ef9b8d9fe..93b9c8ef0ee 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -4691,7 +4691,10 @@ narrowing_initializer_constant_valid_p (tree value, tree endtype, tree *cache)
     {
       tree inner = TREE_OPERAND (op0, 0);
       if (inner == error_mark_node
-	  || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
+	  || ! INTEGRAL_TYPE_P (TREE_TYPE (op0))
+	  || ! SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (op0)))
+	  || ! INTEGRAL_TYPE_P (TREE_TYPE (inner))
+	  || ! SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
 	  || (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (op0)))
 	      > GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (inner)))))
 	break;
@@ -4703,7 +4706,10 @@ narrowing_initializer_constant_valid_p (tree value, tree endtype, tree *cache)
     {
       tree inner = TREE_OPERAND (op1, 0);
       if (inner == error_mark_node
-	  || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
+	  || ! INTEGRAL_TYPE_P (TREE_TYPE (op1))
+	  || ! SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (op1)))
+	  || ! INTEGRAL_TYPE_P (TREE_TYPE (inner))
+	  || ! SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
 	  || (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (op1)))
 	      > GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (inner)))))
 	break;
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 3f63896333e..b7feb1f443c 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,22 @@
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* directives.c (destringize_and_run): Override the location of
+	the CPP_PRAGMA token from a _Pragma directive to the location of
+	the expansion point, as is done for the tokens lexed from it.
+
+2022-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/105732
+	* expr.c (_cpp_parse_expr): Handle CPP_PADDING by just another
+	token.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libcpp/directives.c b/libcpp/directives.c
index 347ddb8b1e1..d764ddfa38e 100644
--- a/libcpp/directives.c
+++ b/libcpp/directives.c
@@ -1905,6 +1905,7 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in,
       maxcount = 50;
       toks = XNEWVEC (cpp_token, maxcount);
       toks[0] = pfile->directive_result;
+      toks[0].src_loc = expansion_loc;
 
       do
 	{
diff --git a/libcpp/expr.c b/libcpp/expr.c
index dd5611dce0e..57db654ed31 100644
--- a/libcpp/expr.c
+++ b/libcpp/expr.c
@@ -1370,6 +1370,10 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)
 	    op.op = CPP_UMINUS;
 	  break;
 
+	case CPP_PADDING:
+	  lex_count--;
+	  continue;
+
 	default:
 	  if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ)
 	    SYNTAX_ERROR2_AT (op.loc,
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index ceaa3e21b19..a1c6e184a50 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,9 @@
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* config/aarch64/lse.S: Define BARRIER and handle memory MODEL 5.
+	* config/aarch64/t-lse: Add a 5th memory model for _sync functions.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgcc/config/aarch64/lse.S b/libgcc/config/aarch64/lse.S
index df965b5a524..9215873842b 100644
--- a/libgcc/config/aarch64/lse.S
+++ b/libgcc/config/aarch64/lse.S
@@ -87,24 +87,44 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 # define L
 # define M     0x000000
 # define N     0x000000
+# define BARRIER
 #elif MODEL == 2
 # define SUFF  _acq
 # define A     a
 # define L
 # define M     0x400000
 # define N     0x800000
+# define BARRIER
 #elif MODEL == 3
 # define SUFF  _rel
 # define A
 # define L     l
 # define M     0x008000
 # define N     0x400000
+# define BARRIER
 #elif MODEL == 4
 # define SUFF  _acq_rel
 # define A     a
 # define L     l
 # define M     0x408000
 # define N     0xc00000
+# define BARRIER
+#elif MODEL == 5
+# define SUFF  _sync
+#ifdef L_swp
+/* swp has _acq semantics.  */
+#  define A    a
+#  define L
+#  define M    0x400000
+#  define N    0x800000
+#else
+/* All other _sync functions have _seq semantics.  */
+#  define A    a
+#  define L    l
+#  define M    0x408000
+#  define N    0xc00000
+#endif
+# define BARRIER dmb		ish
 #else
 # error
 #endif
@@ -127,7 +147,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #endif
 
 #define NAME(BASE)		glue4(__aarch64_, BASE, SIZE, SUFF)
-#define LDXR			glue4(ld, A, xr, S)
+#if MODEL == 5
+/* Drop A for _sync functions.  */
+# define LDXR			glue3(ld, xr, S)
+#else
+# define LDXR			glue4(ld, A, xr, S)
+#endif
 #define STXR			glue4(st, L, xr, S)
 
 /* Temporary registers used.  Other than these, only the return value
@@ -183,10 +208,16 @@ STARTFN	NAME(cas)
 	bne		1f
 	STXR		w(tmp1), s(1), [x2]
 	cbnz		w(tmp1), 0b
-1:	ret
+1:	BARRIER
+	ret
 
 #else
-#define LDXP	glue3(ld, A, xp)
+#if MODEL == 5
+/* Drop A for _sync functions.  */
+# define LDXP	glue2(ld, xp)
+#else
+# define LDXP	glue3(ld, A, xp)
+#endif
 #define STXP	glue3(st, L, xp)
 #ifdef HAVE_AS_LSE
 # define CASP	glue3(casp, A, L)	x0, x1, x2, x3, [x4]
@@ -205,7 +236,8 @@ STARTFN	NAME(cas)
 	bne		1f
 	STXP		w(tmp2), x2, x3, [x4]
 	cbnz		w(tmp2), 0b
-1:	ret
+1:	BARRIER
+	ret
 
 #endif
 
@@ -229,6 +261,7 @@ STARTFN	NAME(swp)
 0:	LDXR		s(0), [x1]
 	STXR		w(tmp1), s(tmp0), [x1]
 	cbnz		w(tmp1), 0b
+	BARRIER
 	ret
 
 ENDFN	NAME(swp)
@@ -273,6 +306,7 @@ STARTFN	NAME(LDNM)
 	OP		s(tmp1), s(0), s(tmp0)
 	STXR		w(tmp2), s(tmp1), [x1]
 	cbnz		w(tmp2), 0b
+	BARRIER
 	ret
 
 ENDFN	NAME(LDNM)
diff --git a/libgcc/config/aarch64/t-lse b/libgcc/config/aarch64/t-lse
index 88d2d84d100..6ec6df79392 100644
--- a/libgcc/config/aarch64/t-lse
+++ b/libgcc/config/aarch64/t-lse
@@ -18,13 +18,13 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-# Compare-and-swap has 5 sizes and 4 memory models.
+# Compare-and-swap has 5 sizes and 5 memory models.
 S0 := $(foreach s, 1 2 4 8 16, $(addsuffix _$(s), cas))
-O0 := $(foreach m, 1 2 3 4, $(addsuffix _$(m)$(objext), $(S0)))
+O0 := $(foreach m, 1 2 3 4 5, $(addsuffix _$(m)$(objext), $(S0)))
 
-# Swap, Load-and-operate have 4 sizes and 4 memory models
+# Swap, Load-and-operate have 4 sizes and 5 memory models
 S1 := $(foreach s, 1 2 4 8, $(addsuffix _$(s), swp ldadd ldclr ldeor ldset))
-O1 := $(foreach m, 1 2 3 4, $(addsuffix _$(m)$(objext), $(S1)))
+O1 := $(foreach m, 1 2 3 4 5, $(addsuffix _$(m)$(objext), $(S1)))
 
 LSE_OBJS := $(O0) $(O1)
 
diff --git a/libgcc/config/avr/libf7/ChangeLog b/libgcc/config/avr/libf7/ChangeLog
index 7e06f52d415..9081ecd3bd1 100644
--- a/libgcc/config/avr/libf7/ChangeLog
+++ b/libgcc/config/avr/libf7/ChangeLog
@@ -1,3 +1,12 @@
+2022-09-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backported from master:
+	2022-09-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/99184
+	* libf7-asm.sx (to_integer, to_unsigned): Don't round 16-bit
+	and 32-bit integers.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgcc/config/avr/libf7/libf7-asm.sx b/libgcc/config/avr/libf7/libf7-asm.sx
index 7629e23e289..9d701f27582 100644
--- a/libgcc/config/avr/libf7/libf7-asm.sx
+++ b/libgcc/config/avr/libf7/libf7-asm.sx
@@ -601,9 +601,6 @@ DEFUN to_integer
     tst     C6
     brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate
 
-    rcall   .Lround
-    brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate
-
     brtc 9f                 ;   >= 0         =>  return
     sbrc    Mask,   5
     .global __negdi2
@@ -658,30 +655,6 @@ DEFUN to_integer
     .global __clr_8
     XJMP    __clr_8
 
-.Lround:
-    ;; C6.7 is known to be 0 here.
-    ;; Return N = 1 iff we have to saturate.
-    cpi     Mask,   0xf
-    breq .Lround16
-    cpi     Mask,   0x1f
-    breq .Lround32
-
-    ;; For now, no rounding in the 64-bit case.  This rounding
-    ;; would have to be integrated into the right-shift.
-    cln
-    ret
-
-.Lround32:
-    rol     C2
-    adc     C3,     ZERO
-    adc     C4,     ZERO
-    rjmp 2f
-
-.Lround16:
-    rol     C4
-2:  adc     C5,     ZERO
-    adc     C6,     ZERO
-    ret
 ENDF to_integer
 #endif /* F7MOD_to_integer_ */
 
@@ -725,29 +698,6 @@ DEFUN to_unsigned
     clr     CA
     F7call  lshrdi3
     POP     r16
-
-    ;; Rounding
-    ;; ??? C6.7 is known to be 0 here.
-    cpi     Mask,   0xf
-    breq .Lround16
-    cpi     Mask,   0x1f
-    breq .Lround32
-
-    ;; For now, no rounding in the 64-bit case.  This rounding
-    ;; would have to be integrated into the right-shift.
-    ret
-
-.Lround32:
-    rol     C2
-    adc     C3,     ZERO
-    adc     C4,     ZERO
-    rjmp 2f
-
-.Lround16:
-    rol     C4
-2:  adc     C5,     ZERO
-    adc     C6,     ZERO
-    brcs    .Lset_0xffff    ; Rounding overflow  =>  saturate
     ret
 
 .Lset_0xffff:
diff --git a/libgo/sysinfo.c b/libgo/sysinfo.c
index 8ce061e2f5f..336a5983750 100644
--- a/libgo/sysinfo.c
+++ b/libgo/sysinfo.c
@@ -158,9 +158,6 @@
 #if defined(HAVE_LINUX_ETHER_H)
 #include <linux/ether.h>
 #endif
-#if defined(HAVE_LINUX_FS_H)
-#include <linux/fs.h>
-#endif
 #if defined(HAVE_LINUX_REBOOT_H)
 #include <linux/reboot.h>
 #endif
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index acd0b312ef2..f3d44133243 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,27 @@
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* testsuite/testsuite_flags.in: Add libphobos library directory as
+	search path to --gdcldflags.
+
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-09-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/unwind/generic.d (__aligned__): Define.
+	(_Unwind_Exception): Align struct to __aligned__.
+
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/emutls.d (emutlsDestroyThread): Clear the per-thread
+	TLS array, don't call free().
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libphobos/libdruntime/gcc/emutls.d b/libphobos/libdruntime/gcc/emutls.d
index 462230508ab..ebeeb8deda3 100644
--- a/libphobos/libdruntime/gcc/emutls.d
+++ b/libphobos/libdruntime/gcc/emutls.d
@@ -222,9 +222,9 @@ void** emutlsAlloc(shared __emutls_object* obj) nothrow @nogc
 }
 
 /*
- * When a thread has finished, remove the TLS array from the GC
- * scan list emutlsArrays, free all allocated TLS variables and
- * finally free the array.
+ * When a thread has finished, free all allocated TLS variables and empty the
+ * array.  The pointer is not free'd as it is stil referenced by the GC scan
+ * list emutlsArrays, which gets destroyed when druntime is unloaded.
  */
 extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
 {
@@ -236,7 +236,7 @@ extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
             free(entry[-1]);
     }
 
-    free(arr);
+    arr.length = 0;
 }
 
 /*
diff --git a/libphobos/libdruntime/gcc/unwind/generic.d b/libphobos/libdruntime/gcc/unwind/generic.d
index 592b3afcb71..68ddd1d5410 100644
--- a/libphobos/libdruntime/gcc/unwind/generic.d
+++ b/libphobos/libdruntime/gcc/unwind/generic.d
@@ -123,7 +123,27 @@ enum : _Unwind_Reason_Code
 // @@@ The IA-64 ABI says that this structure must be double-word aligned.
 // Taking that literally does not make much sense generically.  Instead we
 // provide the maximum alignment required by any type for the machine.
-struct _Unwind_Exception
+     version (ARM)      private enum __aligned__ = 8;
+else version (AArch64)  private enum __aligned__ = 16;
+else version (HPPA)     private enum __aligned__ = 8;
+else version (HPPA64)   private enum __aligned__ = 16;
+else version (MIPS_N32) private enum __aligned__ = 16;
+else version (MIPS_N64) private enum __aligned__ = 16;
+else version (MIPS32)   private enum __aligned__ = 8;
+else version (MIPS64)   private enum __aligned__ = 8;
+else version (PPC)      private enum __aligned__ = 16;
+else version (PPC64)    private enum __aligned__ = 16;
+else version (RISCV32)  private enum __aligned__ = 16;
+else version (RISCV64)  private enum __aligned__ = 16;
+else version (S390)     private enum __aligned__ = 8;
+else version (SPARC)    private enum __aligned__ = 8;
+else version (SPARC64)  private enum __aligned__ = 16;
+else version (SystemZ)  private enum __aligned__ = 8;
+else version (X86)      private enum __aligned__ = 16;
+else version (X86_64)   private enum __aligned__ = 16;
+else static assert( false, "Platform not supported.");
+
+align(__aligned__) struct _Unwind_Exception
 {
     _Unwind_Exception_Class exception_class;
     _Unwind_Exception_Cleanup_Fn exception_cleanup;
diff --git a/libphobos/testsuite/testsuite_flags.in b/libphobos/testsuite/testsuite_flags.in
index bafd5ad4502..8e2f1eefd5b 100755
--- a/libphobos/testsuite/testsuite_flags.in
+++ b/libphobos/testsuite/testsuite_flags.in
@@ -46,6 +46,7 @@ case ${query} in
     --gdcldflags)
       GDCLDFLAGS="-B${BUILD_DIR}/src
                   -B${BUILD_DIR}/libdruntime/gcc
+                  -B${BUILD_DIR}/src/.libs
                   -L${BUILD_DIR}/src/.libs"
       echo ${GDCLDFLAGS}
       ;;
diff --git a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
index 025e575b5bc..5743516c046 100644
--- a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
+++ b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
@@ -72,7 +72,9 @@
 #include <sys/vt.h>
 #include <linux/cdrom.h>
 #include <linux/fd.h>
+#if SANITIZER_ANDROID
 #include <linux/fs.h>
+#endif
 #include <linux/hdreg.h>
 #include <linux/input.h>
 #include <linux/ioctl.h>
@@ -828,10 +830,10 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);
   unsigned IOCTL_EVIOCGPROP = IOCTL_NOT_PRESENT;
   unsigned IOCTL_EVIOCSKEYCODE_V2 = IOCTL_NOT_PRESENT;
 #endif
-  unsigned IOCTL_FS_IOC_GETFLAGS = FS_IOC_GETFLAGS;
-  unsigned IOCTL_FS_IOC_GETVERSION = FS_IOC_GETVERSION;
-  unsigned IOCTL_FS_IOC_SETFLAGS = FS_IOC_SETFLAGS;
-  unsigned IOCTL_FS_IOC_SETVERSION = FS_IOC_SETVERSION;
+  unsigned IOCTL_FS_IOC_GETFLAGS = _IOR('f', 1, long);
+  unsigned IOCTL_FS_IOC_GETVERSION = _IOR('v', 1, long);
+  unsigned IOCTL_FS_IOC_SETFLAGS = _IOW('f', 2, long);
+  unsigned IOCTL_FS_IOC_SETVERSION = _IOW('v', 2, long);
   unsigned IOCTL_GIO_CMAP = GIO_CMAP;
   unsigned IOCTL_GIO_FONT = GIO_FONT;
   unsigned IOCTL_GIO_UNIMAP = GIO_UNIMAP;
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 85e04c45288..52e40723e3b 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,919 @@
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/version [!_GLIBCXX_HOSTED]
+	(__cpp_lib_bit_cast): Define for freestanding.
+	(__cpp_lib_string_contains): Do not define for freestanding.
+	(__cpp_lib_to_underlying): Likewise.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106607
+	* include/bits/regex_compiler.tcc (_Compiler::_M_cur_int_value):
+	Use built-ins to check for integer overflow in back-reference
+	number.
+	* testsuite/28_regex/basic_regex/106607.cc: New test.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106695
+	* include/bits/std_thread.h (thread::_State_impl): Forward
+	individual arguments to _Invoker constructor.
+	(thread::_Invoker): Add constructor. Delete copies.
+	* include/std/future (__future_base::_Deferred_state): Forward
+	individual arguments to _Invoker constructor.
+	(__future_base::_Async_state_impl): Likewise.
+	* testsuite/30_threads/async/106695.cc: New test.
+	* testsuite/30_threads/thread/106695.cc: New test.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106248
+	* include/std/istream [C++17] (operator>>(istream&, char*)):
+	Set eofbit if we stopped extracting at EOF.
+	* testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc:
+	New test.
+	* testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc:
+	New test.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104443
+	* include/bits/stl_iterator.h (common_iterator::operator->):
+	Change return type to just auto.
+
+2022-09-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/string_view (basic_string_view(Range&&)): Add
+	explicit as per P2499R0.
+	* testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc:
+	Adjust implicit conversions. Check implicit conversions fail.
+	* testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc:
+	Likewise.
+
+2022-07-26  Thomas Rodgers  <trodgers@redhat.com>
+
+	Backported from master:
+	2022-07-26  Thomas Rodgers  <trodgers@redhat.com>
+
+	* include/bits/atomic_wait.h (__atomic_spin): Merge spin loops.
+
+2022-07-22  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/106320
+	* include/std/ranges (single_view): Relax constraints on
+	default constructor so as to preserve pre-P2325R3 behavior.
+	(filter_view): Likewise.
+	(transform_view): Likewise.
+	(take_while_view): Likewise.
+	(drop_while_view): Likewise.
+	* testsuite/std/ranges/adaptors/join.cc (test13): New test.
+	* testsuite/std/ranges/p2325.cc: Fix S to be only non default
+	constructible and not also non copy constructible.  XFAIL the
+	tests that verify a non default constructible functor makes a
+	view non default constructible (lines 94, 97 and 98).  XFAIL
+	the test that effectively verifies a non default constructible
+	element type makes single_view non default constructible (line
+	114).
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100823
+	* include/bits/stl_iterator.h (common_iterator): Define move
+	constructor and move assignment operator.
+	(common_iterator::_M_assign): New function implementing
+	assignment.
+	(common_iterator::operator=): Use _M_assign.
+	(common_iterator::_S_valueless): New constant.
+	* testsuite/24_iterators/common_iterator/100823.cc: New test.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (common_iterator): Fix incorrect
+	uses of is_nothrow_assignable_v. Fix inconsistent constraints on
+	friend declaration. Do not move argument in copy constructor.
+	* testsuite/24_iterators/common_iterator/1.cc: Check for
+	noexcept constructibnle/assignable.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103992
+	* include/bits/stl_iterator.h (common_iterator): Use
+	std::construct_at instead of placement new.
+	* testsuite/24_iterators/common_iterator/1.cc: Check copy
+	construction is usable in constant expressions.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (common_iterator): Add constexpr
+	to all member functions (LWG 3574).
+	* testsuite/24_iterators/common_iterator/1.cc: Evaluate some
+	tests as constant expressions.
+	* testsuite/24_iterators/common_iterator/2.cc: Likewise.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/from_chars/4.cc: Only use log2 if C99 math
+	functions are available.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88881
+	* src/filesystem/ops.cc (has_trailing_slash): New helper
+	function.
+	(fs::status): Strip trailing slashes.
+	(fs::symlink_status): Likewise.
+	* testsuite/experimental/filesystem/operations/temp_directory_path.cc:
+	Clean the environment before each test and use TMP instead of
+	TMPDIR so the test passes on Windows.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106162
+	* include/Makefile.am (largefile-config.h): Add
+	stamp-${host_alias} prerequisite.
+	* include/Makefile.in: Regenerate.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/iterators/error_reporting.cc: Use
+	rmdir to remove directories.
+	* testsuite/experimental/filesystem/iterators/error_reporting.cc:
+	Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (counted_iterator::operator++(int)):
+	Add 'constexpr' as per LWG 3643.
+	* testsuite/24_iterators/counted_iterator/lwg3643.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105671
+	* include/std/sstream (basic_stringbuf::_M_high_mark): Add
+	always_inline attribute.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/future (launch): Make operators noexcept.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/ranges_base.h (ranges::size, ranges::empty): Add
+	explicit check for unbounded arrays before using ranges::begin.
+	* testsuite/std/ranges/access/empty.cc: Check handling of unbounded
+	arrays.
+	* testsuite/std/ranges/access/size.cc: Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_automaton.h (_NFA_base::_SizeT): Remove.
+	* include/bits/regex_compiler.h (_Compiler::_IterT): Remove.
+	* include/bits/regex_compiler.tcc: Likewise.
+	* include/bits/regex_scanner.h (_Scanner::_IterT): Remove.
+	* include/bits/regex_scanner.tcc: Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (basic_regex, swap): Add noexcept to
+	non-throwing functions.
+	* include/bits/regex_automaton.h (_State_base, _State)
+	(_NFA_base): Likewise.
+	* include/bits/regex_compiler.h (_Compiler): Likewise.
+	* include/bits/regex_error.h (regex_error::code()): Likewise.
+	* include/bits/regex_scanner.h (_Scanner): Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102447
+	* include/bits/regex_compiler.h (_Compiler::_BracketState): New
+	class.
+	(_Compiler::_BrackeyMatcher): New alias template.
+	(_Compiler::_M_expression_term): Change pair<bool, CharT>
+	parameter to _BracketState. Process first character for
+	ECMAScript syntax as well as POSIX.
+	* include/bits/regex_compiler.tcc
+	(_Compiler::_M_insert_bracket_matcher): Pass _BracketState.
+	(_Compiler::_M_expression_term): Use _BracketState to store
+	state between calls. Improve handling of dashes in ranges.
+	* testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc:
+	Add more tests for ranges containing dashes. Check invalid
+	ranges with character class at the beginning.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_compiler.h (_Compiler::_S_validate): New
+	function.
+	* include/bits/regex_compiler.tcc (_Compiler::_Compiler): Use
+	_S_validate to check flags.
+	* include/bits/regex_error.h (_S_grammar): New error code for
+	internal use.
+	* testsuite/28_regex/basic_regex/ctors/grammar.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_compiler.tcc: Add line break in empty while
+	statement.
+	* include/bits/regex_executor.tcc: Avoid unused parameter
+	warning.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/28_regex/algorithms/regex_replace/char/103664.cc:
+	Add dg-timeout-factor directive.
+	* testsuite/28_regex/basic_regex/84110.cc: Likewise.
+	* testsuite/28_regex/basic_regex/ctors/char/other.cc: Likewise.
+	* testsuite/28_regex/match_results/102667.cc: Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (__detail::__is_contiguous_iter): Move
+	here from <bits/regex_compiler.h>.
+	(basic_regex::_M_compile): New function to compile an NFA from
+	a regular expression string.
+	(basic_regex::basic_regex): Use _M_compile instead of delegating
+	to other constructors.
+	(basic_regex::operator=(const basic_regex&)): Define as
+	defaulted.
+	(basic_regex::operator=(initializer_list<C>)): Use _M_compile.
+	(basic_regex::assign(const basic_regex&)): Use copy assignment.
+	(basic_regex::assign(basic_regex&&)): Use move assignment.
+	(basic_regex::assign(const C*, flag_type)): Use _M_compile
+	instead of constructing a temporary string.
+	(basic_regex::assign(const C*, size_t, flag_type)): Likewise.
+	(basic_regex::assign(const basic_string<C,T,A>&, flag_type)):
+	Use _M_compile instead of constructing a temporary basic_regex.
+	(basic_regex::assign(InputIter, InputIter, flag_type)): Avoid
+	constructing a temporary string for contiguous iterators of the
+	right value type.
+	* include/bits/regex_compiler.h (__is_contiguous_iter): Move to
+	<bits/regex.h>.
+	(__enable_if_contiguous_iter, __disable_if_contiguous_iter)
+	(__compile_nfa): Remove.
+	* testsuite/28_regex/basic_regex/assign/exception_safety.cc: New
+	test.
+	* testsuite/28_regex/basic_regex/ctors/char/other.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103664
+	* include/bits/regex.h (__regex_replace): Declare.
+	(regex_replace): Use it.
+	* include/bits/regex.tcc (__regex_replace): Replace regex_replace
+	definition with __regex_replace.
+	* testsuite/28_regex/algorithms/regex_replace/char/103664.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__detail::__variant::__get_storage):
+	Remove unused function.
+	(__variant_construct_by_index): Set index after construction is
+	complete. Rename to ...
+	(__detail::__variant::__construct_by_index): ... this.
+	(variant): Use new name for __variant_construct_by_index friend
+	declaration. Remove __get_storage friend declaration.
+	(variant::emplace): Use new name and remove try-blocks.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/list.tcc (list::merge): Remove call to size() and
+	try-catch block. Use _Finalize_merge instead.
+	* include/bits/stl_list.h (list::_Finalize_merge): New
+	scope guard type to update _M_size members after a merge.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (basic_regex::multiline): Define for
+	non-strict C++11 and C++14 modes.
+	* include/bits/regex_constants.h (regex_constants::multiline):
+	Add _GLIBCXX_RESOLVE_LIB_DEFECTS comment.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (basic_regex::multiline): Fix #if
+	condition.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (basic_regex::multiline): Define constant
+	for C++17.
+	* include/bits/regex_constants.h (regex_constants::multiline):
+	Define constant for C++17.
+	(regex_constants::__multiline): Define duplicate constant for
+	internal use in C++11 and C++14.
+	* include/bits/regex_executor.h (_Executor::_M_match_multiline()):
+	New member function.
+	(_Executor::_M_is_line_terminator(_CharT)): New member function.
+	(_Executor::_M_at_begin(), _Executor::_M_at_end()): Use new
+	member functions to support multiline matches.
+	* testsuite/28_regex/algorithms/regex_match/multiline.cc: New test.
+
+2022-07-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backported from master:
+	2021-10-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/28_regex/basic_regex/84110.cc (test01)
+	[__cpp_exceptions]: Disambiguate extended.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84110
+	* include/bits/regex_error.h (regex_constants::_S_null): New
+	error code for internal use.
+	* include/bits/regex_scanner.tcc (_Scanner::_M_scan_normal()):
+	Check for null character.
+	* testsuite/28_regex/basic_regex/84110.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (_Variant_storage::_M_storage()): Remove.
+	(__detail::__variant::__get_storage): Remove.
+	(variant): Remove friend declaration of __get_storage.
+
+2022-07-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libstdc++/105128
+	* include/std/source_location (std::source_location::__impl): Move
+	definition before using __builtin_ret_type.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104602
+	* include/std/source_location (source_location::current): Use
+	deduced type of __builtin_source_location().
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (hash<filesystem::path>): Define.
+	* testsuite/27_io/filesystem/path/nonmember/hash_value.cc:
+	Check std::hash specialization.
+
+2022-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/atomic (__atomic_val_t): Use __type_identity_t
+	instead of atomic<T>::value_type, as per LWG 3220.
+	* testsuite/29_atomics/atomic/lwg3220.cc: New test.
+
+2022-06-15  Mark Mentovai  <mark@mentovai.com>
+
+	Backported from master:
+	2022-06-13  Mark Mentovai  <mark@mentovai.com>
+
+	* include/experimental/bits/fs_path.h (__detail::__null_terminated):
+	Rename to __nul_terminated to avoid colliding with a macro in
+	Apple's SDK.
+
+2022-06-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105915
+	* include/experimental/bits/fs_path.h (path::begin, path::end):
+	Remove noexcept from declarations.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2023.xml: Update status.
+	* doc/html/manual/status.html: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/prerequisites.xml: Fix attributes for external
+	hyperlink.
+	* doc/html/manual/setup.html: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Include new chapter.
+	* doc/xml/manual/status_cxx2020.xml: Tweak release numbers.
+	* doc/xml/manual/status_cxx2023.xml: New file.
+	* doc/html/*: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/html/manual/status.html: Regenerate.
+	* doc/xml/manual/status_cxx2020.xml: Fix supported version for
+	C++20 bit operations.
+
+2022-05-13  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-06  Alexandre Oliva  <oliva@adacore.com>
+
+	* include/experimental/bits/simd.h [__ALTIVEC__]: Require VSX
+	for double, long long, and 64-bit long intrinsic types.
+	[__ALTIVEC__] (__intrinsic_type): Mention 128-bit in
+	preexisting long double diagnostic, adjust no-VSX double
+	diagnostic to cover 64-bit long double as well.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-05-02  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/103911
+	* src/c++17/floating_from_chars.cc (find_end_of_float): Accept
+	two delimeters for the exponent part in the form of a possibly
+	NULL string of length two.  Don't use std::tolower.
+	(pattern): Adjust calls to find_end_of_float accordingly.
+
+2022-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105284
+	* include/std/iosfwd: Add declarations for <synstream> class
+	templates and typedefs.
+	* include/std/syncstream (basic_syncbuf, basic_osyncstream):
+	Remove default template arguments.
+	* testsuite/27_io/headers/iosfwd/synopsis.cc: New test.
+	* testsuite/27_io/headers/iosfwd/types.cc: New test.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104217
+	* src/c++17/fs_ops.cc (_GNU_SOURCE): Define.
+	* src/filesystem/dir.cc (_GNU_SOURCE): Define.
+	* src/filesystem/ops.cc (_GNU_SOURCE): Define.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105502
+	* include/bits/random.tcc
+	(operator>>(basic_istream<C,T>&, normal_distribution<R>&)):
+	Update state when __state_avail is false.
+	* testsuite/26_numerics/random/normal_distribution/operators/serialize.cc:
+	Check that deserialized object equals serialized one.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104731
+	* testsuite/27_io/filesystem/iterators/error_reporting.cc:
+	Use a trailing char array as storage for dirent::d_name.
+
+2022-05-06  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	PR c++/105324
+	* testsuite/20_util/from_chars/pr105324.cc: Guard test body
+	with conditional for floating-point overloads of from_char.
+
+2022-04-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99290
+	* src/c++17/fs_ops.cc (fs::copy): Pass error_code to
+	directory_iterator constructor, and check on each iteration.
+	* src/filesystem/ops.cc (fs::copy): Likewise.
+	* testsuite/27_io/filesystem/operations/copy.cc: Check for
+	errors during recursion.
+	* testsuite/experimental/filesystem/operations/copy.cc:
+	Likewise.
+
+2022-04-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105375
+	* include/std/future (packaged_task): Add deduction guides.
+	* testsuite/30_threads/packaged_task/cons/deduction.cc: New test.
+
+2022-04-22  Thomas W Rodgers  <trodgers@redhat.com>
+
+	Backported from master:
+	2022-04-22  Thomas W Rodgers  <trodgers@redhat.com>
+
+	PR libstdc++/102994
+	* include/bits/atomic_base.h (atomic_flag::notify_one,
+	notify_all): Remove const qualification.
+	(__atomic_base::notify_one, notify_all): Likewise.
+	* include/std/atomic (atomic<bool>::notify_one, notify_all):
+	Likewise.
+	(atomic::notify_one, notify_all): Likewise.
+	(atomic<T*>::notify_one, notify_all): Likewise.
+	(atomic_notify_one, atomic_notify_all): Likewise.
+	* testsuite/29_atomics/atomic/wait_notify/102994.cc: Adjust test
+	to account for change in notify_one/notify_all signature.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96592
+	* include/std/tuple (tuple::is_constructible): Remove.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/102177
+	* include/bits/atomic_base.h (__is_valid_cmpexch_failure_order):
+	New function to check if a memory order is valid for the failure
+	case of compare exchange operations.
+	(__atomic_base<I>::compare_exchange_weak): Simplify assertions
+	by using __is_valid_cmpexch_failure_order.
+	(__atomic_base<I>::compare_exchange_strong): Likewise.
+	(__atomic_base<P*>::compare_exchange_weak): Likewise.
+	(__atomic_base<P*>::compare_exchange_strong): Likewise.
+	(__atomic_impl::compare_exchange_weak): Add assertion.
+	(__atomic_impl::compare_exchange_strong): Likewise.
+	* include/std/atomic (atomic::compare_exchange_weak): Likewise.
+	(atomic::compare_exchange_strong): Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/monotonic_buffer_resource/allocate.cc:
+	Ignore -Walloc-larger-than warning.
+	* testsuite/20_util/unsynchronized_pool_resource/allocate.cc:
+	Likewise.
+	* testsuite/29_atomics/atomic/cons/user_pod.cc: Compile with -O1
+	to avoid linker error for __atomic_is_lock_free.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (operator==, operator<=>): Define
+	overloads for homogeneous specializations of reverse_iterator,
+	__normal_iterator and move_iterator.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/24_iterators/move_iterator/dr3265.cc: Fix test to
+	account for LWG 3435 resolution.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101709
+	* src/filesystem/ops-common.h (get_temp_directory_from_env):
+	Add error_code parameter.
+	* src/c++17/fs_ops.cc (fs::temp_directory_path): Pass error_code
+	argument to get_temp_directory_from_env and check it.
+	* src/filesystem/ops.cc (fs::temp_directory_path): Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105324
+	* src/c++17/floating_from_chars.cc (buffer_resource::do_allocate):
+	Remove assertion.
+	* testsuite/20_util/from_chars/pr105324.cc: New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/65018
+	* configure.ac: Check for secure_getenv.
+	* config.h.in: Regenerate.
+	* configure: Regenerate.
+	* src/filesystem/ops-common.h (get_temp_directory_from_env): New
+	helper function to obtain path from the environment.
+	* src/c++17/fs_ops.cc (fs::temp_directory_path): Use new helper.
+	* src/filesystem/ops.cc (fs::temp_directory_path): Likewise.
+	* testsuite/27_io/filesystem/operations/temp_directory_path.cc:
+	Print messages if test cannot be run.
+	* testsuite/experimental/filesystem/operations/temp_directory_path.cc:
+	Likewise. Fix incorrect condition. Use "TMP" to work with
+	Windows as well as POSIX.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++20/sstream-inst.cc (_GLIBCXX_USE_CXX11_ABI): Define to
+	select new ABI.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string/cons/char/moveable.cc: Allow
+	moved-from string to be non-empty.
+	* testsuite/21_strings/basic_string/cons/char/moveable2.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc:
+	Construct empty string before setting oom flag.
+	* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc:
+	Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_compiler.tcc (_Compiler::_M_match_token):
+	Use reserved name for parameter.
+	* testsuite/17_intro/names.cc: Check "token".
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/17_intro/names.cc: Check 'sz'.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/ranges (ranges::lazy_split_view::_InnerIter::end()):
+	Add neoxcept (LWG 3593).
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/internet (address): Use std::_Construct
+	to initialize union members.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/cxx11-ios_failure.cc (io_error_category): Define
+	class and virtual functions as 'final'.
+	(io_category_instance): Use constinit union to make the object
+	immortal.
+	* src/c++11/future.cc (future_error_category): Define class and
+	virtual functions as 'final'.
+	(future_category_instance): Use constinit union.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/span (span(Range&&)): Reorder constraints.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_path.cc (path::_M_split_cmpts()): Remove
+	micro-optimization for "/" path.
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Only access
+	the contents of _M_pathname using const member functions.
+
+2022-04-21  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+
+	Backported from master:
+	2022-01-06  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103853
+	* include/bits/forward_list.tcc (forward_list::merge): Check for
+	self-merge.
+	* testsuite/23_containers/forward_list/operations/merge.cc: New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_construct.h (_Construct, _Construct_novalue):
+	Also cast away cv-qualifiers when converting pointer to void.
+	* testsuite/20_util/allocator/void.cc: Test construct function
+	with cv-qualified types.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103911
+	* include/std/charconv (__from_chars_alpha_to_num): Return
+	char instead of unsigned char. Change invalid return value to
+	127 instead of using numeric trait.
+	(__from_chars_alnum): Fix comment. Do not use std::isdigit.
+	Change type of variable to char.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/ranges_base.h (ranges::advance): Avoid signed
+	overflow. Do nothing if already equal to desired result.
+	* testsuite/24_iterators/range_operations/advance_overflow.cc:
+	New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/ext/rope/pthread7-rope.cc: Add dg-timeout-factor.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-03-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/17_intro/names.cc (func): Undef on AIX.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93602
+	* doc/xml/manual/prerequisites.xml: Document libiconv
+	workarounds.
+	* doc/html/manual/setup.html: Regenerate.
+	* src/Makefile.am (CXXLINK): Add $(LTLIBICONV).
+	* src/Makefile.in: Regenerate.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Fix comment.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc:
+	Check correct feature test macro.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR middle-end/104966
+	* include/bits/locale_facets_nonio.tcc
+	(__moneypunct_cache::_M_cache): Store string sizes in local
+	variable that doesn't escape.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103848
+	* include/bits/stl_deque.h (operator-): Do not use 0 as null
+	pointer constant.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libstdc++-v3/config.h.in b/libstdc++-v3/config.h.in
index 61c342681d4..ea88281f438 100644
--- a/libstdc++-v3/config.h.in
+++ b/libstdc++-v3/config.h.in
@@ -310,6 +310,9 @@
 /* Define if readlink is available in <unistd.h>. */
 #undef HAVE_READLINK
 
+/* Define to 1 if you have the `secure_getenv' function. */
+#undef HAVE_SECURE_GETENV
+
 /* Define to 1 if you have the `setenv' function. */
 #undef HAVE_SETENV
 
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 3120d5855f6..1d5ffd8df11 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -28419,6 +28419,17 @@ if test "x$ac_cv_func__wfopen" = xyes; then :
 #define HAVE__WFOPEN 1
 _ACEOF
 
+fi
+done
+
+  for ac_func in secure_getenv
+do :
+  ac_fn_c_check_func "$LINENO" "secure_getenv" "ac_cv_func_secure_getenv"
+if test "x$ac_cv_func_secure_getenv" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SECURE_GETENV 1
+_ACEOF
+
 fi
 done
 
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index fb256bb0287..4d16b094d7f 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -276,6 +276,7 @@ if $GLIBCXX_IS_NATIVE; then
   AC_CHECK_FUNCS(__cxa_thread_atexit_impl __cxa_thread_atexit)
   AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
   AC_CHECK_FUNCS(_wfopen)
+  AC_CHECK_FUNCS(secure_getenv)
 
   # C11 functions for C++17 library
   AC_CHECK_FUNCS(timespec_get)
diff --git a/libstdc++-v3/doc/html/index.html b/libstdc++-v3/doc/html/index.html
index ed1a05f36f7..b118c214b47 100644
--- a/libstdc++-v3/doc/html/index.html
+++ b/libstdc++-v3/doc/html/index.html
@@ -23,7 +23,7 @@
     </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="book"><a href="manual/index.html">The GNU C++ Library Manual</a></span></dt><dd><dl><dt><span class="part"><a href="manual/intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/support.html">4. 
   Support
diff --git a/libstdc++-v3/doc/html/manual/index.html b/libstdc++-v3/doc/html/manual/index.html
index e34210ee5d9..392e416b954 100644
--- a/libstdc++-v3/doc/html/manual/index.html
+++ b/libstdc++-v3/doc/html/manual/index.html
@@ -4,7 +4,7 @@
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="support.html">4. 
   Support
@@ -145,7 +145,7 @@ Support for C++11 dialect.
 	  </a></dt><dt>21.10. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.3.3.23">Non-unique Mapping Containers</a></dt><dt>21.11. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.4.3.5">Point Iterator Hierarchy</a></dt><dt>21.12. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.4.4.5">Invalidation Guarantee Tags Hierarchy</a></dt><dt>21.13. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.5.7.4">Container Tag Hierarchy</a></dt><dt>21.14. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.3">Hash functions, ranged-hash functions, and
 	      range-hashing functions</a></dt><dt>21.15. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.3.4">Insert hash sequence diagram</a></dt><dt>21.16. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.3.6">Insert hash sequence diagram with a null policy</a></dt><dt>21.17. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.5.5">Hash policy class diagram</a></dt><dt>21.18. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.4.7">Balls and bins</a></dt><dt>21.19. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.6">Insert resize sequence diagram</a></dt><dt>21.20. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.9">Standard resize policy trigger sequence
 		diagram</a></dt><dt>21.21. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.10">Standard resize policy size sequence
-		diagram</a></dt><dt>21.22. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.5">Tree node invariants</a></dt><dt>21.23. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>21.24. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>21.25. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>21.26. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>21.27. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.20">Useless update path</a></dt><dt>21.28. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>21.29. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>21.30. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.3">A simple list</a></dt><dt>21.31. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.6">The counter algorithm</a></dt><dt>21.32. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>21.33. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_features">C++ 2017 Library Features</a></dt><dt>1.6. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.7. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.8. <a href="status.html#table.par2ts_simd_support">Support for Extended ABI Tags</a></dt><dt>1.9. <a href="status.html#table.cxx20_features">C++ 2020 Library Features</a></dt><dt>1.10. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.11. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.12. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx98_deprheaders">C++ 1998 Deprecated Library Header</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.6. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.7. <a href="using_headers.html#table.cxx14_headers">C++ 2014 Library Header</a></dt><dt>3.8. <a href="using_headers.html#table.cxx17_headers">C++ 2017 Library Headers</a></dt><dt>3.9. <a href="using_headers.html#table.cxx20_headers">C++ 2020 Library Headers</a></dt><dt>3.10. <a href="using_headers.html#table.cxx20_deprheaders">C++ 2020 Obsolete Headers</a></dt><dt>3.11. <a href="using_headers.html#table.filesystemts_headers">File System TS Header</a></dt><dt>3.12. <a href="using_headers.html#table.libfundts_headers">Library Fundamentals TS Headers</a></dt><dt>3.13. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.14. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.15. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.16. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.17. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.18. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.19. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>20.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>21.1. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>21.2. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>21.3. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>21.4. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>21.5. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.7">
+		diagram</a></dt><dt>21.22. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.5">Tree node invariants</a></dt><dt>21.23. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>21.24. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>21.25. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>21.26. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>21.27. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.20">Useless update path</a></dt><dt>21.28. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>21.29. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>21.30. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.3">A simple list</a></dt><dt>21.31. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.6">The counter algorithm</a></dt><dt>21.32. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>21.33. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_features">C++ 2017 Library Features</a></dt><dt>1.6. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.7. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.8. <a href="status.html#table.par2ts_simd_support">Support for Extended ABI Tags</a></dt><dt>1.9. <a href="status.html#table.cxx20_features">C++ 2020 Library Features</a></dt><dt>1.10. <a href="status.html#table.cxx23_features">C++ 2023 Library Features</a></dt><dt>1.11. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.12. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.13. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx98_deprheaders">C++ 1998 Deprecated Library Header</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.6. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.7. <a href="using_headers.html#table.cxx14_headers">C++ 2014 Library Header</a></dt><dt>3.8. <a href="using_headers.html#table.cxx17_headers">C++ 2017 Library Headers</a></dt><dt>3.9. <a href="using_headers.html#table.cxx20_headers">C++ 2020 Library Headers</a></dt><dt>3.10. <a href="using_headers.html#table.cxx20_deprheaders">C++ 2020 Obsolete Headers</a></dt><dt>3.11. <a href="using_headers.html#table.filesystemts_headers">File System TS Header</a></dt><dt>3.12. <a href="using_headers.html#table.libfundts_headers">Library Fundamentals TS Headers</a></dt><dt>3.13. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.14. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.15. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.16. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.17. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.18. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.19. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>20.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>21.1. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>21.2. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>21.3. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>21.4. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>21.5. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.7">
 		A Standard String Hash Function
 	      </a></dt><dt>21.6. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.12">
 		Only k String DNA Hash
diff --git a/libstdc++-v3/doc/html/manual/intro.html b/libstdc++-v3/doc/html/manual/intro.html
index 3604e0a1d45..1a8234437d9 100644
--- a/libstdc++-v3/doc/html/manual/intro.html
+++ b/libstdc++-v3/doc/html/manual/intro.html
@@ -5,4 +5,4 @@
 </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.intro"></a>Part I. 
   Introduction
   <a id="id-1.3.3.1.1.1" class="indexterm"></a>
-</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
+</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/setup.html b/libstdc++-v3/doc/html/manual/setup.html
index 636a4401602..f27b8d806df 100644
--- a/libstdc++-v3/doc/html/manual/setup.html
+++ b/libstdc++-v3/doc/html/manual/setup.html
@@ -42,6 +42,39 @@
    </p><p>
    Finally, a few system-specific requirements:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">linux</span></dt><dd><p>
+	  The 'gnu' locale model makes use of <code class="function">iconv</code>
+	  for character set conversions. The relevant functions are provided
+	  by Glibc and so are always available, however they can also be
+	  provided by the separate GNU libiconv library. If GNU libiconv is
+	  found when GCC is built (e.g., because its headers are installed
+	  in <code class="filename">/usr/local/include</code>)
+	  then the <code class="filename">libstdc++.so.6</code> library will have a
+	  run-time dependency on <code class="filename">libiconv.so.2</code>.
+	  If you do not want that run-time dependency then you should do
+	  one of the following:
+	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
+	      Uninstall the libiconv headers before building GCC.
+	      Glibc already provides <code class="function">iconv</code> so you should
+	      not need libiconv anyway.
+	    </p></li><li class="listitem"><p>
+	    <a class="link" href="https://www.gnu.org/software/libiconv/#downloading" target="_top">
+	    Download</a> the libiconv sources and extract them into the
+	    top level of the GCC source tree, e.g.,
+	    </p><pre class="programlisting">
+wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz
+tar xf libiconv-1.16.tar.gz
+ln -s libiconv-1.16 libiconv
+</pre><p>
+	      This will build libiconv as part of building GCC and link to
+	      it statically, so there is no <code class="filename">libiconv.so.2</code>
+	      dependency.
+	    </p></li><li class="listitem"><p>
+	      Configure GCC with <code class="option">--with-libiconv-type=static</code>.
+	      This requires the static <code class="filename">libiconv.a</code> library,
+	      which is not installed by default. You might need to reinstall
+	      libiconv using the <code class="option">--enable-static</code> configure
+	      option to get the static library.
+	    </p></li></ul></div><p>
 	  If GCC 3.1.0 or later on is being used on GNU/Linux, an attempt
 	  will be made to use "C" library functionality necessary for
 	  C++ named locale support.  For GCC 4.6.0 and later, this
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index 25c676d2892..3805e9e24f0 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -2,7 +2,7 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 1. Status</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="intro.html" title="Part I.  Introduction" /><link rel="prev" href="intro.html" title="Part I.  Introduction" /><link rel="next" href="license.html" title="License" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 1. Status</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="intro.html">Prev</a> </td><th width="60%" align="center">Part I. 
   Introduction
   
-</th><td width="20%" align="right"> <a accesskey="n" href="license.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.status"></a>Chapter 1. Status</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.iso"></a>Implementation Status</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.1998"></a>C++ 1998/2003</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.1998.status"></a>Implementation Status</h4></div></div></div><p>
+</th><td width="20%" align="right"> <a accesskey="n" href="license.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.status"></a>Chapter 1. Status</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.iso"></a>Implementation Status</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.1998"></a>C++ 1998/2003</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.1998.status"></a>Implementation Status</h4></div></div></div><p>
 This status table is based on the table of contents of ISO/IEC 14882:2003.
 </p><p>
 This section describes the C++ support in the GCC 11 release series.
@@ -1242,8 +1242,8 @@ presence of the required flag.
 This section describes the C++20 and library TS support in the GCC 11
 release series.
 </p><p>
-The following table lists new library features that have been accepted into
-the C++20 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++20 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -1344,10 +1344,10 @@ or any notes about the implementation.
       </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_atomic_float &gt;= 201711L</code> </td></tr><tr><td align="left">  C++ Synchronized Buffered Ostream </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0053r7.pdf" target="_top">
         P0053R7 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201711L</code> </td></tr><tr><td align="left">  Manipulators for C++ Synchronized Buffered Ostream </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201711L</code> </td></tr><tr><td align="left">  Manipulators for C++ Synchronized Buffered Ostream </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0753r2.pdf" target="_top">
         P0753R2 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201803L</code> </td></tr><tr><td align="left">  Make <code class="code">std::memory_order</code> a scoped enumeration </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201803L</code> </td></tr><tr><td align="left">  Make <code class="code">std::memory_order</code> a scoped enumeration </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0439r0.html" target="_top">
         P0439R0 </a>
       </td><td align="center"> 9.1 </td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">  The Curious Case of Padding Bits, Featuring Atomic Compare-and-Exchange </td><td align="left">
@@ -1428,7 +1428,7 @@ or any notes about the implementation.
       </td></tr><tr><td align="left">  <code class="code">string::reserve</code> Should Not Shrink </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0966r1.html" target="_top">
         P0966R1 </a>
-      </td><td align="center"> 11 </td><td align="left"> </td></tr><tr><td align="left">  <code class="code">char8_t</code>: A type for UTF-8 characters and strings </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left">  <code class="code">char8_t</code>: A type for UTF-8 characters and strings </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0482r6.html" target="_top">
         P0482R6 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_char8_t &gt;= 201811L</code> </td></tr><tr><td align="left">  <code class="code">char8_t</code> backward compatibility remediation </td><td align="left">
@@ -1555,7 +1555,7 @@ or any notes about the implementation.
       </td><td align="center"> </td><td align="left"> </td></tr><tr><td align="left">  Bit-casting object representations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0476r2.html" target="_top">
         P0476R2 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_bit_cast &gt;= 201806L</code> </td></tr><tr><td align="left">  Integral power-of-2 operations </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_bit_cast &gt;= 201806L</code> </td></tr><tr><td align="left">  Integral power-of-2 operations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0556r3.html" target="_top">
         P0556R3 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_int_pow2 &gt;= 201806L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left"> On the names of low-level bit manipulation functions </td><td align="left">
@@ -1675,7 +1675,7 @@ or any notes about the implementation.
       </td><td align="center"> 8.1 </td><td align="left"> <code class="code">__cpp_lib_endian &gt;= 201907L</code> </td></tr><tr><td align="left"> Bit operations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html" target="_top">
         P0553R4 </a>
-      </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left">  Well-behaved interpolation for numbers and pointers </td><td align="left">
+      </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left">  Well-behaved interpolation for numbers and pointers </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0811r3.html" target="_top">
         P0811R3 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_interpolate &gt;= 201902L</code> </td></tr><tr><td align="left"> Mathematical constants </td><td align="left">
@@ -1684,16 +1684,105 @@ or any notes about the implementation.
       </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_math_constants &gt;= 201907L</code> </td></tr><tr><td align="left"> std::source_location </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1208r6.pdf" target="_top">
         P1208R6 </a>
-      </td><td align="center"> 11 </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left">
         <code class="code">__cpp_lib_source_location &gt;= 201907L</code>
       </td></tr><tr><td align="left"> Efficient access to std::basic_stringbuf's Buffer </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf" target="_top">
         P0408R7 </a>
-      </td><td align="center"> 11 </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
 Note 1: This feature is supported in older releases but the
 <code class="code">__cpp_lib</code> macro is not defined to the right value
 (or not defined at all) until the version shown in parentheses.
-</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.tr1"></a>C++ TR1</h3></div></div></div><p>
+</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.2023"></a>C++ 2023</h3></div></div></div><p>
+In this implementation the <code class="literal">-std=gnu++23</code> or
+<code class="literal">-std=c++23</code> flag must be used to enable language
+and library
+features. See <a class="link" href="using.html#manual.intro.using.flags" title="Command Options">dialect</a>
+options. The pre-defined symbol
+<code class="constant">__cplusplus</code> is used to check for the
+presence of the required flag.
+</p><p>
+This section describes the C++23 and library TS support in mainline GCC,
+not in any particular release.
+</p><p>
+The following table lists new library features that have been accepted into
+the C++23 working draft. The "Proposal" column provides a link to the
+ISO C++ committee proposal that describes the feature, while the "Status"
+column indicates the first version of GCC that contains an implementation of
+this feature (if it has been implemented).
+A dash (—) in the status column indicates that the changes in the proposal
+either do not affect the code in libstdc++, or the changes are not required for conformance.
+The "SD-6 Feature Test / Notes" column shows the corresponding macro or header from
+<a class="link" href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations" target="_top">SD-6:
+Feature-testing recommendations for C++</a> (where applicable)
+or any notes about the implementation.
+</p><div class="table"><a id="table.cxx23_features"></a><p class="title"><strong>Table 1.10. C++ 2023 Library Features</strong></p><div class="table-contents"><table class="table" summary="C++ 2023 Library Features" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Library Feature</th><th align="left">Proposal</th><th align="left">Status</th><th align="left">SD-6 Feature Test / Notes</th></tr></thead><tbody><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Ranges and Views</strong></span>
+      </td></tr><tr><td align="left"> Range constructor for std::string_view </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf" target="_top">
+        P1989R2
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> <code class="code">join_view</code> should join all views of ranges </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r1.html" target="_top">
+        P2328R1
+        </a>
+      </td><td align="center"> 11.2 </td><td align="left"> </td></tr><tr><td align="left"> Clarifying range adaptor objects </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2281r1.html" target="_top">
+        P2281R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> Views should not be required to be default constructible </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html" target="_top">
+        P2325R3
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> <code class="code">__cpp_lib_ranges &gt;= 202106L</code> </td></tr><tr><td align="left"> Conditionally borrowed ranges </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2017r1.html" target="_top">
+        P2017R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> Require <code class="code">span</code> &amp; <code class="code">basic_string_view</code> to be Trivially Copyable </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf" target="_top">
+        P2251R1
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Compile-time programming</strong></span>
+      </td></tr><tr><td align="left"> A proposal for a type trait to detect scoped enumerations </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1048r1.pdf" target="_top">
+        P1048R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_is_scoped_enum &gt;= 202011L</code> </td></tr><tr><td align="left"> std::to_underlying for enumerations </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r3.html" target="_top">
+        P1682R3
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_to_underlying &gt;= 202102L</code> </td></tr><tr bgcolor="#B0B0B0"><td align="left"> Missing constexpr in std::optional and std::variant </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html" target="_top">
+        P2231R1
+        </a>
+      </td><td align="center"> 11.3 (<code class="code">optional</code> only) </td><td align="left">
+	<div class="informaltable"><table class="informaltable" border="0"><colgroup><col /></colgroup><tbody><tr><td> <code class="code">__cpp_lib_constexpr_optional &gt;= 202106L</code> </td></tr><tr><td> <code class="code">__cpp_lib_variant &gt;= 202106L</code> </td></tr></tbody></table></div>
+      </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Strings and text</strong></span>
+      </td></tr><tr><td align="left"> string contains function </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r3.html" target="_top">
+        P1679R3
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_string_contains &gt;= 202011L</code> </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Miscellaneous</strong></span>
+      </td></tr><tr><td align="left"> Inheriting from <code class="code">std::variant</code> </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2162r2.html" target="_top">
+        P2162R2
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> <code class="code">__cpp_lib_variant &gt;= 202102L</code> </td></tr><tr><td align="left"> Printing <code class="code">volatile</code> Pointers </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1147r1.html" target="_top">
+        P1147R1
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> </td></tr><tr><td align="left"> Clarifying the status of the "C headers" </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r1.html" target="_top">
+        P2340R1
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr><tr><td align="left"> Relax Requirements for time_point::clock </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html" target="_top">
+        P2212R2
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.tr1"></a>C++ TR1</h3></div></div></div><p>
 This table is based on the table of contents of ISO/IEC DTR 19768
 Doc No: N1836=05-0096 Date: 2005-06-24
 Draft Technical Report on C++ Library Extensions
@@ -1703,7 +1792,7 @@ In this implementation the header names are prefixed by
 <code class="code">&lt;tr1/memory&gt;</code>, and so on.
 </p><p>
 This page describes the TR1 support in the GCC 11 release series.
-</p><div class="table"><a id="table.tr1_status"></a><p class="title"><strong>Table 1.10. C++ TR1 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR1 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left"><span class="emphasis"><em>2</em></span></td><td colspan="3" align="left"><span class="emphasis"><em>General Utilities</em></span></td></tr><tr><td align="left">2.1</td><td align="left">Reference wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.1</td><td align="left">Additions to header <code class="code">&lt;functional&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.2.1</td><td align="left"><code class="code">reference_wrapper</code> construct/copy/destroy</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.2</td><td align="left"><code class="code">reference_wrapper</code> assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.3</td><td align="left"><code class="code">reference_wrapper</code> access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.4</td><td align="left"><code class="code">reference_wrapper</code> invocation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.5</td><td align="left"><code class="code">reference_wrapper</code> helper functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.2.1</td><td align="left">Additions to header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.2</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.3</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left"> </td><td align="left">
+</p><div class="table"><a id="table.tr1_status"></a><p class="title"><strong>Table 1.11. C++ TR1 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR1 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left"><span class="emphasis"><em>2</em></span></td><td colspan="3" align="left"><span class="emphasis"><em>General Utilities</em></span></td></tr><tr><td align="left">2.1</td><td align="left">Reference wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.1</td><td align="left">Additions to header <code class="code">&lt;functional&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.2.1</td><td align="left"><code class="code">reference_wrapper</code> construct/copy/destroy</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.2</td><td align="left"><code class="code">reference_wrapper</code> assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.3</td><td align="left"><code class="code">reference_wrapper</code> access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.4</td><td align="left"><code class="code">reference_wrapper</code> invocation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.5</td><td align="left"><code class="code">reference_wrapper</code> helper functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.2.1</td><td align="left">Additions to header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.2</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.3</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left"> </td><td align="left">
 	<p>
 	  Uses code from
 	  <a class="link" href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm" target="_top">boost::shared_ptr</a>.
@@ -1723,7 +1812,7 @@ Extension for the programming language C++ to support
 decimal floating-point arithmetic
 </p><p>
 This page describes the TR 24733 support in the GCC 11 release series.
-</p><div class="table"><a id="table.decfp_status"></a><p class="title"><strong>Table 1.11. C++ TR 24733 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
+</p><div class="table"><a id="table.decfp_status"></a><p class="title"><strong>Table 1.12. C++ TR 24733 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<span class="emphasis"><em>0</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Introduction</em></span>
@@ -1763,7 +1852,7 @@ non-strict modes (i.e. <code class="code">-std=gnu++NN</code> modes) the
 hypergeometric functions and confluent hypergeometric functions
 from TR1 are also provided, defined in namespace
 <code class="code">__gnu_cxx</code>.
-</p><div class="table"><a id="table.specfun_status"></a><p class="title"><strong>Table 1.12. C++ Special Functions Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ Special Functions Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr bgcolor="#B0B0B0"><td align="left">7</td><td align="left">Macro names</td><td align="left">Partial</td><td align="left">No diagnostic for inconsistent definitions of
+</p><div class="table"><a id="table.specfun_status"></a><p class="title"><strong>Table 1.13. C++ Special Functions Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ Special Functions Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr bgcolor="#B0B0B0"><td align="left">7</td><td align="left">Macro names</td><td align="left">Partial</td><td align="left">No diagnostic for inconsistent definitions of
              <code class="code">__STDCPP_WANT_MATH_SPEC_FUNCS__</code></td></tr><tr><td align="left">8</td><td align="left">Mathematical special functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1</td><td align="left">Additions to header <code class="code">&lt;cmath&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.1</td><td align="left">associated Laguerre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.2</td><td align="left">associated Legendre functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.3</td><td align="left">beta function</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.4</td><td align="left">(complete) elliptic integral of the first kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.5</td><td align="left">(complete) elliptic integral of the second kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.6</td><td align="left">(complete) elliptic integral of the third kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.7</td><td align="left">regular modified cylindrical Bessel functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.8</td><td align="left">cylindrical Bessel functions (of the first kind)</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.9</td><td align="left">irregular modified cylindrical Bessel functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.10</td><td align="left">cylindrical Neumann functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.11</td><td align="left">(incomplete) elliptic integral of the first kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.12</td><td align="left">(incomplete) elliptic integral of the second kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.13</td><td align="left">(incomplete) elliptic integral of the third kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.14</td><td align="left">exponential integral</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.15</td><td align="left">Hermite polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.16</td><td align="left">Laguerre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.17</td><td align="left">Legendre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.18</td><td align="left">Riemann zeta function</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.19</td><td align="left">spherical Bessel functions (of the first kind)</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.20</td><td align="left">spherical associated Legendre functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.21</td><td align="left">spherical Neumann functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.2</td><td align="left">Additions to header <code class="code">&lt;math.h&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">8.3</td><td align="left">The header <code class="code">&lt;ctgmath&gt;</code></td><td align="left">Partial</td><td align="left">Conflicts with C++ 2011 requirements.</td></tr><tr bgcolor="#C8B0B0"><td align="left">8.4</td><td align="left">The header <code class="code">&lt;tgmath.h&gt;</code></td><td align="left">N</td><td align="left">Conflicts with C++ 2011 requirements.</td></tr></tbody></table></div></div><br class="table-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.specfun.specific"></a>Implementation Specific Behavior</h4></div></div></div><p>For behaviour which is specified by the 2011 standard,
       see <a class="link" href="status.html#iso.2011.specific" title="Implementation Specific Behavior">C++ 2011 Implementation
       Specific Behavior</a>. This section documents behaviour which
diff --git a/libstdc++-v3/doc/xml/manual/intro.xml b/libstdc++-v3/doc/xml/manual/intro.xml
index 3e7843f58c1..62cab81651e 100644
--- a/libstdc++-v3/doc/xml/manual/intro.xml
+++ b/libstdc++-v3/doc/xml/manual/intro.xml
@@ -47,15 +47,19 @@
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxx2020.xml">
     </xi:include>
 
-    <!-- Section 01.5 : Status C++ TR1 -->
+    <!-- Section 01.5 : Status C++ 2023 -->
+    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxx2023.xml">
+    </xi:include>
+
+    <!-- Section 01.6 : Status C++ TR1 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxtr1.xml">
     </xi:include>
 
-    <!-- Section 01.6 : Status C++ TR24733 -->
+    <!-- Section 01.7 : Status C++ TR24733 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxtr24733.xml">
     </xi:include>
 
-    <!-- Section 01.7 : Status C++ IS 24733 -->
+    <!-- Section 01.8 : Status C++ IS 29124 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxis29124.xml">
     </xi:include>
   </section>
diff --git a/libstdc++-v3/doc/xml/manual/prerequisites.xml b/libstdc++-v3/doc/xml/manual/prerequisites.xml
index 22e90a7e79d..f00979a1afa 100644
--- a/libstdc++-v3/doc/xml/manual/prerequisites.xml
+++ b/libstdc++-v3/doc/xml/manual/prerequisites.xml
@@ -48,6 +48,57 @@
       <varlistentry>
 	<term>linux</term>
 
+	<listitem>
+	<para>
+	  The 'gnu' locale model makes use of <function>iconv</function>
+	  for character set conversions. The relevant functions are provided
+	  by Glibc and so are always available, however they can also be
+	  provided by the separate GNU libiconv library. If GNU libiconv is
+	  found when GCC is built (e.g., because its headers are installed
+	  in <filename class="directory">/usr/local/include</filename>)
+	  then the <filename>libstdc++.so.6</filename> library will have a
+	  run-time dependency on <filename>libiconv.so.2</filename>.
+	  If you do not want that run-time dependency then you should do
+	  one of the following:
+	</para>
+	<itemizedlist>
+	  <listitem>
+	    <para>
+	      Uninstall the libiconv headers before building GCC.
+	      Glibc already provides <function>iconv</function> so you should
+	      not need libiconv anyway.
+	    </para>
+	  </listitem>
+	  <listitem>
+	    <para>
+	    <link xmlns:xlink="http://www.w3.org/1999/xlink"
+	      xlink:href="https://www.gnu.org/software/libiconv/#downloading">
+	    Download</link> the libiconv sources and extract them into the
+	    top level of the GCC source tree, e.g.,
+	    </para>
+<programlisting>
+wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz
+tar xf libiconv-1.16.tar.gz
+ln -s libiconv-1.16 libiconv
+</programlisting>
+	    <para>
+	      This will build libiconv as part of building GCC and link to
+	      it statically, so there is no <filename>libiconv.so.2</filename>
+	      dependency.
+	    </para>
+	  </listitem>
+	  <listitem>
+	    <para>
+	      Configure GCC with <option>--with-libiconv-type=static</option>.
+	      This requires the static <filename>libiconv.a</filename> library,
+	      which is not installed by default. You might need to reinstall
+	      libiconv using the <option>--enable-static</option> configure
+	      option to get the static library.
+	    </para>
+	  </listitem>
+	</itemizedlist>
+	</listitem>
+
 	<listitem>
 	<para>
 	  If GCC 3.1.0 or later on is being used on GNU/Linux, an attempt
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
index 411a337c534..67aac7d64b8 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
@@ -25,8 +25,8 @@ release series.
 </para>
 
 <para>
-The following table lists new library features that have been accepted into
-the C++20 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++20 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -362,7 +362,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0053r7.pdf">
         P0053R7 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_syncbuf &gt;= 201711L</code> </entry>
     </row>
 
@@ -372,7 +372,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0753r2.pdf">
         P0753R2 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_syncbuf &gt;= 201803L</code> </entry>
     </row>
 
@@ -647,7 +647,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0966r1.html">
         P0966R1 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry />
     </row>
 
@@ -1045,7 +1045,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0476r2.html">
         P0476R2 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_bit_cast &gt;= 201806L</code> </entry>
     </row>
 
@@ -1401,7 +1401,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html">
         P0553R4 </link>
       </entry>
-      <entry align="center"> 10.1 </entry>
+      <entry align="center"> 9.1 </entry>
       <entry> <code>__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </entry>
     </row>
 
@@ -1431,7 +1431,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1208r6.pdf">
         P1208R6 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry>
         <code>__cpp_lib_source_location &gt;= 201907L</code>
       </entry>
@@ -1443,7 +1443,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">
         P0408R7 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry />
     </row>
 
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2023.xml b/libstdc++-v3/doc/xml/manual/status_cxx2023.xml
new file mode 100644
index 00000000000..75f31f55aa9
--- /dev/null
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2023.xml
@@ -0,0 +1,249 @@
+<section xmlns="http://docbook.org/ns/docbook" version="5.0"
+   xml:id="status.iso.2023" xreflabel="Status C++ 2023">
+<?dbhtml filename="status_iso_cxx2023.html"?>
+
+<info><title>C++ 2023</title>
+  <keywordset>
+    <keyword>ISO C++</keyword>
+    <keyword>2023</keyword>
+  </keywordset>
+</info>
+
+<para>
+In this implementation the <literal>-std=gnu++23</literal> or
+<literal>-std=c++23</literal> flag must be used to enable language
+and library
+features. See <link linkend="manual.intro.using.flags">dialect</link>
+options. The pre-defined symbol
+<constant>__cplusplus</constant> is used to check for the
+presence of the required flag.
+</para>
+
+<para>
+This section describes the C++23 and library TS support in mainline GCC,
+not in any particular release.
+</para>
+
+<para>
+The following table lists new library features that have been accepted into
+the C++23 working draft. The "Proposal" column provides a link to the
+ISO C++ committee proposal that describes the feature, while the "Status"
+column indicates the first version of GCC that contains an implementation of
+this feature (if it has been implemented).
+A dash (&#x2014;) in the status column indicates that the changes in the proposal
+either do not affect the code in libstdc++, or the changes are not required for conformance.
+The "SD-6 Feature Test / Notes" column shows the corresponding macro or header from
+<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">SD-6:
+Feature-testing recommendations for C++</link> (where applicable)
+or any notes about the implementation.
+</para>
+
+<table frame="all" xml:id="table.cxx23_features">
+<title>C++ 2023 Library Features</title>
+
+<tgroup cols="4" align="left" colsep="0" rowsep="1">
+<colspec colname="c1"/>
+<colspec colname="c2"/>
+<colspec colname="c3"/>
+<colspec colname="c4"/>
+  <thead>
+    <row>
+      <entry>Library Feature</entry>
+      <entry>Proposal</entry>
+      <entry>Status</entry>
+      <entry>SD-6 Feature Test / Notes</entry>
+    </row>
+  </thead>
+
+  <tbody>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Ranges and Views</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> Range constructor for std::string_view </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf">
+        P1989R2
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> <code>join_view</code> should join all views of ranges </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r1.html">
+        P2328R1
+        </link>
+      </entry>
+      <entry align="center"> 11.2 </entry>
+      <entry />
+    </row>
+
+
+    <row>
+      <entry> Clarifying range adaptor objects </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2281r1.html">
+        P2281R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Views should not be required to be default constructible </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html">
+        P2325R3
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry> <code>__cpp_lib_ranges &gt;= 202106L</code> </entry>
+    </row>
+
+    <row>
+      <entry> Conditionally borrowed ranges </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2017r1.html">
+        P2017R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Require <code>span</code> &amp; <code>basic_string_view</code> to be Trivially Copyable </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf">
+        P2251R1
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Compile-time programming</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> A proposal for a type trait to detect scoped enumerations </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1048r1.pdf">
+        P1048R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_is_scoped_enum &gt;= 202011L</code> </entry>
+    </row>
+
+    <row>
+      <entry> std::to_underlying for enumerations </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r3.html">
+        P1682R3
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_to_underlying &gt;= 202102L</code> </entry>
+    </row>
+
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry> Missing constexpr in std::optional and std::variant </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html">
+        P2231R1
+        </link>
+      </entry>
+      <entry align="center"> 11.3 (<code>optional</code> only) </entry>
+      <entry>
+	<informaltable colsep="0" rowsep="0" rowheader="norowheader" frame="none"><tgroup cols="1"><tbody>
+        <row><entry> <code>__cpp_lib_constexpr_optional &gt;= 202106L</code> </entry></row>
+        <row><entry> <code>__cpp_lib_variant &gt;= 202106L</code> </entry></row>
+        </tbody></tgroup></informaltable>
+      </entry>
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Strings and text</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> string contains function </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r3.html">
+        P1679R3
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_string_contains &gt;= 202011L</code> </entry>
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Miscellaneous</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> Inheriting from <code>std::variant</code> </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2162r2.html">
+        P2162R2
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry> <code>__cpp_lib_variant &gt;= 202102L</code> </entry>
+    </row>
+
+    <row>
+      <entry> Printing <code>volatile</code> Pointers </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1147r1.html">
+        P1147R1
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Clarifying the status of the "C headers" </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r1.html">
+        P2340R1
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Relax Requirements for time_point::clock </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html">
+        P2212R2
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+  </tbody>
+</tgroup>
+</table>
+
+</section>
diff --git a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
index 174fafeee5e..16ea5ffef52 100644
--- a/libstdc++-v3/include/Makefile.am
+++ b/libstdc++-v3/include/Makefile.am
@@ -1275,7 +1275,7 @@ stamp-float128:
 endif
 
 # This header is not installed, it's only used to build libstdc++ itself.
-${host_builddir}/largefile-config.h: ${CONFIG_HEADER}
+${host_builddir}/largefile-config.h: ${CONFIG_HEADER} stamp-${host_alias}
 	@rm -f $@.tmp
 	@-grep 'define _DARWIN_USE_64_BIT_INODE' ${CONFIG_HEADER} >> $@.tmp
 	@-grep 'define _FILE_OFFSET_BITS' ${CONFIG_HEADER} >> $@.tmp
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index 814b0a43b3d..877133d8165 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -1761,7 +1761,7 @@ stamp-host: ${host_headers} ${bits_host_headers} ${ext_host_headers} ${host_head
 @ENABLE_FLOAT128_FALSE@	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
 
 # This header is not installed, it's only used to build libstdc++ itself.
-${host_builddir}/largefile-config.h: ${CONFIG_HEADER}
+${host_builddir}/largefile-config.h: ${CONFIG_HEADER} stamp-${host_alias}
 	@rm -f $@.tmp
 	@-grep 'define _DARWIN_USE_64_BIT_INODE' ${CONFIG_HEADER} >> $@.tmp
 	@-grep 'define _FILE_OFFSET_BITS' ${CONFIG_HEADER} >> $@.tmp
diff --git a/libstdc++-v3/include/bits/atomic_base.h b/libstdc++-v3/include/bits/atomic_base.h
index 60b976bf8d1..2abdc400260 100644
--- a/libstdc++-v3/include/bits/atomic_base.h
+++ b/libstdc++-v3/include/bits/atomic_base.h
@@ -121,6 +121,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       | __memory_order_modifier(__m & __memory_order_modifier_mask));
   }
 
+  constexpr bool
+  __is_valid_cmpexch_failure_order(memory_order __m) noexcept
+  {
+    return (__m & __memory_order_mask) != memory_order_release
+	&& (__m & __memory_order_mask) != memory_order_acq_rel;
+  }
+
   _GLIBCXX_ALWAYS_INLINE void
   atomic_thread_fence(memory_order __m) noexcept
   { __atomic_thread_fence(int(__m)); }
@@ -245,13 +252,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     _GLIBCXX_ALWAYS_INLINE void
-    notify_one() const noexcept
+    notify_one() noexcept
     { std::__atomic_notify_address(&_M_i, false); }
 
     // TODO add const volatile overload
 
     _GLIBCXX_ALWAYS_INLINE void
-    notify_all() const noexcept
+    notify_all() noexcept
     { std::__atomic_notify_address(&_M_i, true); }
 
     // TODO add const volatile overload
@@ -511,13 +518,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(__int_type& __i1, __int_type __i2,
 			    memory_order __m1, memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
 					   int(__m1), int(__m2));
@@ -528,13 +529,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			    memory_order __m1,
 			    memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
 					   int(__m1), int(__m2));
@@ -560,13 +555,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(__int_type& __i1, __int_type __i2,
 			      memory_order __m1, memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
 					   int(__m1), int(__m2));
@@ -577,14 +566,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
 					   int(__m1), int(__m2));
@@ -618,13 +600,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // TODO add const volatile overload
 
       _GLIBCXX_ALWAYS_INLINE void
-      notify_one() const noexcept
+      notify_one() noexcept
       { std::__atomic_notify_address(&_M_i, false); }
 
       // TODO add const volatile overload
 
       _GLIBCXX_ALWAYS_INLINE void
-      notify_all() const noexcept
+      notify_all() noexcept
       { std::__atomic_notify_address(&_M_i, true); }
 
       // TODO add const volatile overload
@@ -869,13 +851,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
 					   int(__m1), int(__m2));
@@ -886,14 +862,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
 					   int(__m1), int(__m2));
@@ -996,6 +965,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			    _Val<_Tp> __desired, memory_order __success,
 			    memory_order __failure) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));
+
 	return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
 					 std::__addressof(__desired), true,
 					 int(__success), int(__failure));
@@ -1007,6 +978,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      _Val<_Tp> __desired, memory_order __success,
 			      memory_order __failure) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));
+
 	return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
 					 std::__addressof(__desired), false,
 					 int(__success), int(__failure));
diff --git a/libstdc++-v3/include/bits/atomic_wait.h b/libstdc++-v3/include/bits/atomic_wait.h
index 394f666d02e..571a0dd08ef 100644
--- a/libstdc++-v3/include/bits/atomic_wait.h
+++ b/libstdc++-v3/include/bits/atomic_wait.h
@@ -142,8 +142,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
     }
 
-    constexpr auto __atomic_spin_count_1 = 12;
-    constexpr auto __atomic_spin_count_2 = 4;
+    constexpr auto __atomic_spin_count_relax = 12;
+    constexpr auto __atomic_spin_count = 16;
 
     struct __default_spin_policy
     {
@@ -157,18 +157,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool
       __atomic_spin(_Pred& __pred, _Spin __spin = _Spin{ }) noexcept
       {
-	for (auto __i = 0; __i < __atomic_spin_count_1; ++__i)
+	for (auto __i = 0; __i < __atomic_spin_count; ++__i)
 	  {
 	    if (__pred())
 	      return true;
-	    __detail::__thread_relax();
-	  }
 
-	for (auto __i = 0; __i < __atomic_spin_count_2; ++__i)
-	  {
-	    if (__pred())
-	      return true;
-	    __detail::__thread_yield();
+	    if (__i < __atomic_spin_count_relax)
+	      __detail::__thread_relax();
+	    else
+	      __detail::__thread_yield();
 	  }
 
 	while (__spin())
diff --git a/libstdc++-v3/include/bits/forward_list.tcc b/libstdc++-v3/include/bits/forward_list.tcc
index bd7a859091f..1145230b910 100644
--- a/libstdc++-v3/include/bits/forward_list.tcc
+++ b/libstdc++-v3/include/bits/forward_list.tcc
@@ -367,6 +367,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       forward_list<_Tp, _Alloc>::
       merge(forward_list&& __list, _Comp __comp)
       {
+	// _GLIBCXX_RESOLVE_LIB_DEFECTS
+	// 3088. forward_list::merge behavior unclear when passed *this
+	if (std::__addressof(__list) == this)
+	  return;
+
 	_Node_base* __node = &this->_M_impl._M_head;
 	while (__node->_M_next && __list._M_impl._M_head._M_next)
 	  {
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index a1f780a9c9b..79085c0c1bd 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -1361,6 +1361,16 @@ extern template class __shared_ptr<const filesystem::filesystem_error::_Impl>;
 
 /// @endcond
 
+// _GLIBCXX_RESOLVE_LIB_DEFECTS
+// 3657. std::hash<std::filesystem::path> is not enabled
+template<>
+  struct hash<filesystem::path>
+  {
+    size_t
+    operator()(const filesystem::path& __p) const noexcept
+    { return filesystem::hash_value(__p); }
+  };
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 
diff --git a/libstdc++-v3/include/bits/list.tcc b/libstdc++-v3/include/bits/list.tcc
index 0ce4c47a90e..62b0ba1063a 100644
--- a/libstdc++-v3/include/bits/list.tcc
+++ b/libstdc++-v3/include/bits/list.tcc
@@ -416,29 +416,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  iterator __last1 = end();
 	  iterator __first2 = __x.begin();
 	  iterator __last2 = __x.end();
-	  const size_t __orig_size = __x.size();
-	  __try {
-	    while (__first1 != __last1 && __first2 != __last2)
-	      if (*__first2 < *__first1)
-		{
-		  iterator __next = __first2;
-		  _M_transfer(__first1, __first2, ++__next);
-		  __first2 = __next;
-		}
-	      else
-		++__first1;
-	    if (__first2 != __last2)
-	      _M_transfer(__last1, __first2, __last2);
 
-	    this->_M_inc_size(__x._M_get_size());
-	    __x._M_set_size(0);
-	  }
-	  __catch(...)
+	  const _Finalize_merge __fin(*this, __x, __first2);
+
+	  while (__first1 != __last1 && __first2 != __last2)
+	    if (*__first2 < *__first1)
+	      {
+		iterator __next = __first2;
+		_M_transfer(__first1, __first2, ++__next);
+		__first2 = __next;
+	      }
+	    else
+	      ++__first1;
+	  if (__first2 != __last2)
 	    {
-	      const size_t __dist = std::distance(__first2, __last2);
-	      this->_M_inc_size(__orig_size - __dist);
-	      __x._M_set_size(__dist);
-	      __throw_exception_again;
+	      _M_transfer(__last1, __first2, __last2);
+	      __first2 = __last2;
 	    }
 	}
     }
@@ -463,30 +456,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	    iterator __last1 = end();
 	    iterator __first2 = __x.begin();
 	    iterator __last2 = __x.end();
-	    const size_t __orig_size = __x.size();
-	    __try
-	      {
-		while (__first1 != __last1 && __first2 != __last2)
-		  if (__comp(*__first2, *__first1))
-		    {
-		      iterator __next = __first2;
-		      _M_transfer(__first1, __first2, ++__next);
-		      __first2 = __next;
-		    }
-		  else
-		    ++__first1;
-		if (__first2 != __last2)
-		  _M_transfer(__last1, __first2, __last2);
-
-		this->_M_inc_size(__x._M_get_size());
-		__x._M_set_size(0);
-	      }
-	    __catch(...)
+
+	    const _Finalize_merge __fin(*this, __x, __first2);
+
+	    while (__first1 != __last1 && __first2 != __last2)
+	      if (__comp(*__first2, *__first1))
+		{
+		  iterator __next = __first2;
+		  _M_transfer(__first1, __first2, ++__next);
+		  __first2 = __next;
+		}
+	      else
+		++__first1;
+	    if (__first2 != __last2)
 	      {
-		const size_t __dist = std::distance(__first2, __last2);
-		this->_M_inc_size(__orig_size - __dist);
-		__x._M_set_size(__dist);
-		__throw_exception_again;
+		_M_transfer(__last1, __first2, __last2);
+		__first2 = __last2;
 	      }
 	  }
       }
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.tcc b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
index 51c23d8003a..4aef5502032 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.tcc
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
@@ -78,32 +78,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       char* __grouping = 0;
       _CharT* __curr_symbol = 0;
       _CharT* __positive_sign = 0;
-      _CharT* __negative_sign = 0;     
+      _CharT* __negative_sign = 0;
+      size_t __sz;
       __try
 	{
 	  const string& __g = __mp.grouping();
-	  _M_grouping_size = __g.size();
-	  __grouping = new char[_M_grouping_size];
-	  __g.copy(__grouping, _M_grouping_size);
+	  __sz = _M_grouping_size = __g.size();
+	  __grouping = new char[__sz];
+	  __g.copy(__grouping, __sz);
 	  _M_use_grouping = (_M_grouping_size
 			     && static_cast<signed char>(__grouping[0]) > 0
 			     && (__grouping[0]
 				 != __gnu_cxx::__numeric_traits<char>::__max));
 
 	  const basic_string<_CharT>& __cs = __mp.curr_symbol();
-	  _M_curr_symbol_size = __cs.size();
-	  __curr_symbol = new _CharT[_M_curr_symbol_size];
-	  __cs.copy(__curr_symbol, _M_curr_symbol_size);
+	  __sz = _M_curr_symbol_size = __cs.size();
+	  __curr_symbol = new _CharT[__sz];
+	  __cs.copy(__curr_symbol, __sz);
 
 	  const basic_string<_CharT>& __ps = __mp.positive_sign();
-	  _M_positive_sign_size = __ps.size();
-	  __positive_sign = new _CharT[_M_positive_sign_size];
-	  __ps.copy(__positive_sign, _M_positive_sign_size);
+	  __sz = _M_positive_sign_size = __ps.size();
+	  __positive_sign = new _CharT[__sz];
+	  __ps.copy(__positive_sign, __sz);
 
 	  const basic_string<_CharT>& __ns = __mp.negative_sign();
-	  _M_negative_sign_size = __ns.size();
-	  __negative_sign = new _CharT[_M_negative_sign_size];
-	  __ns.copy(__negative_sign, _M_negative_sign_size);
+	  __sz = _M_negative_sign_size = __ns.size();
+	  __negative_sign = new _CharT[__sz];
+	  __ns.copy(__negative_sign, __sz);
 
 	  _M_pos_format = __mp.pos_format();
 	  _M_neg_format = __mp.neg_format();
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
index 22ae1f38ebb..2898f7f17e6 100644
--- a/libstdc++-v3/include/bits/random.tcc
+++ b/libstdc++-v3/include/bits/random.tcc
@@ -1955,7 +1955,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool __saved_avail;
       if (__is >> __mean >> __stddev >> __saved_avail)
 	{
-	  if (__saved_avail && (__is >> __x._M_saved))
+	  if (!__saved_avail || (__is >> __x._M_saved))
 	    {
 	      __x._M_saved_available = __saved_avail;
 	      __x.param(param_type(__mean, __stddev));
diff --git a/libstdc++-v3/include/bits/ranges_base.h b/libstdc++-v3/include/bits/ranges_base.h
index 87283b84028..2a525e421b9 100644
--- a/libstdc++-v3/include/bits/ranges_base.h
+++ b/libstdc++-v3/include/bits/ranges_base.h
@@ -379,6 +379,8 @@ namespace ranges
     template<typename _Tp>
       concept __sentinel_size = requires(_Tp& __t)
 	{
+	  requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);
+
 	  { _Begin{}(__t) } -> forward_iterator;
 
 	  { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>;
@@ -462,6 +464,8 @@ namespace ranges
     template<typename _Tp>
       concept __eq_iter_empty = requires(_Tp& __t)
 	{
+	  requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);
+
 	  { _Begin{}(__t) } -> forward_iterator;
 
 	  bool(_Begin{}(__t) == _End{}(__t));
@@ -728,20 +732,23 @@ namespace ranges
 	  {
 	    const auto __diff = __bound - __it;
 
-	    // n and bound must not lead in opposite directions:
-	    __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));
-	    const auto __absdiff = __diff < 0 ? -__diff : __diff;
-	    const auto __absn = __n < 0 ? -__n : __n;;
-	    if (__absn >= __absdiff)
+	    if (__diff == 0)
+	      return __n;
+	    else if (__diff > 0 ? __n >= __diff : __n <= __diff)
 	      {
 		(*this)(__it, __bound);
 		return __n - __diff;
 	      }
-	    else
+	    else if (__n != 0) [[likely]]
 	      {
+		// n and bound must not lead in opposite directions:
+		__glibcxx_assert(__n < 0 == __diff < 0);
+
 		(*this)(__it, __n);
 		return 0;
 	      }
+	    else
+	      return 0;
 	  }
 	else if (__it == __bound || __n == 0)
 	  return __n;
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index a9a035e04d1..314849a6bff 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -57,6 +57,16 @@ namespace __detail
 
   template<typename, typename, typename, bool>
     class _Executor;
+
+  template<typename _Tp>
+    struct __is_contiguous_iter : false_type { };
+
+  template<typename _Tp>
+    struct __is_contiguous_iter<_Tp*> : true_type { };
+
+  template<typename _Tp, typename _Cont>
+    struct __is_contiguous_iter<__gnu_cxx::__normal_iterator<_Tp*, _Cont>>
+    : true_type { };
 }
 
 _GLIBCXX_BEGIN_NAMESPACE_CXX11
@@ -414,6 +424,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       static constexpr flag_type awk = regex_constants::awk;
       static constexpr flag_type grep = regex_constants::grep;
       static constexpr flag_type egrep = regex_constants::egrep;
+#if __cplusplus >= 201703L || !defined __STRICT_ANSI__
+      static constexpr flag_type multiline = regex_constants::multiline;
+#endif
       ///@}
 
       // [7.8.2] construct/copy/destroy
@@ -421,7 +434,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * Constructs a basic regular expression that does not match any
        * character sequence.
        */
-      basic_regex()
+      basic_regex() noexcept
       : _M_flags(ECMAScript), _M_loc(), _M_automaton(nullptr)
       { }
 
@@ -438,8 +451,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       explicit
       basic_regex(const _Ch_type* __p, flag_type __f = ECMAScript)
-      : basic_regex(__p, __p + char_traits<_Ch_type>::length(__p), __f)
-      { }
+      { _M_compile(__p, __p + _Rx_traits::length(__p), __f); }
 
       /**
        * @brief Constructs a basic regular expression from the sequence
@@ -455,8 +467,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       basic_regex(const _Ch_type* __p, std::size_t __len,
 		  flag_type __f = ECMAScript)
-      : basic_regex(__p, __p + __len, __f)
-      { }
+      { _M_compile(__p, __p + __len, __f); }
 
       /**
        * @brief Copy-constructs a basic regular expression.
@@ -486,8 +497,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	basic_regex(const std::basic_string<_Ch_type, _Ch_traits,
 					    _Ch_alloc>& __s,
 		    flag_type __f = ECMAScript)
-	: basic_regex(__s.data(), __s.data() + __s.size(), __f)
-	{ }
+	{ _M_compile(__s.data(), __s.data() + __s.size(), __f); }
 
       /**
        * @brief Constructs a basic regular expression from the range
@@ -505,8 +515,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       template<typename _FwdIter>
 	basic_regex(_FwdIter __first, _FwdIter __last,
 		    flag_type __f = ECMAScript)
-	: basic_regex(std::move(__first), std::move(__last), locale_type(), __f)
-	{ }
+	{ this->assign(__first, __last, __f); }
 
       /**
        * @brief Constructs a basic regular expression from an initializer list.
@@ -517,8 +526,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @throws regex_error if @p __l is not a valid regular expression.
        */
       basic_regex(initializer_list<_Ch_type> __l, flag_type __f = ECMAScript)
-      : basic_regex(__l.begin(), __l.end(), __f)
-      { }
+      { _M_compile(__l.begin(), __l.end(), __f); }
 
       /**
        * @brief Destroys a basic regular expression.
@@ -530,15 +538,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @brief Assigns one regular expression to another.
        */
       basic_regex&
-      operator=(const basic_regex& __rhs)
-      { return this->assign(__rhs); }
+      operator=(const basic_regex&) = default;
 
       /**
        * @brief Move-assigns one regular expression to another.
        */
       basic_regex&
-      operator=(basic_regex&& __rhs) noexcept
-      { return this->assign(std::move(__rhs)); }
+      operator=(basic_regex&&) = default;
 
       /**
        * @brief Replaces a regular expression with a new one constructed from
@@ -561,7 +567,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       basic_regex&
       operator=(initializer_list<_Ch_type> __l)
-      { return this->assign(__l.begin(), __l.end()); }
+      { return this->assign(__l); }
 
       /**
        * @brief Replaces a regular expression with a new one constructed from
@@ -576,30 +582,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
       // [7.8.3] assign
       /**
-       * @brief the real assignment operator.
+       * @brief Assigns one regular expression to another.
        *
        * @param __rhs Another regular expression object.
        */
       basic_regex&
-      assign(const basic_regex& __rhs)
-      {
-	basic_regex __tmp(__rhs);
-	this->swap(__tmp);
-	return *this;
-      }
+      assign(const basic_regex& __rhs) noexcept
+      { return *this = __rhs; }
 
       /**
-       * @brief The move-assignment operator.
+       * @brief Move-assigns one regular expression to another.
        *
        * @param __rhs Another regular expression object.
        */
       basic_regex&
       assign(basic_regex&& __rhs) noexcept
-      {
-	basic_regex __tmp(std::move(__rhs));
-	this->swap(__tmp);
-	return *this;
-      }
+      { return *this = std::move(__rhs); }
 
       /**
        * @brief Assigns a new regular expression to a regex object from a
@@ -616,7 +614,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       basic_regex&
       assign(const _Ch_type* __p, flag_type __flags = ECMAScript)
-      { return this->assign(string_type(__p), __flags); }
+      {
+	_M_compile(__p, __p + _Rx_traits::length(__p), __flags);
+	return *this;
+      }
 
       /**
        * @brief Assigns a new regular expression to a regex object from a
@@ -635,7 +636,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       // 3296. Inconsistent default argument for basic_regex<>::assign
       basic_regex&
       assign(const _Ch_type* __p, size_t __len, flag_type __flags = ECMAScript)
-      { return this->assign(string_type(__p, __len), __flags); }
+      {
+	_M_compile(__p, __p + __len, __flags);
+	return *this;
+      }
 
       /**
        * @brief Assigns a new regular expression to a regex object from a
@@ -653,8 +657,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	assign(const basic_string<_Ch_type, _Ch_traits, _Alloc>& __s,
 	       flag_type __flags = ECMAScript)
 	{
-	  return this->assign(basic_regex(__s.data(), __s.data() + __s.size(),
-					  _M_loc, __flags));
+	  _M_compile(__s.data(), __s.data() + __s.size(), __flags);
+	  return *this;
 	}
 
       /**
@@ -674,7 +678,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	basic_regex&
 	assign(_InputIterator __first, _InputIterator __last,
 	       flag_type __flags = ECMAScript)
-	{ return this->assign(string_type(__first, __last), __flags); }
+	{
+#if __cplusplus >= 201703L
+	  using _ValT = typename iterator_traits<_InputIterator>::value_type;
+	  if constexpr (__detail::__is_contiguous_iter<_InputIterator>::value
+			&& is_same_v<_ValT, value_type>)
+	    {
+	      const auto __len = __last - __first;
+	      const _Ch_type* __p = std::__to_address(__first);
+	      _M_compile(__p, __p + __len, __flags);
+	    }
+	  else
+#endif
+	  this->assign(string_type(__first, __last), __flags);
+	  return *this;
+	}
 
       /**
        * @brief Assigns a new regular expression to a regex object.
@@ -689,7 +707,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       basic_regex&
       assign(initializer_list<_Ch_type> __l, flag_type __flags = ECMAScript)
-      { return this->assign(__l.begin(), __l.end(), __flags); }
+      {
+	_M_compile(__l.begin(), __l.end(), __flags);
+	return *this;
+      }
 
       // [7.8.4] const operations
       /**
@@ -697,7 +718,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * expression.
        */
       unsigned int
-      mark_count() const
+      mark_count() const noexcept
       {
 	if (_M_automaton)
 	  return _M_automaton->_M_sub_count() - 1;
@@ -709,7 +730,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * or in the last call to assign().
        */
       flag_type
-      flags() const
+      flags() const noexcept
       { return _M_flags; }
 
       // [7.8.5] locale
@@ -731,7 +752,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        *        object.
        */
       locale_type
-      getloc() const
+      getloc() const noexcept
       { return _M_loc; }
 
       // [7.8.6] swap
@@ -741,7 +762,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @param __rhs Another regular expression object.
        */
       void
-      swap(basic_regex& __rhs)
+      swap(basic_regex& __rhs) noexcept
       {
 	std::swap(_M_flags, __rhs._M_flags);
 	std::swap(_M_loc, __rhs._M_loc);
@@ -757,13 +778,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     private:
       typedef std::shared_ptr<const __detail::_NFA<_Rx_traits>> _AutomatonPtr;
 
-      template<typename _FwdIter>
-	basic_regex(_FwdIter __first, _FwdIter __last, locale_type __loc,
-		    flag_type __f)
-	: _M_flags(__f), _M_loc(std::move(__loc)),
-	_M_automaton(__detail::__compile_nfa<_Rx_traits>(
-	  std::move(__first), std::move(__last), _M_loc, _M_flags))
-	{ }
+      void
+      _M_compile(const _Ch_type* __first, const _Ch_type* __last,
+		 flag_type __f)
+      {
+	__detail::_Compiler<_Rx_traits> __c(__first, __last, _M_loc, __f);
+	_M_automaton = __c._M_get_nfa();
+	_M_flags = __f;
+      }
 
       template<typename _Bp, typename _Ap, typename _Cp, typename _Rp,
 	__detail::_RegexExecutorPolicy, bool>
@@ -848,7 +870,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   template<typename _Ch_type, typename _Rx_traits>
     inline void
     swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,
-	 basic_regex<_Ch_type, _Rx_traits>& __rhs)
+	 basic_regex<_Ch_type, _Rx_traits>& __rhs) noexcept
     { __lhs.swap(__rhs); }
 
 
@@ -2459,6 +2481,15 @@ _GLIBCXX_END_NAMESPACE_CXX11
 		 = regex_constants::match_default) = delete;
 
   // std [28.11.4] Function template regex_replace
+
+  template<typename _Out_iter, typename _Bi_iter,
+	   typename _Rx_traits, typename _Ch_type>
+    _Out_iter
+    __regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+		    const basic_regex<_Ch_type, _Rx_traits>& __e,
+		    const _Ch_type* __fmt, size_t __len,
+		    regex_constants::match_flag_type __flags);
+
   /**
    * @brief Search for a regular expression within a range for multiple times,
    and replace the matched parts through filling a format string.
@@ -2482,7 +2513,8 @@ _GLIBCXX_END_NAMESPACE_CXX11
 		  regex_constants::match_flag_type __flags
 		  = regex_constants::match_default)
     {
-      return regex_replace(__out, __first, __last, __e, __fmt.c_str(), __flags);
+      return std::__regex_replace(__out, __first, __last, __e, __fmt.c_str(),
+				  __fmt.length(), __flags);
     }
 
   /**
@@ -2505,7 +2537,13 @@ _GLIBCXX_END_NAMESPACE_CXX11
 		  const basic_regex<_Ch_type, _Rx_traits>& __e,
 		  const _Ch_type* __fmt,
 		  regex_constants::match_flag_type __flags
-		  = regex_constants::match_default);
+		  = regex_constants::match_default)
+    {
+      return std::__regex_replace(__out, __first, __last, __e, __fmt,
+				  char_traits<_Ch_type>::length(__fmt),
+				  __flags);
+    }
+
 
   /**
    * @brief Search for a regular expression within a string for multiple times,
diff --git a/libstdc++-v3/include/bits/regex.tcc b/libstdc++-v3/include/bits/regex.tcc
index 39ad3f0a4cc..ef152851e55 100644
--- a/libstdc++-v3/include/bits/regex.tcc
+++ b/libstdc++-v3/include/bits/regex.tcc
@@ -461,10 +461,10 @@ namespace __detail
   template<typename _Out_iter, typename _Bi_iter,
 	   typename _Rx_traits, typename _Ch_type>
     _Out_iter
-    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
-		  const basic_regex<_Ch_type, _Rx_traits>& __e,
-		  const _Ch_type* __fmt,
-		  regex_constants::match_flag_type __flags)
+    __regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+		    const basic_regex<_Ch_type, _Rx_traits>& __e,
+		    const _Ch_type* __fmt, size_t __len,
+		    regex_constants::match_flag_type __flags)
     {
       typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> _IterT;
       _IterT __i(__first, __last, __e, __flags);
@@ -477,7 +477,6 @@ namespace __detail
       else
 	{
 	  sub_match<_Bi_iter> __last;
-	  auto __len = char_traits<_Ch_type>::length(__fmt);
 	  for (; __i != __end; ++__i)
 	    {
 	      if (!(__flags & regex_constants::format_no_copy))
diff --git a/libstdc++-v3/include/bits/regex_automaton.h b/libstdc++-v3/include/bits/regex_automaton.h
index 872a17fe8cb..f108675f35e 100644
--- a/libstdc++-v3/include/bits/regex_automaton.h
+++ b/libstdc++-v3/include/bits/regex_automaton.h
@@ -95,13 +95,13 @@ namespace __detail
     };
 
   protected:
-    explicit _State_base(_Opcode __opcode)
+    explicit _State_base(_Opcode __opcode) noexcept
     : _M_opcode(__opcode), _M_next(_S_invalid_state_id)
     { }
 
   public:
     bool
-    _M_has_alt()
+    _M_has_alt() const noexcept
     {
       return _M_opcode == _S_opcode_alternative
 	|| _M_opcode == _S_opcode_repeat
@@ -130,7 +130,7 @@ namespace __detail
 		    "std::function<bool(char)>");
 
       explicit
-      _State(_Opcode __opcode) : _State_base(__opcode)
+      _State(_Opcode __opcode) noexcept : _State_base(__opcode)
       {
 	if (_M_opcode() == _S_opcode_match)
 	  new (this->_M_matcher_storage._M_addr()) _MatcherT();
@@ -143,7 +143,7 @@ namespace __detail
 	    _MatcherT(__rhs._M_get_matcher());
       }
 
-      _State(_State&& __rhs) : _State_base(__rhs)
+      _State(_State&& __rhs) noexcept : _State_base(__rhs)
       {
 	if (__rhs._M_opcode() == _S_opcode_match)
 	  new (this->_M_matcher_storage._M_addr())
@@ -162,7 +162,7 @@ namespace __detail
       // Since correct ctor and dtor rely on _M_opcode, it's better not to
       // change it over time.
       _Opcode
-      _M_opcode() const
+      _M_opcode() const noexcept
       { return _State_base::_M_opcode; }
 
       bool
@@ -170,11 +170,11 @@ namespace __detail
       { return _M_get_matcher()(__char); }
 
       _MatcherT&
-      _M_get_matcher()
+      _M_get_matcher() noexcept
       { return *static_cast<_MatcherT*>(this->_M_matcher_storage._M_addr()); }
 
       const _MatcherT&
-      _M_get_matcher() const
+      _M_get_matcher() const noexcept
       {
 	return *static_cast<const _MatcherT*>(
 	    this->_M_matcher_storage._M_addr());
@@ -183,11 +183,10 @@ namespace __detail
 
   struct _NFA_base
   {
-    typedef size_t                              _SizeT;
     typedef regex_constants::syntax_option_type _FlagT;
 
     explicit
-    _NFA_base(_FlagT __f)
+    _NFA_base(_FlagT __f) noexcept
     : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),
     _M_has_backref(false)
     { }
@@ -199,21 +198,21 @@ namespace __detail
 
   public:
     _FlagT
-    _M_options() const
+    _M_options() const noexcept
     { return _M_flags; }
 
     _StateIdT
-    _M_start() const
+    _M_start() const noexcept
     { return _M_start_state; }
 
-    _SizeT
-    _M_sub_count() const
+    size_t
+    _M_sub_count() const noexcept
     { return _M_subexpr_count; }
 
     _GLIBCXX_STD_C::vector<size_t> _M_paren_stack;
     _FlagT                    _M_flags;
     _StateIdT                 _M_start_state;
-    _SizeT                    _M_subexpr_count;
+    size_t                    _M_subexpr_count;
     bool                      _M_has_backref;
   };
 
diff --git a/libstdc++-v3/include/bits/regex_compiler.h b/libstdc++-v3/include/bits/regex_compiler.h
index bf7dcc54dba..bae2138e309 100644
--- a/libstdc++-v3/include/bits/regex_compiler.h
+++ b/libstdc++-v3/include/bits/regex_compiler.h
@@ -58,15 +58,14 @@ namespace __detail
     {
     public:
       typedef typename _TraitsT::char_type        _CharT;
-      typedef const _CharT*                       _IterT;
       typedef _NFA<_TraitsT>              	  _RegexT;
       typedef regex_constants::syntax_option_type _FlagT;
 
-      _Compiler(_IterT __b, _IterT __e,
+      _Compiler(const _CharT* __b, const _CharT* __e,
 		const typename _TraitsT::locale_type& __traits, _FlagT __flags);
 
       shared_ptr<const _RegexT>
-      _M_get_nfa()
+      _M_get_nfa() noexcept
       { return std::move(_M_nfa); }
 
     private:
@@ -122,13 +121,45 @@ namespace __detail
 	void
 	_M_insert_bracket_matcher(bool __neg);
 
-      // Returns true if successfully matched one term and should continue.
+      // Cache of the last atom seen in a bracketed range expression.
+      struct _BracketState
+      {
+	enum class _Type : char { _None, _Char, _Class } _M_type = _Type::_None;
+	_CharT _M_char;
+
+	void
+	set(_CharT __c) noexcept { _M_type = _Type::_Char; _M_char = __c; }
+
+	_GLIBCXX_NODISCARD _CharT
+	get() const noexcept { return _M_char; }
+
+	void
+	reset(_Type __t = _Type::_None) noexcept { _M_type = __t; }
+
+	explicit operator bool() const noexcept
+	{ return _M_type != _Type::_None; }
+
+	// Previous token was a single character.
+	_GLIBCXX_NODISCARD bool
+	_M_is_char() const noexcept { return _M_type == _Type::_Char; }
+
+	// Previous token was a character class, equivalent class,
+	// collating symbol etc.
+	_GLIBCXX_NODISCARD bool
+	_M_is_class() const noexcept { return _M_type == _Type::_Class; }
+      };
+
+      template<bool __icase, bool __collate>
+	using _BracketMatcher
+	  = std::__detail::_BracketMatcher<_TraitsT, __icase, __collate>;
+
+      // Returns true if successfully parsed one term and should continue
+      // compiling a bracket expression.
       // Returns false if the compiler should move on.
       template<bool __icase, bool __collate>
 	bool
-	_M_expression_term(pair<bool, _CharT>& __last_char,
-			   _BracketMatcher<_TraitsT, __icase, __collate>&
-			   __matcher);
+	_M_expression_term(_BracketState& __last_char,
+			   _BracketMatcher<__icase, __collate>& __matcher);
 
       int
       _M_cur_int_value(int __radix);
@@ -144,6 +175,26 @@ namespace __detail
 	return ret;
       }
 
+      static _FlagT
+      _S_validate(_FlagT __f)
+      {
+	using namespace regex_constants;
+	switch (__f & (ECMAScript|basic|extended|awk|grep|egrep))
+	  {
+	  case ECMAScript:
+	  case basic:
+	  case extended:
+	  case awk:
+	  case grep:
+	  case egrep:
+	    return __f;
+	  case _FlagT(0):
+	    return __f | ECMAScript;
+	  default:
+	    std::__throw_regex_error(_S_grammar, "conflicting grammar options");
+	  }
+      }
+
       _FlagT              _M_flags;
       _ScannerT           _M_scanner;
       shared_ptr<_RegexT> _M_nfa;
@@ -153,47 +204,6 @@ namespace __detail
       const _CtypeT&      _M_ctype;
     };
 
-  template<typename _Tp>
-    struct __is_contiguous_iter : is_pointer<_Tp>::type { };
-
-  template<typename _Tp, typename _Cont>
-    struct
-    __is_contiguous_iter<__gnu_cxx::__normal_iterator<_Tp*, _Cont>>
-    : true_type { };
-
-  template<typename _Iter, typename _TraitsT>
-    using __enable_if_contiguous_iter
-      = __enable_if_t< __is_contiguous_iter<_Iter>::value,
-                       std::shared_ptr<const _NFA<_TraitsT>> >;
-
-  template<typename _Iter, typename _TraitsT>
-    using __disable_if_contiguous_iter
-      = __enable_if_t< !__is_contiguous_iter<_Iter>::value,
-                       std::shared_ptr<const _NFA<_TraitsT>> >;
-
-  template<typename _TraitsT, typename _FwdIter>
-    inline __enable_if_contiguous_iter<_FwdIter, _TraitsT>
-    __compile_nfa(_FwdIter __first, _FwdIter __last,
-		  const typename _TraitsT::locale_type& __loc,
-		  regex_constants::syntax_option_type __flags)
-    {
-      size_t __len = __last - __first;
-      const auto* __cfirst = __len ? std::__addressof(*__first) : nullptr;
-      using _Cmplr = _Compiler<_TraitsT>;
-      return _Cmplr(__cfirst, __cfirst + __len, __loc, __flags)._M_get_nfa();
-    }
-
-  template<typename _TraitsT, typename _FwdIter>
-    inline __disable_if_contiguous_iter<_FwdIter, _TraitsT>
-    __compile_nfa(_FwdIter __first, _FwdIter __last,
-		  const typename _TraitsT::locale_type& __loc,
-		  regex_constants::syntax_option_type __flags)
-    {
-      const basic_string<typename _TraitsT::char_type> __str(__first, __last);
-      return __compile_nfa<_TraitsT>(__str.data(), __str.data() + __str.size(),
-				     __loc, __flags);
-    }
-
   // [28.13.14]
   template<typename _TraitsT, bool __icase, bool __collate>
     class _RegexTranslatorBase
diff --git a/libstdc++-v3/include/bits/regex_compiler.tcc b/libstdc++-v3/include/bits/regex_compiler.tcc
index 440669debe0..6f42f2aed65 100644
--- a/libstdc++-v3/include/bits/regex_compiler.tcc
+++ b/libstdc++-v3/include/bits/regex_compiler.tcc
@@ -63,17 +63,9 @@ namespace __detail
 {
   template<typename _TraitsT>
     _Compiler<_TraitsT>::
-    _Compiler(_IterT __b, _IterT __e,
+    _Compiler(const _CharT* __b, const _CharT* __e,
 	      const typename _TraitsT::locale_type& __loc, _FlagT __flags)
-    : _M_flags((__flags
-		& (regex_constants::ECMAScript
-		   | regex_constants::basic
-		   | regex_constants::extended
-		   | regex_constants::grep
-		   | regex_constants::egrep
-		   | regex_constants::awk))
-	       ? __flags
-	       : __flags | regex_constants::ECMAScript),
+    : _M_flags(_S_validate(__flags)),
       _M_scanner(__b, __e, _M_flags, __loc),
       _M_nfa(make_shared<_RegexT>(__loc, _M_flags)),
       _M_traits(_M_nfa->_M_traits),
@@ -140,7 +132,8 @@ namespace __detail
 	return true;
       if (this->_M_atom())
 	{
-	  while (this->_M_quantifier());
+	  while (this->_M_quantifier())
+	    ;
 	  return true;
 	}
       return false;
@@ -410,7 +403,7 @@ namespace __detail
     _M_insert_character_class_matcher()
     {
       __glibcxx_assert(_M_value.size() == 1);
-      _BracketMatcher<_TraitsT, __icase, __collate> __matcher
+      _BracketMatcher<__icase, __collate> __matcher
 	(_M_ctype.is(_CtypeT::upper, _M_value[0]), _M_traits);
       __matcher._M_add_character_class(_M_value, false);
       __matcher._M_ready();
@@ -424,25 +417,17 @@ namespace __detail
     _Compiler<_TraitsT>::
     _M_insert_bracket_matcher(bool __neg)
     {
-      _BracketMatcher<_TraitsT, __icase, __collate> __matcher(__neg, _M_traits);
-      pair<bool, _CharT> __last_char; // Optional<_CharT>
-      __last_char.first = false;
-      if (!(_M_flags & regex_constants::ECMAScript))
-	{
-	  if (_M_try_char())
-	    {
-	      __last_char.first = true;
-	      __last_char.second = _M_value[0];
-	    }
-	  else if (_M_match_token(_ScannerT::_S_token_bracket_dash))
-	    {
-	      __last_char.first = true;
-	      __last_char.second = '-';
-	    }
-	}
-      while (_M_expression_term(__last_char, __matcher));
-      if (__last_char.first)
-	__matcher._M_add_char(__last_char.second);
+      _BracketMatcher<__icase, __collate> __matcher(__neg, _M_traits);
+      _BracketState __last_char;
+      if (_M_try_char())
+	__last_char.set(_M_value[0]);
+      else if (_M_match_token(_ScannerT::_S_token_bracket_dash))
+	// Dash as first character is a normal character.
+	__last_char.set('-');
+      while (_M_expression_term(__last_char, __matcher))
+	;
+      if (__last_char._M_is_char())
+	__matcher._M_add_char(__last_char.get());
       __matcher._M_ready();
       _M_stack.push(_StateSeqT(
 		      *_M_nfa,
@@ -453,27 +438,27 @@ namespace __detail
   template<bool __icase, bool __collate>
     bool
     _Compiler<_TraitsT>::
-    _M_expression_term(pair<bool, _CharT>& __last_char,
-		       _BracketMatcher<_TraitsT, __icase, __collate>& __matcher)
+    _M_expression_term(_BracketState& __last_char,
+		       _BracketMatcher<__icase, __collate>& __matcher)
     {
       if (_M_match_token(_ScannerT::_S_token_bracket_end))
 	return false;
 
+      // Add any previously cached char into the matcher and update cache.
       const auto __push_char = [&](_CharT __ch)
       {
-	if (__last_char.first)
-	  __matcher._M_add_char(__last_char.second);
-	else
-	  __last_char.first = true;
-	__last_char.second = __ch;
+	if (__last_char._M_is_char())
+	  __matcher._M_add_char(__last_char.get());
+	__last_char.set(__ch);
       };
-      const auto __flush = [&]
+      // Add any previously cached char into the matcher and update cache.
+      const auto __push_class = [&]
       {
-	if (__last_char.first)
-	  {
-	    __matcher._M_add_char(__last_char.second);
-	    __last_char.first = false;
-	  }
+        if (__last_char._M_is_char())
+	  __matcher._M_add_char(__last_char.get());
+	// We don't cache anything here, just record that the last thing
+	// processed was a character class (or similar).
+	__last_char.reset(_BracketState::_Type::_Class);
       };
 
       if (_M_match_token(_ScannerT::_S_token_collsymbol))
@@ -482,16 +467,16 @@ namespace __detail
 	  if (__symbol.size() == 1)
 	    __push_char(__symbol[0]);
 	  else
-	    __flush();
+	    __push_class();
 	}
       else if (_M_match_token(_ScannerT::_S_token_equiv_class_name))
 	{
-	  __flush();
+	  __push_class();
 	  __matcher._M_add_equivalence_class(_M_value);
 	}
       else if (_M_match_token(_ScannerT::_S_token_char_class_name))
 	{
-	  __flush();
+	  __push_class();
 	  __matcher._M_add_character_class(_M_value, false);
 	}
       else if (_M_try_char())
@@ -508,49 +493,50 @@ namespace __detail
       // It turns out that no one reads BNFs ;)
       else if (_M_match_token(_ScannerT::_S_token_bracket_dash))
 	{
-	  if (!__last_char.first)
+	  if (_M_match_token(_ScannerT::_S_token_bracket_end))
 	    {
-	      if (!(_M_flags & regex_constants::ECMAScript))
-		{
-		  if (_M_match_token(_ScannerT::_S_token_bracket_end))
-		    {
-		      __push_char('-');
-		      return false;
-		    }
-		  __throw_regex_error(
-		    regex_constants::error_range,
-		    "Unexpected dash in bracket expression. For POSIX syntax, "
-		    "a dash is not treated literally only when it is at "
-		    "beginning or end.");
-		}
+	      // For "-]" the dash is a literal character.
 	      __push_char('-');
+	      return false;
 	    }
-	  else
+	  else if (__last_char._M_is_class())
+	    {
+	      // "\\w-" is invalid, start of range must be a single char.
+	      __throw_regex_error(regex_constants::error_range,
+		    "Invalid start of range in bracket expression.");
+	    }
+	  else if (__last_char._M_is_char())
 	    {
 	      if (_M_try_char())
 		{
-		  __matcher._M_make_range(__last_char.second, _M_value[0]);
-		  __last_char.first = false;
+		  // "x-y"
+		  __matcher._M_make_range(__last_char.get(), _M_value[0]);
+		  __last_char.reset();
 		}
 	      else if (_M_match_token(_ScannerT::_S_token_bracket_dash))
 		{
-		  __matcher._M_make_range(__last_char.second, '-');
-		  __last_char.first = false;
+		  // "x--"
+		  __matcher._M_make_range(__last_char.get(), '-');
+		  __last_char.reset();
 		}
 	      else
-		{
-		  if (_M_scanner._M_get_token()
-		      != _ScannerT::_S_token_bracket_end)
-		    __throw_regex_error(
-		      regex_constants::error_range,
-		      "Character is expected after a dash.");
-		  __push_char('-');
-		}
+		__throw_regex_error(regex_constants::error_range,
+		      "Invalid end of range in bracket expression.");
 	    }
+	  else if (_M_flags & regex_constants::ECMAScript)
+	    {
+	      // A dash that is not part of an existing range. Might be the
+	      // start of a new range, or might just be a literal '-' char.
+	      // Only ECMAScript allows that in the middle of a bracket expr.
+	      __push_char('-');
+	    }
+	  else
+	    __throw_regex_error(regex_constants::error_range,
+				"Invalid dash in bracket expression.");
 	}
       else if (_M_match_token(_ScannerT::_S_token_quoted_class))
 	{
-	  __flush();
+	  __push_class();
 	  __matcher._M_add_character_class(_M_value,
 					   _M_ctype.is(_CtypeT::upper,
 						       _M_value[0]));
@@ -586,9 +572,9 @@ namespace __detail
   template<typename _TraitsT>
     bool
     _Compiler<_TraitsT>::
-    _M_match_token(_TokenT token)
+    _M_match_token(_TokenT __token)
     {
-      if (token == _M_scanner._M_get_token())
+      if (__token == _M_scanner._M_get_token())
 	{
 	  _M_value = _M_scanner._M_get_value();
 	  _M_scanner._M_advance();
@@ -602,10 +588,12 @@ namespace __detail
     _Compiler<_TraitsT>::
     _M_cur_int_value(int __radix)
     {
-      long __v = 0;
-      for (typename _StringT::size_type __i = 0;
-	   __i < _M_value.length(); ++__i)
-	__v =__v * __radix + _M_traits.value(_M_value[__i], __radix);
+      int __v = 0;
+      for (_CharT __c : _M_value)
+	if (__builtin_mul_overflow(__v, __radix, &__v)
+	    || __builtin_add_overflow(__v, _M_traits.value(__c, __radix), &__v))
+	    std::__throw_regex_error(regex_constants::error_backref,
+				     "invalid back reference");
       return __v;
     }
 
diff --git a/libstdc++-v3/include/bits/regex_constants.h b/libstdc++-v3/include/bits/regex_constants.h
index 1c3dd36d57c..0fd2879c817 100644
--- a/libstdc++-v3/include/bits/regex_constants.h
+++ b/libstdc++-v3/include/bits/regex_constants.h
@@ -64,7 +64,7 @@ namespace regex_constants
     _S_grep,
     _S_egrep,
     _S_polynomial,
-    _S_syntax_last
+    _S_multiline
   };
 
   /**
@@ -170,6 +170,24 @@ namespace regex_constants
   _GLIBCXX17_INLINE constexpr syntax_option_type egrep =
     static_cast<syntax_option_type>(1 << _S_egrep);
 
+#if __cplusplus >= 201703L || !defined __STRICT_ANSI__
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 2503. multiline option should be added to syntax_option_type
+  /**
+   * Specifies that the `^` anchor matches at the beginning of a line,
+   * and the `$` anchor matches at the end of a line, not only at the
+   * beginning/end of the input.
+   * Valid for the ECMAScript syntax, ignored otherwise.
+   * @since C++17
+   */
+  _GLIBCXX17_INLINE constexpr syntax_option_type multiline =
+    static_cast<syntax_option_type>(1 << _S_multiline);
+#endif
+
+  /// Extension: Equivalent to regex_constants::multiline for C++11 and C++14.
+  _GLIBCXX17_INLINE constexpr syntax_option_type __multiline =
+    static_cast<syntax_option_type>(1 << _S_multiline);
+
   /**
    * Extension: Ensure both space complexity of compiled regex and
    * time complexity execution are not exponential.
@@ -310,9 +328,10 @@ namespace regex_constants
     static_cast<match_flag_type>(1 << _S_continuous);
 
   /**
-   * --first is a valid iterator position.  When this flag is set then the
-   * flags match_not_bol and match_not_bow are ignored by the regular
-   * expression algorithms 28.11 and iterators 28.12.
+   * `--first` is a valid iterator position.  When this flag is set then the
+   * flags `match_not_bol` and `match_not_bow` are ignored by the algorithms
+   * `regex_match`, `regex_search`, and `regex_replace`, and by the iterators
+   * `regex_iterator` and `regex_token_iterator`.
    */
   _GLIBCXX17_INLINE constexpr match_flag_type match_prev_avail =
     static_cast<match_flag_type>(1 << _S_prev_avail);
diff --git a/libstdc++-v3/include/bits/regex_error.h b/libstdc++-v3/include/bits/regex_error.h
index 27593833544..e7b7b420ec4 100644
--- a/libstdc++-v3/include/bits/regex_error.h
+++ b/libstdc++-v3/include/bits/regex_error.h
@@ -61,6 +61,8 @@ namespace regex_constants
       _S_error_badrepeat,
       _S_error_complexity,
       _S_error_stack,
+      _S_null,
+      _S_grammar
     };
 
   /** The expression contained an invalid collating element name. */
@@ -150,7 +152,7 @@ namespace regex_constants
      * @returns the regex error code.
      */
     regex_constants::error_type
-    code() const
+    code() const noexcept
     { return _M_code; }
 
   private:
diff --git a/libstdc++-v3/include/bits/regex_executor.h b/libstdc++-v3/include/bits/regex_executor.h
index 4a641eeee6c..ebaad88b75f 100644
--- a/libstdc++-v3/include/bits/regex_executor.h
+++ b/libstdc++-v3/include/bits/regex_executor.h
@@ -78,12 +78,12 @@ namespace __detail
       _M_results(__results),
       _M_rep_count(_M_nfa.size()),
       _M_states(_M_nfa._M_start(), _M_nfa.size()),
-      _M_flags((__flags & regex_constants::match_prev_avail)
-	       ? (__flags
-		  & ~regex_constants::match_not_bol
-		  & ~regex_constants::match_not_bow)
-	       : __flags)
-      { }
+      _M_flags(__flags)
+      {
+	using namespace regex_constants;
+	if (__flags & match_prev_avail) // ignore not_bol and not_bow
+	  _M_flags &= ~(match_not_bol | match_not_bow);
+      }
 
       // Set matched when string exactly matches the pattern.
       bool
@@ -165,16 +165,39 @@ namespace __detail
       bool
       _M_at_begin() const
       {
-	return _M_current == _M_begin
-	  && !(_M_flags & (regex_constants::match_not_bol
-			   | regex_constants::match_prev_avail));
+	if (_M_current == _M_begin)
+	  {
+	    // match_not_bol means ^ does not match [_M_begin,_M_begin)
+	    if (_M_flags & regex_constants::match_not_bol)
+	      return false;
+	    // match_prev_avail means _M_begin is not the start of the input.
+	    if (_M_flags & regex_constants::match_prev_avail)
+	      {
+		// For ECMAScript multiline matches, check if the previous
+		// character is a line terminator.
+		if (_M_match_multiline())
+		  return _M_is_line_terminator(*std::prev(_M_current));
+		else
+		  return false;
+	      }
+	    else // ^ matches at _M_begin
+	      return true;
+	  }
+	else if (_M_match_multiline())
+	  return _M_is_line_terminator(*std::prev(_M_current));
+	else
+	  return false;
       }
 
       bool
       _M_at_end() const
       {
-	return _M_current == _M_end
-	  && !(_M_flags & regex_constants::match_not_eol);
+	if (_M_current == _M_end)
+	  return !(_M_flags & regex_constants::match_not_eol);
+	else if (_M_match_multiline())
+	  return _M_is_line_terminator(*_M_current);
+	else
+	  return false;
       }
 
       bool
@@ -183,6 +206,31 @@ namespace __detail
       bool
       _M_lookahead(_StateIdT __next);
 
+      bool
+      _M_is_line_terminator(_CharT __c) const
+      {
+	const auto& __traits = _M_re._M_automaton->_M_traits;
+	const auto& __ct = use_facet<ctype<_CharT>>(__traits.getloc());
+	const char __n{ __ct.narrow(__c, ' ') };
+	if (__n == '\n')
+	  return true;
+	if (_M_re._M_automaton->_M_options() & regex_constants::ECMAScript)
+	  {
+	    if (__n == '\r')
+	      return true;
+	    // FIXME: U+2028 (line separator) and U+2029 (paragraph separator)
+	  }
+	return false;
+      }
+
+      bool
+      _M_match_multiline() const noexcept
+      {
+	constexpr auto __m
+	  = regex_constants::ECMAScript | regex_constants::__multiline;
+	return (_M_re._M_automaton->_M_options() & __m) == __m;
+      }
+
        // Holds additional information used in BFS-mode.
       template<typename _SearchMode, typename _ResultsVec>
 	struct _State_info;
diff --git a/libstdc++-v3/include/bits/regex_executor.tcc b/libstdc++-v3/include/bits/regex_executor.tcc
index 405d1c4d0d1..88bbbf42f78 100644
--- a/libstdc++-v3/include/bits/regex_executor.tcc
+++ b/libstdc++-v3/include/bits/regex_executor.tcc
@@ -423,7 +423,7 @@ namespace __detail
   template<typename _BiIter, typename _Alloc, typename _TraitsT,
 	   bool __dfs_mode>
     void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
-    _M_handle_accept(_Match_mode __match_mode, _StateIdT __i)
+    _M_handle_accept(_Match_mode __match_mode, _StateIdT)
     {
       if (__dfs_mode)
 	{
diff --git a/libstdc++-v3/include/bits/regex_scanner.h b/libstdc++-v3/include/bits/regex_scanner.h
index e810fa7dd31..4e7d5efb34b 100644
--- a/libstdc++-v3/include/bits/regex_scanner.h
+++ b/libstdc++-v3/include/bits/regex_scanner.h
@@ -211,23 +211,22 @@ namespace __detail
     : public _ScannerBase
     {
     public:
-      typedef const _CharT*                                       _IterT;
       typedef std::basic_string<_CharT>                           _StringT;
       typedef regex_constants::syntax_option_type                 _FlagT;
       typedef const std::ctype<_CharT>                            _CtypeT;
 
-      _Scanner(_IterT __begin, _IterT __end,
+      _Scanner(const _CharT* __begin, const _CharT* __end,
 	       _FlagT __flags, std::locale __loc);
 
       void
       _M_advance();
 
       _TokenT
-      _M_get_token() const
+      _M_get_token() const noexcept
       { return _M_token; }
 
       const _StringT&
-      _M_get_value() const
+      _M_get_value() const noexcept
       { return _M_value; }
 
 #ifdef _GLIBCXX_DEBUG
@@ -257,8 +256,8 @@ namespace __detail
       void
       _M_eat_class(char);
 
-      _IterT                        _M_current;
-      _IterT                        _M_end;
+      const _CharT*                 _M_current;
+      const _CharT*                 _M_end;
       _CtypeT&                      _M_ctype;
       _StringT                      _M_value;
       void (_Scanner::* _M_eat_escape)();
diff --git a/libstdc++-v3/include/bits/regex_scanner.tcc b/libstdc++-v3/include/bits/regex_scanner.tcc
index a3512083f0e..473dc888a20 100644
--- a/libstdc++-v3/include/bits/regex_scanner.tcc
+++ b/libstdc++-v3/include/bits/regex_scanner.tcc
@@ -54,8 +54,7 @@ namespace __detail
 {
   template<typename _CharT>
     _Scanner<_CharT>::
-    _Scanner(typename _Scanner::_IterT __begin,
-	     typename _Scanner::_IterT __end,
+    _Scanner(const _CharT* __begin, const _CharT* __end,
 	     _FlagT __flags, std::locale __loc)
     : _ScannerBase(__flags),
       _M_current(__begin), _M_end(__end),
@@ -176,6 +175,16 @@ namespace __detail
 	  _M_state = _S_state_in_brace;
 	  _M_token = _S_token_interval_begin;
 	}
+      else if (__builtin_expect(__c == _CharT(0), false))
+	{
+	  if (!_M_is_ecma())
+	    {
+	      __throw_regex_error(regex_constants::_S_null,
+		  "Unexpected null character in regular expression");
+	    }
+	  _M_token = _S_token_ord_char;
+	  _M_value.assign(1, __c);
+	}
       else if (__c != ']' && __c != '}')
 	{
 	  auto __it = _M_token_tbl;
diff --git a/libstdc++-v3/include/bits/std_thread.h b/libstdc++-v3/include/bits/std_thread.h
index 2a500bf1777..976526001c5 100644
--- a/libstdc++-v3/include/bits/std_thread.h
+++ b/libstdc++-v3/include/bits/std_thread.h
@@ -204,7 +204,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 	template<typename... _Args>
 	  _State_impl(_Args&&... __args)
-	  : _M_func{{std::forward<_Args>(__args)...}}
+	  : _M_func(std::forward<_Args>(__args)...)
 	  { }
 
 	void
@@ -238,6 +238,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Tuple>
       struct _Invoker
       {
+	template<typename... _Args>
+	  explicit
+	  _Invoker(_Args&&... __args)
+	  : _M_t(std::forward<_Args>(__args)...)
+	  { }
+
 	_Tuple _M_t;
 
 	template<typename>
diff --git a/libstdc++-v3/include/bits/stl_construct.h b/libstdc++-v3/include/bits/stl_construct.h
index e53ed0d9f91..f14fba0cfb1 100644
--- a/libstdc++-v3/include/bits/stl_construct.h
+++ b/libstdc++-v3/include/bits/stl_construct.h
@@ -116,7 +116,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return;
 	}
 #endif
-      ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...);
+      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
     }
 #else
   template<typename _T1, typename _T2>
@@ -132,7 +132,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _T1>
     inline void
     _Construct_novalue(_T1* __p)
-    { ::new(static_cast<void*>(__p)) _T1; }
+    { ::new((void*)__p) _T1; }
 
   template<typename _ForwardIterator>
     _GLIBCXX20_CONSTEXPR void
diff --git a/libstdc++-v3/include/bits/stl_deque.h b/libstdc++-v3/include/bits/stl_deque.h
index 20c73b4fc3c..8236fe35ce7 100644
--- a/libstdc++-v3/include/bits/stl_deque.h
+++ b/libstdc++-v3/include/bits/stl_deque.h
@@ -353,7 +353,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
       {
 	return difference_type(_S_buffer_size())
-	  * (__x._M_node - __y._M_node - int(__x._M_node != 0))
+	  * (__x._M_node - __y._M_node - bool(__x._M_node))
 	  + (__x._M_cur - __x._M_first)
 	  + (__y._M_last - __y._M_cur);
       }
@@ -365,10 +365,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       template<typename _RefR, typename _PtrR>
 	friend difference_type
 	operator-(const _Self& __x,
-		  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
+		  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
+	_GLIBCXX_NOEXCEPT
 	{
 	  return difference_type(_S_buffer_size())
-	    * (__x._M_node - __y._M_node - int(__x._M_node != 0))
+	    * (__x._M_node - __y._M_node - bool(__x._M_node))
 	    + (__x._M_cur - __x._M_first)
 	    + (__y._M_last - __y._M_cur);
 	}
diff --git a/libstdc++-v3/include/bits/stl_iterator.h b/libstdc++-v3/include/bits/stl_iterator.h
index beeb4ef4c8a..7d5d12e3bcf 100644
--- a/libstdc++-v3/include/bits/stl_iterator.h
+++ b/libstdc++-v3/include/bits/stl_iterator.h
@@ -77,11 +77,12 @@
 # define __cpp_lib_array_constexpr 201803L
 #endif
 
-#if __cplusplus > 201703L
+#if __cplusplus >= 202002L
 # include <compare>
 # include <new>
 # include <bits/exception_defines.h>
 # include <bits/iterator_concepts.h>
+# include <bits/stl_construct.h>
 #endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -537,6 +538,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<=>(const reverse_iterator<_IteratorL>& __x,
 		const reverse_iterator<_IteratorR>& __y)
     { return __y.base() <=> __x.base(); }
+
+  // Additional, non-standard overloads to avoid ambiguities with greedy,
+  // unconstrained overloads in associated namespaces.
+
+  template<typename _Iterator>
+    constexpr bool
+    operator==(const reverse_iterator<_Iterator>& __x,
+	       const reverse_iterator<_Iterator>& __y)
+    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
+    { return __x.base() == __y.base(); }
+
+  template<three_way_comparable _Iterator>
+    constexpr compare_three_way_result_t<_Iterator, _Iterator>
+    operator<=>(const reverse_iterator<_Iterator>& __x,
+		const reverse_iterator<_Iterator>& __y)
+    { return __y.base() <=> __x.base(); }
 #endif // C++20
   ///@}
 
@@ -1113,6 +1130,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		const __normal_iterator<_IteratorR, _Container>& __rhs)
     noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
     { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
+
+  template<typename _Iterator, typename _Container>
+    constexpr bool
+    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
+	       const __normal_iterator<_Iterator, _Container>& __rhs)
+    noexcept(noexcept(__lhs.base() == __rhs.base()))
+    requires requires {
+      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
+    }
+    { return __lhs.base() == __rhs.base(); }
+
+  template<typename _Iterator, typename _Container>
+    constexpr std::__detail::__synth3way_t<_Iterator>
+    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
+		const __normal_iterator<_Iterator, _Container>& __rhs)
+    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
+    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
 #else
    // Forward iterator requirements
   template<typename _IteratorL, typename _IteratorR, typename _Container>
@@ -1588,20 +1622,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
     { return !(__x < __y); }
 
-#if ! (__cplusplus > 201703L && __cpp_lib_concepts)
   // Note: See __normal_iterator operators note from Gaby to understand
   // why we have these extra overloads for some move_iterator operators.
 
-  // These extra overloads are not needed in C++20, because the ones above
-  // are constrained with a requires-clause and so overload resolution will
-  // prefer them to greedy unconstrained function templates.
-
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR bool
     operator==(const move_iterator<_Iterator>& __x,
 	       const move_iterator<_Iterator>& __y)
     { return __x.base() == __y.base(); }
 
+#if __cpp_lib_three_way_comparison
+  template<three_way_comparable _Iterator>
+    constexpr compare_three_way_result_t<_Iterator>
+    operator<=>(const move_iterator<_Iterator>& __x,
+		const move_iterator<_Iterator>& __y)
+    { return __x.base() <=> __y.base(); }
+#else
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR bool
     operator!=(const move_iterator<_Iterator>& __x,
@@ -1697,7 +1733,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _S_noexcept1()
       {
 	if constexpr (is_trivially_default_constructible_v<_Tp>)
-	  return is_nothrow_assignable_v<_Tp, _Up>;
+	  return is_nothrow_assignable_v<_Tp&, _Up>;
 	else
 	  return is_nothrow_constructible_v<_Tp, _Up>;
       }
@@ -1767,19 +1803,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       noexcept(_S_noexcept<const _It2&, const _Sent2&>())
       : _M_valueless(), _M_index(__x._M_index)
       {
+	__glibcxx_assert(__x._M_has_value());
 	if (_M_index == 0)
 	  {
 	    if constexpr (is_trivially_default_constructible_v<_It>)
 	      _M_it = std::move(__x._M_it);
 	    else
-	      ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
+	      std::construct_at(std::__addressof(_M_it), __x._M_it);
 	  }
 	else if (_M_index == 1)
 	  {
 	    if constexpr (is_trivially_default_constructible_v<_Sent>)
 	      _M_sent = std::move(__x._M_sent);
 	    else
-	      ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
+	      std::construct_at(std::__addressof(_M_sent), __x._M_sent);
 	  }
       }
 
@@ -1787,31 +1824,75 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     common_iterator(const common_iterator& __x)
     noexcept(_S_noexcept<const _It&, const _Sent&>())
     : _M_valueless(), _M_index(__x._M_index)
+    {
+      if (_M_index == 0)
+	{
+	  if constexpr (is_trivially_default_constructible_v<_It>)
+	    _M_it = __x._M_it;
+	  else
+	    std::construct_at(std::__addressof(_M_it), __x._M_it);
+	}
+      else if (_M_index == 1)
+	{
+	  if constexpr (is_trivially_default_constructible_v<_Sent>)
+	    _M_sent = __x._M_sent;
+	  else
+	    std::construct_at(std::__addressof(_M_sent), __x._M_sent);
+	}
+    }
+
+    constexpr
+    common_iterator(common_iterator&& __x)
+    noexcept(_S_noexcept<_It, _Sent>())
+    : _M_valueless(), _M_index(__x._M_index)
     {
       if (_M_index == 0)
 	{
 	  if constexpr (is_trivially_default_constructible_v<_It>)
 	    _M_it = std::move(__x._M_it);
 	  else
-	    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
+	    std::construct_at(std::__addressof(_M_it), std::move(__x._M_it));
 	}
       else if (_M_index == 1)
 	{
 	  if constexpr (is_trivially_default_constructible_v<_Sent>)
 	    _M_sent = std::move(__x._M_sent);
 	  else
-	    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
+	    std::construct_at(std::__addressof(_M_sent),
+			      std::move(__x._M_sent));
 	}
     }
 
-    common_iterator&
+    constexpr common_iterator&
+    operator=(const common_iterator&) = default;
+
+    constexpr common_iterator&
     operator=(const common_iterator& __x)
     noexcept(is_nothrow_copy_assignable_v<_It>
 	     && is_nothrow_copy_assignable_v<_Sent>
 	     && is_nothrow_copy_constructible_v<_It>
 	     && is_nothrow_copy_constructible_v<_Sent>)
+    requires (!is_trivially_copy_assignable_v<_It>
+		|| !is_trivially_copy_assignable_v<_Sent>)
     {
-      return this->operator=<_It, _Sent>(__x);
+      _M_assign(__x);
+      return *this;
+    }
+
+    constexpr common_iterator&
+    operator=(common_iterator&&) = default;
+
+    constexpr common_iterator&
+    operator=(common_iterator&& __x)
+    noexcept(is_nothrow_move_assignable_v<_It>
+	     && is_nothrow_move_assignable_v<_Sent>
+	     && is_nothrow_move_constructible_v<_It>
+	     && is_nothrow_move_constructible_v<_Sent>)
+    requires (!is_trivially_move_assignable_v<_It>
+		|| !is_trivially_move_assignable_v<_Sent>)
+    {
+      _M_assign(std::move(__x));
+      return *this;
     }
 
     template<typename _It2, typename _Sent2>
@@ -1819,72 +1900,45 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	&& convertible_to<const _Sent2&, _Sent>
 	&& assignable_from<_It&, const _It2&>
 	&& assignable_from<_Sent&, const _Sent2&>
-      common_iterator&
+      constexpr common_iterator&
       operator=(const common_iterator<_It2, _Sent2>& __x)
       noexcept(is_nothrow_constructible_v<_It, const _It2&>
 	       && is_nothrow_constructible_v<_Sent, const _Sent2&>
-	       && is_nothrow_assignable_v<_It, const _It2&>
-	       && is_nothrow_assignable_v<_Sent, const _Sent2&>)
+	       && is_nothrow_assignable_v<_It&, const _It2&>
+	       && is_nothrow_assignable_v<_Sent&, const _Sent2&>)
       {
-	switch(_M_index << 2 | __x._M_index)
-	  {
-	  case 0b0000:
-	    _M_it = __x._M_it;
-	    break;
-	  case 0b0101:
-	    _M_sent = __x._M_sent;
-	    break;
-	  case 0b0001:
-	    _M_it.~_It();
-	    _M_index = -1;
-	    [[fallthrough]];
-	  case 0b1001:
-	    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
-	    _M_index = 1;
-	    break;
-	  case 0b0100:
-	    _M_sent.~_Sent();
-	    _M_index = -1;
-	    [[fallthrough]];
-	  case 0b1000:
-	    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
-	    _M_index = 0;
-	    break;
-	  default:
-	    __glibcxx_assert(__x._M_has_value());
-	    __builtin_unreachable();
-	  }
+	__glibcxx_assert(__x._M_has_value());
+	_M_assign(__x);
 	return *this;
       }
 
+    constexpr
     ~common_iterator()
     {
-      switch (_M_index)
-	{
-	case 0:
-	  _M_it.~_It();
-	  break;
-	case 1:
-	  _M_sent.~_Sent();
-	  break;
-	}
+      if (_M_index == 0)
+	_M_it.~_It();
+      else if (_M_index == 1)
+	_M_sent.~_Sent();
     }
 
-    decltype(auto)
+    [[nodiscard]]
+    constexpr decltype(auto)
     operator*()
     {
       __glibcxx_assert(_M_index == 0);
       return *_M_it;
     }
 
-    decltype(auto)
+    [[nodiscard]]
+    constexpr decltype(auto)
     operator*() const requires __detail::__dereferenceable<const _It>
     {
       __glibcxx_assert(_M_index == 0);
       return *_M_it;
     }
 
-    decltype(auto)
+    [[nodiscard]]
+    constexpr auto
     operator->() const requires __detail::__common_iter_has_arrow<_It>
     {
       __glibcxx_assert(_M_index == 0);
@@ -1899,7 +1953,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return __arrow_proxy{*_M_it};
     }
 
-    common_iterator&
+    constexpr common_iterator&
     operator++()
     {
       __glibcxx_assert(_M_index == 0);
@@ -1907,7 +1961,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return *this;
     }
 
-    decltype(auto)
+    constexpr decltype(auto)
     operator++(int)
     {
       __glibcxx_assert(_M_index == 0);
@@ -1929,9 +1983,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     template<typename _It2, sentinel_for<_It> _Sent2>
       requires sentinel_for<_Sent, _It2>
-      friend bool
-      operator==(const common_iterator& __x,
-		 const common_iterator<_It2, _Sent2>& __y)
+      friend constexpr bool
+      operator== [[nodiscard]] (const common_iterator& __x,
+				const common_iterator<_It2, _Sent2>& __y)
       {
 	switch(__x._M_index << 2 | __y._M_index)
 	  {
@@ -1951,9 +2005,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     template<typename _It2, sentinel_for<_It> _Sent2>
       requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
-      friend bool
-      operator==(const common_iterator& __x,
-		 const common_iterator<_It2, _Sent2>& __y)
+      friend constexpr bool
+      operator== [[nodiscard]] (const common_iterator& __x,
+				const common_iterator<_It2, _Sent2>& __y)
       {
 	switch(__x._M_index << 2 | __y._M_index)
 	  {
@@ -1974,9 +2028,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
       requires sized_sentinel_for<_Sent, _It2>
-      friend iter_difference_t<_It2>
-      operator-(const common_iterator& __x,
-		const common_iterator<_It2, _Sent2>& __y)
+      friend constexpr iter_difference_t<_It2>
+      operator- [[nodiscard]] (const common_iterator& __x,
+			       const common_iterator<_It2, _Sent2>& __y)
       {
 	switch(__x._M_index << 2 | __y._M_index)
 	  {
@@ -1995,7 +2049,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  }
       }
 
-    friend iter_rvalue_reference_t<_It>
+    [[nodiscard]]
+    friend constexpr iter_rvalue_reference_t<_It>
     iter_move(const common_iterator& __i)
     noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
     requires input_iterator<_It>
@@ -2005,7 +2060,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
     template<indirectly_swappable<_It> _It2, typename _Sent2>
-      friend void
+      friend constexpr void
       iter_swap(const common_iterator& __x,
 		const common_iterator<_It2, _Sent2>& __y)
       noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
@@ -2018,9 +2073,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   private:
     template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
+      requires (!same_as<_It2, _Sent2>) && copyable<_It2>
       friend class common_iterator;
 
-    bool _M_has_value() const noexcept { return _M_index < 2; }
+    constexpr bool
+    _M_has_value() const noexcept { return _M_index != _S_valueless; }
+
+    template<typename _CIt>
+      constexpr void
+      _M_assign(_CIt&& __x)
+      {
+	if (_M_index == __x._M_index)
+	  {
+	    if (_M_index == 0)
+	      _M_it = std::forward<_CIt>(__x)._M_it;
+	    else if (_M_index == 1)
+	      _M_sent = std::forward<_CIt>(__x)._M_sent;
+	  }
+	else
+	  {
+	    if (_M_index == 0)
+	      _M_it.~_It();
+	    else if (_M_index == 1)
+	      _M_sent.~_Sent();
+	    _M_index = _S_valueless;
+
+	    if (__x._M_index == 0)
+	      std::construct_at(std::__addressof(_M_it),
+				std::forward<_CIt>(__x)._M_it);
+	    else if (__x._M_index == 1)
+	      std::construct_at(std::__addressof(_M_sent),
+				std::forward<_CIt>(__x)._M_sent);
+	    _M_index = __x._M_index;
+	  }
+      }
 
     union
     {
@@ -2028,7 +2114,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _Sent _M_sent;
       unsigned char _M_valueless;
     };
-    unsigned char _M_index; // 0==_M_it, 1==_M_sent, 2==valueless
+    unsigned char _M_index; // 0 == _M_it, 1 == _M_sent, 2 == valueless
+
+    static constexpr unsigned char _S_valueless{2};
   };
 
   template<typename _It, typename _Sent>
@@ -2188,7 +2276,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return *this;
       }
 
-      decltype(auto)
+      constexpr decltype(auto)
       operator++(int)
       {
 	__glibcxx_assert(_M_length > 0);
@@ -2200,7 +2288,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    ++_M_length;
 	    __throw_exception_again;
 	  }
-
       }
 
       constexpr counted_iterator
diff --git a/libstdc++-v3/include/bits/stl_list.h b/libstdc++-v3/include/bits/stl_list.h
index dbe05a9834b..2c70adf2b93 100644
--- a/libstdc++-v3/include/bits/stl_list.h
+++ b/libstdc++-v3/include/bits/stl_list.h
@@ -1,6 +1,7 @@
 // List implementation -*- C++ -*-
 
 // Copyright (C) 2001-2021 Free Software Foundation, Inc.
+// Copyright The GNU Toolchain Authors.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -1966,6 +1967,40 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 			     __false_type{});
       }
 #endif
+
+#if _GLIBCXX_USE_CXX11_ABI
+      // Update _M_size members after merging (some of) __src into __dest.
+      struct _Finalize_merge
+      {
+	explicit
+	_Finalize_merge(list& __dest, list& __src, const iterator& __src_next)
+	: _M_dest(__dest), _M_src(__src), _M_next(__src_next)
+	{ }
+
+	~_Finalize_merge()
+	{
+	  // For the common case, _M_next == _M_sec.end() and the std::distance
+	  // call is fast. But if any *iter1 < *iter2 comparison throws then we
+	  // have to count how many elements remain in _M_src.
+	  const size_t __num_unmerged = std::distance(_M_next, _M_src.end());
+	  const size_t __orig_size = _M_src._M_get_size();
+	  _M_dest._M_inc_size(__orig_size - __num_unmerged);
+	  _M_src._M_set_size(__num_unmerged);
+	}
+
+	list& _M_dest;
+	list& _M_src;
+	const iterator& _M_next;
+
+#if __cplusplus >= 201103L
+	_Finalize_merge(const _Finalize_merge&) = delete;
+#endif
+      };
+#else
+      struct _Finalize_merge
+      { explicit _Finalize_merge(list&, list&, const iterator&) { } };
+#endif
+
     };
 
 #if __cpp_deduction_guides >= 201606
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 1cc1b3bf686..830b51e45a0 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -140,10 +140,10 @@ namespace __detail
     inline _Source
     _S_range_begin(_Source __begin) { return __begin; }
 
-  struct __null_terminated { };
+  struct __nul_terminated { };
 
   template<typename _Source>
-    inline __null_terminated
+    inline __nul_terminated
     _S_range_end(_Source) { return {}; }
 
   template<typename _CharT, typename _Traits, typename _Alloc>
@@ -425,8 +425,8 @@ namespace __detail
     class iterator;
     typedef iterator const_iterator;
 
-    iterator begin() const noexcept;
-    iterator end() const noexcept;
+    iterator begin() const;
+    iterator end() const;
 
     /// @cond undocumented
     // Create a basic_string by reading until a null character.
@@ -473,11 +473,11 @@ namespace __detail
       struct _Cvt;
 
     static string_type
-    _S_convert(value_type* __src, __detail::__null_terminated)
+    _S_convert(value_type* __src, __detail::__nul_terminated)
     { return string_type(__src); }
 
     static string_type
-    _S_convert(const value_type* __src, __detail::__null_terminated)
+    _S_convert(const value_type* __src, __detail::__nul_terminated)
     { return string_type(__src); }
 
     template<typename _Iter>
@@ -491,7 +491,7 @@ namespace __detail
 
     template<typename _InputIterator>
       static string_type
-      _S_convert(_InputIterator __src, __detail::__null_terminated)
+      _S_convert(_InputIterator __src, __detail::__nul_terminated)
       {
 	auto __s = _S_string_from_iter(__src);
 	return _S_convert(__s.c_str(), __s.c_str() + __s.size());
@@ -518,7 +518,7 @@ namespace __detail
 
     template<typename _InputIterator>
       static string_type
-      _S_convert_loc(_InputIterator __src, __detail::__null_terminated,
+      _S_convert_loc(_InputIterator __src, __detail::__nul_terminated,
 		     const std::locale& __loc)
       {
 	const std::string __s = _S_string_from_iter(__src);
diff --git a/libstdc++-v3/include/experimental/bits/simd.h b/libstdc++-v3/include/experimental/bits/simd.h
index 421c923e7b0..0e58ae01b17 100644
--- a/libstdc++-v3/include/experimental/bits/simd.h
+++ b/libstdc++-v3/include/experimental/bits/simd.h
@@ -2303,17 +2303,23 @@ template <typename _Tp>
   template <>                                                                  \
     struct __intrinsic_type_impl<_Tp> { using type = __vector _Tp; }
 _GLIBCXX_SIMD_PPC_INTRIN(float);
+#ifdef __VSX__
 _GLIBCXX_SIMD_PPC_INTRIN(double);
+#endif
 _GLIBCXX_SIMD_PPC_INTRIN(signed char);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned char);
 _GLIBCXX_SIMD_PPC_INTRIN(signed short);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned short);
 _GLIBCXX_SIMD_PPC_INTRIN(signed int);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned int);
+#if defined __VSX__ || __SIZEOF_LONG__ == 4
 _GLIBCXX_SIMD_PPC_INTRIN(signed long);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned long);
+#endif
+#ifdef __VSX__
 _GLIBCXX_SIMD_PPC_INTRIN(signed long long);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned long long);
+#endif
 #undef _GLIBCXX_SIMD_PPC_INTRIN
 
 template <typename _Tp, size_t _Bytes>
@@ -2323,10 +2329,11 @@ template <typename _Tp, size_t _Bytes>
     static constexpr bool _S_is_ldouble = is_same_v<_Tp, long double>;
     // allow _Tp == long double with -mlong-double-64
     static_assert(!(_S_is_ldouble && sizeof(long double) > sizeof(double)),
-		  "no __intrinsic_type support for long double on PPC");
+		  "no __intrinsic_type support for 128-bit floating point on PowerPC");
 #ifndef __VSX__
-    static_assert(!is_same_v<_Tp, double>,
-		  "no __intrinsic_type support for double on PPC w/o VSX");
+    static_assert(!(is_same_v<_Tp, double>
+		    || (_S_is_ldouble && sizeof(long double) == sizeof(double))),
+		  "no __intrinsic_type support for 64-bit floating point on PowerPC w/o VSX");
 #endif
     using type =
       typename __intrinsic_type_impl<
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index 6ce070ae775..07eb137fb80 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -441,13 +441,15 @@ namespace ip
     // constructors:
     constexpr address() noexcept : _M_v4(), _M_is_v4(true) { }
 
+#if __cpp_constexpr_dynamic_alloc
     constexpr
+#endif
     address(const address& __a) noexcept : _M_uninit(), _M_is_v4(__a._M_is_v4)
     {
       if (_M_is_v4)
-	::new (std::addressof(_M_v4)) address_v4(__a.to_v4());
+	std::_Construct(std::addressof(_M_v4), __a.to_v4());
       else
-	::new (std::addressof(_M_v6)) address_v6(__a.to_v6());
+	std::_Construct(std::addressof(_M_v6), __a.to_v6());
     }
 
     constexpr
@@ -470,7 +472,7 @@ namespace ip
     address&
     operator=(const address_v4& __a) noexcept
     {
-      ::new (std::addressof(_M_v4)) address_v4(__a);
+      std::_Construct(std::addressof(_M_v4), __a);
       _M_is_v4 = true;
       return *this;
     }
@@ -478,7 +480,7 @@ namespace ip
     address&
     operator=(const address_v6& __a) noexcept
     {
-      ::new (std::addressof(_M_v6)) address_v6(__a);
+      std::_Construct(std::addressof(_M_v6), __a);
       _M_is_v4 = false;
       return *this;
     }
diff --git a/libstdc++-v3/include/std/atomic b/libstdc++-v3/include/std/atomic
index fdffacc35df..22faf82edde 100644
--- a/libstdc++-v3/include/std/atomic
+++ b/libstdc++-v3/include/std/atomic
@@ -172,11 +172,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { _M_base.notify_one(); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { _M_base.notify_all(); }
 #endif // __cpp_lib_atomic_wait
   };
@@ -320,6 +320,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
 			    memory_order __f) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -330,6 +332,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
 			    memory_order __f) volatile noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -352,6 +356,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
 			      memory_order __f) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -362,6 +368,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
 			      memory_order __f) volatile noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -391,11 +399,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { std::__atomic_notify_address(&_M_i, false); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { std::__atomic_notify_address(&_M_i, true); }
 #endif // __cpp_lib_atomic_wait 
 
@@ -645,11 +653,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { _M_b.notify_one(); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { _M_b.notify_all(); }
 #endif // __cpp_lib_atomic_wait
       __pointer_type
@@ -1228,9 +1236,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   atomic_flag_clear(volatile atomic_flag* __a) noexcept
   { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }
 
-
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 3220. P0558 broke conforming C++14 uses of atomic shared_ptr
   template<typename _Tp>
-    using __atomic_val_t = typename atomic<_Tp>::value_type;
+    using __atomic_val_t = __type_identity_t<_Tp>;
   template<typename _Tp>
     using __atomic_diff_t = typename atomic<_Tp>::difference_type;
 
@@ -1421,12 +1430,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _Tp>
     inline void
-    atomic_notify_one(const atomic<_Tp>* __a) noexcept
+    atomic_notify_one(atomic<_Tp>* __a) noexcept
     { __a->notify_one(); }
 
   template<typename _Tp>
     inline void
-    atomic_notify_all(const atomic<_Tp>* __a) noexcept
+    atomic_notify_all(atomic<_Tp>* __a) noexcept
     { __a->notify_all(); }
 #endif // __cpp_lib_atomic_wait
 
diff --git a/libstdc++-v3/include/std/charconv b/libstdc++-v3/include/std/charconv
index 8572e376c92..65f923993fa 100644
--- a/libstdc++-v3/include/std/charconv
+++ b/libstdc++-v3/include/std/charconv
@@ -39,7 +39,6 @@
 
 #include <type_traits>
 #include <bit>			// for __bit_width
-#include <cctype>		// for isdigit
 #include <bits/charconv.h>	// for __to_chars_len, __to_chars_10_impl
 #include <bits/error_constants.h> // for std::errc
 #include <ext/numeric_traits.h>
@@ -466,7 +465,7 @@ namespace __detail
       return true;
     }
 
-  constexpr unsigned char
+  constexpr char
   __from_chars_alpha_to_num(char __c)
   {
     switch (__c)
@@ -550,10 +549,10 @@ namespace __detail
     case 'Z':
       return 35;
     }
-    return __gnu_cxx::__int_traits<unsigned char>::__max;
+    return 127;
   }
 
-  /// std::from_chars implementation for integers in bases 11 to 26.
+  /// std::from_chars implementation for integers in bases 11 to 36.
   template<typename _Tp>
     bool
     __from_chars_alnum(const char*& __first, const char* __last, _Tp& __val,
@@ -562,8 +561,8 @@ namespace __detail
       bool __valid = true;
       while (__first != __last)
 	{
-	  unsigned char __c = *__first;
-	  if (std::isdigit(__c))
+	  char __c = *__first;
+	  if ('0' <= __c && __c <= '9') // isdigit
 	    __c -= '0';
 	  else
 	    {
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 09e54c3703b..7aa243eb625 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -139,34 +139,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     deferred = 2
   };
 
-  constexpr launch operator&(launch __x, launch __y)
+  constexpr launch operator&(launch __x, launch __y) noexcept
   {
     return static_cast<launch>(
 	static_cast<int>(__x) & static_cast<int>(__y));
   }
 
-  constexpr launch operator|(launch __x, launch __y)
+  constexpr launch operator|(launch __x, launch __y) noexcept
   {
     return static_cast<launch>(
 	static_cast<int>(__x) | static_cast<int>(__y));
   }
 
-  constexpr launch operator^(launch __x, launch __y)
+  constexpr launch operator^(launch __x, launch __y) noexcept
   {
     return static_cast<launch>(
 	static_cast<int>(__x) ^ static_cast<int>(__y));
   }
 
-  constexpr launch operator~(launch __x)
+  constexpr launch operator~(launch __x) noexcept
   { return static_cast<launch>(~static_cast<int>(__x)); }
 
-  inline launch& operator&=(launch& __x, launch __y)
+  inline launch& operator&=(launch& __x, launch __y) noexcept
   { return __x = __x & __y; }
 
-  inline launch& operator|=(launch& __x, launch __y)
+  inline launch& operator|=(launch& __x, launch __y) noexcept
   { return __x = __x | __y; }
 
-  inline launch& operator^=(launch& __x, launch __y)
+  inline launch& operator^=(launch& __x, launch __y) noexcept
   { return __x = __x ^ __y; }
 
   /// Status code for futures
@@ -1621,6 +1621,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
     };
 
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 3117. Missing packaged_task deduction guides
+#if __cpp_deduction_guides >= 201606
+  template<typename _Res, typename... _ArgTypes>
+    packaged_task(_Res(*)(_ArgTypes...)) -> packaged_task<_Res(_ArgTypes...)>;
+
+  template<typename _Fun, typename _Signature = typename
+	   __function_guide_helper<decltype(&_Fun::operator())>::type>
+    packaged_task(_Fun) -> packaged_task<_Signature>;
+#endif
+
   /// swap
   template<typename _Res, typename... _ArgTypes>
     inline void
@@ -1647,7 +1658,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	explicit
 	_Deferred_state(_Args&&... __args)
 	: _M_result(new _Result<_Res>()),
-	  _M_fn{{std::forward<_Args>(__args)...}}
+	  _M_fn(std::forward<_Args>(__args)...)
 	{ }
 
     private:
@@ -1714,7 +1725,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	explicit
 	_Async_state_impl(_Args&&... __args)
 	: _M_result(new _Result<_Res>()),
-	  _M_fn{{std::forward<_Args>(__args)...}}
+	  _M_fn(std::forward<_Args>(__args)...)
 	{
 	  _M_thread = std::thread{&_Async_state_impl::_M_run, this};
 	}
diff --git a/libstdc++-v3/include/std/iosfwd b/libstdc++-v3/include/std/iosfwd
index 52fa4b6cccb..610383992fb 100644
--- a/libstdc++-v3/include/std/iosfwd
+++ b/libstdc++-v3/include/std/iosfwd
@@ -207,6 +207,24 @@ _GLIBCXX_END_NAMESPACE_CXX11
   /// Class for @c wchar_t mixed input and output file streams.
   typedef basic_fstream<wchar_t> 	wfstream;
 #endif
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+           typename _Allocator = allocator<_CharT>>
+    class basic_syncbuf;
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+           typename _Allocator = allocator<_CharT>>
+    class basic_osyncstream;
+
+  using syncbuf = basic_syncbuf<char>;
+  using osyncstream = basic_osyncstream<char>;
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  using wsyncbuf = basic_syncbuf<wchar_t>;
+  using wosyncstream = basic_osyncstream<wchar_t>;
+#endif
+#endif // C++20 && CXX11_ABI
+
   /** @}  */
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/std/istream b/libstdc++-v3/include/std/istream
index 5ad60dbd709..109564b3c0d 100644
--- a/libstdc++-v3/include/std/istream
+++ b/libstdc++-v3/include/std/istream
@@ -784,7 +784,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  - if `width()` is greater than zero, `n` is `min(width(), n)`
    *  - otherwise `n` is the number of elements of the array
    *  - (before C++20 the pointer is assumed to point to an array of
-   *  - the largest possible size for an array of `char_type`).
+   *    the largest possible size for an array of `char_type`).
    *
    *  Characters are extracted and stored until one of the following happens:
    *  - `n - 1` characters are stored
@@ -802,19 +802,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_istream<_CharT, _Traits>&
     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
     {
+#ifdef __OPTIMIZE__
+      // Function inlining might make the buffer size known, allowing us to
+      // prevent overflow.
       size_t __n = __builtin_object_size(__s, 0);
-      if (__builtin_expect(__n < sizeof(_CharT), false))
+      if (__n < sizeof(_CharT))
 	{
 	  // There is not even space for the required null terminator.
 	  __glibcxx_assert(__n >= sizeof(_CharT));
+	  // No point calling __istream_extract, but still need to reset width.
 	  __in.width(0);
 	  __in.setstate(ios_base::failbit);
 	}
+      else if (__n != (size_t)-1)
+	{
+	  __n /= sizeof(_CharT);
+	  streamsize __w = __in.width();
+	  std::__istream_extract(__in, __s, __n);
+	  if (__in.good() && (__w <= 0 || __n < __w))
+	    {
+	      // Stopped extracting early to avoid overflowing the buffer,
+	      // but might have stopped anyway (and set eofbit) if at EOF.
+	      const typename _Traits::int_type __c = __in.rdbuf()->sgetc();
+	      const bool __eof = _Traits::eq_int_type(__c, _Traits::eof());
+	      if (__builtin_expect(__eof, true)) // Assume EOF, not overflow.
+		__in.setstate(ios_base::eofbit);
+	    }
+	}
       else
+#endif // __OPTIMIZE
 	{
-	  if (__n == (size_t)-1)
-	    __n = __gnu_cxx::__numeric_traits<streamsize>::__max;
-	  std::__istream_extract(__in, __s, __n / sizeof(_CharT));
+	  // Buffer size is unknown, have to assume it's huge.
+	  streamsize __n = __gnu_cxx::__numeric_traits<streamsize>::__max;
+	  __n /= sizeof(_CharT);
+	  std::__istream_extract(__in, __s, __n);
 	}
       return __in;
     }
diff --git a/libstdc++-v3/include/std/ranges b/libstdc++-v3/include/std/ranges
index f55ee15e1b1..0a67c45f1b8 100644
--- a/libstdc++-v3/include/std/ranges
+++ b/libstdc++-v3/include/std/ranges
@@ -200,7 +200,7 @@ namespace ranges
     class single_view : public view_interface<single_view<_Tp>>
     {
     public:
-      single_view() requires default_initializable<_Tp> = default;
+      single_view() = default;
 
       constexpr explicit
       single_view(const _Tp& __t)
@@ -1463,9 +1463,7 @@ namespace views::__adaptor
       _Vp _M_base = _Vp();
 
     public:
-      filter_view() requires (default_initializable<_Vp>
-			      && default_initializable<_Pred>)
-	= default;
+      filter_view() requires default_initializable<_Vp> = default;
 
       constexpr
       filter_view(_Vp __base, _Pred __pred)
@@ -1829,9 +1827,7 @@ namespace views::__adaptor
       _Vp _M_base = _Vp();
 
     public:
-      transform_view() requires (default_initializable<_Vp>
-				 && default_initializable<_Fp>)
-	= default;
+      transform_view() requires default_initializable<_Vp> = default;
 
       constexpr
       transform_view(_Vp __base, _Fp __fun)
@@ -2150,9 +2146,7 @@ namespace views::__adaptor
       _Vp _M_base = _Vp();
 
     public:
-      take_while_view() requires (default_initializable<_Vp>
-				  && default_initializable<_Pred>)
-	= default;
+      take_while_view() requires default_initializable<_Vp> = default;
 
       constexpr
       take_while_view(_Vp base, _Pred __pred)
@@ -2356,9 +2350,7 @@ namespace views::__adaptor
       _Vp _M_base = _Vp();
 
     public:
-      drop_while_view() requires (default_initializable<_Vp>
-				  && default_initializable<_Pred>)
-	= default;
+      drop_while_view() requires default_initializable<_Vp> = default;
 
       constexpr
       drop_while_view(_Vp __base, _Pred __pred)
@@ -2916,7 +2908,7 @@ namespace views::__adaptor
 	    { return _InnerIter<_Const>{_M_i}; }
 
 	    constexpr default_sentinel_t
-	    end() const
+	    end() const noexcept
 	    { return default_sentinel; }
 	  };
 
diff --git a/libstdc++-v3/include/std/source_location b/libstdc++-v3/include/std/source_location
index 6cf6d7949cf..647ca0b9e3d 100644
--- a/libstdc++-v3/include/std/source_location
+++ b/libstdc++-v3/include/std/source_location
@@ -43,12 +43,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   {
   private:
     using uint_least32_t = __UINT_LEAST32_TYPE__;
+    struct __impl
+    {
+      const char* _M_file_name;
+      const char* _M_function_name;
+      unsigned _M_line;
+      unsigned _M_column;
+    };
+    using __builtin_ret_type = decltype(__builtin_source_location());
 
   public:
 
     // [support.srcloc.cons], creation
     static consteval source_location
-    current(const void* __p = __builtin_source_location()) noexcept
+    current(__builtin_ret_type __p = __builtin_source_location()) noexcept
     {
       source_location __ret;
       __ret._M_impl = static_cast <const __impl*>(__p);
@@ -75,14 +83,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return _M_impl ? _M_impl->_M_function_name : ""; }
 
   private:
-    struct __impl
-    {
-      const char* _M_file_name;
-      const char* _M_function_name;
-      unsigned _M_line;
-      unsigned _M_column;
-    };
-
     const __impl* _M_impl = nullptr;
   };
 
diff --git a/libstdc++-v3/include/std/span b/libstdc++-v3/include/std/span
index af0d24b29f2..2adf1ca2e09 100644
--- a/libstdc++-v3/include/std/span
+++ b/libstdc++-v3/include/std/span
@@ -201,11 +201,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{ }
 
       template<typename _Range>
-	requires ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
-	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
-	  && (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
+	requires (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
 	  && (!__detail::__is_std_array<remove_cvref_t<_Range>>::value)
 	  && (!is_array_v<remove_cvref_t<_Range>>)
+	  && ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
+	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
 	  && __is_compatible_ref<ranges::range_reference_t<_Range>>::value
 	constexpr explicit(extent != dynamic_extent)
 	span(_Range&& __range)
diff --git a/libstdc++-v3/include/std/sstream b/libstdc++-v3/include/std/sstream
index f21664100ab..56555ecd98a 100644
--- a/libstdc++-v3/include/std/sstream
+++ b/libstdc++-v3/include/std/sstream
@@ -425,6 +425,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       // This might not be the same character as _M_string.end() because
       // basic_stringbuf::overflow might have written to unused capacity
       // in _M_string without updating its length.
+      __attribute__((__always_inline__))
       char_type*
       _M_high_mark() const _GLIBCXX_NOEXCEPT
       {
diff --git a/libstdc++-v3/include/std/string_view b/libstdc++-v3/include/std/string_view
index d8cbee9bee0..68df70e99f1 100644
--- a/libstdc++-v3/include/std/string_view
+++ b/libstdc++-v3/include/std/string_view
@@ -160,7 +160,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      })
 	  && (!requires { typename _DRange::traits_type; }
 	      || is_same_v<typename _DRange::traits_type, _Traits>)
-	constexpr
+	constexpr explicit
 	basic_string_view(_Range&& __r)
 	noexcept(noexcept(ranges::size(__r)) && noexcept(ranges::data(__r)))
 	: _M_len(ranges::size(__r)), _M_str(ranges::data(__r))
diff --git a/libstdc++-v3/include/std/syncstream b/libstdc++-v3/include/std/syncstream
index db6ebd50471..ac39d0f2243 100644
--- a/libstdc++-v3/include/std/syncstream
+++ b/libstdc++-v3/include/std/syncstream
@@ -50,8 +50,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  template<typename _CharT, typename _Traits = char_traits<_CharT>,
-	    typename _Alloc = allocator<_CharT>>
+  template<typename _CharT, typename _Traits, typename _Alloc>
     class basic_syncbuf : public __syncbuf_base<_CharT, _Traits>
     {
     public:
@@ -241,8 +240,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __mutex _M_mtx;
     };
 
-  template <typename _CharT, typename _Traits = char_traits<_CharT>,
-	    typename _Alloc = allocator<_CharT>>
+  template <typename _CharT, typename _Traits, typename _Alloc>
     class basic_osyncstream : public basic_ostream<_CharT, _Traits>
     {
       using __ostream_type = basic_ostream<_CharT, _Traits>;
diff --git a/libstdc++-v3/include/std/tuple b/libstdc++-v3/include/std/tuple
index dcf30bd9a8d..63bd68fbe43 100644
--- a/libstdc++-v3/include/std/tuple
+++ b/libstdc++-v3/include/std/tuple
@@ -553,10 +553,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<bool, typename... _Types>
     struct _TupleConstraints
     {
-      template<typename _Tp, typename _Up> // Workaround for PR 96592
-	using is_constructible
-	  = __bool_constant<__is_constructible(_Tp, _Up)>;
-
       // Constraint for a non-explicit constructor.
       // True iff each Ti in _Types... can be constructed from Ui in _UTypes...
       // and every Ui is implicitly convertible to Ti.
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index c0585cb5999..285c5be6521 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -435,13 +435,6 @@ namespace __variant
       ~_Variant_storage()
       { _M_reset(); }
 
-      void*
-      _M_storage() const noexcept
-      {
-	return const_cast<void*>(static_cast<const void*>(
-	    std::addressof(_M_u)));
-      }
-
       constexpr bool
       _M_valid() const noexcept
       {
@@ -473,13 +466,6 @@ namespace __variant
       void _M_reset() noexcept
       { _M_index = static_cast<__index_type>(variant_npos); }
 
-      void*
-      _M_storage() const noexcept
-      {
-	return const_cast<void*>(static_cast<const void*>(
-	    std::addressof(_M_u)));
-      }
-
       constexpr bool
       _M_valid() const noexcept
       {
@@ -804,11 +790,6 @@ namespace __variant
     : _FUN_type<_Tp, _Variant>
     { };
 
-  // Returns the raw storage for __v.
-  template<typename _Variant>
-    void* __get_storage(_Variant&& __v) noexcept
-    { return __v._M_storage(); }
-
   template <typename _Maybe_variant_cookie, typename _Variant>
     struct _Extra_visit_slot_needed
     {
@@ -1108,19 +1089,21 @@ namespace __variant
 	>;
     }
 
-} // namespace __variant
-} // namespace __detail
-
   template<size_t _Np, typename _Variant, typename... _Args>
-    void __variant_construct_by_index(_Variant& __v, _Args&&... __args)
+    inline void
+    __construct_by_index(_Variant& __v, _Args&&... __args)
     {
-      __v._M_index = _Np;
       auto&& __storage = __detail::__variant::__get<_Np>(__v);
       ::new ((void*)std::addressof(__storage))
         remove_reference_t<decltype(__storage)>
 	  (std::forward<_Args>(__args)...);
+      // Construction didn't throw, so can set the new index now:
+      __v._M_index = _Np;
     }
 
+} // namespace __variant
+} // namespace __detail
+
   template<typename _Tp, typename... _Types>
     constexpr bool
     holds_alternative(const variant<_Types...>& __v) noexcept
@@ -1356,8 +1339,9 @@ namespace __variant
       template <typename... _UTypes, typename _Tp>
 	friend decltype(auto) __variant_cast(_Tp&&);
       template<size_t _Np, typename _Variant, typename... _Args>
-	friend void __variant_construct_by_index(_Variant& __v,
-						 _Args&&... __args);
+	friend void
+	__detail::__variant::__construct_by_index(_Variant& __v,
+						  _Args&&... __args);
 
       static_assert(sizeof...(_Types) > 0,
 		    "variant must have at least one alternative");
@@ -1521,12 +1505,13 @@ namespace __variant
 	  static_assert(_Np < sizeof...(_Types),
 			"The index must be in [0, number of alternatives)");
 	  using type = variant_alternative_t<_Np, variant>;
+	  namespace __variant = std::__detail::__variant;
 	  // Provide the strong exception-safety guarantee when possible,
 	  // to avoid becoming valueless.
 	  if constexpr (is_nothrow_constructible_v<type, _Args...>)
 	    {
 	      this->_M_reset();
-	      __variant_construct_by_index<_Np>(*this,
+	      __variant::__construct_by_index<_Np>(*this,
 		  std::forward<_Args>(__args)...);
 	    }
 	  else if constexpr (is_scalar_v<type>)
@@ -1535,9 +1520,9 @@ namespace __variant
 	      const type __tmp(std::forward<_Args>(__args)...);
 	      // But these steps won't throw:
 	      this->_M_reset();
-	      __variant_construct_by_index<_Np>(*this, __tmp);
+	      __variant::__construct_by_index<_Np>(*this, __tmp);
 	    }
-	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
+	  else if constexpr (__variant::_Never_valueless_alt<type>()
 	      && _Traits::_S_move_assign)
 	    {
 	      // This construction might throw:
@@ -1551,17 +1536,8 @@ namespace __variant
 	      // This case only provides the basic exception-safety guarantee,
 	      // i.e. the variant can become valueless.
 	      this->_M_reset();
-	      __try
-		{
-		  __variant_construct_by_index<_Np>(*this,
-		    std::forward<_Args>(__args)...);
-		}
-	      __catch (...)
-		{
-		  using __index_type = decltype(this->_M_index);
-		  this->_M_index = static_cast<__index_type>(variant_npos);
-		  __throw_exception_again;
-		}
+	      __variant::__construct_by_index<_Np>(*this,
+		std::forward<_Args>(__args)...);
 	    }
 	  return std::get<_Np>(*this);
 	}
@@ -1575,6 +1551,7 @@ namespace __variant
 	  static_assert(_Np < sizeof...(_Types),
 			"The index must be in [0, number of alternatives)");
 	  using type = variant_alternative_t<_Np, variant>;
+	  namespace __variant = std::__detail::__variant;
 	  // Provide the strong exception-safety guarantee when possible,
 	  // to avoid becoming valueless.
 	  if constexpr (is_nothrow_constructible_v<type,
@@ -1582,10 +1559,10 @@ namespace __variant
 						   _Args...>)
 	    {
 	      this->_M_reset();
-	      __variant_construct_by_index<_Np>(*this, __il,
+	      __variant::__construct_by_index<_Np>(*this, __il,
 		  std::forward<_Args>(__args)...);
 	    }
-	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
+	  else if constexpr (__variant::_Never_valueless_alt<type>()
 	      && _Traits::_S_move_assign)
 	    {
 	      // This construction might throw:
@@ -1599,17 +1576,8 @@ namespace __variant
 	      // This case only provides the basic exception-safety guarantee,
 	      // i.e. the variant can become valueless.
 	      this->_M_reset();
-	      __try
-		{
-		  __variant_construct_by_index<_Np>(*this, __il,
-		    std::forward<_Args>(__args)...);
-		}
-	      __catch (...)
-		{
-		  using __index_type = decltype(this->_M_index);
-		  this->_M_index = static_cast<__index_type>(variant_npos);
-		  __throw_exception_again;
-		}
+	      __variant::__construct_by_index<_Np>(*this, __il,
+		std::forward<_Args>(__args)...);
 	    }
 	  return std::get<_Np>(*this);
 	}
@@ -1685,10 +1653,6 @@ namespace __variant
 	friend constexpr decltype(auto)
 	__detail::__variant::__get(_Vp&& __v) noexcept;
 
-      template<typename _Vp>
-	friend void*
-	__detail::__variant::__get_storage(_Vp&& __v) noexcept;
-
 #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP) \
       template<typename... _Tp> \
 	friend constexpr bool \
diff --git a/libstdc++-v3/include/std/version b/libstdc++-v3/include/std/version
index f35b9da2307..e86b94bf9dc 100644
--- a/libstdc++-v3/include/std/version
+++ b/libstdc++-v3/include/std/version
@@ -177,6 +177,9 @@
 #define __cpp_lib_atomic_float 201711L
 #define __cpp_lib_atomic_ref 201806L
 #define __cpp_lib_atomic_value_initialization 201911L
+#if __has_builtin(__builtin_bit_cast)
+# define __cpp_lib_bit_cast 201806L
+#endif
 #define __cpp_lib_bitops 201907L
 #define __cpp_lib_bounded_array_traits 201902L
 // __cpp_lib_char8_t is defined in <bits/c++config.h>
@@ -209,9 +212,6 @@
 # endif
 #endif
 #define __cpp_lib_bind_front 201907L
-#if __has_builtin(__builtin_bit_cast)
-# define __cpp_lib_bit_cast 201806L
-#endif
 // FIXME: #define __cpp_lib_execution 201902L
 #define __cpp_lib_integer_comparison_functions 202002L
 #define __cpp_lib_constexpr_algorithms 201806L
@@ -272,8 +272,10 @@
 #if __cplusplus > 202002L
 // c++2b
 #define __cpp_lib_is_scoped_enum 202011L
+#if _GLIBCXX_HOSTED
 #define __cpp_lib_string_contains 202011L
 #define __cpp_lib_to_underlying 202102L
+#endif
 #endif // C++2b
 #endif // C++20
 #endif // C++17
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 16f4cc6eff4..f92a52748c5 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -267,7 +267,9 @@ CXXLINK = \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CXX) \
 	$(VTV_CXXLINKFLAGS) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) \
+	$(LTLDFLAGS) $(LTLIBICONV) \
+	-o $@
 
 # Symbol versioning for shared libraries.
 if ENABLE_SYMVERS
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index 4df5c829a7f..2fff46209ad 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -631,7 +631,9 @@ CXXLINK = \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CXX) \
 	$(VTV_CXXLINKFLAGS) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) \
+	$(LTLDFLAGS) $(LTLIBICONV) \
+	-o $@
 
 @ENABLE_SYMVERS_TRUE@CLEANFILES = libstdc++-symbols.ver $(version_dep)
 @ENABLE_SYMVERS_DARWIN_TRUE@@ENABLE_SYMVERS_TRUE@version_arg = -Wl,-exported_symbols_list,libstdc++-symbols.explist
diff --git a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
index a918ab21015..e40685bf45a 100644
--- a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
+++ b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
@@ -44,14 +44,15 @@
 
 namespace
 {
-  struct io_error_category : std::error_category
+  struct io_error_category final : std::error_category
   {
-    virtual const char*
-    name() const noexcept
+    const char*
+    name() const noexcept final
     { return "iostream"; }
 
     _GLIBCXX_DEFAULT_ABI_TAG
-    virtual std::string message(int __ec) const
+    std::string
+    message(int __ec) const final
     {
       std::string __msg;
       switch (std::io_errc(__ec))
@@ -67,13 +68,17 @@ namespace
     }
   };
 
-  const io_error_category&
-  __io_category_instance() noexcept
+  struct constant_init
   {
-    static const io_error_category __ec{};
-    return __ec;
-  }
+    union {
+      unsigned char unused;
+      io_error_category cat;
+    };
+    constexpr constant_init() : cat() { }
+    ~constant_init() { /* do nothing, union member is not destroyed */ }
+  };
 
+  __constinit constant_init io_category_instance{};
 } // namespace
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -82,7 +87,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   const error_category&
   iostream_category() noexcept
-  { return __io_category_instance(); }
+  { return io_category_instance.cat; }
 
   ios_base::failure::failure(const string& __str)
   : system_error(io_errc::stream, __str) { }
diff --git a/libstdc++-v3/src/c++11/future.cc b/libstdc++-v3/src/c++11/future.cc
index c1a1a828e27..75f832ec1c5 100644
--- a/libstdc++-v3/src/c++11/future.cc
+++ b/libstdc++-v3/src/c++11/future.cc
@@ -27,14 +27,15 @@
 
 namespace
 {
-  struct future_error_category : public std::error_category
+  struct future_error_category final : public std::error_category
   {
-    virtual const char*
-    name() const noexcept
+    const char*
+    name() const noexcept final
     { return "future"; }
 
     _GLIBCXX_DEFAULT_ABI_TAG
-    virtual std::string message(int __ec) const
+    std::string
+    message(int __ec) const final
     {
       std::string __msg;
       switch (std::future_errc(__ec))
@@ -59,12 +60,17 @@ namespace
     }
   };
 
-  const future_error_category&
-  __future_category_instance() noexcept
+  struct constant_init
   {
-    static const future_error_category __fec{};
-    return __fec;
-  }
+    union {
+      unsigned char unused;
+      future_error_category cat;
+    };
+    constexpr constant_init() : cat() { }
+    ~constant_init() { /* do nothing, union member is not destroyed */ }
+  };
+
+  __constinit constant_init future_category_instance{};
 }
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -76,7 +82,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   { _GLIBCXX_THROW_OR_ABORT(future_error(make_error_code(future_errc(__i)))); }
 
   const error_category& future_category() noexcept
-  { return __future_category_instance(); }
+  { return future_category_instance.cat; }
 
   future_error::~future_error() noexcept { }
 
diff --git a/libstdc++-v3/src/c++17/floating_from_chars.cc b/libstdc++-v3/src/c++17/floating_from_chars.cc
index aa074869872..ca1ad84e2ca 100644
--- a/libstdc++-v3/src/c++17/floating_from_chars.cc
+++ b/libstdc++-v3/src/c++17/floating_from_chars.cc
@@ -37,7 +37,6 @@
 #include <cmath>
 #include <cstdlib>
 #include <cstring>
-#include <cctype>
 #include <locale.h>
 #include <bits/functexcept.h>
 #if _GLIBCXX_HAVE_XLOCALE_H
@@ -75,7 +74,6 @@ namespace
 	return m_buf + std::__exchange(m_bytes, m_bytes + bytes);
 
       __glibcxx_assert(m_ptr == nullptr);
-      __glibcxx_assert(alignment != 1);
 
       m_ptr = operator new(bytes);
       m_bytes = bytes;
@@ -116,10 +114,10 @@ namespace
 
   // Find initial portion of [first, last) containing a floating-point number.
   // The string `digits` is either `dec_digits` or `hex_digits`
-  // and `exp` is 'e' or 'p' or '\0'.
+  // and `exp` is "eE", "pP" or NULL.
   const char*
   find_end_of_float(const char* first, const char* last, const char* digits,
-		    char exp)
+		    const char *exp)
   {
     while (first < last && strchr(digits, *first) != nullptr)
       ++first;
@@ -129,7 +127,7 @@ namespace
 	while (first < last && strchr(digits, *first))
 	  ++first;
       }
-    if (first < last && exp != 0 && std::tolower((unsigned char)*first) == exp)
+    if (first < last && exp != nullptr && (*first == exp[0] || *first == exp[1]))
       {
 	++first;
 	if (first < last && (*first == '-' || *first == '+'))
@@ -211,7 +209,7 @@ namespace
 
 	if ((last - first + 2) > buffer_resource::guaranteed_capacity())
 	  {
-	    last = find_end_of_float(first + neg, last, digits, 'p');
+	    last = find_end_of_float(first + neg, last, digits, "pP");
 #ifndef __cpp_exceptions
 	    if ((last - first + 2) > buffer_resource::guaranteed_capacity())
 	      {
@@ -235,7 +233,7 @@ namespace
 	if ((last - first) > buffer_resource::guaranteed_capacity())
 	  {
 	    last = find_end_of_float(first + neg, last, digits,
-				     "e"[fmt == chars_format::fixed]);
+				     fmt == chars_format::fixed ? nullptr : "eE");
 #ifndef __cpp_exceptions
 	    if ((last - first) > buffer_resource::guaranteed_capacity())
 	      {
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index acff0ff926e..481b49d20be 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -27,6 +27,10 @@
 # define NEED_DO_COPY_FILE
 # define NEED_DO_SPACE
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <filesystem>
@@ -404,8 +408,12 @@ fs::copy(const path& from, const path& to, copy_options options,
       // set an unused bit in options to disable further recursion
       if (!is_set(options, copy_options::recursive))
 	options |= static_cast<copy_options>(4096);
-      for (const directory_entry& x : directory_iterator(from))
-	copy(x.path(), to/x.path().filename(), options, ec);
+      for (const directory_entry& x : directory_iterator(from, ec))
+	{
+	  copy(x.path(), to/x.path().filename(), options, ec);
+	  if (ec)
+	    return;
+	}
     }
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2683. filesystem::copy() says "no effects"
@@ -1584,7 +1592,8 @@ fs::symlink_status(const fs::path& p)
   return result;
 }
 
-fs::path fs::temp_directory_path()
+fs::path
+fs::temp_directory_path()
 {
   error_code ec;
   path tmp = temp_directory_path(ec);
@@ -1593,32 +1602,12 @@ fs::path fs::temp_directory_path()
   return tmp;
 }
 
-fs::path fs::temp_directory_path(error_code& ec)
+fs::path
+fs::temp_directory_path(error_code& ec)
 {
-  path p;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  unsigned len = 1024;
-  std::wstring buf;
-  do
-    {
-      buf.resize(len);
-      len = GetTempPathW(buf.size(), buf.data());
-    } while (len > buf.size());
-
-  if (len == 0)
-    {
-      ec.assign((int)GetLastError(), std::system_category());
-      return p;
-    }
-  buf.resize(len);
-  p = std::move(buf);
-#else
-  const char* tmpdir = nullptr;
-  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
-  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
-    tmpdir = ::getenv(*e);
-  p = tmpdir ? tmpdir : "/tmp";
-#endif
+  path p = fs::get_temp_directory_from_env(ec);
+  if (ec)
+    return p;
   auto st = status(p, ec);
   if (ec)
     p.clear();
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index 506ff25f9a6..967d9471134 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -1872,11 +1872,6 @@ path::_M_split_cmpts()
       _M_cmpts.type(_Type::_Filename);
       return;
     }
-  if (_M_pathname.length() == 1 && _M_pathname[0] == preferred_separator)
-    {
-      _M_cmpts.type(_Type::_Root_dir);
-      return;
-    }
 
   _Parser parser(_M_pathname);
 
diff --git a/libstdc++-v3/src/c++20/sstream-inst.cc b/libstdc++-v3/src/c++20/sstream-inst.cc
index b3fbd6ead44..55d1fe5234d 100644
--- a/libstdc++-v3/src/c++20/sstream-inst.cc
+++ b/libstdc++-v3/src/c++20/sstream-inst.cc
@@ -26,7 +26,9 @@
 // ISO C++ 14882:
 //
 
-// Instantiations in this file are only for the new SSO std::string ABI
+// Instantiations in this file are only for the new SSO std::string ABI.
+#define _GLIBCXX_USE_CXX11_ABI 1
+
 #include <sstream>
 
 #if _GLIBCXX_USE_CXX11_ABI
diff --git a/libstdc++-v3/src/filesystem/dir.cc b/libstdc++-v3/src/filesystem/dir.cc
index 06e165b8888..446ddf0d2f2 100644
--- a/libstdc++-v3/src/filesystem/dir.cc
+++ b/libstdc++-v3/src/filesystem/dir.cc
@@ -25,6 +25,10 @@
 #ifndef _GLIBCXX_USE_CXX11_ABI
 # define _GLIBCXX_USE_CXX11_ABI 1
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <experimental/filesystem>
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 529d4e09016..a76a2e6198d 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -567,6 +567,47 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 
 #endif // _GLIBCXX_HAVE_SYS_STAT_H
 
+  // Find OS-specific name of temporary directory from the environment,
+  // Caller must check that the path is an accessible directory.
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  inline wstring
+  get_temp_directory_from_env(error_code& ec)
+  {
+    unsigned len = 1024;
+    std::wstring buf;
+    do
+      {
+	buf.resize(len);
+	len = GetTempPathW(buf.size(), buf.data());
+      } while (len > buf.size());
+
+    if (len == 0)
+      ec.assign((int)GetLastError(), std::system_category());
+    else
+      ec.clear();
+
+    buf.resize(len);
+    return buf;
+  }
+#else
+  inline const char*
+  get_temp_directory_from_env(error_code& ec) noexcept
+  {
+    ec.clear();
+    for (auto env : { "TMPDIR", "TMP", "TEMP", "TEMPDIR" })
+      {
+#if _GLIBCXX_HAVE_SECURE_GETENV
+	auto tmpdir = ::secure_getenv(env);
+#else
+	auto tmpdir = ::getenv(env);
+#endif
+	if (tmpdir)
+	  return tmpdir;
+      }
+    return "/tmp";
+  }
+#endif
+
 _GLIBCXX_END_NAMESPACE_FILESYSTEM
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 3f2290f372d..b7df8d99b6c 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -27,6 +27,10 @@
 # define NEED_DO_COPY_FILE
 # define NEED_DO_SPACE
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <experimental/filesystem>
@@ -344,8 +348,12 @@ fs::copy(const path& from, const path& to, copy_options options,
       // set an unused bit in options to disable further recursion
       if (!is_set(options, copy_options::recursive))
 	options |= static_cast<copy_options>(4096);
-      for (const directory_entry& x : directory_iterator(from))
-	copy(x.path(), to/x.path().filename(), options, ec);
+      for (const directory_entry& x : directory_iterator(from, ec))
+	{
+	  copy(x.path(), to/x.path().filename(), options, ec);
+	  if (ec)
+	    return;
+	}
     }
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2683. filesystem::copy() says "no effects"
@@ -1195,13 +1203,43 @@ fs::space(const path& p, error_code& ec) noexcept
   return info;
 }
 
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+static bool has_trailing_slash(const fs::path& p)
+{
+  wchar_t c = p.native().back();
+  return c == '/' || c == L'\\';
+}
+#endif
+
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
 fs::file_status
 fs::status(const fs::path& p, error_code& ec) noexcept
 {
   file_status status;
+
+  auto str = p.c_str();
+
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  // stat() fails if there's a trailing slash (PR 88881)
+  path p2;
+  if (p.has_relative_path() && has_trailing_slash(p))
+    {
+      __try
+	{
+	  p2 = p.parent_path();
+	  str = p2.c_str();
+	}
+      __catch(const bad_alloc&)
+	{
+	  ec = std::make_error_code(std::errc::not_enough_memory);
+	  return status;
+	}
+      str = p2.c_str();
+    }
+#endif
+
   stat_type st;
-  if (posix::stat(p.c_str(), &st))
+  if (posix::stat(str, &st))
     {
       int err = errno;
       ec.assign(err, std::generic_category());
@@ -1224,8 +1262,30 @@ fs::file_status
 fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept
 {
   file_status status;
+
+  auto str = p.c_str();
+
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  // stat() fails if there's a trailing slash (PR 88881)
+  path p2;
+  if (p.has_relative_path() && has_trailing_slash(p))
+    {
+      __try
+	{
+	  p2 = p.parent_path();
+	  str = p2.c_str();
+	}
+      __catch(const bad_alloc&)
+	{
+	  ec = std::make_error_code(std::errc::not_enough_memory);
+	  return status;
+	}
+      str = p2.c_str();
+    }
+#endif
+
   stat_type st;
-  if (posix::lstat(p.c_str(), &st))
+  if (posix::lstat(str, &st))
     {
       int err = errno;
       ec.assign(err, std::generic_category());
@@ -1289,7 +1349,8 @@ fs::system_complete(const path& p, error_code& ec)
 #endif
 }
 
-fs::path fs::temp_directory_path()
+fs::path
+fs::temp_directory_path()
 {
   error_code ec;
   path tmp = temp_directory_path(ec);
@@ -1298,31 +1359,12 @@ fs::path fs::temp_directory_path()
   return tmp;
 }
 
-fs::path fs::temp_directory_path(error_code& ec)
+fs::path
+fs::temp_directory_path(error_code& ec)
 {
-  path p;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  unsigned len = 1024;
-  std::wstring buf;
-  do
-    {
-      buf.resize(len);
-      len = GetTempPathW(buf.size(), buf.data());
-    } while (len > buf.size());
-
-  if (len == 0)
-    {
-      ec.assign((int)GetLastError(), std::system_category());
-      return p;
-    }
-  buf.resize(len);
-  p = std::move(buf);
-#else
-  const char* tmpdir = nullptr;
-  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
-  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
-    tmpdir = ::getenv(*e);
-  p = tmpdir ? tmpdir : "/tmp";
+  path p = fs::get_temp_directory_from_env(ec);
+  if (ec)
+    return p;
   auto st = status(p, ec);
   if (ec)
     p.clear();
@@ -1331,7 +1373,5 @@ fs::path fs::temp_directory_path(error_code& ec)
       p.clear();
       ec = std::make_error_code(std::errc::not_a_directory);
     }
-#endif
   return p;
 }
-
diff --git a/libstdc++-v3/src/filesystem/path.cc b/libstdc++-v3/src/filesystem/path.cc
index a935573740f..8e8806a953f 100644
--- a/libstdc++-v3/src/filesystem/path.cc
+++ b/libstdc++-v3/src/filesystem/path.cc
@@ -337,15 +337,18 @@ path::_M_split_cmpts()
   _M_type = _Type::_Multi;
   _M_cmpts.clear();
 
-  if (_M_pathname.empty())
+  // Use const-reference to access _M_pathname, to avoid "leaking" COW string.
+  const auto& pathname = _M_pathname;
+
+  if (pathname.empty())
     return;
 
   {
     // Approximate count of components, to reserve space in _M_cmpts vector:
     int count = 1;
-    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_sep_last = _S_is_dir_sep(pathname[0]);
     bool saw_non_sep = !saw_sep_last;
-    for (value_type c : _M_pathname)
+    for (value_type c : pathname)
       {
        if (_S_is_dir_sep(c))
          saw_sep_last = true;
@@ -363,13 +366,13 @@ path::_M_split_cmpts()
   }
 
   size_t pos = 0;
-  const size_t len = _M_pathname.size();
+  const size_t len = pathname.size();
 
   // look for root name or root directory
-  if (_S_is_dir_sep(_M_pathname[0]))
+  if (_S_is_dir_sep(pathname[0]))
     {
       // look for root name, such as "//" or "//foo"
-      if (len > 1 && _M_pathname[1] == _M_pathname[0])
+      if (len > 1 && pathname[1] == pathname[0])
 	{
 	  if (len == 2)
 	    {
@@ -378,11 +381,11 @@ path::_M_split_cmpts()
 	      return;
 	    }
 
-	  if (!_S_is_dir_sep(_M_pathname[2]))
+	  if (!_S_is_dir_sep(pathname[2]))
 	    {
 	      // got root name, find its end
 	      pos = 3;
-	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
+	      while (pos < len && !_S_is_dir_sep(pathname[pos]))
 		++pos;
 	      if (pos == len)
 		{
@@ -409,7 +412,7 @@ path::_M_split_cmpts()
       ++pos;
     }
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  else if (len > 1 && _M_pathname[1] == L':')
+  else if (len > 1 && pathname[1] == L':')
     {
       // got disk designator
       if (len == 2)
@@ -418,7 +421,7 @@ path::_M_split_cmpts()
 	  return;
 	}
       _M_add_root_name(2);
-      if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
+      if (len > 2 && _S_is_dir_sep(pathname[2]))
 	_M_add_root_dir(2);
       pos = 2;
     }
@@ -426,9 +429,9 @@ path::_M_split_cmpts()
   else
     {
       size_t n = 1;
-      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+      for (; n < pathname.size() && !_S_is_dir_sep(pathname[n]); ++n)
 	{ }
-      if (n == _M_pathname.size())
+      if (n == pathname.size())
 	{
 	  _M_type = _Type::_Filename;
 	  return;
@@ -438,7 +441,7 @@ path::_M_split_cmpts()
   size_t back = pos;
   while (pos < len)
     {
-      if (_S_is_dir_sep(_M_pathname[pos]))
+      if (_S_is_dir_sep(pathname[pos]))
 	{
 	  if (back != pos)
 	    _M_add_filename(back, pos - back);
@@ -450,7 +453,7 @@ path::_M_split_cmpts()
 
   if (back != pos)
     _M_add_filename(back, pos - back);
-  else if (_S_is_dir_sep(_M_pathname.back()))
+  else if (_S_is_dir_sep(pathname.back()))
     {
       // [path.itr]/8
       // "Dot, if one or more trailing non-root slash characters are present."
diff --git a/libstdc++-v3/testsuite/17_intro/names.cc b/libstdc++-v3/testsuite/17_intro/names.cc
index 226b2d9c24a..554e32162ae 100644
--- a/libstdc++-v3/testsuite/17_intro/names.cc
+++ b/libstdc++-v3/testsuite/17_intro/names.cc
@@ -106,6 +106,8 @@
 #define z (
 
 #define tmp (
+#define sz (
+#define token (
 
 #if __cplusplus < 201103L
 #define uses_allocator  (
@@ -195,6 +197,8 @@
 #undef y
 // <sys/var.h> defines vario::v
 #undef v
+// <sys/timer.h> defines trb::func and cputime_tmr::func
+#undef func
 #endif
 
 #ifdef __APPLE__
diff --git a/libstdc++-v3/testsuite/20_util/allocator/void.cc b/libstdc++-v3/testsuite/20_util/allocator/void.cc
index e3d024d525b..3720774abaf 100644
--- a/libstdc++-v3/testsuite/20_util/allocator/void.cc
+++ b/libstdc++-v3/testsuite/20_util/allocator/void.cc
@@ -87,8 +87,23 @@ static_assert( std::is_same<std::allocator<void>::const_pointer, const void*>(),
     "const_pointer is const void*" );
 #endif // C++20
 
+void
+test02()
+{
+  std::allocator<void> av;
+  int* p = std::allocator<int>().allocate(1);
+  const int* c = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, c, 0);
+  volatile int* v = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, v, 0);
+  const volatile int* cv = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, cv, 0);
+  std::allocator<int>().deallocate(p, 1);
+}
+
 int
 main()
 {
   test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/4.cc b/libstdc++-v3/testsuite/20_util/from_chars/4.cc
index 7cee4dcbc23..4064f1d4177 100644
--- a/libstdc++-v3/testsuite/20_util/from_chars/4.cc
+++ b/libstdc++-v3/testsuite/20_util/from_chars/4.cc
@@ -300,9 +300,11 @@ test_max_mantissa()
 
   if (Float_limits::is_iec559 && Float_limits::digits < UInt_limits::digits)
   {
+#ifdef _GLIBCXX_USE_C99_MATH_TR1
     std::printf("Testing %d-bit float, using %zu-bit integer\n",
 	Float_limits::digits + (int)std::log2(Float_limits::max_exponent) + 1,
 	sizeof(UIntT) * __CHAR_BIT__);
+#endif
 
     std::from_chars_result res;
     FloatT flt;
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
new file mode 100644
index 00000000000..ef24b4c5c7b
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
@@ -0,0 +1,16 @@
+// { dg-do run { target c++17 } }
+
+#include <charconv>
+#include <string>
+
+int main()
+{
+#if __cpp_lib_to_chars >= 201611L // FP from_char not available otherwise.
+  // PR libstdc++/105324
+  // std::from_chars() assertion at floating_from_chars.cc:78
+  std::string s(512, '1');
+  s[1] = '.';
+  long double d;
+  std::from_chars(s.data(), s.data() + s.size(), d);
+#endif
+}
diff --git a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
index 40180223bae..a98815d932b 100644
--- a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
@@ -238,8 +238,11 @@ test07()
   std::pmr::monotonic_buffer_resource mbr(&cr);
   try
   {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
     // Try to allocate a ridiculous size:
     void* p = mbr.allocate(std::size_t(-2), 1);
+#pragma GCC diagnostic pop
     // Should not reach here!
     VERIFY( !"attempt to allocate SIZE_MAX-1 should not have succeeded" );
     throw p;
diff --git a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
index a76afbe87a2..fe847dadd27 100644
--- a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
@@ -281,10 +281,13 @@ test07()
   std::pmr::unsynchronized_pool_resource upr(&cr);
   try
   {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
     // Try to allocate a ridiculous size (and use a large extended alignment
     // so that careful_resource::do_allocate can distinguish this allocation
     // from any required for the pool resource's internal data structures):
     void* p = upr.allocate(std::size_t(-2), 1024);
+#pragma GCC diagnostic pop
     // Should not reach here!
     VERIFY( !"attempt to allocate SIZE_MAX-1 should not have succeeded" );
     throw p;
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
index 5de2a5f9330..3ba39ec432d 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
@@ -35,7 +35,9 @@ void test01()
 
   std::string c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
index fe91c5ab539..5804ccb6bf8 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
@@ -44,7 +44,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
index 1caedcccfce..59d1d775134 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
@@ -42,7 +42,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
index d05afb7d466..67e25de2916 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
@@ -35,7 +35,9 @@ void test01()
 
   std::wstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
index e301984612d..c72eb9bfddb 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
@@ -44,7 +44,9 @@ void test01()
 
   twstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
index d3e4744ff34..6a2bc2714b5 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
@@ -42,7 +42,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
index 87d8c2f4068..6a3ed55f557 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
@@ -71,8 +71,8 @@ int main()
 
   string s = "PR libstdc++/87749 a string that is longer than a short string";
   const auto ptr = s.c_str();
-  oom = true;
   string ss;
+  oom = true;
   ss = std::move(s); // allocators are equal, should not allocate new storage
   VERIFY( ss.c_str() == ptr );
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
index 4d744f8a411..536ca6153d3 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
@@ -72,8 +72,8 @@ int main()
 
   string s = L"PR libstdc++/87749 a string that is longer than a short string";
   const auto ptr = s.c_str();
-  oom = true;
   string ss;
+  oom = true;
   ss = std::move(s); // allocators are equal, should not allocate new storage
   VERIFY( ss.c_str() == ptr );
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc
index fa85f1994c9..c95239c613b 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc
@@ -36,7 +36,7 @@ test01()
   };
 
   R r;
-  std::string_view s = r;
+  std::string_view s{r};
   VERIFY( s == r.str );
   VERIFY( s.data() == std::ranges::data(r) );
   VERIFY( s.size() == std::ranges::size(r) );
@@ -50,10 +50,15 @@ test01()
   static_assert( std::ranges::contiguous_range<R2> );
   static_assert( std::ranges::sized_range<R2> );
   R2 r2;
-  std::string_view s2 = r2; // uses conversion to string_view
+  std::string_view s2(r2); // uses conversion to string_view
   VERIFY( s2 == "Out of range" );
   VERIFY( std::string_view(const_cast<const R2&>(r2)) == s2 );
 
+  // And again using copy-initialization instead of direct-initialization.
+  std::string_view s2_implicit = r2; // uses conversion to string_view
+  VERIFY( s2_implicit == "Out of range" );
+  VERIFY( std::string_view(const_cast<const R2&>(r2)) == s2_implicit );
+
   struct R3 : R
   {
     using R::begin;
@@ -91,7 +96,7 @@ test01()
   static_assert( std::ranges::contiguous_range<R5> );
   static_assert( std::ranges::sized_range<R5> );
   R5 r5;
-  std::string_view s5 = r5; // Uses range constructor
+  std::string_view s5(r5); // Uses range constructor
   VERIFY( s5 == r5.str );
   s5 = std::string_view(std::move(r5)); // In C++20 this used conversion op.
   VERIFY( s5 == r5.str );	        // In C++23 it uses range constructor.
@@ -156,15 +161,30 @@ test04()
   };
 
   R r;
-  std::basic_string_view s = r; // Use deduction guide.
+  std::basic_string_view s(r); // Use deduction guide.
 
   static_assert( std::is_same_v<decltype(s), std::string_view> );
 }
 
+void
+test05()
+{
+  struct R
+  {
+    const char* begin() const { return nullptr; }
+    const char* end() const { return nullptr; }
+  };
+
+  // P2499R0 string_view range constructor should be explicit
+  // P2516R0 string_view is implicitly convertible from what?
+  static_assert( ! std::is_convertible_v<R, std::string_view> );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
   test04();
+  test05();
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc
index cf73ae36a60..2144ca49e77 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc
@@ -36,7 +36,7 @@ test01()
   };
 
   R r;
-  std::wstring_view s = r;
+  std::wstring_view s{r};
   VERIFY( s == r.str );
   VERIFY( s.data() == std::ranges::data(r) );
   VERIFY( s.size() == std::ranges::size(r) );
@@ -50,10 +50,15 @@ test01()
   static_assert( std::ranges::contiguous_range<R2> );
   static_assert( std::ranges::sized_range<R2> );
   R2 r2;
-  std::wstring_view s2 = r2; // uses conversion to wstring_view
+  std::wstring_view s2(r2); // uses conversion to wstring_view
   VERIFY( s2 == L"Out of range" );
   VERIFY( std::wstring_view(const_cast<const R2&>(r2)) == s2 );
 
+  // And again using copy-initialization instead of direct-initialization.
+  std::wstring_view s2_implicit = r2; // uses conversion to wstring_view
+  VERIFY( s2_implicit == L"Out of range" );
+  VERIFY( std::wstring_view(const_cast<const R2&>(r2)) == s2_implicit );
+
   struct R3 : R
   {
     using R::begin;
@@ -91,10 +96,10 @@ test01()
   static_assert( std::ranges::contiguous_range<R5> );
   static_assert( std::ranges::sized_range<R5> );
   R5 r5;
-  std::wstring_view s5 = r5; // Uses range constructor
+  std::wstring_view s5(r5); // Uses range constructor
   VERIFY( s5 == r5.str );
   s5 = std::wstring_view(std::move(r5)); // In C++20 this used conversion op.
-  VERIFY( s5 == r5.str );	        // In C++23 it uses range constructor.
+  VERIFY( s5 == r5.str );	         // In C++23 it uses range constructor.
 
   wchar_t arr[] = L"arrangement\0with\0nulls";
   std::wstring_view sa = arr; // Does not use range constructor
@@ -156,15 +161,30 @@ test04()
   };
 
   R r;
-  std::basic_string_view s = r; // Use deduction guide.
+  std::basic_string_view s(r); // Use deduction guide.
 
   static_assert( std::is_same_v<decltype(s), std::wstring_view> );
 }
 
+void
+test05()
+{
+  struct R
+  {
+    const wchar_t* begin() const { return nullptr; }
+    const wchar_t* end() const { return nullptr; }
+  };
+
+  // P2499R0 string_view range constructor should be explicit
+  // P2516R0 string_view is implicitly convertible from what?
+  static_assert( ! std::is_convertible_v<R, std::wstring_view> );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
   test04();
+  test05();
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
index f467d114c24..7ae3ccda22f 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
@@ -22,7 +22,7 @@
 
 #ifndef __cpp_lib_constexpr_string_view
 # error "Feature test macro for constexpr copy is missing in <string_view>"
-#elif __cpp_lib_constexpr_iterator < 201811L
+#elif __cpp_lib_constexpr_string_view < 201811L
 # error "Feature test macro for constexpr copy has wrong value in <string_view>"
 #endif
 
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
new file mode 100644
index 00000000000..0f6f520c33b
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
@@ -0,0 +1,48 @@
+// { dg-do run { target c++11 } }
+// C++11 23.3.4.6 Operations [forwardlist.ops]
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+void
+test_stable()
+{
+  std::forward_list<double> a{1.5, 2.0, 3.5, 4.1};
+  std::forward_list<double> b{1.0, 2.5, 3.0, 4.3, 4.2, 5.0};
+
+  a.merge(b, std::less<int>{});
+
+  // result is sorted with respect to std::less<int>, so 1.0 and 1.5 are
+  // equivalent, and stability guarantee means the element from a comes first.
+  const std::forward_list<double> r { 1.5, 1.0,
+				      2.0, 2.5,
+				      3.5, 3.0,
+				      4.1, 4.3, 4.2,
+				      5.0};
+
+  VERIFY(a == r);
+}
+
+void
+test_lwg3088()
+{
+  // LWG 3088: forward_list::merge behavior unclear when passed *this
+  // PR libstdc++/103853
+  std::forward_list<int> c1{ 1, 2, 3 };
+  const std::forward_list<int> c2 = c1;
+  c1.merge(c1);
+  VERIFY( c1 == c2 );
+  c1.merge(c1, std::less<long>{});
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1));
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1), std::less<long>{});
+  VERIFY( c1 == c2 );
+}
+
+int
+main()
+{
+  test_stable();
+  test_lwg3088();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc b/libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc
index fb8c7adab27..e07069adab6 100644
--- a/libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc
+++ b/libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc
@@ -27,15 +27,30 @@ test01()
   using I = std::common_iterator<int*, const int*>;
   static_assert( std::is_default_constructible_v<I> );
   static_assert( std::is_copy_constructible_v<I> );
+  static_assert( std::is_move_constructible_v<I> );
   static_assert( std::is_copy_assignable_v<I> );
+  static_assert( std::is_move_assignable_v<I> );
   static_assert( std::is_constructible_v<I, int*> );
   static_assert( std::is_constructible_v<I, const int*> );
 
-  struct sentinel { operator int*() const { return nullptr; } };
+  static_assert( std::is_nothrow_copy_constructible_v<I> ); // GCC extension
+  static_assert( std::is_nothrow_move_constructible_v<I> ); // GCC extension
+  static_assert( std::is_nothrow_copy_assignable_v<I> ); // GCC extension
+  static_assert( std::is_nothrow_move_assignable_v<I> ); // GCC extension
+
+  struct sentinel { operator int*() const noexcept { return nullptr; } };
   using K = std::common_iterator<int*, sentinel>;
   static_assert( std::is_constructible_v<I, const K&> );
   static_assert( std::is_assignable_v<I, const K&> );
 
+  static_assert( std::is_nothrow_assignable_v<I&, const K&> ); // GCC extension
+
+  struct sentinel_throwing { operator int*() const { return nullptr; } };
+  using K_throwing = std::common_iterator<int*, sentinel_throwing>;
+  // Conversion is noexcept(false)
+  static_assert( ! std::is_nothrow_assignable_v<I&, const K_throwing&> );
+
+
   struct sentinel2
   {
     const int* p;
@@ -46,6 +61,12 @@ test01()
   using J = std::common_iterator<const int*, sentinel2>;
   static_assert( std::is_constructible_v<J, const I&> );
   static_assert( std::is_convertible_v<const I&, J> );
+
+  static_assert( std::is_constructible_v<J, I> );
+  static_assert( std::is_convertible_v<I, J> );
+
+  // Constructor is noexcept(false)
+  static_assert( ! std::is_nothrow_constructible_v<J, I> );
 }
 
 void
@@ -88,7 +109,7 @@ test02()
     VERIFY( i == (&i - out) );
 }
 
-void
+constexpr bool
 test03()
 {
   int arr[2] = { 1, 2 };
@@ -117,6 +138,9 @@ test03()
   VERIFY( (j - end) == -2 );
   VERIFY( (j - i) == 0 );
 
+  if (std::is_constant_evaluated())
+    return true;
+
   try
   {
     struct S { operator const int*() const { throw 1; } };
@@ -126,8 +150,12 @@ test03()
   catch (int)
   {
   }
+
+  return true;
 }
 
+static_assert( test03() );
+
 void
 test04()
 {
@@ -150,6 +178,22 @@ test04()
   VERIFY( x.i == 2 );
 }
 
+constexpr bool
+test_pr103992()
+{
+  using C1 = std::common_iterator<std::reverse_iterator<int*>,
+				  std::unreachable_sentinel_t>;
+  using C2 = std::common_iterator<std::reverse_iterator<const int*>,
+				  std::unreachable_sentinel_t>;
+  C1 c1;
+  C2 c2 = c1;
+  C1 c3 = c1;
+
+  return true;
+}
+
+static_assert( test_pr103992() );
+
 int
 main()
 {
diff --git a/libstdc++-v3/testsuite/24_iterators/common_iterator/100823.cc b/libstdc++-v3/testsuite/24_iterators/common_iterator/100823.cc
new file mode 100644
index 00000000000..4f2b23de8cc
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/common_iterator/100823.cc
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++20 -D_GLIBCXX_ASSERTIONS" }
+// { dg-do run { target c++20 } }
+#include <iterator>
+#include <testsuite_iterators.h>
+#include <testsuite_hooks.h>
+
+void
+test_valueless_assignment()
+{
+  int x[1] { };
+  __gnu_test::test_forward_range<int> r(x);
+  using Iter = decltype(r.begin());
+  using Sent = decltype(r.end());
+
+  std::common_iterator<Iter, Sent> i;
+  const std::common_iterator<Iter, Sent> j(r.begin());
+  try
+  {
+    struct Bomb
+    {
+      bool operator==(Iter) const { return true; }
+      operator Sent() const { throw 1; }
+    };
+    std::common_iterator<Iter, Bomb> b{Bomb{}};
+    i = b; // Throws, leaving i valueless-by-exception.
+    VERIFY(false);
+  }
+  catch (int)
+  {
+    std::common_iterator<Iter, Sent> k(i);
+
+    // PR libstdc++/100823
+    k = i; // Valid even though both operands are valueless.
+
+    i = j; // No longer valueless.
+  }
+  VERIFY( i == j );
+}
+
+int main()
+{
+  test_valueless_assignment();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/common_iterator/2.cc b/libstdc++-v3/testsuite/24_iterators/common_iterator/2.cc
index 80f4f2b0151..f8580b57890 100644
--- a/libstdc++-v3/testsuite/24_iterators/common_iterator/2.cc
+++ b/libstdc++-v3/testsuite/24_iterators/common_iterator/2.cc
@@ -32,18 +32,18 @@ struct iterator
   using difference_type = std::ptrdiff_t;
   using reference = value;
 
-  value operator*() const { return value{counter}; }
+  constexpr value operator*() const { return value{counter}; }
 
-  iterator& operator++() { ++counter; return *this; }
+  constexpr iterator& operator++() { ++counter; return *this; }
 
-  iterator operator++(int) { auto i = *this; ++counter; return i; }
+  constexpr iterator operator++(int) { auto i = *this; ++counter; return i; }
 
-  bool operator==(sentinel s) const { return counter == s.limit; }
+  constexpr bool operator==(sentinel s) const { return counter == s.limit; }
 
   int counter = 0;
 };
 
-void
+constexpr bool
 test01()
 {
   iterator i;
@@ -54,10 +54,12 @@ test01()
   VERIFY( begin->n == 1 );
   ++begin;
   VERIFY( begin == end );
+
+  return true;
 }
 
 int
 main()
 {
-  test01();
+  constexpr bool b1 = test01();
 }
diff --git a/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3643.cc b/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3643.cc
new file mode 100644
index 00000000000..e6f12b46c12
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3643.cc
@@ -0,0 +1,27 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+#include <iterator>
+
+struct InputIterator
+{
+  using difference_type = int;
+  using value_type = int;
+
+  constexpr int operator*() const noexcept { return 0; }
+  InputIterator& operator++() { return *this; }
+  constexpr void operator++(int) { }
+};
+
+static_assert( std::input_iterator<InputIterator> );
+static_assert( !std::forward_iterator<InputIterator> );
+
+constexpr bool
+test_lwg3643()
+{
+  std::counted_iterator<InputIterator> iter({}, 1);
+  iter++;
+  return iter == std::default_sentinel;
+}
+
+static_assert( test_lwg3643() );
diff --git a/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc b/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
index e4219b8c78b..3ce0df5d111 100644
--- a/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
+++ b/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do compile { target c++11 } }
+// { dg-do run { target c++11 } }
 
 #include <iterator>
 
@@ -27,18 +27,18 @@ struct Iter
   using reference = int&;
   using difference_type = std::ptrdiff_t;
 
-  Iter();
+  Iter() { }
 
-  // Construction from int* is not valid:
-  Iter(int*) = delete;
+  // Construction from int* should not be used:
+  Iter(int*) { throw 1; }
 
-  // Assignment from int* is valid:
-  Iter& operator=(int*);
+  // Assignment from int* is OK:
+  Iter& operator=(int*) { return *this; }
 
-  Iter& operator++();
-  Iter operator++(int);
-  int& operator*() const;
-  int* operator->() const;
+  Iter& operator++() { return *this; }
+  Iter operator++(int) { return *this; }
+  int& operator*() const { static int i; return i; }
+  int* operator->() const { return &**this; }
 
   template<int N> friend bool operator==(Iter, Iter);
 };
@@ -49,3 +49,8 @@ void test01()
   int i = 0;
   m = std::make_move_iterator(&i); // Should use assignment not construction
 }
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc b/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc
new file mode 100644
index 00000000000..0fadcd6e99a
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc
@@ -0,0 +1,37 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+// Public domain testcase from Casey Carter, send to LWG list on 2021-07-24.
+//
+// Here's a compile-only test case for which n is INT_MIN, which will overflow
+// if simply negated to get |n|: https://godbolt.org/z/M7Wz1nW58.
+
+#include <cassert>
+#include <iterator>
+#include <limits>
+
+struct I {
+    using difference_type = int;
+    using value_type = int;
+
+    int x;
+
+    constexpr int operator*() const { return x; }
+    constexpr I& operator++() { ++x; return *this; }
+    constexpr I operator++(int) { ++x; return {x - 1}; }
+    constexpr bool operator==(const I&) const = default;
+
+    constexpr int operator-(const I& that) const { return x - that.x; }
+
+    constexpr I& operator--() { --x; return *this; }
+    constexpr I operator--(int) { --x; return {x - 1}; }
+};
+static_assert(std::bidirectional_iterator<I>);
+static_assert(std::sized_sentinel_for<I, I>);
+
+constexpr bool test() {
+    using L = std::numeric_limits<int>;
+    I i{-2};
+    return std::ranges::advance(i, L::min(), I{-4}) == L::min() + 2;
+}
+static_assert(test());
diff --git a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
index f947f8ae848..e8705ca7879 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
@@ -25,6 +25,7 @@
 
 #include <random>
 #include <sstream>
+#include <testsuite_hooks.h>
 
 void
 test01()
@@ -37,10 +38,43 @@ test01()
   str << u;
 
   str >> v;
+  VERIFY( u == v );
+}
+
+void
+test_pr105502()
+{
+  // PR libstdc++/105502 std::normal_distribution deserialization issue
+  std::stringstream str;
+  std::normal_distribution<> d{1, 2}, d2;
+  std::minstd_rand0 g;
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = true
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = false
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
 }
 
 int main()
 {
   test01();
-  return 0;
+  test_pr105502();
 }
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc
new file mode 100644
index 00000000000..6d89a0e5fef
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc
@@ -0,0 +1,40 @@
+// { dg-do run }
+
+#include <sstream>
+#include <testsuite_hooks.h>
+
+void
+test_pr106248()
+{
+  char buf[5] = {'x', 'x', 'x', 'x', 'x'};
+  std::string s("  four");
+  std::istringstream in(s);
+  in >> buf;
+#if __cplusplus >= 202002L
+  // Extraction stops because buffer is full.
+  VERIFY( in.good() );
+#else
+  // PR libstdc++/106248
+  // Extraction stops because all input has been consumed and eofbit is set.
+  VERIFY( in.eof() );
+#endif
+  // Extracted string must be null-terminated.
+  VERIFY( buf[4] == '\0' );
+  VERIFY( std::string(buf) == "four" );
+
+  in.clear();
+  in.str(s);
+  for (int i = 0; i < 5; ++i)
+    s[i] = 'x';
+
+  in.width(5);
+  in >> buf;
+  // Extraction stops due to field width, eofbit not set.
+  VERIFY( in.good() );
+  VERIFY( std::string(buf) == "four" );
+}
+
+int main()
+{
+  test_pr106248();
+}
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc
new file mode 100644
index 00000000000..7c226600b9e
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc
@@ -0,0 +1,40 @@
+// { dg-do run }
+
+#include <sstream>
+#include <testsuite_hooks.h>
+
+void
+test_pr106248()
+{
+  wchar_t buf[5] = {L'x', L'x', L'x', L'x', L'x'};
+  std::wstring s(L"  four");
+  std::wistringstream in(s);
+  in >> buf;
+#if __cplusplus >= 202002L
+  // Extraction stops because buffer is full.
+  VERIFY( in.good() );
+#else
+  // PR libstdc++/106248
+  // Extraction stops because all input has been consumed and eofbit is set.
+  VERIFY( in.eof() );
+#endif
+  // Extracted string must be null-terminated.
+  VERIFY( buf[4] == L'\0' );
+  VERIFY( std::wstring(buf) == L"four" );
+
+  in.clear();
+  in.str(s);
+  for (int i = 0; i < 5; ++i)
+    s[i] = L'x';
+
+  in.width(5);
+  in >> buf;
+  // Extraction stops due to field width, eofbit not set.
+  VERIFY( in.good() );
+  VERIFY( std::wstring(buf) == L"four" );
+}
+
+int main()
+{
+  test_pr106248();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
index 1f297a731a3..a26b29f0974 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
@@ -28,35 +28,44 @@
 
 int choice;
 
-struct dirent global_dirent;
-
 extern "C" struct dirent* readdir(DIR*)
 {
+  // On some targets dirent::d_name is very small, but the OS allocates
+  // a trailing char array after the dirent struct. Emulate that here.
+  union State
+  {
+    struct dirent d;
+    char buf[sizeof(struct dirent) + 16] = {};
+  };
+
+  static State state;
+  char* d_name = state.buf + offsetof(struct dirent, d_name);
+
   switch (choice)
   {
   case 1:
-    global_dirent.d_ino = 999;
+    state.d.d_ino = 999;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_REG
-    global_dirent.d_type = DT_REG;
+    state.d.d_type = DT_REG;
 #endif
-    global_dirent.d_reclen = 0;
-    std::char_traits<char>::copy(global_dirent.d_name, "file", 5);
+    state.d.d_reclen = 0;
+    std::char_traits<char>::copy(d_name, "file", 5);
     choice = 0;
-    return &global_dirent;
+    return &state.d;
   case 2:
-    global_dirent.d_ino = 111;
+    state.d.d_ino = 111;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_DIR
-    global_dirent.d_type = DT_DIR;
+    state.d.d_type = DT_DIR;
 #endif
-    global_dirent.d_reclen = 60;
-    std::char_traits<char>::copy(global_dirent.d_name, "subdir", 7);
+    state.d.d_reclen = 60;
+    std::char_traits<char>::copy(d_name, "subdir", 7);
     choice = 1;
-    return &global_dirent;
+    return &state.d;
   default:
     errno = EIO;
     return nullptr;
   }
-  return &global_dirent;
+  return &state.d;
 }
 
 void
@@ -98,7 +107,7 @@ void
 test02()
 {
   namespace fs = std::filesystem;
-  auto dir = __gnu_test::nonexistent_path();
+  const auto dir = __gnu_test::nonexistent_path();
   fs::create_directories(dir/"subdir");
 
   std::error_code ec;
@@ -128,7 +137,12 @@ test02()
   }
 #endif
 
-  fs::remove_all(dir, ec);
+  // Cannot use fs::remove_all here because that uses
+  // recursive_directory_iterator which would use the fake readdir above.
+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  ::rmdir((dir/"subdir").c_str());
+  ::rmdir(dir.c_str());
+#endif
 }
 
 int
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
index 761cfc29b13..c00cf85641e 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
@@ -193,6 +193,34 @@ test05()
   VERIFY( !ec );  // Previous value should be cleared (LWG 2683)
 }
 
+void
+test_pr99290()
+{
+  auto dir = __gnu_test::nonexistent_path();
+  auto source = dir/"source";
+  auto dest = dir/"dest";
+  create_directories(source/"emptydir");
+  create_directories(dest/"emptydir");
+  std::ofstream{source/"file"} << 'a';
+  std::ofstream{dest/"file"} << 'b';
+  // PR libstdc++/99290
+  // std::filesystem::copy does not always report errors for recursion
+  std::error_code ec;
+  copy(source, dest, ec);
+  VERIFY( ec == std::errc::file_exists );
+
+#if __cpp_exceptions
+  try {
+    copy(source, dest);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::file_exists );
+  }
+#endif
+
+  remove_all(dir);
+}
+
 int
 main()
 {
@@ -201,4 +229,5 @@ main()
   test03();
   test04();
   test05();
+  test_pr99290();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
index b55cd6c60b6..1cfda583be3 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
@@ -20,6 +20,7 @@
 
 #include <filesystem>
 #include <stdlib.h>
+#include <stdio.h>
 #include <testsuite_hooks.h>
 #include <testsuite_fs.h>
 
@@ -58,7 +59,10 @@ test01()
   clean_env();
 
   if (!fs::exists("/tmp"))
+  {
+    puts("/tmp doesn't exist, not testing it for temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec = make_error_code(std::errc::invalid_argument);
   fs::path p1 = fs::temp_directory_path(ec);
@@ -75,7 +79,10 @@ test02()
   clean_env();
 
   if (!set_env("TMP", __gnu_test::nonexistent_path().string()))
+  {
+    puts("Cannot set environment variables, not testing temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec;
   fs::path p = fs::temp_directory_path(ec);
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc
index 7b7c912a6df..be15b314149 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc
@@ -42,9 +42,19 @@ test02()
   }
 }
 
+void
+test03()
+{
+  std::hash<path> h;
+  // LWG 3657. std::hash<std::filesystem::path> is not enabled
+  for (const path p : __gnu_test::test_paths)
+    VERIFY( h(p) == hash_value(p) );
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc b/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc
new file mode 100644
index 00000000000..48f733bf28a
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc
@@ -0,0 +1,119 @@
+// { dg-do compile }
+
+#include <iosfwd>
+
+namespace std
+{
+  // [iosfwd.syn]
+
+  template<class charT> struct char_traits;
+  template<> struct char_traits<char>;
+#if __cplusplus >= 202002L
+  template<> struct char_traits<char8_t>;
+#endif
+#if __cplusplus >= 201103L
+  template<> struct char_traits<char16_t>;
+  template<> struct char_traits<char32_t>;
+#endif
+  template<> struct char_traits<wchar_t>;
+
+  template<class T> class allocator;
+
+  template<class charT, class traits>
+    class basic_ios;
+  template<class charT, class traits>
+    class basic_streambuf;
+  template<class charT, class traits>
+    class basic_istream;
+  template<class charT, class traits>
+    class basic_ostream;
+  template<class charT, class traits>
+    class basic_iostream;
+
+_GLIBCXX_BEGIN_NAMESPACE_CXX11
+  template<class charT, class traits, class Allocator>
+    class basic_stringbuf;
+  template<class charT, class traits, class Allocator>
+    class basic_istringstream;
+  template<class charT, class traits, class Allocator>
+    class basic_ostringstream;
+  template<class charT, class traits, class Allocator>
+    class basic_stringstream;
+_GLIBCXX_END_NAMESPACE_CXX11
+
+  template<class charT, class traits>
+    class basic_filebuf;
+  template<class charT, class traits>
+    class basic_ifstream;
+  template<class charT, class traits>
+    class basic_ofstream;
+  template<class charT, class traits>
+    class basic_fstream;
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  template<class charT, class traits, class Allocator>
+    class basic_syncbuf;
+  template<class charT, class traits, class Allocator>
+    class basic_osyncstream;
+#endif
+
+  template<class charT, class traits>
+    class istreambuf_iterator;
+  template<class charT, class traits>
+    class ostreambuf_iterator;
+
+  typedef basic_ios<char>    ios;
+  typedef basic_ios<wchar_t> wios;
+
+  typedef basic_streambuf<char> streambuf;
+  typedef basic_istream<char>   istream;
+  typedef basic_ostream<char>   ostream;
+  typedef basic_iostream<char>  iostream;
+
+  typedef basic_stringbuf<char>     stringbuf;
+  typedef basic_istringstream<char> istringstream;
+  typedef basic_ostringstream<char> ostringstream;
+  typedef basic_stringstream<char>  stringstream;
+
+
+  typedef basic_filebuf<char>  filebuf;
+  typedef basic_ifstream<char> ifstream;
+  typedef basic_ofstream<char> ofstream;
+  typedef basic_fstream<char>  fstream;
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  typedef basic_syncbuf<char>     syncbuf;
+  typedef basic_osyncstream<char> osyncstream;
+#endif
+
+  typedef basic_streambuf<wchar_t> wstreambuf;
+  typedef basic_istream<wchar_t>   wistream;
+  typedef basic_ostream<wchar_t>   wostream;
+  typedef basic_iostream<wchar_t>  wiostream;
+
+  typedef basic_stringbuf<wchar_t>     wstringbuf;
+  typedef basic_istringstream<wchar_t> wistringstream;
+  typedef basic_ostringstream<wchar_t> wostringstream;
+  typedef basic_stringstream<wchar_t>  wstringstream;
+
+  typedef basic_filebuf<wchar_t>  wfilebuf;
+  typedef basic_ifstream<wchar_t> wifstream;
+  typedef basic_ofstream<wchar_t> wofstream;
+  typedef basic_fstream<wchar_t>  wfstream;
+
+#if __cplusplus >= 202002L
+  typedef basic_syncbuf<wchar_t>     wsyncbuf;
+  typedef basic_osyncstream<wchar_t> wosyncstream;
+#endif
+
+  template<class state> class fpos;
+  typedef fpos<std::mbstate_t> streampos;
+  typedef fpos<std::mbstate_t> wstreampos;
+#if __cplusplus >= 202002L
+  typedef fpos<std::mbstate_t> u8streampos;
+#endif
+#if __cplusplus >= 201103L
+  typedef fpos<std::mbstate_t> u16streampos;
+  typedef fpos<std::mbstate_t> u32streampos;
+#endif
+}
diff --git a/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc b/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc
new file mode 100644
index 00000000000..e2c9c9b8dfa
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc
@@ -0,0 +1,214 @@
+// { dg-do compile { target c++11 } }
+
+#include <iosfwd>
+
+template<class, class> struct Same { static constexpr bool value = false; };
+template<class T> struct Same<T, T> { static constexpr bool value = true; };
+
+template<class T> using Traits = std::char_traits<T>;
+template<class T> using Alloc = std::allocator<T>;
+
+using std::basic_ios;
+
+static_assert(Same<basic_ios<char>,
+		   basic_ios<char, Traits<char>>
+		   >::value,
+    "std::basic_ios<char> has the correct default template argument");
+
+static_assert(Same<basic_ios<wchar_t>,
+		   basic_ios<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ios<wchar_t> has the correct default template argument");
+
+using std::basic_streambuf;
+
+static_assert(Same<basic_streambuf<char>,
+		   basic_streambuf<char, Traits<char>>
+		   >::value,
+    "std::basic_streambuf<char> has the correct default template argument");
+
+static_assert(Same<basic_streambuf<wchar_t>,
+		   basic_streambuf<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_streambuf<wchar_t> has the correct default template argument");
+
+using std::basic_istream;
+
+static_assert(Same<basic_istream<char>,
+		   basic_istream<char, Traits<char>>
+		   >::value,
+    "std::basic_istream<char> has the correct default template argument");
+
+static_assert(Same<basic_istream<wchar_t>,
+		   basic_istream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_istream<wchar_t> has the correct default template argument");
+
+using std::basic_ostream;
+
+static_assert(Same<basic_ostream<char>,
+		   basic_ostream<char, Traits<char>>
+		   >::value,
+    "std::basic_ostream<char> has the correct default template argument");
+
+static_assert(Same<basic_ostream<wchar_t>,
+		   basic_ostream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ostream<wchar_t> has the correct default template argument");
+
+using std::basic_iostream;
+
+static_assert(Same<basic_iostream<char>,
+		   basic_iostream<char, Traits<char>>>::value,
+    "std::basic_iostream<char> has the correct default template argument");
+
+static_assert(Same<basic_iostream<wchar_t>,
+		   basic_iostream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_iostream<wchar_t> has the correct default template argument");
+
+using std::basic_stringbuf;
+
+static_assert(Same<basic_stringbuf<char>,
+		   basic_stringbuf<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_stringbuf<char> has the correct default template argument");
+
+static_assert(Same<basic_stringbuf<wchar_t>,
+		   basic_stringbuf<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_stringbuf<wchar_t> has the correct default template argument");
+
+using std::basic_istringstream;
+
+static_assert(Same<basic_istringstream<char>,
+		   basic_istringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_istringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_istringstream<wchar_t>,
+		   basic_istringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_istringstream<wchar_t> has the correct default template argument");
+
+using std::basic_ostringstream;
+
+static_assert(Same<basic_ostringstream<char>,
+		   basic_ostringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_ostringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ostringstream<wchar_t>,
+		   basic_ostringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_ostringstream<wchar_t> has the correct default template argument");
+
+using std::basic_stringstream;
+
+static_assert(Same<basic_stringstream<char>,
+		   basic_stringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_stringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_stringstream<wchar_t>,
+		   basic_stringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_stringstream<wchar_t> has the correct default template argument");
+
+using std::basic_filebuf;
+
+static_assert(Same<basic_filebuf<char>,
+		   basic_filebuf<char, Traits<char>>
+		   >::value,
+    "std::basic_filebuf<char> has the correct default template argument");
+
+static_assert(Same<basic_filebuf<wchar_t>,
+		   basic_filebuf<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_filebuf<wchar_t> has the correct default template argument");
+
+using std::basic_ifstream;
+
+static_assert(Same<basic_ifstream<char>,
+		   basic_ifstream<char, Traits<char>>
+		   >::value,
+    "std::basic_ifstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ifstream<wchar_t>,
+		   basic_ifstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ifstream<wchar_t> has the correct default template argument");
+
+using std::basic_ofstream;
+
+static_assert(Same<basic_ofstream<char>,
+		   basic_ofstream<char, Traits<char>>
+		   >::value,
+    "std::basic_ofstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ofstream<wchar_t>,
+		   basic_ofstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ofstream<wchar_t> has the correct default template argument");
+
+using std::basic_fstream;
+
+static_assert(Same<basic_fstream<char>,
+		   basic_fstream<char, Traits<char>>
+		   >::value,
+    "std::basic_fstream<char> has the correct default template argument");
+
+static_assert(Same<basic_fstream<wchar_t>,
+		   basic_fstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_fstream<wchar_t> has the correct default template argument");
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+using std::basic_syncbuf;
+
+static_assert(Same<basic_syncbuf<char>,
+		   basic_syncbuf<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_syncbuf<char> has the correct default template argument");
+
+static_assert(Same<basic_syncbuf<wchar_t>,
+		   basic_syncbuf<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_syncbuf<wchar_t> has the correct default template argument");
+
+using std::basic_osyncstream;
+
+static_assert(Same<basic_osyncstream<char>,
+		   basic_osyncstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_osyncstream<char> has the correct default template argument");
+
+static_assert(Same<basic_osyncstream<wchar_t>,
+		   basic_osyncstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_osyncstream<wchar_t> has the correct default template argument");
+#endif
+
+using std::istreambuf_iterator;
+
+static_assert(Same<istreambuf_iterator<char>,
+		   istreambuf_iterator<char, Traits<char>>
+		   >::value,
+    "std::istreambuf_iterator<char> has the correct default template argument");
+
+static_assert(Same<istreambuf_iterator<wchar_t>,
+		   istreambuf_iterator<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::istreambuf_iterator<wchar_t> has the correct default template argument");
+
+using std::ostreambuf_iterator;
+
+static_assert(Same<ostreambuf_iterator<char>,
+		   ostreambuf_iterator<char, Traits<char>>
+		   >::value,
+    "std::ostreambuf_iterator<char> has the correct default template argument");
+
+static_assert(Same<ostreambuf_iterator<wchar_t>,
+		   ostreambuf_iterator<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::ostreambuf_iterator<wchar_t> has the correct default template argument");
diff --git a/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc
index 7df70604ea6..0d76e63da7b 100644
--- a/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc
+++ b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc
@@ -69,6 +69,16 @@ test01()
 void
 test02()
 {
+  VERIFY(regex_match("-", regex("[-]", regex_constants::ECMAScript)));
+  VERIFY(regex_match("-", regex("[--]", regex_constants::ECMAScript)));
+  VERIFY(regex_match("-", regex("[---]", regex_constants::ECMAScript)));
+  VERIFY(regex_match("-", regex("[----]", regex_constants::ECMAScript)));
+  VERIFY(regex_match("-", regex("[-----]", regex_constants::ECMAScript)));
+
+  VERIFY(regex_match("-", regex("[-]", regex_constants::extended)));
+  VERIFY(regex_match("-", regex("[--]", regex_constants::extended)));
+  VERIFY(regex_match("-", regex("[---]", regex_constants::extended)));
+  VERIFY(regex_match("-", regex("[----]", regex_constants::extended)));
   try
   {
     std::regex re("[-----]", std::regex::extended);
@@ -78,7 +88,6 @@ test02()
   {
     VERIFY(e.code() == std::regex_constants::error_range);
   }
-  std::regex re("[-----]", std::regex::ECMAScript);
 
   VERIFY(!regex_match("b", regex("[-ac]", regex_constants::extended)));
   VERIFY(!regex_match("b", regex("[ac-]", regex_constants::extended)));
@@ -93,7 +102,27 @@ test02()
   }
   catch (const std::regex_error& e)
   {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+  try
+  {
+    regex("[@--]", regex_constants::extended);
+    VERIFY(false);
   }
+  catch (const std::regex_error& e)
+  {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+  try
+  {
+    regex("[--%]", regex_constants::extended);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+
   VERIFY(regex_match("].", regex("[][.hyphen.]-0]*", regex_constants::extended)));
 }
 
@@ -158,6 +187,36 @@ test06()
   VERIFY(regex_match("a-", debian_cron_namespace_ok));
 }
 
+// libstdc++/102447
+void
+test07()
+{
+  VERIFY(regex_match("-", std::regex("[\\w-]", std::regex::ECMAScript)));
+  VERIFY(regex_match("a", std::regex("[\\w-]", std::regex::ECMAScript)));
+  VERIFY(regex_match("-", std::regex("[a-]", std::regex::ECMAScript)));
+  VERIFY(regex_match("a", std::regex("[a-]", std::regex::ECMAScript)));
+
+  try
+  {
+    std::regex re("[\\w-a]", std::regex::ECMAScript);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+
+  try
+  {
+    std::regex re("[\\w--]", std::regex::ECMAScript);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+}
+
 int
 main()
 {
@@ -167,6 +226,7 @@ main()
   test04();
   test05();
   test06();
+  test07();
 
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/multiline.cc b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/multiline.cc
new file mode 100644
index 00000000000..a1982fc8f78
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/multiline.cc
@@ -0,0 +1,74 @@
+// { dg-do run { target c++11 } }
+#include <regex>
+#include <testsuite_hooks.h>
+
+#if __cplusplus >= 201703L || !defined __STRICT_ANSI__
+static_assert( std::regex_constants::multiline == std::regex::multiline );
+static_assert( std::regex_constants::__multiline == std::regex::multiline );
+#else
+namespace test { constexpr int multiline = 0; }
+namespace check {
+  using namespace test;
+  using namespace std::regex_constants;
+  int ml = multiline;
+}
+#endif
+
+void
+test01()
+{
+  using namespace std::regex_constants;
+
+  std::regex ml{"^a.$", __multiline};
+  VERIFY( ml.flags() == __multiline );
+  VERIFY(!std::regex_search("abx\nxab", ml));
+  VERIFY(std::regex_search("x\nab", ml));
+  VERIFY(std::regex_search("ab\n", ml));
+  VERIFY(std::regex_search("x\nab\nx", ml));
+
+  ml.assign("a$\n^b$\n^c", ECMAScript|__multiline);
+  VERIFY( ml.flags() == ECMAScript|__multiline );
+  VERIFY( regex_search("a\nb\nc", ml) );
+
+  ml.assign("a$\n^b$\n^c", ECMAScript|__multiline|icase);
+  VERIFY( ml.flags() == ECMAScript|__multiline|icase );
+  VERIFY( regex_search("A\nB\nC", ml) );
+}
+
+void
+test_pr102480()
+{
+  using namespace std::regex_constants;
+
+  std::regex re("^a");
+  std::regex reml("^a", __multiline);
+  VERIFY( std::regex_match("\na" + 1, re));
+  VERIFY( std::regex_match("\na" + 1, reml));
+  // PR libstdc++/102480
+  VERIFY(!std::regex_match("\na" + 1, re, match_prev_avail));
+  VERIFY( std::regex_match("\na" + 1, reml, match_prev_avail));
+  VERIFY(!std::regex_match("\na" + 1, re, match_not_bol));
+  VERIFY(!std::regex_match("\na" + 1, re, match_prev_avail|match_not_bol));
+  VERIFY( std::regex_match("\na" + 1, reml, match_prev_avail|match_not_bol));
+  VERIFY(!std::regex_match("\ra" + 1, re, match_prev_avail));
+  VERIFY( std::regex_match("\ra" + 1, reml, match_prev_avail));
+  VERIFY(!std::regex_match("xa" + 1, re, match_prev_avail));
+  VERIFY(!std::regex_match("xa" + 1, reml, match_prev_avail));
+
+  std::regex bre("^a", basic|__multiline);
+  VERIFY(std::regex_match("\na" + 1, bre));
+  VERIFY(!std::regex_match("\na" + 1, bre, match_not_bol));
+  // multiline is ignored for any grammar except ECMAScript,
+  // so none of the following should match even though
+  // match_prev_avail is set and *--first == '\n'.
+  VERIFY(!std::regex_match("\na" + 1, bre, match_prev_avail));
+  VERIFY(!std::regex_match("\na" + 1, bre, match_prev_avail|match_not_bol));
+  VERIFY(!std::regex_match("\ra" + 1, bre, match_prev_avail));
+  VERIFY(!std::regex_match("xa" + 1, bre, match_prev_avail));
+}
+
+int main()
+{
+  test01();
+  test_pr102480();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/103664.cc b/libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/103664.cc
new file mode 100644
index 00000000000..c61912823d5
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/103664.cc
@@ -0,0 +1,12 @@
+// { dg-do run { target c++11 } }
+// { dg-timeout-factor 2 }
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+int main()
+{
+  // PR libstdc++/103664
+  std::string a = regex_replace("123", std::regex("2"), std::string("a\0b", 3));
+  VERIFY( a == std::string("1a\0b3", 5) );
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc
new file mode 100644
index 00000000000..f8e7fb2364d
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc
@@ -0,0 +1,25 @@
+// { dg-do run { target c++11 } }
+
+#include <regex>
+#include <string>
+#include <climits>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/106607 - Regex integer overflow on large backreference value
+
+int main()
+{
+  std::regex r("(.)\\1"); // OK
+
+  try
+  {
+    long long n = (unsigned)-1 + 2LL;          // 4294967297 for 32-bit int
+    VERIFY( (int)n == 1 );                     // 4294967297 % 2^32 == 1
+    std::regex r("(.)\\" + std::to_string(n)); // Invalid back reference.
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY( e.code() == std::regex_constants::error_backref );
+  }
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/84110.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/84110.cc
new file mode 100644
index 00000000000..a4d5db6c14a
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/84110.cc
@@ -0,0 +1,43 @@
+// { dg-do run { target c++11 } }
+// { dg-timeout-factor 2 }
+#include <regex>
+#include <string>
+#include <testsuite_hooks.h>
+
+void test01()
+{
+  const std::string s(1ul, '\0');
+  std::regex re(s);
+  VERIFY( std::regex_match(s, re) ); // PR libstdc++/84110
+
+#if __cpp_exceptions
+  using namespace std::regex_constants;
+  // See https://gcc.gnu.org/pipermail/gcc-patches/2021-October/582486.html
+  using std::regex_constants::extended;
+
+  for (auto syn : {basic, extended, awk, grep, egrep})
+  {
+    try
+    {
+      std::regex{s, syn}; // '\0' is not valid for other grammars
+      VERIFY( false );
+    }
+    catch (const std::regex_error&)
+    {
+    }
+  }
+#endif
+}
+
+void test02()
+{
+  const std::string s("uh-\0h", 5);
+  std::regex re(s);
+  VERIFY( std::regex_match(s, re) );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/assign/exception_safety.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/assign/exception_safety.cc
new file mode 100644
index 00000000000..462eebcf2cd
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/assign/exception_safety.cc
@@ -0,0 +1,20 @@
+// { dg-do run { target c++11 } }
+#include <regex>
+#include <testsuite_hooks.h>
+
+int main()
+{
+  const auto f = std::regex::ECMAScript|std::regex::icase;
+  std::regex re("abc", f);
+  try
+  {
+    re.assign("[", std::regex::extended);
+    VERIFY( false );
+  }
+  catch (const std::regex_error&)
+  {
+    // [re.regex.assign] "If an exception is thrown, *this is unchanged."
+    VERIFY( re.flags() == f );
+    VERIFY( std::regex_match("abc", re) );
+  }
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/char/other.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/char/other.cc
new file mode 100644
index 00000000000..10c20d9d4bc
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/char/other.cc
@@ -0,0 +1,38 @@
+// { dg-do run { target c++11 } }
+// { dg-timeout-factor 2 }
+#include <regex>
+#include <testsuite_iterators.h>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  signed char s[] = { 'a', '.' };
+  std::regex re(s, s+2); // This used to fail up to GCC 11.2
+  // VERIFY( regex_match("an", re) );
+
+  std::wstring str = L"xx";
+  str[0] = '1';
+  str[1] = '2';
+  re.assign(str.begin(), str.end());
+  VERIFY( regex_match("12", re) );
+}
+
+void
+test02()
+{
+  int i[] = { 'a', '.', '[', 'x', 'y', 'z', ']' };
+  __gnu_test::forward_container<int> fwd(i);
+  std::regex re(fwd.begin(), fwd.end());
+  VERIFY( regex_match("any", re) );
+
+  __gnu_test::input_container<int> input(i);
+  re.assign(input.begin(), input.end(), std::regex::icase);
+  VERIFY( regex_match("ANY", re) );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/grammar.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/grammar.cc
new file mode 100644
index 00000000000..fd8531c4530
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/grammar.cc
@@ -0,0 +1,53 @@
+// { dg-do run { target c++11 } }
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::regex re{""};
+  VERIFY( re.flags() & std::regex::ECMAScript );
+
+  std::regex re2{"", std::regex::flag_type{}};
+  VERIFY( re2.flags() == std::regex::flag_type() ); // See also PR 83598
+}
+
+void
+test02()
+{
+  // A valid value of type syntax_option_type shall have at most one of the
+  // grammar elements ECMAScript, basic, extended, awk, grep, egrep, set.
+
+  try
+  {
+    std::regex{"", std::regex::ECMAScript|std::regex::basic};
+    VERIFY( false );
+  }
+  catch (const std::regex_error&)
+  {
+  }
+
+  try
+  {
+    std::regex{"", std::regex::extended|std::regex::basic};
+    VERIFY( false );
+  }
+  catch (const std::regex_error&)
+  {
+  }
+
+  try
+  {
+    std::regex{"", std::regex::grep|std::regex::basic};
+    VERIFY( false );
+  }
+  catch (const std::regex_error&)
+  {
+  }
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/match_results/102667.cc b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
index 9e38c9edaa4..1614f3f9eb8 100644
--- a/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
+++ b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
@@ -1,4 +1,5 @@
 // { dg-do run { target c++11 } }
+// { dg-timeout-factor 2 }
 
 #include <regex>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc b/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
index 7eab17b12e0..dffdaef7afd 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
@@ -1,3 +1,4 @@
+// { dg-options "-O1" }
 // { dg-do link { target c++11 } }
 
 // Copyright (C) 2009-2021 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/lwg3220.cc b/libstdc++-v3/testsuite/29_atomics/atomic/lwg3220.cc
new file mode 100644
index 00000000000..d2ff6cf9fe3
--- /dev/null
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/lwg3220.cc
@@ -0,0 +1,13 @@
+// { dg-do compile { target c++11 } }
+// DR 3220. P0558 broke conforming C++14 uses of atomic shared_ptr
+
+#include <atomic>
+#include <memory>
+
+struct Abstract { virtual void test() = 0; };
+struct Concrete : Abstract { virtual void test() override {} };
+
+int main() {
+  std::shared_ptr<Abstract> ptr;
+  std::atomic_store<Abstract>(&ptr, std::make_shared<Concrete>());
+}
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc b/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
index 9d92ff954f1..f572ce7ef11 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
@@ -5,13 +5,13 @@
 #include <atomic>
 
 void
-test1(const std::atomic<char*>& a, char* p)
+test1(std::atomic<char*>& a, char* p)
 {
   a.wait(p);
 }
 
 void
-test2(const std::atomic<int>* a, int v)
+test2(std::atomic<int>* a, int v)
 {
   std::atomic_wait(a, v);
   std::atomic_notify_one(a);
diff --git a/libstdc++-v3/testsuite/30_threads/async/106695.cc b/libstdc++-v3/testsuite/30_threads/async/106695.cc
new file mode 100644
index 00000000000..74996342dc7
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/async/106695.cc
@@ -0,0 +1,29 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-gthreads "" }
+
+// PR libstdc++/106695
+// Explicit copy constructor does not work for a parameter passed via std::async
+
+#include <future>
+
+struct A {
+  A() = default;
+  explicit A(const A&) = default;
+};
+
+void func(const A&) { }
+
+void
+test_async()
+{
+  (void) std::async(std::launch::async, func, A{});
+  (void) std::async(std::launch::deferred, func, A{});
+  (void) std::async(func, A{});
+}
+
+void
+test_task()
+{
+  std::packaged_task<void(const A&)> task(func);
+  task(A{});
+}
diff --git a/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc b/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc
new file mode 100644
index 00000000000..0eb69763ab9
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc
@@ -0,0 +1,85 @@
+// // Copyright (C) 2017-2022 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++17 } }
+
+#include <future>
+
+template<typename T, typename U> struct require_same;
+template<typename T> struct require_same<T, T> { using type = void; };
+
+template<typename T, typename U>
+  typename require_same<T, U>::type
+  check_type(U&) { }
+
+void f0v();
+void f0vn() noexcept;
+int f0i();
+int f0in() noexcept;
+long f1l(int&);
+long f1ln(double*) noexcept;
+
+void
+test01()
+{
+  std::packaged_task task1{f0v};
+  check_type<std::packaged_task<void()>>(task1);
+
+  std::packaged_task task2{f0vn};
+  check_type<std::packaged_task<void()>>(task2);
+
+  std::packaged_task task3{f0i};
+  check_type<std::packaged_task<int()>>(task3);
+
+  std::packaged_task task4{f0in};
+  check_type<std::packaged_task<int()>>(task4);
+
+  std::packaged_task task5{f1l};
+  check_type<std::packaged_task<long(int&)>>(task5);
+
+  std::packaged_task task6{f1ln};
+  check_type<std::packaged_task<long(double*)>>(task6);
+
+  std::packaged_task task5a{std::move(task5)};
+  check_type<std::packaged_task<long(int&)>>(task5a);
+
+  std::packaged_task task6a{std::move(task6)};
+  check_type<std::packaged_task<long(double*)>>(task6a);
+}
+
+struct X {
+  int operator()(const short&, void*);
+};
+
+struct Y {
+  void operator()(int) const & noexcept;
+};
+
+void
+test02()
+{
+  X x;
+  std::packaged_task task1{x};
+  check_type<std::packaged_task<int(const short&, void*)>>(task1);
+
+  Y y;
+  std::packaged_task task2{y};
+  check_type<std::packaged_task<void(int)>>(task2);
+
+  std::packaged_task task3{[&x](float) -> X& { return x; }};
+  check_type<std::packaged_task<X&(float)>>(task3);
+}
diff --git a/libstdc++-v3/testsuite/30_threads/thread/106695.cc b/libstdc++-v3/testsuite/30_threads/thread/106695.cc
new file mode 100644
index 00000000000..97e9e922d8e
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/thread/106695.cc
@@ -0,0 +1,21 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-gthreads "" }
+
+// PR libstdc++/106695
+// Explicit copy constructor does not work for a parameter passed via std::async
+
+#include <thread>
+
+struct A {
+  A() = default;
+  explicit A(const A&) = default;
+};
+
+void func(const A&) { }
+
+void
+test_thread()
+{
+  std::thread t(func, A{});
+  t.join();
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc b/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
index 806c511ebef..f005b7d5293 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
@@ -99,7 +99,7 @@ void
 test02()
 {
   namespace fs = std::experimental::filesystem;
-  auto dir = __gnu_test::nonexistent_path();
+  const auto dir = __gnu_test::nonexistent_path();
   fs::create_directories(dir/"subdir");
 
   std::error_code ec;
@@ -129,7 +129,12 @@ test02()
   }
 #endif
 
-  fs::remove_all(dir, ec);
+  // Cannot use fs::remove_all here because that depends on
+  // recursive_directory_iterator which would use the fake readdir above.
+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  ::rmdir((dir/"subdir").c_str());
+  ::rmdir(dir.c_str());
+#endif
 }
 
 int
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
index 947d270e6a4..817e51d2d21 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
@@ -190,6 +190,34 @@ test05()
   VERIFY( !ec );  // Previous value should be cleared (LWG 2683)
 }
 
+void
+test_pr99290()
+{
+  auto dir = __gnu_test::nonexistent_path();
+  auto source = dir/"source";
+  auto dest = dir/"dest";
+  create_directories(source/"emptydir");
+  create_directories(dest/"emptydir");
+  std::ofstream{source/"file"} << 'a';
+  std::ofstream{dest/"file"} << 'b';
+  // PR libstdc++/99290
+  // std::filesystem::copy does not always report errors for recursion
+  std::error_code ec;
+  copy(source, dest, ec);
+  VERIFY( ec == std::errc::file_exists );
+
+#if __cpp_exceptions
+  try {
+    copy(source, dest);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::file_exists );
+  }
+#endif
+
+  remove_all(dir);
+}
+
 int
 main()
 {
@@ -198,4 +226,5 @@ main()
   test03();
   test04();
   test05();
+  test_pr99290();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
index 03e777b0041..b78f663dee9 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
@@ -21,6 +21,7 @@
 
 #include <experimental/filesystem>
 #include <stdlib.h>
+#include <stdio.h>
 #include <testsuite_hooks.h>
 #include <testsuite_fs.h>
 
@@ -59,7 +60,10 @@ test01()
   clean_env();
 
   if (!fs::exists("/tmp"))
+  {
+    puts("/tmp doesn't exist, not testing it for temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec = make_error_code(std::errc::invalid_argument);
   fs::path p1 = fs::temp_directory_path(ec);
@@ -75,8 +79,11 @@ test02()
 {
   clean_env();
 
-  if (set_env("TMPDIR", __gnu_test::nonexistent_path().string()))
+  if (!set_env("TMP", __gnu_test::nonexistent_path().string()))
+  {
+    puts("Cannot set environment variables, not testing temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec;
   fs::path p = fs::temp_directory_path(ec);
@@ -98,6 +105,8 @@ test03()
   if (!__gnu_test::permissions_are_testable())
     return;
 
+  clean_env();
+
   auto p = __gnu_test::nonexistent_path();
   create_directories(p/"tmp");
   permissions(p, fs::perms::none);
@@ -122,8 +131,10 @@ test03()
 void
 test04()
 {
+  clean_env();
+
   __gnu_test::scoped_file f;
-  set_env("TMPDIR", f.path.string());
+  set_env("TMP", f.path.string());
   std::error_code ec;
   auto r = fs::temp_directory_path(ec);
   VERIFY( ec == std::make_error_code(std::errc::not_a_directory) );
diff --git a/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc b/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
index 5df9f330cd4..ed0614e2797 100644
--- a/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
+++ b/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
@@ -20,6 +20,7 @@
 // { dg-do run }
 // { dg-options "-pthread"  }
 // { dg-require-effective-target pthread }
+// { dg-timeout-factor 2 }
 
 #include <ext/rope>
 #include <cstring>
@@ -33,7 +34,7 @@ typedef __gnu_cxx::rope<char, std::allocator<char> > rope_type;
 rope_type foo2;
 rope_type foo4;
 
-void* thread_main(void *) 
+void* thread_main(void *)
 {
   // To see a problem with gcc 3.3 and before, set a break point here.
   // Single step through c_str implementation, call sched_yield after
diff --git a/libstdc++-v3/testsuite/std/ranges/access/empty.cc b/libstdc++-v3/testsuite/std/ranges/access/empty.cc
index b2d8b105325..693355c6cf5 100644
--- a/libstdc++-v3/testsuite/std/ranges/access/empty.cc
+++ b/libstdc++-v3/testsuite/std/ranges/access/empty.cc
@@ -119,6 +119,16 @@ test04()
   static_assert( ! noexcept(std::ranges::empty(E3{})) );
 }
 
+template<typename T>
+  concept has_empty = requires (T& t) { std::ranges::empty(t); };
+
+// If T is an array of unknown bound, ranges::empty(E) is ill-formed.
+static_assert( ! has_empty<int[]> );
+static_assert( ! has_empty<int(&)[]> );
+static_assert( ! has_empty<int[][2]> );
+struct Incomplete;
+static_assert( ! has_empty<Incomplete[]> );
+
 int
 main()
 {
diff --git a/libstdc++-v3/testsuite/std/ranges/access/size.cc b/libstdc++-v3/testsuite/std/ranges/access/size.cc
index f25a1cb9ddb..db843cddccb 100644
--- a/libstdc++-v3/testsuite/std/ranges/access/size.cc
+++ b/libstdc++-v3/testsuite/std/ranges/access/size.cc
@@ -120,6 +120,16 @@ test06()
   static_assert( std::ranges::size(R{}) == 42 );
 }
 
+template<typename T>
+  concept has_size = requires (T& t) { std::ranges::size(t); };
+
+// If T is an array of unknown bound, ranges::size(E) is ill-formed.
+static_assert( ! has_size<int[]> );
+static_assert( ! has_size<int(&)[]> );
+static_assert( ! has_size<int[][2]> );
+struct Incomplete;
+static_assert( ! has_size<Incomplete[]> );
+
 int
 main()
 {
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
index d774e8d9385..14e254bc734 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
@@ -193,6 +193,20 @@ test11()
     ;
 }
 
+void
+test13()
+{
+  // PR libstdc++/106320
+  auto l = std::views::transform([](auto x) {
+    return x | std::views::transform([x=0](auto y) {
+      return y;
+    });
+  });
+  static_assert(!std::default_initializable<decltype(l)>);
+  std::vector<std::vector<int>> v{{5, 6, 7}};
+  v | l | std::views::join;
+}
+
 int
 main()
 {
@@ -207,4 +221,5 @@ main()
   test09();
   test10();
   test11();
+  test13();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/p2325.cc b/libstdc++-v3/testsuite/std/ranges/p2325.cc
index 205b3458928..ab743916f5b 100644
--- a/libstdc++-v3/testsuite/std/ranges/p2325.cc
+++ b/libstdc++-v3/testsuite/std/ranges/p2325.cc
@@ -5,8 +5,8 @@
 // Parts of P2325R3 are deliberately omitted in libstdc++ 11, in particular the
 // removal of default ctors for back_/front_insert_iterator, ostream_iterator,
 // ref_view and basic_istream_view/::iterator, so as to maximize backward
-// compatibility with pre-P2325R3 code.  So most static_asserts in this test fail,
-// see the xfails at the end of this file.
+// compatibility with pre-P2325R3 code.  Namely all asserts that verify lack of
+// default constructibility fail; see the xfails at the end of this file.
 
 #include <ranges>
 #include <iterator>
@@ -93,7 +93,7 @@ test06()
   static_assert(default_initializable<decltype(views::single(0) | adaptor(f1))>);
   static_assert(!default_initializable<decltype(views::single(0) | adaptor(f2))>);
 
-  struct S { S() = delete; };
+  struct S { S() = delete; S(const S&) = default; S(S&&) = default; };
   static_assert(!default_initializable<decltype(views::single(declval<S>()) | adaptor(f1))>);
   static_assert(!default_initializable<decltype(views::single(declval<S>()) | adaptor(f2))>);
 }
@@ -109,7 +109,7 @@ void
 test07()
 {
   // Verify join_view is conditionally default constructible.
-  struct S { S() = delete; };
+  struct S { S() = delete; S(const S&) = default; S(S&&) = default; };
   using type1 = ranges::join_view<ranges::single_view<ranges::single_view<S>>>;
   static_assert(!default_initializable<type1>);
   using type2 = ranges::join_view<ranges::single_view<ranges::single_view<int>>>;
@@ -173,6 +173,10 @@ test11()
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 76 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 77 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 84 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 94 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 97 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 98 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 114 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 124 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 126 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 128 }
