Alex Coplan (3):
      varasm: Fix type confusion bug
      aarch64: Fix up bfmlal lane pattern [PR104921]
      arm: Fix ICE due to infinite splitting [PR109800]

Alexandre Oliva (5):
      testsuite: vect: update unaligned message
      [PR105324] libstdc++: testsuite: pr105324 requires FP from_char
      libstdc++: ppc: conditionalize vsx-only simd intrinsics
      libstdc++: check for openat
      libstdc++: check for openat with dirfd in std::filesystem

Andre Vieira (1):
      aarch64: Implement ACLE Data Intrinsics

Andreas Krebbel (1):
      IBM zSystems/testsuite: PR105147: Skip pr105140.c

Andrew Pinski (3):
      Fix fc-prototypes usage with C_INT64_T and non LP64 Targets.
      match.pd: When simplifying BFR of an insert, require a mode precision integral type [PR108688]
      MATCH: Fix infinite loop between `vec_cond(vec_cond(a,b,0), c, d)` and `a & b`

Anthony Sharp (1):
      call_summary: add missing template keyword

Arsen Arsenović (2):
      c++: top level bind when rewriting coroutines [PR106188]
      extend.texi: replace @itemx not preceded by @item.

Christophe Lyon (1):
      aarch64: fix warning emission for ABI break since GCC 9.1

David Malcolm (2):
      analyzer: fix ICE comparing VECTOR_CSTs [PR105252]
      analyzer: fix ICEs on complex constants [PR105365,105366]

Detlef Vollmann (1):
      libstdc++: Move closing brace outside #endif [PR104866]

Dimitar Dimitrov (1):
      pru: Fix CLZ expansion for QI and HI modes

Eric Biggers (1):
      options: fix cl_target_option_print_diff() with strings

Eric Botcazou (9):
      Fix internal error with vectorization on SPARC
      Fix PR target/107248
      Fix recent thinko in operand_equal_p
      Fix wrong array type conversion with different storage orde
      Fix thinko in operator_bitwise_xor::op1_range
      Fix problematic interaction between bitfields, unions, SSO and SRA
      Fix PR target/90458
      Fix PR target/109140
      Remove obsolete configure code in gnattools

Florian Weimer (2):
      libsanitizer: Avoid implicit function declaration in configure test
      libiberty: Fix C89-isms in configure tests

Francois-Xavier Coudert (1):
      LTO: Prune some warnings in the testsuite

François Dumont (1):
      libstdc++: Fix printing of std::span for versioned namespace

François-Xavier Coudert (1):
      Darwin: Future-proof and homogeneize detection of darwin versions

Fritz Reese (1):
      fortran: Fix conv of UNION constructors [PR105310]

GCC Administrator (544):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Georg-Johann Lay (1):
      Fix PR target/99184: Wrong cast from double to 16-bit and 32-bit ints

H.J. Lu (5):
      x86: Add missing .note.GNU-stack to assembly source
      x86: Add .note.GNU-stack section only for Linux
      x86: Require AVX for F16C and VAES
      i386: Mark XMM4-XMM6 as clobbered by encodekey128/encodekey256
      Always use TYPE_MODE instead of DECL_MODE for vector field

Haochen Gui (2):
      rs6000: correct vector sign extend builtins on Big Endian
      rs6000: call vector load/store with length only on 64-bit Power10

Harald Anlauf (42):
      Fortran: improve error recovery on invalid array section
      Fortran: fix error recovery on invalid array section
      Fortran: fix checking of arguments to UNPACK when MASK is a variable [PR105813]
      Fortran: fix simplification of INDEX(str1,str2) [PR105691]
      Fortran: handle explicit-shape specs with constant bounds [PR105954]
      Fortran: improve error recovery for EXTENDS_TYPE_OF() [PR106121]
      Fortran: error recovery on invalid CLASS(), PARAMETER declarations [PR105243]
      Fortran: error recovery from calculation of storage size of a symbol [PR103504]
      Fortran: catch NULL pointer dereferences while simplifying PACK [PR106857]
      Fortran: error recovery on invalid ARRAY argument to FINDLOC [PR106986]
      Fortran: improve error recovery while simplifying size of bad array [PR103694]
      Fortran: NULL pointer dereference in invalid simplification [PR106985]
      Fortran: fix ICE in generate_coarray_sym_init [PR82868]
      Fortran: error recovery while simplifying intrinsic UNPACK [PR107054]
      Fortran: error recovery with references of bad array constructors [PR105633]
      Fortran: BOZ literal constants are not compatible to any type [PR103413]
      Fortran: reject NULL actual argument without explicit interface [PR107576]
      Fortran: incorrect array bounds when bound intrinsic used in decl [PR108131]
      Fortran: diagnose USE associated symbols in COMMON blocks [PR108453]
      Fortran: fix ICE in check_charlen_present [PR108420]
      Fortran: fix ICE in get_expr_storage_size [PR108421]
      Fortran: fix NULL pointer dereference in gfc_check_dependency [PR108502]
      Fortran: avoid ICE on invalid array subscript triplets [PR108501]
      Fortran: error recovery for bad initializers of implied-shape arrays [PR106209]
      Fortran: ICE in transformational_result [PR108529]
      Fortran: fix ICE in compare_bound_int [PR108527]
      Fortran: error recovery on invalid array section [PR108609]
      Fortran: ASSOCIATE variables should not be TREE_STATIC [PR95107]
      Fortran: improve checking of character length specification [PR96025]
      Fortran: reject invalid CHARACTER length of derived type components [PR96024]
      Fortran: fix corner case of IBITS intrinsic [PR108937]
      Fortran: fix ICE with bind(c) in block data [PR104332]
      Fortran: fix bounds check for copying of class expressions [PR106945]
      Fortran: procedures with BIND(C) attribute require explicit interface [PR85877]
      Fortran: simplification of NEAREST for large argument [PR109186]
      Fortran: reject MODULE PROCEDURE outside generic module interface [PR99036]
      Fortran: fix compile-time simplification of SET_EXPONENT [PR109511]
      Fortran: CLASS pointer function result in variable definition context [PR109846]
      Fortran: simplification of FINDLOC for constant complex arguments [PR110585]
      Fortran: formal symbol attributes for intrinsic procedures [PR110288]
      Fortran: intrinsics and deferred-length character arguments [PR95947,PR110658]
      Fortran: out of bounds access with nested implied-do IO [PR111837]

Hongyu Wang (1):
      AVX512F: Add missing macro for mask(z?)_scalf_s[sd] [PR 105339]

Iain Buclaw (18):
      libphobos: Don't call free on the TLS array in the emutls destroy function.
      libphobos: Give _Unwind_Exception an alignment that best resembles __attribute__((aligned))
      darwin, d: Support outfile substitution for libphobos
      d: Set TYPE_ARTIFICIAL on internal TypeInfo types
      tilegx: Fix infinite loop in gen-mul-tables generator
      d: Fix error: aggregate value used where floating point was expected
      d: Update DIP links in gdc documentation to point at upstream repository
      d: Fix ICE on named continue label in an unrolled loop [PR107592]
      d: Fix internal compiler error: in visit, at d/imports.cc:72 (PR108050)
      libphobos: Backport library and bindings fixes from mainline
      d: Fix ICE on explicit immutable struct import [PR108877]
      d: Refactor DECL_ARGUMENT and DECL_RESULT generation to own function
      d: Delay removing DECL_EXTERNAL from thunks until funcion has finished
      d: Fix undefined reference to lambda defined in private enum [PR109108]
      d: Suboptimal codegen for __builtin_expect(cond, false)
      d: Fix ICE in setValue, at d/dmd/dinterpret.c:7013
      d: Fix core.volatile.volatileLoad discarded if result is unused
      d: Fix PR 108842: Cannot use enum array with -fno-druntime

Iain Sandoe (13):
      Darwin: Fix bootstrap for X86.
      Darwin: Update rules for handling alignment of globals.
      Darwin: Fix empty g++ command lines [PR105599].
      configure, Darwin: Correct a pasto in host-shared processing.
      libgcc, Darwin: No early install for the compatibility libgcc_s.1.dylib.
      Darwin, fixincludes: Handle MacOS13 SDK Apple-specific deprecations [PR107568].
      Darwin, fixincludes: Handle Apple Blocks in objc/runtime.h.
      libsanitizer, darwin: Unsupport Darwin >= 22 for now.
      c++,coroutines: Stabilize names of promoted slot vars [PR101118].
      c++, coroutines: Fix block nests when the function has no top-level bind.
      c++tools, configury: Configure with C++; test checking status [PR98821].
      Darwin, libgcc : Adjust min version supported for the OS.
      Darwin, PPC: Fix struct layout with pragma pack [PR110044].

Ian Lance Taylor (2):
      libgo: don't include <linux/fs.h> when building gen-sysinfo.go
      syscall: add prlimit

Jakub Jelinek (88):
      emit-rtl: Fix -fcompare-debug bug with label references in debug insns [PR105203]
      sparc: Preserve ORIGINAL_REGNO in epilogue_renumber [PR105257]
      rtlanal: Fix up replace_rtx [PR105333]
      asan: Fix up asan_redzone_buffer::emit_redzone_byte [PR105396]
      i386: Fix up ix86_gimplify_va_arg [PR105331]
      c++: Don't emit deprecated warnings on lambda declarations
      isel: Fix up gimple_expand_vec_set_expr [PR105528]
      testsuite: Fix up pr104637 testcase [PR104637]
      libcpp: Ignore CPP_PADDING tokens in _cpp_parse_expr [PR105732]
      fold-const: Fix up -fsanitize=null in C++ [PR105729]
      varasm: Fix up ICE in narrowing_initializer_constant_valid_p [PR105998]
      libstdc++: Tweak source_location for clang trunk [PR105128]
      libgomp: Fix up target-31.c test [PR106045]
      expand: Fix up expand_cond_expr_using_cmove [PR106030]
      ifcvt: Don't introduce trapping or faulting reads in noce_try_sign_mask [PR106032]
      wide-int: Fix up wi::shifted_mask [PR106144]
      cgraphunit: Don't emit asm thunks for -dx [PR106261]
      c++: Implement P2327R1 - De-deprecating volatile compound operations
      i386: Fix up mode iterators that weren't expanded [PR106721]
      openmp, c: Tighten up c_tree_equal [PR106981]
      openmp: Fix ICE with taskgroup at -O0 -fexceptions [PR107001]
      libgomp: Fix up creation of artificial teams
      c++: Fix up constexpr handling of char/signed char/short pre/post inc/decrement [PR105774]
      c, c++: Fix up excess precision handling of scalar_to_vector conversion [PR107358]
      libatomic: Handle AVX+CX16 AMD like Intel for 16b atomics [PR104688]
      reg-stack: Fix a -fcompare-debug bug in reg-stack [PR107183]
      i386: Uglify some local identifiers in *intrin.h [PR107748]
      c: Fix compile time hog in c_genericize [PR107127]
      testsuite: Fix up broken testcase [PR107127]
      asan: Fix up error recovery for too large frames [PR107317]
      i386: Fix up ix86_abi handling [PR106875]
      cfgbuild: Fix DEBUG_INSN handling in find_bb_boundaries [PR106719]
      ivopts: Fix IP_END handling for asm goto [PR107997]
      into-ssa: Fix emitting debug stmts after asm goto [PR108095]
      c++: Ensure !!var is not an lvalue [PR107065]
      loop-invariant: Split preheader edge if the preheader bb ends with jump [PR106751]
      testsuite: Fix up pr64536.c for LLP64 targets [PR108151]
      testsuite: Fix up pr64536.c for LLP64 targets [PR108151]
      openmp: Don't try to destruct DECL_OMP_PRIVATIZED_MEMBER vars [PR108180]
      cse: Fix up CSE const_anchor handling [PR108193]
      tree-ssa-dom: can_infer_simple_equiv fixes [PR108068]
      expr: Fix up store_expr into SUBREG_PROMOTED_* target [PR108264]
      generic-match-head: Don't assume GENERIC folding is done only early [PR108237]
      fortran: Fix up function types for realloc and sincos{,f,l} builtins [PR108349]
      openmp: Fix up OpenMP expansion of non-rectangular loops [PR108459]
      c++: Fix up handling of references to anon union members in initializers [PR53932]
      store-merging: Disable string_concatenate mode if start or end aren't byte aligned [PR108498]
      doc: Fix up return type of __builtin_va_arg_pack_len [PR108560]
      bbpart: Fix up ICE on asm goto [PR108596]
      c++, openmp: Handle some OMP_*/OACC_* constructs during constant expression evaluation [PR108607]
      ree: Fix -fcompare-debug issues in combine_reaching_defs [PR108573]
      nested, openmp: Wrap OMP_CLAUSE_*_GIMPLE_SEQ into GIMPLE_BIND for declare_vars [PR108435]
      fortran: Fix up hash table usage in gfc_trans_use_stmts [PR108451]
      vect-patterns: Fix up vect_widened_op_tree [PR108692]
      c++: Avoid incorrect shortening of divisions [PR108365]
      c++: Handle structured bindings like anon unions in initializers [PR108474]
      i386: Call get_available_features for all CPUs with max_level >= 1 [PR100758]
      libgomp: Fix up some typos in libgomp.texi
      i386: Fix up builtins used in avx512bf16vlintrin.h [PR108881]
      cgraphclones: Don't share DECL_ARGUMENTS between thunk and its artificial thunk [PR108854]
      cfgexpand: Handle WIDEN_{PLUS,MINUS}_EXPR and VEC_WIDEN_{PLUS,MINUS}_{HI,LO}_EXPR in expand_debug_expr [PR108967]
      c++, debug: Fix up locus of DW_TAG_imported_module [PR108716]
      libquadmath: Assorted libquadmath strtoflt128 fixes [PR87204, PR94756]
      diagnostics: Fix up selftests with $COLUMNS < 42 [PR108973]
      c-family: Fix up -Wsign-compare BIT_NOT_EXPR handling [PR107465]
      c-family: Incremental fix for -Wsign-compare BIT_NOT_EXPR handling [PR107465]
      c++: Don't clear TREE_READONLY for -fmerge-all-constants for non-aggregates [PR107558]
      c++: Treat unnamed bitfields as padding for __has_unique_object_representations [PR109096]
      openmp: Fix up handling of doacross loops with noreturn body in loops [PR108685]
      c, ubsan: Instrument even shortened divisions [PR109151]
      tree-inline: Fix up multiversioning with vector arguments [PR105554]
      c++: Drop TREE_READONLY on vars (possibly) initialized by tls wrapper [PR109164]
      tree-vect-generic: Fix up expand_vector_condition [PR109176]
      predict: Don't emit -Wsuggest-attribute=cold warning for functions which already have that attribute [PR105685]
      i386: Require just 32-bit alignment for SLOT_FLOATxFDI_387 -m32 -mpreferred-stack-boundary=2 DImode temporaries [PR109276]
      sanopt: Return TODO_cleanup_cfg if any .{UB,HWA,A}SAN_* calls were lowered [PR106190]
      libiberty: Make strstr.c in libiberty ANSI compliant
      c++: Fix Solaris bootstraps across midnight
      reassoc: Fix up another ICE with returns_twice call [PR109410]
      tree-ssa-ccp, wide-int: Fix up handling of [LR]ROTATE_EXPR in bitwise ccp [PR109778]
      testsuite: Add further testcase for already fixed PR [PR109778]
      Update ChangeLog and version files for release
      Bump BASE-VER
      match.pd: Ensure (op CONSTANT_CLASS_P CONSTANT_CLASS_P) is simplified [PR109505]
      fortran: Fix ICE on pr96024.f90 on big-endian hosts [PR96024]
      testsuite: Fix up pr107397.f90 test [PR107397]
      store-merging: Fix up >= 64 bit insertion [PR111015]
      tree-ssa-strlen: Fix up handling of conditionally zero memcpy [PR110914]

Jan Hubicka (2):
      Fix modref_tree::remap_params
      Fix ipa-cp wrt volatile loads

Jason Merrill (30):
      c++: rodata and defaulted ctor [PR104142]
      c++: low -faligned-new [PR102071]
      c++: local function versioning [PR104669]
      c++: empty base constexpr -fno-elide-ctors [PR105245]
      c++: temp cleanup in new [PR105265]
      c++: lambda and the current instantiation [PR82980]
      c++: constexpr trivial -fno-elide-ctors [PR104646]
      c++: pack init-capture of unresolved overload [PR102629]
      c++: template-id with current inst qualifier [PR102300]
      c++: alignment of local typedef in template [PR65211]
      c++: template conversion op [PR101698]
      c++: NRV and ref-extended temps [PR101442]
      c++: constexpr ref to array of array [PR102307]
      c++: constexpr empty aggr [PR105795]
      c++: redeclared hidden friend [PR105761]
      c++: redeclared hidden friend take 2 [PR105852]
      c++: anon union designated init [PR105925]
      c++: dependent generic lambda template-id [PR106024]
      c++: defaulted friend op== [PR106361]
      c++: variable tmpl partial specialization [PR108468]
      c++: co_await and initializer_list [PR103871]
      c++: co_await and move-only type [PR105406]
      c++: &enum::enumerator [PR101869]
      c++: namespace-scoped friend in local class [PR69410]
      c++: constant, array, lambda, template [PR108975]
      c++: constexpr PMF conversion [PR105996]
      c-family: -Wsequence-point and COMPONENT_REF [PR107163]
      c++: non-templated friends [PR105852]
      c++: array DMI and member fn [PR109666]
      c++: member vs global template [PR106310]

Jeff Law (1):
      [committed] Fix more problems with new linker warnings

Jerry DeLisle (1):
      ICE in gfc_free_namespace. ice-on-invalid.

John David Anglin (2):
      Fix addvdi3 and subvdi3 patterns
      Skip guality tests on hppa-hpux.

Jonathan Wakely (130):
      libstdc++: Avoid -Wzero-as-null-pointer-constant warning [PR103848]
      libstdc++: Fix warning in __moneypunct_cache::_M_cache [PR104966]
      libstdc++: Fix macro checked by test
      libstdc++: Fix incorrect IS number in doc comment
      libstdc++: Use LTLIBICONV when linking libstdc++.so [PR93602]
      libstdc++: Fix test failure on AIX
      libstdc++: Increase timeout for pthread7-rope.cc test
      libstdc++: Avoid overflow in ranges::advance(i, n, bound)
      libstdc++: Do not use std::isdigit in <charconv> [PR103911]
      libstdc++: Ignore cv-quals when std::allocator<void> constructs
      libstdc++: Avoid unwanted allocations in filesystem::path
      libstdc++: Reorder constraints on std::span::span(Range&&) constructor.
      libstdc++: Improvements to standard error category objects (part deux)
      libstdc++: Use std::construct_at in net::ip::address
      libstdc++: Add missing noexcept to lazy_split_view iterator (LWG 3593)
      libstdc++: Add another non-reserved name to tests
      libstdc++: Fix non-reserved name in <regex> header
      libstdc++: Fix tests that fail with fully-dynamic-string
      libstdc++: Ensure C++20 std::stringstream definitions use correct ABI
      libstdc++: Use secure_getenv for filesystem::temp_directory_path() [PR65018]
      libstdc++: Remove bogus assertion in std::from_chars [PR105324]
      libstdc++: Fix filesystem::temp_directory_path [PR101709]
      libstdc++: Fix test that fails in C++20 mode
      libstdc++: Fix ambiguous comparisons for iterators in C++20
      libstdc++: Fix test failures at -O0
      libstdc++: Remove "no stronger" assertion in compare exchange [PR102177]
      libstdc++: Remove workaround for FE bug in std::tuple [PR96592]
      libstdc++: Add deduction guides for std::packaged_task [PR105375]
      libstdc++: Fix error reporting in filesystem::copy [PR99290]
      libstdc++: Fix test that fails on Solaris [PR104731]
      libstdc++: Fix deserialization for std::normal_distribution [PR105502]
      libstdc++: Define _GNU_SOURCE for secure_getenv on Cygwin [PR104217]
      libstdc++: Add <syncstream> declarations to <iosfwd> [PR105284]
      libstdc++: Fix status docs for <bit> support
      libstdc++: Add C++23 status docs
      libstdc++: Fix hyperlink in docs
      libstdc++: Document support for constexpr optional (P2231R1)
      libstdc++: Partially revert r11-9772-g6f8133689f4397 [PR105915]
      libstdc++: Use type_identity_t for non-deducible std::atomic_xxx args
      libstdc++: Define std::hash<std::filesystem::path> (LWG 3657)
      libstdc++: Fix cast in source_location::current() [PR104602]
      libstdc++: Remove unused functions in std::variant implementation
      libstdc++: std::basic_regex should treat '\0' as an ordinary char [PR84110]
      libstdc++: Implement std::regex_constants::multiline (LWG 2503)
      libstdc++: Fix preprocessor check for C++17
      libstdc++: Define basic_regex::multiline for non-strict modes
      libstdc++: Replace try-catch in std::list::merge to avoid O(N) size
      libstdc++: Remove try/catch overhead in std::variant::emplace
      libstdc++: Fix std::regex_replace for strings with embedded null [PR103664]
      libstdc++: Simplify std::basic_regex construction and assignment
      libstdc++: Add dg-timeout-factor to some more regex tests
      libstdc++: Tweaks to <regex> to avoid warnings
      libstdc++: Check for invalid syntax_option_type values in <regex>
      libstdc++: Fix handling of invalid ranges in std::regex [PR102447]
      libstdc++: Add noexcept to functions in <regex>
      libstdc++: Remove obfuscating typedefs in <regex>
      libstdc++: Make ranges::size and ranges::empty check for unbounded arrays
      libstdc++: Add noexcept to std::launch operators
      libstdc++: Mark non-exported function always_inline [PR105671]
      libstdc++: Add constexpr to std::counted_iterator post-increment (LWG 3643)
      libstdc++: Properly remove temporary directories in filesystem tests
      libstdc++: Add missing prerequisite to generated header [PR106162]
      libstdc++: Fix experimental::filesystem::status on Windows [PR88881]
      libstdc++: testsuite: Guard use of C99 std::log2
      libstdc++: Make std::common_iterator completely constexpr-able (LWG 3574)
      libstdc++: Use std::construct_at in std::common_iterator [PR103992]
      libstdc++: Fix minor bugs in std::common_iterator
      libstdc++: Fix std::common_iterator assignment [PR100823]
      libstdc++: Make std::string_view(Range&&) constructor explicit
      libstdc++: Tweak common_iterator::operator-> return type [PR104443]
      libstdc++: Check for EOF if extraction avoids buffer overflow [PR106248]
      libstdc++: Fix for explicit copy ctors in <thread> and <future> [PR106695]
      libstdc++: Check for overflow in regex back-reference [PR106607]
      libstdc++: Fix feature test macros in <version> for freestanding
      doc: Document correct -fwide-exec-charset defaults [PR41041]
      libstdc++: Remove empty <author> elements in manual
      libstdc++: Fix unsafe use of dirent::d_name [PR107814]
      libstdc++: Unblock atomic wait on non-futex platforms [PR106183]
      libstdc++: Fix build failures for avr
      libstdc++: Fix std::random_device for avr
      libstdc++: Horrible macro hacks to allow building on avr
      libstdc++: Fix std::filesystem errors with -fkeep-inline-functions [PR108636]
      libstdc++: Fix name of <experimental/optional> in comment
      libstdc++: Fix uses_allocator_construction_args for pair<T&&, U&&> [PR108952]
      libstdc++: Fix GDB Xmethod for std::shared_ptr::use_count() [PR109064]
      libstdc++: Fix dangling reference in filesystem::path::filename()
      libstdc++: Reduce Doxygen output for PDF
      libstdc++: Fix outdated docs about demangling exception messages
      libstdc++: Fix error in doxygen comments in <atomic>
      libstdc++: Add missing runtime exception to licence notice
      libstdc++: Document LWG 1203 API change in manual
      libstdc++: Strip absolute paths from files shown in Doxygen docs
      libstdc++: Make std::lcm and std::gcd detect overflow [PR105844]
      libstdc++: Fix broken backport for std::lcm [PR105844]
      libstdc++: Fix std::chrono::hh_mm_ss with unsigned rep [PR108265]
      libstdc++: Fix self-move for std::weak_ptr [PR108118]
      libstdc++: Add missing move in ranges::copy
      libstdc++: Fix reading UTF-8 characters for 16-bit targets [PR104875]
      libstdc++: Fix tests with non-const operator==
      libstdc++: Use emplace in std::variant::operator=(T&&) as per LWG 3585
      libstdc++: Add nodiscard attribute to filesystem operations
      libstdc++: Add always_inline attribute to std::byte operators
      libstdc++: Fix std::is_nothrow_invocable_r for uncopyable prvalues [PR91456]
      libstdc++: Fix pool resource build errors for H8 [PR107801]
      libstdc++: Fix src/c++17/memory_resource for H8 targets [PR107801]
      doc: Fix description of x86 -m32 option [PR109954]
      libstdc++: Simplify constraints for std::any construction [PR104242]
      libstdc++: Document removal of implicit allocator rebinding extensions
      libstdc++: Fix wstring conversions in filesystem::path [PR95048]
      libstdc++: Check conversion from filesystem::path to wide strings [PR95048]
      libstdc++: Add workaround for std::make_integer_sequence bug [PR111357]
      libstdc++: Prevent unwanted ADL in std::to_array [PR111512]
      libstdc++: Fix constexpr functions to conform to older standards
      Revert "libstdc++: Horrible macro hacks to allow building on avr"
      libstdc++: Add utility for creating std::error_code from OS errors
      libstdc++: Avoid unconditional use of errc::not_supported [PR 99327]
      libstdc++: Fix typos in std::filesystem code
      libstdc++: Avoid symlink race in filesystem::remove_all [PR104161]
      libstdc++: Fix filesystem::remove_all races [PR104161]
      libstdc++: Fix std::filesystem build failure for Windows
      libstdc++: Fix filesystem::remove_all for Windows [PR104161]
      libstdc++: Simplify resource management in directory iterators
      libstdc++: Fix directory iterator build for newlib
      libstdc++: Do not optimize away storing pathname if it's needed
      libstdc++: Use ENOSYS for unsupported filesystem ops on AVR
      libstdc++: Fix formatting in std::filesystem helper function
      libstdc++: Use close-on-exec for file descriptors in filesystem::copy_file
      libstdc++: Make std::filesystem::copy_file work for procfs [PR108178]
      libstdc++: Add more tests for filesystem directory iterators
      libstdc++: Fix testsuite failures with -O0

José Rui Faustino de Sousa (5):
      Fortran: Fix ICE with -fcheck=pointer [PR100136]
      Fortran: Fix ICE with automatic reallocation [PR100245]
      Fortran: Fix function attributes [PR100132]
      Fortran: Fix ICE and wrong code for assumed-rank arrays [PR100029, PR100040]
      Fortran: Add missing TKR initialization to class variables [PR100097, PR100098]

Kewen Lin (13):
      testsuite: Skip pr105250.c for powerpc and s390 [PR105266]
      rs6000: Preserve REG_EH_REGION when replacing load/store [PR106091]
      rs6000/test: Fix empty TU in some cases of effective targets [PR106345]
      rs6000: Fix the condition with frame_pointer_needed_indeed [PR96072]
      rs6000: Raise error for __vector_{quad,pair} uses without MMA enabled [PR106736]
      rs6000: Teach rs6000_opaque_type_invalid_use_p about inline asm [PR108272]
      rs6000: Teach rs6000_opaque_type_invalid_use_p about gcall [PR108348]
      rs6000/test: Adjust some test cases on partial vector [PR96373]
      rs6000: Fix vector_set_var_p9 by considering BE [PR108807]
      rs6000: Fix vector parity support [PR108699]
      rs6000: Don't use TFmode for 128 bits fp constant in toc [PR110011]
      rs6000: Guard __builtin_{un,}pack_vector_int128 with vsx [PR109932]
      rs6000: Correct vsx operands output for xxeval [PR110741]

Kewen.Lin (1):
      rs6000: Adjust mov optabs for opaque modes [PR103353]

Kito Cheng (1):
      RISC-V: Fix wrong expansion for arch-canonicalize

Kyrylo Tkachov (1):
      aarch64: Add support for -mcpu=neoverse-v2

Lewis Hyatt (1):
      c: Fix location for _Pragma tokens [PR97498]

Maciej W. Rozycki (2):
      RISC-V: Remove duplicate backslashes from `stack_protect_set_<mode>'
      testsuite: Require vectors of doubles for pr97428.c

Marek Polacek (7):
      c++: ambiguous call not diagnosed after DR2352 [PR97296]
      c++: wrong error with constexpr COMPOUND_EXPR [PR105321]
      c++: enum in generic lambda at global scope [PR105398]
      c++: global-namespace-qualified var after class def [PR90107]
      c++: Fix ICE with -Wmismatched-tags [PR105725]
      c++: constinit on pointer to function [PR104066]
      c++: fix ICE in joust_maybe_elide_copy [PR106675]

Mark Mentovai (2):
      libstdc++: Rename __null_terminated to avoid collision with Apple SDK
      Darwin: Future-proof -mmacosx-version-min

Martin Jambor (3):
      ipa: Release body of clone_of when removing its last clone (PR 100413)
      tree-sra: Fix union handling in build_reconstructed_reference
      ipa: Release body more carefully when removing nodes (PR 107944)

Martin Liska (7):
      ipa-icf: skip variables with body_removed
      libsanitizer: cherry-pick 9cf13067cb5088626ba7 from upstream
      x86: fix VENDOR_MAX enum value
      i386: fix pedantic warning
      Factor out jobserver_active_p.
      lto: support --jobserver-style=fifo for recent GNU make
      lto-wrapper: silent warnings in tests

Matthias Kretz (28):
      c++: don't ICE on NAMESPACE_DECL inside FUNCTION_DECL
      libstdc++: Ensure __builtin_constant_p isn't lost on the way
      libstdc++: printf format string fix in testsuite
      libstdc++: Fix incorrect __builtin_is_constant_evaluated calls
      libstdc++: Fix uses of non-reserved names in simd header
      libstdc++: Add missing constexpr on simd shift implementation
      libstdc++: Fix -Wsign-compare issue
      libstdc++: Simplify three helper functions into one
      libstdc++: Fix simd test compilation with Clang
      libstdc++: Skip integer division optimization for Clang
      libstdc++: Annotate most lambdas with always_inline
      libstdc++: Fix simd build failure on clang
      libstdc++: Test that integral simd reductions are precise
      libstdc++: More efficient masked inc-/decrement implementation
      libstdc++: Always-inline most of non-cmath fixed_size implementation
      libstdc++: Fix formatting
      libstdc++: Fix simd compilation with Clang
      libstdc++: Fix operator% implementation for Clang
      libstdc++: Add missing trait is_simd_flag_type
      libstdc++: Resolve -Wunused-variable warnings in stdx::simd and tests
      libstdc++: Add missing constexpr to simd_neon
      libstdc++: Fix SFINAE for __is_intrinsic_type on ARM
      libstdc++: Fix type of first argument to vec_cntm call
      libstdc++: Add missing constexpr to simd
      libstdc++: Resolve -Wsign-compare issue
      libstdc++: Fix test assumptions on long and long double
      libstdc++: Simplify calculation of expected value in simd test
      libstdc++: Correct NTTP and simd_mask ctor call

Max Filippov (2):
      gcc: xtensa: fix PR target/105879
      gcc: fix PR rtl-optimization/107482

Michael Meissner (6):
      rs6000: Ignore fusion option flags for inlining test [PR102059]
      [BACKPORT] Disable generating load/store vector pairs for block copies.
      Do not enable -mblock-ops-vector-pair.
      Backport from master
      Do not generate vmaddfp and vnmsubfp
      Fix power10 fusion bug with prefixed loads, PR target/105325

Mikael Morin (3):
      fortran: Move the clobber generation code
      fortran: Fix invalid function decl clobber ICE [PR105012]
      fortran: Move clobbers after evaluation of all arguments [PR106817]

Oleg Endo (2):
      SH: Fix PR101469 peephole bug
      SH: Fix PR 101177

Pat Haugen (2):
      Fix register count when not splitting Complex IEEE 128-bit args.
      Disable generation of scalar modulo instructions.

Patrick Palka (17):
      c++: partial ordering with dependent NTTP type [PR105289]
      c++: ICE with requires-expr and -Wsequence-point [PR105304]
      c++: decltype of non-dependent call of class type [PR105386]
      libstdc++: Don't use std::tolower in <charconv> [PR103911]
      c++: deduction guides and ttp rewriting [PR102479]
      libstdc++: Fix backward compatibility of P2325R3 backport [PR106320]
      c++: quadratic constexpr behavior for left-assoc logical exprs [PR102780]
      libstdc++: Fix __max_diff_type::operator>>= for negative values
      c++: bogus warning with value init of const pmf [PR92752]
      c++: return-type-req in constraint using only outer tparms [PR104527]
      c++: ICE with failed __is_constructible constraint [PR100474]
      c++: requires-expr and access checking [PR107179]
      c++: explicit specialization and trailing requirements [PR107864]
      c++: extract_local_specs and unevaluated contexts [PR100295]
      c++: thinko in extract_local_specs [PR108998]
      libstdc++: Implement P2520R0 changes to move_iterator's iterator_concept
      c++: noexcept-spec from nested class confusion [PR109761]

Paul A. Clarke (1):
      rs6000: __Uglify non-uglified local variables in headers

Paul E. Murphy (1):
      go: Update usage of TARGET_AIX to TARGET_AIX_OS

Paul Thomas (1):
      Fortran: ICE on recursive derived types with allocatable components [PR107872]

Pavel I. Kryukov (1):
      libstdc++: Add self-merge check to std::forward_list::merge [PR103853]

Peter Bergner (5):
      rs6000: Adjust -mdejagnu-cpu to filter out -mtune [PR106345]
      rs6000: Update testsuite to use -mdejagnu-cpu= and -mdejagnu-tune= options
      c: Handle initializations of opaque types [PR106016]
      rs6000: Allow conversions of MMA pointer types [PR106017]
      rs6000: Don't ICE when we disassemble an MMA variable [PR101322]

Philipp Fent (2):
      libstdc++: Add pretty printer for std::span
      libstdc++: Add pretty printer for std::initializer_list

Philipp Tomsich (6):
      aarch64: fix off-by-one in reading cpuinfo
      aarch64: update Ampere-1 core definition
      aarch64: Add support for Ampere-1A (-mcpu=ampere1a) CPU
      aarch64: update ampere1 vectorization cost
      aarch64: disable LDP via tuning structure for -mcpu=ampere1
      PR target/108589 - Check REG_P for AARCH64_FUSE_ADDSUB_2REG_CONST1

Qing Zhao (1):
      i386: Adjust -fzero-call-used-regs to always use XOR [PR101891]

Rainer Orth (2):
      libstdc++: Fix 28_regex/basic_regex/84110.cc on Solaris
      Support parallel testing in libgomp, part I [PR66005]

Richard Biener (54):
      Update BASE-VER to 11.3.1
      ipa/105598 - testcase for PR105598
      middle-end/105140 - fix bogus recursion in fold_convertible_p
      tree-optimization/105250 - adjust fold_convertible_p PR105140 fix
      tree-optimization/105148 - fix IVOPTs recording uses
      tree-optimization/105163 - abnormal SSA coalescing and reassoc
      tree-optimization/105173 - fix insertion logic in reassoc
      tree-optimization/105263 - reassoc and DFP
      tree-optimization/105312 - fix ISEL VCOND expansion
      tree-optimization/105368 - avoid overflow in powi_cost
      tree-optimization/105431 - another overflow in powi handling
      rtl-optimization/105559 - avoid quadratic behavior in delete_insn_and_edges
      tree-optimization/105437 - BB vect with extern defs of throwing stmts
      tree-optimization/105726 - adjust array bound heuristic
      tree-optimization/103116 - SLP permutes and peeling for gaps
      middle-end/103193 - avoid canonicalizing <= and >= to == for floats
      tree-optimization/105618 - restore load sinking
      middle-end/106027 - fix types in needle folding
      tree-optimization/106112 - fix CSE from wider operation
      tree-optimization/106131 - wrong code with FRE rewriting
      middle-end/106331 - fix mem attributes for string op arguments
      tree-optimization/106513 - fix mistake in bswap symbolic number shifts
      lto/106540 - fix LTO tree input wrt dwarf2out_register_external_die
      tree-optimization/106189 - avoid division by zero exception
      tree-optimization/106892 - avoid invalid pointer association in predcom
      tree-optimization/106934 - avoid BIT_FIELD_REF of bitfields
      tree-optimization/107107 - tail-merging VN wrong-code
      tree-optimization/107212 - SLP reduction of reduction paths
      tree-optimization/107254 - check and support live lanes from permutes
      tree-optimization/107323 - loop distribution partition ordering issue
      tree-optimization/107554 - fix ICE in stlen optimization
      restrict gcc.dg/pr107554.c to 64bit platforms
      tree-optimization/106809 - compile time hog in VN
      tree-optimization/109491 - ICE in expressions_equal_p
      middle-end/104450 - ISEL and non-call EH
      middle-end/104464 - ISEL and non-call EH #2
      tree-optimization/105484 - VEC_SET and EH
      ipa/106124 - ICE with -fkeep-inline-functions and OpenMP
      tree-optimization/107451 - SLP load vectorization issue
      tree-optimization/108076 - if-conversion and forced labels
      middle-end/108625 - wrong folding due to misinterpreted !
      tree-optimization/109473 - ICE with reduction epilog adjustment op
      tree-optimization/109502 - vector conversion between mask and non-mask
      rtl-optimization/109585 - alias analysis typo
      tree-optimization/109573 - avoid ICEing on unexpected live def
      lto/109263 - lto-wrapper and -g0 -ggdb
      tree-optimization/108821 - store motion and volatiles
      tree-optimization/109473 - fix type mismatch in reduction vectorization
      tree-optimization/109724 - new testcase
      tree-optimization/107898 - ICE with -Walloca-larger-than
      tree-optimization/108950 - widen-sum reduction ICE
      testsuite/108985 - missing vect_simd_clones target requirement on test
      middle-end/109505 - backport match.pd ! support for GENERIC
      middle-end/110200 - genmatch force-leaf and convert interaction

Richard Earnshaw (3):
      arm: big-endian issue in gen_cpymem_ldrd_strd [PR105981]
      arm: correctly handle misaligned MEMs on MVE [PR105463]
      cselib: add function to check if SET is redundant [PR106187]

Richard Sandiford (24):
      rtl-ssa: Fix prev/next_def confusion [PR104869]
      aarch64: Fix GTY markup for arm_sve.h [PR106491]
      aarch64: Define __ARM_FEATURE_RCPC
      aarch64: Fix matching of BRKNS
      aarch64: Prevent generation of /M BRKAS and BRKBS
      aarch64: Use local frame vars in shrink-wrapping code
      aarch64: Avoid a use of callee_offset
      aarch64: Explicitly handle frames with no saved registers
      aarch64: Add bytes_below_saved_regs to frame info
      aarch64: Add bytes_below_hard_fp to frame info
      aarch64: Tweak aarch64_save/restore_callee_saves
      aarch64: Only calculate chain_offset if there is a chain
      aarch64: Rename locals_offset to bytes_above_locals
      aarch64: Rename hard_fp_offset to bytes_above_hard_fp
      aarch64: Tweak frame_size comment
      aarch64: Measure reg_offset from the bottom of the frame
      aarch64: Simplify top of frame allocation
      aarch64: Minor initial adjustment tweak
      aarch64: Tweak stack clash boundary condition
      aarch64: Put LR save probe in first 16 bytes
      aarch64: Simplify probe of final frame allocation
      aarch64: Explicitly record probe registers in frame info
      aarch64: Remove below_hard_fp_saved_regs_size
      aarch64: Make stack smash canary protect saved registers

Sebastian Huber (3):
      RTEMS: Do not define _GNU_SOURCE by default
      RTEMS: Add -mvrsave multilibs
      RTEMS: Tune multilib selection

Sebastian Pop (2):
      [AArch64] add barriers to ool __sync builtins
      AArch64: Add UNSPECV_PATCHABLE_AREA [PR98776]

Segher Boessenkool (8):
      rs6000/testsuite: Skip pr105140.c
      rs6000: Improve .machine
      rs6000: Do not use rs6000_cpu for .machine ppc and ppc64 (PR104829)
      rs6000: Disparage lfiwzx and similar
      rs6000/testsuite: xfail bswap-brw.c
      rs6000: Add effective target has_arch_ppc64
      rs6000: Make the has_arch target selectors actually work
      rs6000: genfusion: Rewrite load/compare code

Sergei Trofimovich (3):
      gcov-profile: Allow negative counts of indirect calls [PR105282]
      gcc/config/t-i386: add build dependencies on i386-builtin-types.inc
      driver: fix environ corruption after putenv() [PR106624]

Simon Cook (1):
      RISC-V: Don't unconditionally add m,a,f,d in arch-canonicalize

Simon Wright (1):
      Darwin: Truncate kernel-provided version to OS major for Darwin >= 20.

Stam Markianos-Wright (1):
      Fix memory constraint on MVE v[ld/st][2/4] instructions [PR107714]

Stefan Schulze Frielinghaus (2):
      IBM zSystems: Fix function_ok_for_sibcall [PR106355]
      s390: libatomic: Fix 16 byte atomic {cas,load,store}

Steve Kargl (4):
      Fortran: do not generate conflicting results under -ff2c [PR104313]
      Fortran: error handling of global entity appearing in COMMON block [PR103259]
      Fortran: fix diagnostics for SELECT RANK [PR100607]
      Add a check for invalid use of BOZ with a derived type.

Surya Kumari Jangala (1):
      regrename: Fix -fcompare-debug issue in check_new_reg_p [PR105041]

Tamar Christina (1):
      testsuite: Backport testsuite changes from GCC 12 to GCC 11

Thomas Koenig (1):
      Change "long_double" into "long double" for C prototypes from Fortran.

Thomas Rodgers (1):
      libstdc++: Minor codegen improvement for atomic wait spinloop

Thomas Schwinge (4):
      nvptx: Define (dummy) 'TARGET_PTX_6_0'
      nvptx: In 'STARTFILE_SPEC', fix 'crt0.o' for '-mmainkernel'
      Support parallel testing in libgomp, part II [PR66005]
      Support parallel testing in libgomp: fallback Perl 'flock' [PR66005]

Thomas W Rodgers (3):
      libstdc++: Make atomic notify_one and notify_all non-const
      libstdc++: Add missing free functions for atomic_flag [PR103934]
      libstdc++: Add missing free functions for atomic_flag [PR103934]

Tim Song (1):
      libstdc++: Force _Hash_node_value_base methods inline to fix abi (PR111050)

Tobias Burnus (2):
      OpenMP: Fix folding with simd's linear clause [PR106492]
      OpenMP/Fortran: Fix handling of optional is_device_ptr + bind(C) [PR108546]

Tom de Vries (2):
      [nvptx] Add bar.warp.sync
      [nvptx] Add uniform_warp_check insn

Torbjörn SVENSSON (1):
      IRA: Make sure array is big enough

Uros Bizjak (3):
      i386: Fix assert in ix86_function_arg [PR105970]
      alpha: Introduce target specific store_data_bypass_p function [PR105209]
      i386: Handle CONST_WIDE_INT in output_pic_addr_const [PR111340]

Vladimir N. Makarov (1):
      [PR104637] LRA: Split hard regs as many as possible on one subpass

liuhongt (10):
      Fix insn does not satisfy its constraints: sse2_lshrv1ti3
      Fix unrecognizable insn due to illegal immediate_operand (const_int 255) of QImode.
      x86: Add a new option -mdaz-ftz to enable FTZ and DAZ flags in MXCSR.
      Make option mvzeroupper independent of optimization level.
      Refine maskloadmn pattern with UNSPEC_MASKLOAD.
      Refine maskstore patterns with UNSPEC_MASKMOV.
      Workaround possible CPUID bug in Sandy Bridge.
      Software mitigation: Disable gather generation in vectorization for GDS affected Intel Processors.
      Support -m[no-]gather to enable/disable vectorization for all gather instructions
      Disparage slightly for the alternative which move DFmode between SSE_REGS and GENERAL_REGS.

diff --git a/ChangeLog b/ChangeLog
index f612f0c1c5b..48d69d2bf1c 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,15 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2022-06-26  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* configure: Regenerate.
+	* configure.ac: Correct use of $host.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/c++tools/ChangeLog b/c++tools/ChangeLog
index 0ccbd443fe7..46505bf853b 100644
--- a/c++tools/ChangeLog
+++ b/c++tools/ChangeLog
@@ -1,3 +1,24 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2021-07-21  Iain Sandoe  <iain@sandoe.co.uk>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/98821
+	* config.h.in: Regenerate.
+	* configure: Regenerate.
+	* configure.ac: Configure using C++.  Pull logic to
+	detect enabled checking modes; default to release
+	checking.
+	* server.cc (AI_NUMERICSERV): Define a fallback value.
+	(gcc_assert): New.
+	(gcc_unreachable): New.
+	(fancy_abort): Only build when checking is enabled.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/c++tools/config.h.in b/c++tools/config.h.in
index bfb49582357..410b2f7dab8 100644
--- a/c++tools/config.h.in
+++ b/c++tools/config.h.in
@@ -1,5 +1,8 @@
 /* config.h.in.  Generated from configure.ac by autoheader.  */
 
+/* Define if you want assertions enabled. This is a cheap check. */
+#undef ENABLE_ASSERT_CHECKING
+
 /* Define if accept4 provided. */
 #undef HAVE_ACCEPT4
 
diff --git a/c++tools/configure b/c++tools/configure
index a288f7abe5d..742816e4253 100755
--- a/c++tools/configure
+++ b/c++tools/configure
@@ -626,10 +626,7 @@ NETLIBS
 get_gcc_base_ver
 EGREP
 GREP
-CPP
-ac_ct_CC
-CFLAGS
-CC
+CXXCPP
 PIEFLAG
 MAINTAINER
 CXX_AUX_TOOLS
@@ -701,6 +698,7 @@ ac_user_opts='
 enable_option_checking
 enable_c___tools
 enable_maintainer_mode
+enable_checking
 enable_default_pie
 with_gcc_major_version_only
 '
@@ -713,9 +711,7 @@ LDFLAGS
 LIBS
 CPPFLAGS
 CCC
-CC
-CFLAGS
-CPP'
+CXXCPP'
 
 
 # Initialize some variables set by options.
@@ -1332,6 +1328,10 @@ Optional Features:
   --enable-maintainer-mode
                           enable maintainer mode. Add rules to rebuild
                           configurey bits
+  --enable-checking[=LIST]
+                          enable expensive run-time checks. With LIST, enable
+                          only specific categories of checks. Categories are:
+                          yes,no,all,none,release.
   --enable-default-pie    enable Position Independent Executable as default
 
 Optional Packages:
@@ -1348,9 +1348,7 @@ Some influential environment variables:
   LIBS        libraries to pass to the linker, e.g. -l<library>
   CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
-  CC          C compiler command
-  CFLAGS      C compiler flags
-  CPP         C preprocessor
+  CXXCPP      C++ preprocessor
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
@@ -1470,48 +1468,10 @@ fi
 
 } # ac_fn_cxx_try_compile
 
-# ac_fn_c_try_compile LINENO
-# --------------------------
-# Try to compile conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
-  if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_compile
-
-# ac_fn_c_try_cpp LINENO
-# ----------------------
+# ac_fn_cxx_try_cpp LINENO
+# ------------------------
 # Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_cpp ()
+ac_fn_cxx_try_cpp ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   if { { ac_try="$ac_cpp conftest.$ac_ext"
@@ -1530,7 +1490,7 @@ $as_echo "$ac_try_echo"; } >&5
   fi
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; } > conftest.i && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test -z "$ac_cxx_preproc_warn_flag$ac_cxx_werror_flag" ||
 	 test ! -s conftest.err
        }; then :
   ac_retval=0
@@ -1543,14 +1503,14 @@ fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
-} # ac_fn_c_try_cpp
+} # ac_fn_cxx_try_cpp
 
-# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
+# ac_fn_cxx_check_header_mongrel LINENO HEADER VAR INCLUDES
+# ---------------------------------------------------------
 # Tests whether HEADER exists, giving a warning if it cannot be compiled using
 # the include files in INCLUDES and setting the cache variable VAR
 # accordingly.
-ac_fn_c_check_header_mongrel ()
+ac_fn_cxx_check_header_mongrel ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   if eval \${$3+:} false; then :
@@ -1571,7 +1531,7 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 $4
 #include <$2>
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_header_compiler=yes
 else
   ac_header_compiler=no
@@ -1587,7 +1547,7 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <$2>
 _ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+if ac_fn_cxx_try_cpp "$LINENO"; then :
   ac_header_preproc=yes
 else
   ac_header_preproc=no
@@ -1597,7 +1557,7 @@ rm -f conftest.err conftest.i conftest.$ac_ext
 $as_echo "$ac_header_preproc" >&6; }
 
 # So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
+case $ac_header_compiler:$ac_header_preproc:$ac_cxx_preproc_warn_flag in #((
   yes:no: )
     { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
 $as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
@@ -1630,13 +1590,13 @@ $as_echo "$ac_res" >&6; }
 fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
-} # ac_fn_c_check_header_mongrel
+} # ac_fn_cxx_check_header_mongrel
 
-# ac_fn_c_try_run LINENO
-# ----------------------
+# ac_fn_cxx_try_run LINENO
+# ------------------------
 # Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
 # that executables *can* be run.
-ac_fn_c_try_run ()
+ac_fn_cxx_try_run ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   if { { ac_try="$ac_link"
@@ -1672,13 +1632,13 @@ fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
-} # ac_fn_c_try_run
+} # ac_fn_cxx_try_run
 
-# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
+# ac_fn_cxx_check_header_compile LINENO HEADER VAR INCLUDES
+# ---------------------------------------------------------
 # Tests whether HEADER exists and can be compiled using the include files in
 # INCLUDES, setting the cache variable VAR accordingly.
-ac_fn_c_check_header_compile ()
+ac_fn_cxx_check_header_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
@@ -1691,7 +1651,7 @@ else
 $4
 #include <$2>
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   eval "$3=yes"
 else
   eval "$3=no"
@@ -1703,12 +1663,12 @@ eval ac_res=\$$3
 $as_echo "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
-} # ac_fn_c_check_header_compile
+} # ac_fn_cxx_check_header_compile
 
-# ac_fn_c_try_link LINENO
-# -----------------------
+# ac_fn_cxx_try_link LINENO
+# -------------------------
 # Try to link conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_link ()
+ac_fn_cxx_try_link ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   rm -f conftest.$ac_objext conftest$ac_exeext
@@ -1728,7 +1688,7 @@ $as_echo "$ac_try_echo"; } >&5
   fi
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
+	 test -z "$ac_cxx_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
@@ -1749,7 +1709,7 @@ fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
-} # ac_fn_c_try_link
+} # ac_fn_cxx_try_link
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
@@ -2955,6 +2915,13 @@ done
 test -n "$AUTOHEADER" || AUTOHEADER="$MISSING autoheader"
 
 
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build C++ tools" >&5
 $as_echo_n "checking whether to build C++ tools... " >&6; }
   # Check whether --enable-c++-tools was given.
@@ -2989,6 +2956,37 @@ $as_echo "$maintainer_mode" >&6; }
 test "$maintainer_mode" = yes && MAINTAINER=yes
 
 
+# Handle configuration of checking; for the tools in this directory we
+# default to release checking and stricter checks do not change this.
+
+# Check whether --enable-checking was given.
+if test "${enable_checking+set}" = set; then :
+  enableval=$enable_checking; ac_checking_flags="${enableval}"
+else
+
+# Default to checking.
+ac_checking_flags=yes
+
+fi
+
+IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS="$IFS,"
+for check in release $ac_checking_flags
+do
+	case $check in
+	# these set all the flags to specific states
+	yes|all|release|assert) ac_assert_checking=1 ; ;;
+	no|none) ac_assert_checking= ; ;;
+	*) ;;
+	esac
+done
+IFS="$ac_save_IFS"
+
+if test x$ac_assert_checking != x ; then
+
+$as_echo "#define ENABLE_ASSERT_CHECKING 1" >>confdefs.h
+
+fi
+
 # Check whether --enable-default-pie was given.
 # Check whether --enable-default-pie was given.
 if test "${enable_default_pie+set}" = set; then :
@@ -3000,545 +2998,6 @@ fi
 
 
 # Check if O_CLOEXEC is defined by fcntl
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-if test -z "$CC"; then
-          if test -n "$ac_tool_prefix"; then
-    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-fi
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  ac_prog_rejected=no
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
-       ac_prog_rejected=yes
-       continue
-     fi
-    ac_cv_prog_CC="cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# != 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
-  fi
-fi
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl.exe
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$CC" && break
-  done
-fi
-if test -z "$CC"; then
-  ac_ct_CC=$CC
-  for ac_prog in cl.exe
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CC" && break
-done
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-fi
-
-fi
-
-
-test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "no acceptable C compiler found in \$PATH
-See \`config.log' for more details" "$LINENO" 5; }
-
-# Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
-  { { ac_try="$ac_compiler $ac_option >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    sed '10a\
-... rest of stderr output deleted ...
-         10q' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-  fi
-  rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_compiler_gnu=yes
-else
-  ac_compiler_gnu=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_c_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GCC=yes
-else
-  GCC=
-fi
-ac_test_CFLAGS=${CFLAGS+set}
-ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_c_werror_flag=$ac_c_werror_flag
-   ac_c_werror_flag=yes
-   ac_cv_prog_cc_g=no
-   CFLAGS="-g"
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-else
-  CFLAGS=""
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-else
-  ac_c_werror_flag=$ac_save_c_werror_flag
-	 CFLAGS="-g"
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_c_werror_flag=$ac_save_c_werror_flag
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS=$ac_save_CFLAGS
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if ${ac_cv_prog_cc_c89+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
-ac_save_CC=$CC
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-struct stat;
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_c89=$ac_arg
-fi
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then :
-
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for O_CLOEXEC" >&5
 $as_echo_n "checking for O_CLOEXEC... " >&6; }
@@ -3559,7 +3018,7 @@ return open ("/dev/null", O_RDONLY | O_CLOEXEC);
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_o_cloexec=yes
 else
   ac_cv_o_cloexec=no
@@ -3574,26 +3033,22 @@ $as_echo "#define HOST_HAS_O_CLOEXEC 1" >>confdefs.h
 
 fi
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if ${ac_cv_prog_CPP+:} false; then :
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C++ preprocessor" >&5
+$as_echo_n "checking how to run the C++ preprocessor... " >&6; }
+if test -z "$CXXCPP"; then
+  if ${ac_cv_prog_CXXCPP+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+      # Double quotes because CXXCPP needs to be expanded
+    for CXXCPP in "$CXX -E" "/lib/cpp"
     do
       ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
+for ac_cxx_preproc_warn_flag in '' yes
 do
   # Use a header file that comes with gcc, so configuring glibc
   # with a fresh cross-compiler works.
@@ -3610,7 +3065,7 @@ do
 #endif
 		     Syntax error
 _ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+if ac_fn_cxx_try_cpp "$LINENO"; then :
 
 else
   # Broken: fails on valid input.
@@ -3624,7 +3079,7 @@ rm -f conftest.err conftest.i conftest.$ac_ext
 /* end confdefs.h.  */
 #include <ac_nonexistent.h>
 _ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+if ac_fn_cxx_try_cpp "$LINENO"; then :
   # Broken: success on invalid input.
 continue
 else
@@ -3642,17 +3097,17 @@ if $ac_preproc_ok; then :
 fi
 
     done
-    ac_cv_prog_CPP=$CPP
+    ac_cv_prog_CXXCPP=$CXXCPP
 
 fi
-  CPP=$ac_cv_prog_CPP
+  CXXCPP=$ac_cv_prog_CXXCPP
 else
-  ac_cv_prog_CPP=$CPP
+  ac_cv_prog_CXXCPP=$CXXCPP
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXXCPP" >&5
+$as_echo "$CXXCPP" >&6; }
 ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
+for ac_cxx_preproc_warn_flag in '' yes
 do
   # Use a header file that comes with gcc, so configuring glibc
   # with a fresh cross-compiler works.
@@ -3669,7 +3124,7 @@ do
 #endif
 		     Syntax error
 _ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+if ac_fn_cxx_try_cpp "$LINENO"; then :
 
 else
   # Broken: fails on valid input.
@@ -3683,7 +3138,7 @@ rm -f conftest.err conftest.i conftest.$ac_ext
 /* end confdefs.h.  */
 #include <ac_nonexistent.h>
 _ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+if ac_fn_cxx_try_cpp "$LINENO"; then :
   # Broken: success on invalid input.
 continue
 else
@@ -3701,15 +3156,15 @@ if $ac_preproc_ok; then :
 else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+as_fn_error $? "C++ preprocessor \"$CXXCPP\" fails sanity check
 See \`config.log' for more details" "$LINENO" 5; }
 fi
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
@@ -3862,7 +3317,7 @@ main ()
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_header_stdc=yes
 else
   ac_cv_header_stdc=no
@@ -3935,7 +3390,7 @@ main ()
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
+if ac_fn_cxx_try_run "$LINENO"; then :
 
 else
   ac_cv_header_stdc=no
@@ -3959,7 +3414,7 @@ for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
 		  inttypes.h stdint.h unistd.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+ac_fn_cxx_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
 "
 if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
@@ -3973,7 +3428,7 @@ done
 
 for ac_header in sys/mman.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "sys/mman.h" "ac_cv_header_sys_mman_h" "$ac_includes_default"
+  ac_fn_cxx_check_header_mongrel "$LINENO" "sys/mman.h" "ac_cv_header_sys_mman_h" "$ac_includes_default"
 if test "x$ac_cv_header_sys_mman_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SYS_MMAN_H 1
@@ -4016,7 +3471,7 @@ connect (fd, (sockaddr *)&un, sizeof (un));
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_af_unix=yes
 else
   ac_cv_af_unix=no
@@ -4070,7 +3525,7 @@ connect (fd, (sockaddr *)&in6, sizeof (in6));
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_af_inet6=yes
 else
   ac_cv_af_inet6=no
@@ -4111,7 +3566,7 @@ epoll_pwait (fd, 0, 0, -1, 0);
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_epoll=yes
 else
   ac_cv_epoll=no
@@ -4147,7 +3602,7 @@ pselect (0, 0, 0, 0, 0, 0);
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_pselect=yes
 else
   ac_cv_pselect=no
@@ -4184,7 +3639,7 @@ select (0, 0, 0, 0, 0);
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_select=yes
 else
   ac_cv_select=no
@@ -4220,7 +3675,7 @@ int err = accept4 (1, 0, 0, SOCK_NONBLOCK);
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_accept4=yes
 else
   ac_cv_accept4=no
@@ -4259,7 +3714,7 @@ const char *str = inet_ntop (AF_INET6, &in6, buf, sizeof (buf));
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"; then :
   ac_cv_inet_ntop=yes
 else
   ac_cv_inet_ntop=no
@@ -4325,7 +3780,7 @@ for ac_lib in '' nsl; do
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_cxx_try_link "$LINENO"; then :
   ac_cv_search_gethostbyname=$ac_res
 fi
 rm -f core conftest.err conftest.$ac_objext \
@@ -4381,7 +3836,7 @@ for ac_lib in '' socket; do
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_cxx_try_link "$LINENO"; then :
   ac_cv_search_socket=$ac_res
 fi
 rm -f core conftest.err conftest.$ac_objext \
@@ -4431,7 +3886,7 @@ return socket ();
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_cxx_try_link "$LINENO"; then :
   ac_cv_lib_socket_socket=yes
 else
   ac_cv_lib_socket_socket=no
diff --git a/c++tools/configure.ac b/c++tools/configure.ac
index c8f85209188..c89ac6a41a4 100644
--- a/c++tools/configure.ac
+++ b/c++tools/configure.ac
@@ -41,6 +41,8 @@ MISSING=`cd $ac_aux_dir && ${PWDCMD-pwd}`/missing
 AC_CHECK_PROGS([AUTOCONF], [autoconf], [$MISSING autoconf])
 AC_CHECK_PROGS([AUTOHEADER], [autoheader], [$MISSING autoheader])
 
+AC_LANG(C++)
+
 dnl Enabled by default
 AC_MSG_CHECKING([whether to build C++ tools])
   AC_ARG_ENABLE(c++-tools, 
@@ -67,6 +69,35 @@ AC_MSG_RESULT([$maintainer_mode])
 test "$maintainer_mode" = yes && MAINTAINER=yes
 AC_SUBST(MAINTAINER)
 
+# Handle configuration of checking; for the tools in this directory we
+# default to release checking and stricter checks do not change this.
+
+AC_ARG_ENABLE(checking,
+[AS_HELP_STRING([[--enable-checking[=LIST]]],
+		[enable expensive run-time checks.  With LIST,
+		 enable only specific categories of checks.
+		 Categories are: yes,no,all,none,release.])],
+[ac_checking_flags="${enableval}"],[
+# Default to checking.
+ac_checking_flags=yes
+])
+IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS="$IFS,"
+for check in release $ac_checking_flags
+do
+	case $check in
+	# these set all the flags to specific states
+	yes|all|release|assert) ac_assert_checking=1 ; ;;
+	no|none) ac_assert_checking= ; ;;
+	*) ;;
+	esac
+done
+IFS="$ac_save_IFS"
+
+if test x$ac_assert_checking != x ; then
+  AC_DEFINE(ENABLE_ASSERT_CHECKING, 1,
+[Define if you want assertions enabled.  This is a cheap check.])
+fi
+
 # Check whether --enable-default-pie was given.
 AC_ARG_ENABLE(default-pie,
 [AS_HELP_STRING([--enable-default-pie],
diff --git a/c++tools/server.cc b/c++tools/server.cc
index 6ba63fa8ed4..ebc1efbda94 100644
--- a/c++tools/server.cc
+++ b/c++tools/server.cc
@@ -61,6 +61,10 @@ along with GCC; see the file COPYING3.  If not see
 # define gai_strerror(X) ""
 #endif
 
+#ifndef AI_NUMERICSERV
+#define AI_NUMERICSERV 0
+#endif
+
 #include <getopt.h>
 
 // Select or epoll
@@ -92,6 +96,28 @@ along with GCC; see the file COPYING3.  If not see
 #define DIR_SEPARATOR '/'
 #endif
 
+/* Imported from libcpp/system.h
+   Use gcc_assert(EXPR) to test invariants.  */
+#if ENABLE_ASSERT_CHECKING
+#define gcc_assert(EXPR)                                                \
+   ((void)(!(EXPR) ? fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0 : 0))
+#elif (GCC_VERSION >= 4005)
+#define gcc_assert(EXPR)                                                \
+  ((void)(__builtin_expect (!(EXPR), 0) ? __builtin_unreachable (), 0 : 0))
+#else
+/* Include EXPR, so that unused variable warnings do not occur.  */
+#define gcc_assert(EXPR) ((void)(0 && (EXPR)))
+#endif
+
+/* Use gcc_unreachable() to mark unreachable locations (like an
+   unreachable default case of a switch.  Do not use gcc_assert(0).  */
+#if (GCC_VERSION >= 4005) && !ENABLE_ASSERT_CHECKING
+#define gcc_unreachable() __builtin_unreachable ()
+#else
+#define gcc_unreachable() (fancy_abort (__FILE__, __LINE__, __FUNCTION__))
+#endif
+
+
 #if NETWORKING
 struct netmask {
   in6_addr addr;
@@ -202,11 +228,13 @@ internal_error (const char *fmt, ...)
 
 /* Hooked to from gcc_assert & gcc_unreachable.  */
 
+#if ENABLE_ASSERT_CHECKING
 void ATTRIBUTE_NORETURN ATTRIBUTE_COLD
 fancy_abort (const char *file, int line, const char *func)
 {
   internal_error ("in %s, at %s:%d", func, trim_src_file (file), line);
 }
+#endif
 
 /* Exploded on a signal.  */
 
diff --git a/config/ChangeLog b/config/ChangeLog
index f31a9d0be66..28b8a737fb3 100644
--- a/config/ChangeLog
+++ b/config/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/configure b/configure
index e218a19e333..74775c31c58 100755
--- a/configure
+++ b/configure
@@ -8277,7 +8277,7 @@ fi
 # Check whether --enable-host-shared was given.
 if test "${enable_host_shared+set}" = set; then :
   enableval=$enable_host_shared; host_shared=$enableval
- case $target in
+ case $host in
    x86_64-*-darwin* | aarch64-*-darwin*)
      if test x$host_shared != xyes ; then
        # PIC is the default, and actually cannot be switched off.
@@ -8287,7 +8287,7 @@ if test "${enable_host_shared+set}" = set; then :
   *) ;;
  esac
 else
-  case $target in
+  case $host in
   x86_64-*-darwin* | aarch64-*-darwin*) host_shared=yes ;;
   *) host_shared=no ;;
  esac
diff --git a/configure.ac b/configure.ac
index 7e8e628b325..3613860460e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1872,7 +1872,7 @@ AC_ARG_ENABLE(host-shared,
 [AS_HELP_STRING([--enable-host-shared],
 		[build host code as shared libraries])],
 [host_shared=$enableval
- case $target in
+ case $host in
    x86_64-*-darwin* | aarch64-*-darwin*)
      if test x$host_shared != xyes ; then
        # PIC is the default, and actually cannot be switched off.
@@ -1881,7 +1881,7 @@ AC_ARG_ENABLE(host-shared,
      fi ;;
   *) ;;
  esac],
-[case $target in
+[case $host in
   x86_64-*-darwin* | aarch64-*-darwin*) host_shared=yes ;;
   *) host_shared=no ;;
  esac])
diff --git a/contrib/ChangeLog b/contrib/ChangeLog
index f8ba1872bd6..73ecfe5ddc7 100644
--- a/contrib/ChangeLog
+++ b/contrib/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/contrib/header-tools/ChangeLog b/contrib/header-tools/ChangeLog
index 20964349a91..c6bf489533e 100644
--- a/contrib/header-tools/ChangeLog
+++ b/contrib/header-tools/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/contrib/reghunt/ChangeLog b/contrib/reghunt/ChangeLog
index 1fbad2ead71..8c438a39a11 100644
--- a/contrib/reghunt/ChangeLog
+++ b/contrib/reghunt/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/contrib/regression/ChangeLog b/contrib/regression/ChangeLog
index e1fab595ec4..5412df7fab5 100644
--- a/contrib/regression/ChangeLog
+++ b/contrib/regression/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/fixincludes/ChangeLog b/fixincludes/ChangeLog
index 0d936806ea0..9afb9b3031f 100644
--- a/fixincludes/ChangeLog
+++ b/fixincludes/ChangeLog
@@ -1,3 +1,27 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2023-01-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* fixincl.x: Regenerate.
+	* inclhack.def (darwin_objc_runtime_1): New hack.
+	* tests/base/objc/runtime.h: New file.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2023-01-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/107568
+	* fixincl.x: Regenerate.
+	* inclhack.def: Add a fix for MacOS13 SDK function deprecations
+	in stdio.h.
+	* tests/base/stdio.h (__deprecated_msg): New test.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/fixincludes/fixincl.x b/fixincludes/fixincl.x
index 6c50e972165..57bc3fa5489 100644
--- a/fixincludes/fixincl.x
+++ b/fixincludes/fixincl.x
@@ -2,11 +2,11 @@
  *
  * DO NOT EDIT THIS FILE   (fixincl.x)
  *
- * It has been AutoGen-ed  July  1, 2021 at 03:44:46 PM by AutoGen 5.18.7
+ * It has been AutoGen-ed  May 15, 2023 at 11:55:05 PM by AutoGen 5.18.7
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Jul  1 15:44:46 CEST 2021
+/* DO NOT SVN-MERGE THIS FILE, EITHER Mon May 15 23:55:05 BST 2023
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 260 fixup descriptions.
+ * This file contains 262 fixup descriptions.
  *
  * See README for more information.
  *
@@ -2608,6 +2608,46 @@ static const char* apzBsd_Stdio_Attrs_ConflictPatch[] = {
 int vfscanf(FILE *, const char *, __builtin_va_list) __asm__ (_BSD_STRING(__USER_LABEL_PREFIX__) \"__svfscanf\");",
     (char*)NULL };
 
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Apple_Local_Stdio_Fn_Deprecation fix
+ */
+tSCC zApple_Local_Stdio_Fn_DeprecationName[] =
+     "apple_local_stdio_fn_deprecation";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zApple_Local_Stdio_Fn_DeprecationList[] =
+  "stdio.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzApple_Local_Stdio_Fn_DeprecationMachs[] = {
+        "*-*-*darwin2*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zApple_Local_Stdio_Fn_DeprecationSelect0[] =
+       "__deprecated_msg([^\n\
+]*)$";
+
+#define    APPLE_LOCAL_STDIO_FN_DEPRECATION_TEST_CT  1
+static tTestDesc aApple_Local_Stdio_Fn_DeprecationTests[] = {
+  { TT_EGREP,    zApple_Local_Stdio_Fn_DeprecationSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Apple_Local_Stdio_Fn_Deprecation
+ */
+static const char* apzApple_Local_Stdio_Fn_DeprecationPatch[] = {
+    "format",
+    "#if defined(__APPLE_LOCAL_DEPRECATIONS)\n\
+%0\n\
+#endif",
+    (char*)NULL };
+
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
  *  Description of Ctrl_Quotes_Def fix
@@ -3044,6 +3084,53 @@ static const char* apzDarwin_Os_Trace_2Patch[] = {
 #endif",
     (char*)NULL };
 
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Darwin_Objc_Runtime_1 fix
+ */
+tSCC zDarwin_Objc_Runtime_1Name[] =
+     "darwin_objc_runtime_1";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Objc_Runtime_1List[] =
+  "objc/runtime.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Objc_Runtime_1Machs[] = {
+        "*-*-darwin2*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Objc_Runtime_1Select0[] =
+       "OBJC_EXPORT void.*\n\
+objc_enumerateClasses.*\n\
+.*\n\
+.*\n\
+.*\n\
+.*void \\(\\^ _Nonnull block.*\n\
+.*\n\
+.*\n\
+.*OBJC_REFINED_FOR_SWIFT.*";
+
+#define    DARWIN_OBJC_RUNTIME_1_TEST_CT  1
+static tTestDesc aDarwin_Objc_Runtime_1Tests[] = {
+  { TT_EGREP,    zDarwin_Objc_Runtime_1Select0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Objc_Runtime_1
+ */
+static const char* apzDarwin_Objc_Runtime_1Patch[] = {
+    "format",
+    "#if __BLOCKS__\n\
+%0\n\
+#endif",
+    (char*)NULL };
+
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
  *  Description of Darwin_Os_Trace_3 fix
@@ -10560,9 +10647,9 @@ static const char* apzX11_SprintfPatch[] = {
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          298
+#define REGEX_COUNT          300
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            260
+#define FIX_COUNT            262
 
 /*
  *  Enumerate the fixes
@@ -10629,6 +10716,7 @@ typedef enum {
     BROKEN_CABS_FIXIDX,
     BROKEN_NAN_FIXIDX,
     BSD_STDIO_ATTRS_CONFLICT_FIXIDX,
+    APPLE_LOCAL_STDIO_FN_DEPRECATION_FIXIDX,
     CTRL_QUOTES_DEF_FIXIDX,
     CTRL_QUOTES_USE_FIXIDX,
     CXX_UNREADY_FIXIDX,
@@ -10640,6 +10728,7 @@ typedef enum {
     DARWIN_LONGJMP_NORETURN_FIXIDX,
     DARWIN_OS_TRACE_1_FIXIDX,
     DARWIN_OS_TRACE_2_FIXIDX,
+    DARWIN_OBJC_RUNTIME_1_FIXIDX,
     DARWIN_OS_TRACE_3_FIXIDX,
     DARWIN_OS_BASE_1_FIXIDX,
     DARWIN_DISPATCH_OBJECT_1_FIXIDX,
@@ -11136,6 +11225,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {
      BSD_STDIO_ATTRS_CONFLICT_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aBsd_Stdio_Attrs_ConflictTests,   apzBsd_Stdio_Attrs_ConflictPatch, 0 },
 
+  {  zApple_Local_Stdio_Fn_DeprecationName,    zApple_Local_Stdio_Fn_DeprecationList,
+     apzApple_Local_Stdio_Fn_DeprecationMachs,
+     APPLE_LOCAL_STDIO_FN_DEPRECATION_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aApple_Local_Stdio_Fn_DeprecationTests,   apzApple_Local_Stdio_Fn_DeprecationPatch, 0 },
+
   {  zCtrl_Quotes_DefName,    zCtrl_Quotes_DefList,
      apzCtrl_Quotes_DefMachs,
      CTRL_QUOTES_DEF_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
@@ -11191,6 +11285,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {
      DARWIN_OS_TRACE_2_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Os_Trace_2Tests,   apzDarwin_Os_Trace_2Patch, 0 },
 
+  {  zDarwin_Objc_Runtime_1Name,    zDarwin_Objc_Runtime_1List,
+     apzDarwin_Objc_Runtime_1Machs,
+     DARWIN_OBJC_RUNTIME_1_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Objc_Runtime_1Tests,   apzDarwin_Objc_Runtime_1Patch, 0 },
+
   {  zDarwin_Os_Trace_3Name,    zDarwin_Os_Trace_3List,
      apzDarwin_Os_Trace_3Machs,
      DARWIN_OS_TRACE_3_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
diff --git a/fixincludes/inclhack.def b/fixincludes/inclhack.def
index 066bef99162..c2f54d1189a 100644
--- a/fixincludes/inclhack.def
+++ b/fixincludes/inclhack.def
@@ -1269,6 +1269,18 @@ fix = {
     test_text = '#define  vfscanf	__svfscanf';
 };
 
+fix = {
+    hackname  = apple_local_stdio_fn_deprecation;
+    mach      = "*-*-*darwin2*";
+    files     = stdio.h;
+    select    = "__deprecated_msg([^\n]*)$";
+    c_fix     = format;
+    c_fix_arg = "#if defined(__APPLE_LOCAL_DEPRECATIONS)\n"
+                "%0\n"
+                "#endif";
+    test_text = '__deprecated_msg("This function is provided for compat...")';
+};
+
 /*
  *  Fix various macros used to define ioctl numbers.
  *  The traditional syntax was:
@@ -1479,6 +1491,41 @@ fix = {
   test_text = "typedef void (^os_trace_payload_t)(xpc_object_t xdict);";
 };
 
+/*
+ *  macOSX 13.0 SDK objc/runtime.h uses Apple Blocks extension without a guard.
+ */
+
+fix = {
+  hackname  = darwin_objc_runtime_1;
+  mach      = "*-*-darwin2*";
+  files     = objc/runtime.h;
+  select    =   <<- _EOSelect_
+	OBJC_EXPORT void.*
+	objc_enumerateClasses.*
+	.*
+	.*
+	.*
+	.*void \(\^ _Nonnull block.*
+	.*
+	.*
+	.*OBJC_REFINED_FOR_SWIFT.*
+	_EOSelect_;
+  c_fix     = format;
+  c_fix_arg = "#if __BLOCKS__\n%0\n#endif";
+  test_text = <<- _OBJC_RUNTIME_1
+OBJC_EXPORT void
+objc_enumerateClasses(const void * _Nullable image,
+                      const char * _Nullable namePrefix,
+                      Protocol * _Nullable conformingTo,
+                      Class _Nullable subclassing,
+                      void (^ _Nonnull block)(Class _Nonnull aClass, BOOL * _Nonnull stop)
+                      OBJC_NOESCAPE)
+OBJC_AVAILABLE(13.0, 16.0, 16.0, 9.0, 7.0)
+OBJC_REFINED_FOR_SWIFT;
+_OBJC_RUNTIME_1;
+};
+
+
 /*
  *  In Mac OS X 10.1[012] <os/trace.h>, need to guard users of
  *  os_trace_payload_t typedef, too.
diff --git a/fixincludes/tests/base/objc/runtime.h b/fixincludes/tests/base/objc/runtime.h
new file mode 100644
index 00000000000..8b4855bb8ab
--- /dev/null
+++ b/fixincludes/tests/base/objc/runtime.h
@@ -0,0 +1,24 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/objc/runtime.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_OBJC_RUNTIME_1_CHECK )
+#if __BLOCKS__
+OBJC_EXPORT void
+objc_enumerateClasses(const void * _Nullable image,
+                      const char * _Nullable namePrefix,
+                      Protocol * _Nullable conformingTo,
+                      Class _Nullable subclassing,
+                      void (^ _Nonnull block)(Class _Nonnull aClass, BOOL * _Nonnull stop)
+                      OBJC_NOESCAPE)
+OBJC_AVAILABLE(13.0, 16.0, 16.0, 9.0, 7.0)
+OBJC_REFINED_FOR_SWIFT;
+#endif
+#endif  /* DARWIN_OBJC_RUNTIME_1_CHECK */
diff --git a/fixincludes/tests/base/stdio.h b/fixincludes/tests/base/stdio.h
index 491c75da6e5..38381bacb2d 100644
--- a/fixincludes/tests/base/stdio.h
+++ b/fixincludes/tests/base/stdio.h
@@ -41,6 +41,13 @@ int vfscanf(FILE *, const char *, __builtin_va_list) __asm__ (_BSD_STRING(__USER
 #endif  /* BSD_STDIO_ATTRS_CONFLICT_CHECK */
 
 
+#if defined( APPLE_LOCAL_STDIO_FN_DEPRECATION_CHECK )
+#if defined(__APPLE_LOCAL_DEPRECATIONS)
+__deprecated_msg("This function is provided for compat...")
+#endif
+#endif  /* APPLE_LOCAL_STDIO_FN_DEPRECATION_CHECK */
+
+
 #if defined( HPUX10_STDIO_DECLARATIONS_CHECK )
 #  define _iob __iob
 
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index f628d2eafc5..a6e5b12f92f 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-11.3.0
+11.4.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index a0587d18824..8042db6aaf0 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,2421 @@
+2023-10-20  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/101177
+	* config/sh/sh.md (unnamed split pattern): Fix comparison of
+	find_regno_note result.
+
+2023-10-17  liuhongt  <hongtao.liu@intel.com>
+
+	Backported from master:
+	2023-07-06  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/110170
+	* config/i386/i386.md (movdf_internal): Disparage slightly for
+	2 alternatives (r,v) and (v,r) by adding constraint modifier
+	'?'.
+
+2023-10-07  Andrew Pinski  <pinskia@gmail.com>
+
+	Backported from master:
+	2023-10-06  Andrew Pinski  <pinskia@gmail.com>
+
+	PR middle-end/111699
+	* match.pd ((c ? a : b) op d, (c ? a : b) op (c ? d : e),
+	(v ? w : 0) ? a : b, c1 ? c2 ? a : b : b): Enable only for GIMPLE.
+
+2023-10-02  Pat Haugen  <pthaugen@linux.ibm.com>
+
+	Backported from master:
+	2023-09-19  Pat Haugen  <pthaugen@linux.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_rtx_costs): Check whether the
+	modulo instruction is disabled.
+	* config/rs6000/rs6000.h (RS6000_DISABLE_SCALAR_MODULO): New.
+	* config/rs6000/rs6000.md (mod<mode>3, *mod<mode>3): Check it.
+	(define_expand umod<mode>3): New.
+	(define_insn umod<mode>3): Rename to *umod<mode>3 and check if the modulo
+	instruction is disabled.
+	(umodti3, modti3): Check if the modulo instruction is disabled.
+
+2023-09-12  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2023-09-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/111340
+	* config/i386/i386.c (output_pic_addr_const): Handle CONST_WIDE_INT.
+	Call output_addr_const for CASE_CONST_SCALAR_INT.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_save_regs_above_locals_p):
+	New function.
+	(aarch64_layout_frame): Use it to decide whether locals should
+	go above or below the saved registers.
+	(aarch64_expand_prologue): Update stack layout comment.
+	Emit a stack tie after the final adjustment.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame::saved_regs_size)
+	(aarch64_frame::below_hard_fp_saved_regs_size): Delete.
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Update accordingly.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame::sve_save_and_probe)
+	(aarch64_frame::hard_fp_save_and_probe): New fields.
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Initialize them.
+	Rather than asserting that a leaf function saves LR, instead assert
+	that a leaf function saves something.
+	(aarch64_get_separate_components): Prevent the chosen probe
+	registers from being individually shrink-wrapped.
+	(aarch64_allocate_and_probe_stack_space): Remove workaround for
+	probe registers that aren't at the bottom of the previous allocation.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_allocate_and_probe_stack_space):
+	Always probe the residual allocation at offset 1024, asserting
+	that that is in range.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Ensure that
+	the LR save slot is in the first 16 bytes of the register save area.
+	(aarch64_allocate_and_probe_stack_space): Remove workaround for
+	when LR was not in the first 16 bytes.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_allocate_and_probe_stack_space):
+	Don't probe final allocations that are exactly 1KiB in size (after
+	unprobed space above the final allocation has been deducted).
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Tweak
+	calculation of initial_adjust for frames in which all saves
+	are SVE saves.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Simplify
+	the allocation of the top of the frame.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame): Add comment above
+	reg_offset.
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Walk offsets
+	from the bottom of the frame, rather than the bottom of the saved
+	register area.  Measure reg_offset from the bottom of the frame
+	rather than the bottom of the saved register area.
+	(aarch64_save_callee_saves): Update accordingly.
+	(aarch64_restore_callee_saves): Likewise.
+	(aarch64_get_separate_components): Likewise.
+	(aarch64_process_components): Likewise.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame::frame_size): Tweak comment.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame::hard_fp_offset): Rename
+	to...
+	(aarch64_frame::bytes_above_hard_fp): ...this.
+	* config/aarch64/aarch64.c (aarch64_layout_frame)
+	(aarch64_expand_prologue): Update accordingly.
+	(aarch64_initial_elimination_offset): Likewise.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame::locals_offset): Rename to...
+	(aarch64_frame::bytes_above_locals): ...this.
+	* config/aarch64/aarch64.c (aarch64_layout_frame)
+	(aarch64_initial_elimination_offset): Update accordingly.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_expand_prologue): Move the
+	calculation of chain_offset into the emit_frame_chain block.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame::callee_offset): Delete.
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Remove
+	callee_offset handling.
+	(aarch64_save_callee_saves): Replace the start_offset parameter
+	with a bytes_below_sp parameter.
+	(aarch64_restore_callee_saves): Likewise.
+	(aarch64_expand_prologue): Update accordingly.
+	(aarch64_expand_epilogue): Likewise.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame::bytes_below_hard_fp): New
+	field.
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Initialize it.
+	(aarch64_expand_epilogue): Use it instead of
+	below_hard_fp_saved_regs_size.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (aarch64_frame::bytes_below_saved_regs): New
+	field.
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Initialize it,
+	and use it instead of crtl->outgoing_args_size.
+	(aarch64_get_separate_components): Use bytes_below_saved_regs instead
+	of outgoing_args_size.
+	(aarch64_process_components): Likewise.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_layout_frame): Explicitly
+	allocate the frame in one go if there are no saved registers.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_expand_prologue): Use
+	chain_offset rather than callee_offset.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_save_callee_saves): Use
+	a local shorthand for cfun->machine->frame.
+	(aarch64_restore_callee_saves, aarch64_get_separate_components):
+	(aarch64_process_components): Likewise.
+	(aarch64_allocate_and_probe_stack_space): Likewise.
+	(aarch64_expand_prologue, aarch64_expand_epilogue): Likewise.
+	(aarch64_layout_frame): Use existing shorthand for one more case.
+
+2023-09-12  Haochen Gui  <guihaoc@gcc.gnu.org>
+
+	Backported from master:
+	2023-08-31  Haochen Gui  <guihaoc@gcc.gnu.org>
+
+	PR target/96762
+	* config/rs6000/rs6000-string.c (expand_block_move): Call vector
+	load/store with length only on 64-bit Power10.
+
+2023-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/110914
+	* tree-ssa-strlen.c (strlen_pass::handle_builtin_memcpy): Don't call
+	adjust_last_stmt unless len is known constant.
+
+2023-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/111015
+	* gimple-ssa-store-merging.c
+	(imm_store_chain_info::output_merged_store): Use wi::mask and
+	wide_int_to_tree instead of unsigned HOST_WIDE_INT shift and
+	build_int_cst to build BIT_AND_EXPR mask.
+
+2023-08-16  liuhongt  <hongtao.liu@intel.com>
+
+	* config/i386/i386.opt: Add new option mgather.
+
+2023-08-16  liuhongt  <hongtao.liu@intel.com>
+
+	Backported from master:
+	2023-08-16  liuhongt  <hongtao.liu@intel.com>
+
+	* config/i386/i386-options.c (m_GDS): New macro.
+	* config/i386/x86-tune.def (X86_TUNE_USE_GATHER): Don't enable
+	for m_GDS.
+
+2023-08-09  liuhongt  <hongtao.liu@intel.com>
+
+	* common/config/i386/cpuinfo.h (get_available_features): Check
+	max_subleaf_level for valid subleaf before use CPUID.
+
+2023-08-01  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-07-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/110741
+	* config/rs6000/altivec.md (define_insn xxeval): Correct vsx
+	operands output with "x".
+
+2023-07-14  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/101469
+	* config/sh/sh.md (peephole2): Handle case where eliminated reg
+	is also	used by the address of the following memory operand.
+
+2023-07-05  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2023-06-23   Michael Meissner  <meissner@linux.ibm.com>
+		    Aaron Sawdey   <acsawdey@linux.ibm.com>
+
+	PR target/105325
+	* config/rs6000/genfusion.pl (gen_ld_cmpi_p10_one): Fix problems that
+	allowed prefixed lwa to be generated.
+	* config/rs6000/fusion.md: Regenerate.
+	* config/rs6000/predicates.md (ds_form_mem_operand): Delete.
+	* config/rs6000/rs6000.md (prefixed attribute): Add support for load
+	plus compare immediate fused insns.
+	(maybe_prefixed): Likewise.
+
+2023-07-05  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2023-06-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/genfusion.pl (gen_ld_cmpi_p10_one): New, rewritten and
+	split out from...
+	(gen_ld_cmpi_p10): ... this.
+
+2023-06-29  liuhongt  <hongtao.liu@intel.com>
+
+	PR rtl-optimization/110237
+	* config/i386/sse.md (<avx512>_store<mode>_mask): Refine with
+	UNSPEC_MASKMOV.
+	(maskstore<mode><avx512fmaskmodelower): Ditto.
+	(*<avx512>_store<mode>_mask): New define_insn, it's renamed
+	from original <avx512>_store<mode>_mask.
+
+2023-06-29  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/110309
+	* config/i386/sse.md (maskload<mode><avx512fmaskmodelower>):
+	Refine pattern with UNSPEC_MASKLOAD.
+	(maskload<mode><avx512fmaskmodelower>): Ditto.
+
+2023-06-28  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2023-06-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR testsuite/66005
+	* doc/install.texi: Document (optional) Perl usage for parallel
+	testing of libgomp.
+
+2023-06-28  liuhongt  <hongtao.liu@intel.com>
+
+	* config/i386/i386-features.c (pass_insert_vzeroupper:gate):
+	Move flag_expensive_optimizations && !optimize_size to ..
+	* config/i386/i386-options.c (ix86_option_override_internal):
+	.. this, it makes -mvzeroupper independent of optimization
+	level, but still keeps the behavior of architecture
+	tuning(emit_vzeroupper) unchanged.
+	(rest_of_handle_insert_vzeroupper): Remove
+	flag_expensive_optimizations && !optimize_size.
+
+2023-06-20  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/109932
+	* config/rs6000/rs6000-builtin.def (BU_VSX_MISC_2): New macro.
+	({un,}pack_vector_int128): Use BU_VSX_MISC_2 instead of
+	BU_P7_MISC_2.
+
+2023-06-20  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-06-12  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/110011
+	* config/rs6000/rs6000.c (output_toc): Use the mode of the 128-bit
+	floating constant itself for real_to_target call.
+
+2023-06-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-06-12  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/110200
+	* genmatch.c (expr::gen_transform): Put braces around
+	the if arm for the (convert ...) short-cut.
+
+2023-06-09  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2023-05-25  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/109800
+	* config/arm/arm.md (movdf): Generate temporary pseudo in DImode
+	instead of DFmode.
+	* config/arm/vfp.md (no_literal_pool_df_immediate): Rather than punning an
+	lvalue DFmode pseudo into DImode, use a DImode pseudo and pun it into
+	DFmode as an rvalue.
+
+2023-06-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2023-06-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/110044
+	* config/rs6000/rs6000.c (darwin_rs6000_special_round_type_align):
+	Make sure that we do not have a cap on field alignment before altering
+	the struct layout based on the type alignment of the first entry.
+
+2023-06-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-05-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109505
+	* match.pd ((x | CST1) & CST2 -> (x & CST2) | (CST1 & CST2),
+	Combine successive equal operations with constants,
+	(A +- CST1) +- CST2 -> A + CST3, (CST1 - A) +- CST2 -> CST3 - A,
+	CST1 - (CST2 - A) -> CST3 + A): Use ! on ops with 2 CONSTANT_CLASS_P
+	operands.
+
+2023-06-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109505
+	* doc/match-and-simplify.texi: Amend ! documentation.
+	* genmatch.c (expr::gen_transform): Code-generate ! support
+	for GENERIC.
+	(parser::parse_expr): Allow ! for GENERIC.
+
+2023-06-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-06-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR target/109954
+	* doc/invoke.texi (x86 Options): Fix description of -m32 option.
+
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-22   Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/70243
+	* config/rs6000/vsx.md (vsx_fmav4sf4): Do not generate vmaddfp.  Back
+	port from master 04/10/2023.
+	(vsx_nfmsv4sf4): Do not generate vnmsubfp.
+
+2023-05-16  Simon Wright  <simon@pushface.org>
+
+	Backported from master:
+	2022-06-12  Simon Wright  <simon@pushface.org>
+
+	PR target/104871
+	* config/darwin-driver.c (darwin_find_version_from_kernel): If the OS
+	version is darwin20 (macOS 11) or greater, truncate the version to the
+	major number.
+
+2023-05-16  Mark Mentovai  <mark@mentovai.com>
+
+	Backported from master:
+	2022-06-12  Mark Mentovai  <mark@mentovai.com>
+
+	* config/darwin-c.c: Make -mmacosx-version-min more future-proof.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2022-05-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/105599
+	* config/darwin.h: Move versions-specific handling of multiply_defined
+	from SUBTARGET_DRIVER_SELF_SPECS to LINK_SPEC.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2021-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.gcc: Emit L2_MAX_OFILE_ALIGNMENT with suitable
+	values for the host.
+	* config/darwin.c (darwin_emit_common): Error for alignment
+	values > 32768.
+	* config/darwin.h (MAX_OFILE_ALIGNMENT): Rework to use the
+	configured L2_MAX_OFILE_ALIGNMENT.
+
+2023-05-16  François-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	Backported from master:
+	2021-12-18  François-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	* config/darwin-driver.c: Make version code more future-proof.
+	* config.gcc: Homogeneize darwin versions.
+	* configure.ac: Homogeneize darwin versions.
+	* configure: Regenerate.
+
+2023-05-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/i386/darwin.h (ENDFILE_SPEC): Fix trailing '\'.
+
+2023-05-15  liuhongt  <hongtao.liu@intel.com>
+
+	* config/i386/cygwin.h (ENDFILE_SPEC): Link crtfastmath.o
+	whenever -mdaz-ftz is specified. Don't link crtfastmath.o
+	when -mno-daz-ftz is specified.
+	* config/i386/darwin.h (ENDFILE_SPEC): Ditto.
+	* config/i386/gnu-user-common.h
+	(GNU_USER_TARGET_MATHFILE_SPEC): Ditto.
+	* config/i386/mingw32.h (ENDFILE_SPEC): Ditto.
+	* config/i386/i386.opt (mdaz-ftz): New option.
+	* doc/invoke.texi (x86 options): Document mftz-daz.
+
+2023-05-09  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-05-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109778
+	* wide-int.h (wi::lrotate, wi::rrotate): Call wi::lrshift on
+	wi::zext (x, width) rather than x if width != precision, rather
+	than using wi::zext (right, width) after the shift.
+	* tree-ssa-ccp.c (bit_value_binop): Call wi::ext on the results
+	of wi::lrotate or wi::rrotate.
+
+2023-05-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-03-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/108950
+	* tree-vect-patterns.c (vect_recog_widen_sum_pattern):
+	Check oprnd0 is defined in the loop.
+	* tree-vect-loop.c (vectorizable_reduction): Record all
+	operands vector types, compute that of invariants and
+	properly update their SLP nodes.
+
+2023-05-05  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107898
+	* gimple-ssa-warn-alloca.c (alloca_call_type): Check
+	the type of the alloca argument is compatible with size_t
+	before querying ranges.
+
+2023-05-03  Arsen Arsenović  <arsen@aarsen.me>
+
+	* doc/extend.texi: Replace @itemx not being preceded by @item.
+
+2023-05-03  Anthony Sharp  <anthonysharp15@gmail.com>
+
+	Backported from master:
+	2021-08-27  Anthony Sharp  <anthonysharp15@gmail.com>
+
+	* symbol-summary.h: Added missing template keyword.
+
+2023-05-03  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109473
+	* tree-vect-loop.c (get_initial_def_for_reduction):
+	Convert the scalar values to the vector component type
+	before using it to build the vector for the initial value.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109410
+	* tree-ssa-reassoc.c (build_and_add_sum): Split edge from entry
+	block if first statement of the function is a call to returns_twice
+	function.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/106190
+	* sanopt.c (pass_sanopt::execute): Return TODO_cleanup_cfg if any
+	of the IFN_{UB,HWA,A}SAN_* internal fns are lowered.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/109276
+	* config/i386/i386.c (assign_386_stack_local): For DImode
+	with SLOT_FLOATxFDI_387 and -m32 -mpreferred-stack-boundary=2 pass
+	align 32 rather than 0 to assign_stack_local.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/105685
+	* predict.c (compute_function_frequency): Don't call
+	warn_function_cold if function already has cold attribute.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109176
+	* tree-vect-generic.c (expand_vector_condition): If a has
+	vector boolean type and is a comparison, also check if both
+	the comparison and VEC_COND_EXPR could be successfully expanded
+	individually.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105554
+	* function.h (push_struct_function): Add ABSTRACT_P argument defaulted
+	to false.
+	* function.c (push_struct_function): Add ABSTRACT_P argument, pass it
+	to allocate_struct_function instead of false.
+	* tree-inline.c (initialize_cfun): Don't copy DECL_ARGUMENTS
+	nor DECL_RESULT here.  Pass true as ABSTRACT_P to
+	push_struct_function.  Call targetm.target_option.relayout_function
+	after it.
+	(tree_function_versioning): Formatting fix.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108685
+	* omp-expand.c (expand_omp_for_ordered_loops): Add L0_BB argument,
+	use its loop_father rather than BODY_BB's loop_father.
+	(expand_omp_for_generic): Adjust expand_omp_for_ordered_loops caller.
+	If broken_loop with ordered > collapse and at least one of those
+	extra loops aren't guaranteed to have at least one iteration, change
+	l0_bb's loop_father to entry_bb's loop_father.  Set cont_bb's
+	loop_father to l0_bb's loop_father rather than l1_bb's.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR testsuite/108973
+	* selftest-diagnostic.c
+	(test_diagnostic_context::test_diagnostic_context): Set
+	caret_max_width to 80.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/108967
+	* cfgexpand.c (expand_debug_expr): Handle WIDEN_{PLUS,MINUS}_EXPR
+	and VEC_WIDEN_{PLUS,MINUS}_{HI,LO}_EXPR.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108854
+	* cgraphclones.c (duplicate_thunk_for_node): If no parameter
+	changes are needed, copy at least DECL_ARGUMENTS PARM_DECL
+	nodes and adjust their DECL_CONTEXT.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/108881
+	* config/i386/i386-builtin.def (__builtin_ia32_cvtne2ps2bf16_v16hi,
+	__builtin_ia32_cvtne2ps2bf16_v16hi_mask,
+	__builtin_ia32_cvtne2ps2bf16_v16hi_maskz,
+	__builtin_ia32_cvtne2ps2bf16_v8hi,
+	__builtin_ia32_cvtne2ps2bf16_v8hi_mask,
+	__builtin_ia32_cvtne2ps2bf16_v8hi_maskz,
+	__builtin_ia32_cvtneps2bf16_v8sf_mask,
+	__builtin_ia32_cvtneps2bf16_v8sf_maskz,
+	__builtin_ia32_cvtneps2bf16_v4sf_mask,
+	__builtin_ia32_cvtneps2bf16_v4sf_maskz,
+	__builtin_ia32_dpbf16ps_v8sf, __builtin_ia32_dpbf16ps_v8sf_mask,
+	__builtin_ia32_dpbf16ps_v8sf_maskz, __builtin_ia32_dpbf16ps_v4sf,
+	__builtin_ia32_dpbf16ps_v4sf_mask,
+	__builtin_ia32_dpbf16ps_v4sf_maskz): Require also
+	OPTION_MASK_ISA_AVX512VL.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/100758
+	* common/config/i386/cpuinfo.h (cpu_indicator_init): Call
+	get_available_features for all CPUs with max_level >= 1, rather
+	than just Intel or AMD.
+
+2023-05-02  Andrew Pinski  <apinski@marvell.com>
+
+	Backported from master:
+	2023-02-09  Andrew Pinski  <apinski@marvell.com>
+
+	PR tree-optimization/108688
+	* match.pd (bit_field_ref [bit_insert]): Avoid generating
+	BIT_FIELD_REFs of non-mode-precision integral operands.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/108692
+	* tree-vect-patterns.c (vect_widened_op_tree): If rhs_code is
+	widened_code which is different from code, don't call
+	vect_look_through_possible_promotion but instead just check op is
+	SSA_NAME with integral type for which vect_is_simple_use is true
+	and call set_op on this_unprom.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108435
+	* tree-nested.c (convert_nonlocal_omp_clauses)
+	<case OMP_CLAUSE_LASTPRIVATE>: If info->new_local_var_chain and *seq
+	is not a GIMPLE_BIND, wrap the sequence into a new GIMPLE_BIND
+	before calling declare_vars.
+	(convert_nonlocal_omp_clauses) <case OMP_CLAUSE_LINEAR>: Merge
+	with the OMP_CLAUSE_LASTPRIVATE handling except for whether
+	seq is initialized to &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause)
+	or &OMP_CLAUSE_LINEAR_GIMPLE_SEQ (clause).
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/108573
+	* ree.c (combine_reaching_defs): Don't return false for paradoxical
+	subregs in DEBUG_INSNs.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/108596
+	* bb-reorder.c (fix_up_fall_thru_edges): Handle the case where cur_bb
+	ends with asm goto and has a crossing fallthrough edge to the same bb
+	that contains at least one of its labels by restoring EDGE_CROSSING
+	flag even on possible edge from cur_bb to new_bb successor.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR other/108560
+	* doc/extend.texi: Fix up return type of __builtin_va_arg_pack_len
+	from size_t to int.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/108498
+	* gimple-ssa-store-merging.c (class store_operand_info):
+	End coment with full stop rather than comma.
+	(split_group): Likewise.
+	(merged_store_group::apply_stores): Clear string_concatenation if
+	start or end aren't on a byte boundary.
+
+2023-05-02  Eric Biggers  <ebiggers@google.com>
+
+	Backported from master:
+	2023-01-24  Eric Biggers  <ebiggers@google.com>
+
+	PR bootstrap/90543
+	* optc-save-gen.awk: Fix copy-and-paste error.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108459
+	* omp-expand.c (expand_omp_for_init_counts): Use fold_build1 rather
+	than fold_unary for NEGATE_EXPR.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108237
+	* generic-match-head.c: Include tree-pass.h.
+	(canonicalize_math_p, optimize_vectors_before_lowering_p): Define
+	to false if cfun and cfun->curr_properties has PROP_gimple_opt_math
+	resp. PROP_gimple_lvec property set.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108264
+	* expr.c (store_expr): For stores into SUBREG_PROMOTED_* targets
+	from source which doesn't have scalar integral mode first convert
+	it to outer_mode.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/108068
+	* tree.h (real_maybe_zerop): Declare.
+	* tree.c (real_maybe_zerop): Define.
+	* tree-ssa-dom.c (record_edge_info): Use it instead of
+	real_zerop or TREE_CODE (op1) == SSA_NAME || real_zerop.  Always set
+	can_infer_simple_equiv to false for decimal floating point types.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/108193
+	* cse.c (compute_const_anchors): Change n type to
+	unsigned HOST_WIDE_INT, adjust comparison against it to avoid
+	warnings.  Formatting fix.
+	(insert_const_anchor): Use gen_int_mode instead of GEN_INT.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/106751
+	* loop-invariant.c (move_invariant_reg): If preheader bb ends
+	with a JUMP_INSN, split the preheader edge and emit invariants
+	into the new preheader basic block.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/108095
+	* tree-into-ssa.c (maybe_register_def): Insert debug stmt
+	on all non-EH edges from asm goto if they have a single
+	predecessor rather than asserting there is at most one such edge.
+	Test whether there are no PHI nodes next to the single predecessor
+	test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/107997
+	* tree-ssa-loop-ivopts.c: Include cfganal.h.
+	(create_new_iv) <case IP_END>: If ip_end_pos bb is non-empty and ends
+	with a stmt which ends bb, instead of adding iv update after it split
+	the latch edge and insert iterator into the new latch bb.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/106719
+	* cfgbuild.c (find_bb_boundaries): If there are NOTEs in between
+	debug_insn (seen after flow_transfer_insn) and insn, move NOTEs
+	before all the DEBUG_INSNs and split after NOTEs.  If there are
+	other insns like jump table data, clear debug_insn.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/106875
+	* config/i386/i386.opt (x_ix86_abi): Remove TargetSave.
+	(ix86_abi): Replace it with TargetVariable.
+	* config/i386/i386-options.c (ix86_function_specific_save,
+	ix86_function_specific_restore): Don't save and restore x_ix86_abi.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/107317
+	* asan.c: Include diagnostic-core.h.
+	(asan_emit_stack_protection): Return NULL early if seen_error ().
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-02-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/108821
+	* tree-ssa-loop-im.c (sm_seq_valid_bb): We can also not
+	move volatile accesses.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-03-27  Richard Biener  <rguenther@suse.de>
+
+	PR lto/109263
+	* lto-wrapper.c (run_gcc): Parse alternate debug options
+	as well, they always enable debug.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109573
+	* tree-vect-loop.c (vectorizable_live_operation): Allow
+	unhandled SSA copy as well.  Demote assert to checking only.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/109585
+	* tree-ssa-alias.c (aliasing_component_refs_p): Fix typo.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109502
+	* tree-vect-stmts.c (vectorizable_assignment): Fix
+	check for conversion between mask and non-mask types.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109473
+	* tree-vect-loop.c (vect_create_epilog_for_reduction):
+	Convert scalar result to the computation type before performing
+	the reduction adjustment.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-02-02  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/108625
+	* genmatch.c (expr::gen_transform): Also disallow resimplification
+	from pushing to lseq with force_leaf.
+	(dt_simplify::gen_1): Likewise.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/108076
+	* tree-if-conv.c (if_convertible_loop_p_1): Reject blocks
+	with non-local or forced labels that we later remove
+	labels from.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107451
+	* tree-vect-stmts.c (vectorizable_load): Avoid loading
+	SLP group members from group numbers in excess of the
+	vectorization factor.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-03-29  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/106124
+	* dwarf2out.c (lookup_type_die): Reset TREE_ASM_WRITTEN
+	so we can re-create the DIE for the type if required.
+
+2023-04-24  Haochen Gui  <guihaoc@gcc.gnu.org>
+
+	PR target/108812
+	* config/rs6000/vsx.md (vsx_sign_extend_qi_<mode>): Rename to...
+	(vsx_sign_extend_v16qi_<mode>): ... this.
+	(vsx_sign_extend_hi_<mode>): Rename to...
+	(vsx_sign_extend_v8hi_<mode>): ... this.
+	(vsx_sign_extend_si_v2di): Rename to...
+	(vsx_sign_extend_v4si_v2di): ... this.
+	(vsignextend_qi_<mode>): Remove.
+	(vsignextend_hi_<mode>): Remove.
+	(vsignextend_si_v2di): Remove.
+	(vsignextend_v2di_v1ti): Remove.
+	(*xxspltib_<mode>_split): Replace gen_vsx_sign_extend_qi_v2di with
+	gen_vsx_sign_extend_v16qi_v2di and gen_vsx_sign_extend_qi_v4si
+	with gen_vsx_sign_extend_v16qi_v4si.
+	* config/rs6000/rs6000.md (split for DI constant generation):
+	Replace gen_vsx_sign_extend_qi_si with gen_vsx_sign_extend_v16qi_si.
+	(split for HSDI constant generation): Replace gen_vsx_sign_extend_qi_di
+	with gen_vsx_sign_extend_v16qi_di and gen_vsx_sign_extend_qi_si
+	with gen_vsx_sign_extend_v16qi_si.
+	* config/rs6000/rs6000-builtin.def (__builtin_altivec_vsignextsb2d):
+	Set ICODE to vsx_sign_extend_v16qi_v2di.
+	(__builtin_altivec_vsignextsb2w): Set ICODE to
+	vsx_sign_extend_v16qi_v4si.
+	(__builtin_altivec_visgnextsh2d): Set ICODE to
+	vsx_sign_extend_v8hi_v2di.
+	(__builtin_altivec_vsignextsh2w): Set ICODE to
+	vsx_sign_extend_v8hi_v4si.
+	(__builtin_altivec_vsignextsw2d): Set ICDE to
+	vsx_sign_extend_si_v2di.
+	(__builtin_altivec_vsignext): Set ICODE to vsx_sign_extend_v2di_v1ti.
+
+2023-04-18  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2023-01-31  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	PR target/108589
+	* config/aarch64/aarch64.c (aarch_macro_fusion_pair_p): Check
+	REG_P on SET_DEST.
+
+2023-04-17  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2023-04-17  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+		    Di Zhao  <di.zhao@amperecomputing.com>
+
+	* config/aarch64/aarch64-tuning-flags.def (AARCH64_EXTRA_TUNING_OPTION):
+	Add AARCH64_EXTRA_TUNE_NO_LDP_COMBINE.
+	* config/aarch64/aarch64.c (aarch64_operands_ok_for_ldpstp):
+	Check for the above tuning option when processing loads.
+
+2023-04-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105484
+	* gimple-isel.cc (gimple_expand_vec_set_expr): Clean EH, return
+	whether the CFG changed.
+	(gimple_expand_vec_exprs): When the CFG changed, clean it up.
+
+2023-04-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/104464
+	* gimple-isel.cc (gimple_expand_vec_cond_expr): Postpone
+	throwing check to after unproblematic replacement.
+
+2023-04-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/104450
+	* gimple-isel.cc: Pass cfun around.
+	(+gimple_expand_vec_cond_expr): Do not combine a throwing
+	comparison with the select.
+
+2023-04-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109491
+	* tree-ssa-sccvn.c (expressions_equal_p): Restore the
+	NULL operands test.
+
+2023-04-17  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-04-04  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/108699
+	* config/rs6000/altivec.md (*p9v_parity<mode>2): Rename to ...
+	(rs6000_vprtyb<mode>2): ... this.
+	* config/rs6000/rs6000-builtin.def (VPRTYBD): Replace parityv2di2 with
+	rs6000_vprtybv2di2.
+	(VPRTYBW): Replace parityv4si2 with rs6000_vprtybv4si2.
+	(VPRTYBQ): Replace parityv1ti2 with rs6000_vprtybv1ti2.
+	* config/rs6000/vector.md (parity<mode>2 with VEC_IP): Expand with
+	popcountv16qi2 and the corresponding rs6000_vprtyb<mode>2.
+
+2023-04-17  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-04-04  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/108807
+	* config/rs6000/rs6000.c (rs6000_expand_vector_set_var_p9): Fix gen
+	function for permutation control vector by considering big endianness.
+
+2023-04-13  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2023-03-27  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+		    Jiangning Liu  <jiangning.liu@amperecomputing.com>
+		    Manolis Tsamis  <manolis.tsamis@vrull.eu>
+
+	* config/aarch64/aarch64.c: Update vector costs for ampere1.
+
+2023-04-11  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/109067
+	* config/rs6000/rs6000.c (create_complex_muldiv): Delete.
+	(init_float128_ieee): Delete code to switch complex multiply and divide
+	for long double.  Backport from master, 3/20/2023.
+	(complex_multiply_builtin_code): New helper function.
+	(complex_divide_builtin_code): Likewise.
+	(rs6000_mangle_decl_assembler_name): Add support for mangling the name
+	of complex 128-bit multiply and divide built-in functions.
+
+2023-03-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/109140
+	* config/sparc/sparc.c (sparc_expand_vcond): Call signed_condition
+	on operand #3 to get the final condition code.  Use std::swap.
+	* config/sparc/sparc.md (vcondv8qiv8qi): New VIS 4 expander.
+	(fucmp<gcond:code>8<P:mode>_vis): Move around.
+	(fpcmpu<gcond:code><GCM:gcm_name><P:mode>_vis): Likewise.
+	(vcondu<GCM:mode><GCM:mode>): New VIS 4 expander.
+
+2023-03-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2023-03-01  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/108546
+	* omp-low.c (lower_omp_target): Remove optional handling
+	on the receiver side, i.e. inside target (data), for
+	use_device_ptr.
+
+2023-02-24  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backported from master:
+	2023-02-24  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/riscv/t-rtems: Keep only -mcmodel=medany 64-bit multilibs.
+	Add non-compact 32-bit multilibs.
+
+2023-02-20  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2023-02-06  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/104921
+	* config/aarch64/aarch64-simd.md (aarch64_bfmlal<bt>_lane<q>v4sf):
+	Use correct constraint for operand 3.
+
+2023-02-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/90458
+	* config/i386/i386.c (ix86_compute_frame_layout): Disable the
+	effects of -fstack-clash-protection for TARGET_STACK_PROBE.
+	(ix86_expand_prologue): Likewise.
+
+2023-02-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-01-18  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/108348
+	* config/rs6000/rs6000.c (rs6000_opaque_type_invalid_use_p): Add the
+	support for invalid uses of MMA opaque type in function arguments.
+
+2023-02-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-01-16  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/108272
+	* config/rs6000/rs6000.c (rs6000_opaque_type_invalid_use_p): Add the
+	support for invalid uses in inline asm, factor out the checking and
+	erroring to lambda function check_and_error_invalid_use.
+
+2023-02-07  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106809
+	* tree-ssa-sccvn.c (dominaged_by_p_w_unex): Check we have
+	more than one successor before doing extra work.
+
+2023-02-02  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2023-01-18  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/107944
+	* cgraph.c (cgraph_node::remove): Check whether nodes up the
+	lcone_of chain also do not need the body.
+
+2023-01-26  Dimitar Dimitrov  <dimitar@dinux.eu>
+
+	Backported from master:
+	2023-01-22  Dimitar Dimitrov  <dimitar@dinux.eu>
+
+	* config/pru/pru.h (CLZ_DEFINED_VALUE_AT_ZERO): Fix value for QI
+	and HI input modes.
+	* config/pru/pru.md (clz): Fix generated code for QI and HI
+	input modes.
+
+2023-01-25  Christophe Lyon  <christophe.lyon@arm.com>
+
+	Backported from master:
+	2023-01-12  Christophe Lyon  <christophe.lyon@arm.com>
+		    Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_function_arg_alignment): Fix
+	comment.
+	(aarch64_layout_arg): Factorize warning conditions.
+	(aarch64_function_arg_boundary): Fix typo.
+	* function.c (currently_expanding_function_start): New variable.
+	(expand_function_start): Handle
+	currently_expanding_function_start.
+	* function.h (currently_expanding_function_start): Declare.
+
+2023-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-11  Richard Biener  <rguenther@suse.de>
+		    Nikita Voronov  <nik_1357@mail.ru>
+
+	PR tree-optimization/107554
+	* tree-ssa-strlen.c (strlen_pass::count_nonzero_bytes):
+	Use unsigned HOST_WIDE_INT type for the strlen.
+
+2023-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107323
+	* tree-loop-distribution.c (pg_unmark_merged_alias_ddrs):
+	New function.
+	(loop_distribution::break_alias_scc_partitions): Revert
+	postorder save/restore from the PR94125 fix.  Instead
+	make sure to not ignore edges from SCCs we are going to
+	merge.
+
+2023-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107254
+	* tree-vect-slp.c (vect_slp_analyze_node_operations_1):
+	For permutes also analyze live lanes.
+	(vect_schedule_slp_node): For permutes also code generate
+	live lane extracts.
+
+2023-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107212
+	* tree-vect-loop.c (vectorizable_reduction): Make sure to
+	set STMT_VINFO_REDUC_DEF for all live lanes in a SLP
+	reduction.
+	(vectorizable_live_operation): Do not pun to the SLP
+	node representative for reduction epilogue generation.
+
+2023-01-24  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-08-16  Sergei Trofimovich  <siarheit@google.com>
+
+	PR driver/106624
+	* gcc.c (driver::detect_jobserver): Allocate storage xputenv()
+	argument using xstrdup().
+
+2023-01-16  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2022-12-01  Alex Coplan  <alex.coplan@arm.com>
+
+	* varasm.c (assemble_variable): Fix type confusion bug when
+	checking for ".vtable_map_vars" section.
+
+2023-01-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/108199
+	* tree-sra.c (sra_modify_expr): Deal with reverse storage order
+	for bit-field references.
+
+2023-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	Backported from master:
+	2022-12-30  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	PR target/107714
+	* config/arm/arm-protos.h (mve_struct_mem_operand): New protoype.
+	* config/arm/arm.c (mve_struct_mem_operand): New function.
+	* config/arm/constraints.md (Ug): New constraint.
+	* config/arm/mve.md (mve_vst4q<mode>): Change constraint.
+	(mve_vst2q<mode>): Likewise.
+	(mve_vld4q<mode>): Likewise.
+	(mve_vld2q<mode>): Likewise.
+	* config/arm/predicates.md (mve_struct_operand): New predicate.
+
+2023-01-05  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106736
+	* config/rs6000/mma.md (define_expand movoo): Call function
+	rs6000_opaque_type_invalid_use_p to check and emit error message for
+	the invalid use of opaque type.
+	(define_expand movxo): Likewise.
+	* config/rs6000/rs6000-protos.h
+	(rs6000_opaque_type_invalid_use_p): New function declaration.
+	(currently_expanding_gimple_stmt): New extern declaration.
+	* config/rs6000/rs6000.c (rs6000_opaque_type_invalid_use_p): New
+	function.
+
+2022-12-22  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-08-10  Martin Liska  <mliska@suse.cz>
+
+	* opts-jobserver.h: Add one member.
+	* opts-common.c (jobserver_info::jobserver_info): Parse FIFO
+	format of --jobserver-auth.
+
+2022-12-22  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-08-10  Martin Liska  <mliska@suse.cz>
+
+	* gcc.c (driver::detect_jobserver): Remove and move to
+	jobserver.h.
+	* lto-wrapper.c (jobserver_active_p): Likewise.
+	(run_gcc): Likewise.
+	* opts-jobserver.h: New file.
+	* opts-common.c (jobserver_info::jobserver_info): New function.
+
+2022-12-15  Sebastian Pop  <spop@amazon.com>
+
+	PR target/98776
+	* config/aarch64/aarch64-protos.h (aarch64_output_patchable_area):
+	Declared.
+	* config/aarch64/aarch64.c (aarch64_print_patchable_function_entry):
+	Emit an UNSPECV_PATCHABLE_AREA pseudo instruction.
+	(aarch64_output_patchable_area): New.
+	* config/aarch64/aarch64.md (UNSPECV_PATCHABLE_AREA): New.
+	(patchable_area): Define.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107107
+	* tree-ssa-sccvn.c (visit_reference_op_store): Do not
+	affect value-numbering when doing the tail merging
+	MODIFY_EXPR lookup.
+
+2022-12-01  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/107863
+	* config/i386/i386-expand.c (ix86_expand_vec_set_builtin):
+	Convert op1 to target mode whenever mode mismatch.
+
+2022-11-30  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (addvdi3): Force operand 2 to a register.
+	Remove "addi,tsv,*" instruction from unamed pattern.
+	(subvdi3): Force operand 1 to a register.
+	Remove "subi,tsv" instruction from from unamed pattern.
+
+2022-11-29  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backported from master:
+	2022-11-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	PR rtl-optimization/107482
+	* ira-color.c (assign_hard_reg): Only call
+	update_costs_from_copies when retry_p is false.
+
+2022-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* range-op.cc (operator_bitwise_xor::op1_range): Fix thinko.
+
+2022-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-loop-distribution.c (loop_distribution::classify_builtin_ldst):
+	Bail out if source and destination do not have the same storage order.
+
+2022-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/107748
+	* config/i386/smmintrin.h (_mm_extract_ps): Uglify names of local
+	variables and union members.
+
+2022-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/107183
+	* reg-stack.c (next_flags_user): Add DEBUG_SEEN argument.
+	If >= 0 and a DEBUG_INSN would be otherwise returned, set
+	DEBUG_SEEN to 1 and ignore it.
+	(swap_rtx_condition): Add DEBUG_SEEN argument.  In >= 0
+	mode only set DEBUG_SEEN to 1 if problematic DEBUG_ISNSs
+	were seen and revert all changes on success in that case.
+	Don't try to recog_memoized DEBUG_INSNs.
+	(compare_for_stack_reg): Adjust swap_rtx_condition caller.
+	If it returns true and debug_seen is 1, call swap_rtx_condition
+	again with debug_seen -1.
+
+2022-11-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2022-11-19  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* config/nvptx/nvptx.h (STARTFILE_SPEC): Fix 'crt0.o' for
+	'-mmainkernel'.
+
+2022-11-16  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2022-11-14  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	* config/aarch64/aarch64-cores.def (AARCH64_CORE): Add ampere1a.
+	* config/aarch64/aarch64-cost-tables.h: Add ampere1a_extra_costs.
+	* config/aarch64/aarch64-fusion-pairs.def (AARCH64_FUSION_PAIR):
+	Define a new fusion pair for A+B+1/A-B-1 (i.e., add/subtract two
+	registers and then +1/-1).
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* config/aarch64/aarch64.c (aarch_macro_fusion_pair_p): Implement
+	idiom-matcher for the new fusion pair.
+	* doc/invoke.texi: Add ampere1a.
+
+2022-11-08  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-10-25  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107304
+	* expr.c (get_inner_reference): Always use TYPE_MODE for vector
+	field with vector raw mode.
+
+2022-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c/41041
+	* doc/cppopts.texi: Document -fwide-exec-charset defaults
+	correctly.
+
+2022-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* fold-const.c (operand_compare::operand_equal_p) <COMPONENT_REF>:
+	Do not take into account operand 2.
+	(operand_compare::hash_operand) <COMPONENT_REF>: Likewise.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107001
+	* omp-low.c (lower_omp_taskgroup): Don't add GOMP_RETURN statement
+	at the end.
+	* omp-expand.c (build_omp_regions_1): Clarify GF_OMP_TARGET_KIND_DATA
+	is not stand-alone directive.  For GIMPLE_OMP_TASKGROUP, also don't
+	update parent.
+	(omp_make_gimple_edges) <case GIMPLE_OMP_TASKGROUP>: Reset
+	cur_region back after new_omp_region.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/106721
+	* config/i386/sse.md
+	(avx512er_vmrcp28<mode><mask_name><round_saeonly_name>): Fix typo,
+	mask_opernad3 -> mask_operand3.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-07-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/106261
+	* cgraphunit.c (cgraph_node::assemble_thunks_and_aliases): Don't
+	output asm thunks for -dx.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-07-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/106144
+	* wide-int.cc (wi::shifted_mask): If end >= prec, return right after
+	emitting element for shift or if shift is 0 first element after start.
+	(wide_int_cc_tests): Add tests for equivalency of wi::mask and
+	wi::shifted_mask with 0 start.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/106032
+	* ifcvt.c (noce_try_sign_mask): Punt if !t_unconditional, and
+	t may_trap_or_fault_p, even if it is cheap.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/106030
+	* expr.c (expand_cond_expr_using_cmove): Pass NULL_RTX instead of
+	temp to expand_operands if mode has been promoted.
+
+2022-10-27  Torbjörn SVENSSON  <torbjorn.svensson@foss.st.com>
+
+	Backported from master:
+	2022-10-27  Torbjörn SVENSSON  <torbjorn.svensson@foss.st.com>
+		    Yvan ROUX  <yvan.roux@foss.st.com>
+
+	* ira.c: Resize array after reg number increased.
+
+2022-10-26  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2022-10-06  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	* config/aarch64/aarch64-cores.def (AARCH64_CORE): Update
+	Ampere-1 core entry.
+
+2022-10-26  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2022-10-06  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	* config/aarch64/driver-aarch64.c (readline): Fix off-by-one.
+
+2022-10-25  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2022-10-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	PR target/106355
+	* config/s390/s390.c (s390_call_saved_register_used): For a
+	parameter with BLKmode fix determining number of consecutive
+	registers.
+
+2022-10-25  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-10-25  Martin Liska  <mliska@suse.cz>
+
+	PR target/107364
+	* common/config/i386/i386-cpuinfo.h (enum processor_vendor):
+	Fix pedantic warning.
+
+2022-10-25  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-10-24  Martin Liska  <mliska@suse.cz>
+
+	PR target/107364
+	* common/config/i386/i386-cpuinfo.h (enum processor_vendor):
+	  Reorder enum values as BUILTIN_VENDOR_MAX should not point
+	  in the middle of the valid enum values.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64-sve.md (*aarch64_brk<brk_op>_cc): Remove
+	merging alternative.
+	(*aarch64_brk<brk_op>_ptest): Likewise.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/iterators.md (SVE_BRKP): New iterator.
+	* config/aarch64/aarch64-sve.md (*aarch64_brkn_cc): New pattern.
+	(*aarch64_brkn_ptest): Likewise.
+	(*aarch64_brk<brk_op>_cc): Restrict to SVE_BRKP.
+	(*aarch64_brk<brk_op>_ptest): Likewise.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* config/aarch64/aarch64.h (AARCH64_FL_FOR_ARCH8_3): Add
+	AARCH64_FL_RCPC.
+	(AARCH64_ISA_RCPC): New macro.
+	* config/aarch64/aarch64-cores.def (thunderx3t110, zeus, neoverse-v1)
+	(neoverse-512tvb, saphira): Remove RCPC from these Armv8.3-A+ cores.
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Define
+	__ARM_FEATURE_RCPC when appropriate.
+
+2022-10-19  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/96072
+	* config/rs6000/rs6000-logue.c (rs6000_emit_epilogue): Update the
+	condition for adding REG_CFA_DEF_CFA reg note with
+	frame_pointer_needed_indeed.
+
+2022-10-17  Pat Haugen  <pthaugen@linux.ibm.com>
+
+	PR target/99685
+	* config/rs6000/rs6000-call.c (rs6000_function_arg_advance_1): Bump
+	register count when not splitting IEEE 128-bit Complex.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106934
+	* tree-ssa.c (non_rewritable_mem_ref_base): Avoid BIT_FIELD_REFs
+	of bitfields.
+	(maybe_rewrite_mem_ref_base): Likewise.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106892
+	* tree-predcom.c (ref_at_iteration): Do not associate the
+	constant part of the offset into the MEM_REF offset
+	operand, across a non-zero offset.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106189
+	* gimple-array-bounds.cc (array_bounds_checker::check_mem_ref):
+	Divide using offset_ints.
+
+2022-10-14  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backported from master:
+	2022-07-25  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/aarch64/aarch64.md (rbit<mode>2): Rename this ...
+	(@aarch64_rbit<mode>): ... to this and change it in...
+	(ffs<mode>2,ctz<mode>2): ... here.
+	(@aarch64_rev16<mode>): New.
+	* config/aarch64/aarch64-builtins.c: (aarch64_builtins):
+	Define the following enum AARCH64_REV16, AARCH64_REV16L,
+	AARCH64_REV16LL, AARCH64_RBIT, AARCH64_RBITL, AARCH64_RBITLL.
+	(aarch64_init_data_intrinsics): New.
+	(aarch64_general_init_builtins): Add call to
+	aarch64_init_data_intrinsics.
+	(aarch64_expand_builtin_data_intrinsic): New.
+	(aarch64_general_expand_builtin): Add call to
+	aarch64_expand_builtin_data_intrinsic.
+	* config/aarch64/arm_acle.h (__clz, __clzl, __clzll, __cls, __clsl,
+	__clsll, __rbit, __rbitl, __rbitll, __rev, __revl, __revll, __rev16,
+	__rev16l, __rev16ll, __ror, __rorl, __rorll, __revsh): New.
+
+2022-10-14  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/107248
+	* config/sparc/sparc.c (sparc_expand_prologue): Emit a frame
+	blockage for leaf functions.
+	(sparc_flat_expand_prologue): Emit frame instead of full blockage.
+	(sparc_expand_epilogue): Emit a frame blockage for leaf functions.
+	(sparc_flat_expand_epilogue): Emit frame instead of full blockage.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR lto/106540
+	PR lto/106334
+	* lto-streamer-in.c (lto_read_tree_1): Use lto_input_tree_1
+	to input DECL_INITIAL, avoiding to commit drefs.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106513
+	* gimple-ssa-store-merging.c (do_shift_rotate): Use uint64_t
+	for head_marker.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/106331
+	* builtins.c (get_memory_rtx): Compute alignment from
+	the original address and set MEM_OFFSET to unknown when
+	we create a MEM_EXPR from the base object of the address.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106131
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Force alias-set
+	zero when offsetting the read looking through an aggregate
+	copy.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-06-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106112
+	* tree-ssa-sccvn.c (valueized_wider_op): Properly extend
+	a constant operand according to its type.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-06-20  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/106027
+	* fold-const.c (fold_to_nonsharp_ineq_using_bound): Use the
+	type of the prevailing comparison for the new comparison type.
+	(fold_binary_loc): Use proper types for the A < X && A + 1 > Y
+	to A < X && A >= Y folding.
+
+2022-10-03  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-10-03  Sergei Trofimovich  <siarheit@google.com>
+
+	PR target/107064
+	* config/i386/t-i386: Add build-time dependencies against
+	i386-builtin-types.inc to i386-builtins.o, i386-expand.o,
+	i386-features.o.
+
+2022-09-29  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-09-28  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107061
+	* config/i386/predicates.md (encodekey128_operation): Check
+	XMM4-XMM6 as clobbered.
+	(encodekey256_operation): Likewise.
+	* config/i386/sse.md (encodekey128u32): Clobber XMM4-XMM6.
+	(encodekey256u32): Likewise.
+
+2022-09-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-cores.def (neoverse-v2): New entry.
+	* config/aarch64/aarch64-tune.md: Regenerate.
+	* doc/invoke.texi (AArch64 Options): Document neoverse-v2.
+
+2022-09-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-09-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/106491
+	* config/aarch64/aarch64-sve-builtins.cc (scalar_types)
+	(acle_vector_types, acle_svpattern, acle_svprfop): Add GTY
+	markup to (new) extern declarations instead of to the main
+	definition.
+
+2022-09-14  Tom de Vries  <tdevries@suse.de>
+
+	Backported from master:
+	2022-02-01  Tom de Vries  <tdevries@suse.de>
+
+	* config/nvptx/nvptx.c (nvptx_single): Use nvptx_uniform_warp_check.
+	* config/nvptx/nvptx.md (define_c_enum "unspecv"): Add
+	UNSPECV_UNIFORM_WARP_CHECK.
+	(define_insn "nvptx_uniform_warp_check"): New define_insn.
+
+2022-09-14  Tom de Vries  <tdevries@suse.de>
+
+	Backported from master:
+	2022-02-01  Tom de Vries  <tdevries@suse.de>
+
+	* config/nvptx/nvptx.c (nvptx_single): Use nvptx_warpsync.
+	* config/nvptx/nvptx.md (define_c_enum "unspecv"): Add
+	UNSPECV_WARPSYNC.
+	(define_insn "nvptx_warpsync"): New define_insn.
+
+2022-09-14  Thomas Schwinge  <thomas@codesourcery.com>
+
+	* config/nvptx/nvptx.h (TARGET_PTX_6_0): '#define' to 'false'.
+
+2022-09-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-09-01  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101322
+	* config/rs6000/rs6000-call.c (rs6000_gimple_fold_mma_builtin):
+	Enforce the use of a valid MMA pointer type.
+
+2022-09-08  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/rtems.h (CPP_OS_DEFAULT_SPEC): Define __PPC_VRSAVE__ if
+	-mvrsave is present.
+	* config/rs6000/t-rtems: Add -mvrsave multilib variants for
+	-mcpu=e6500.
+
+2022-09-02  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2022-08-03  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR rtl-optimization/106187
+	* alias.h (mems_same_for_tbaa_p): Declare.
+	* alias.c (mems_same_for_tbaa_p): New function.
+	* dse.c (record_store): Use it instead of open-coding
+	alias check.
+	* cselib.h (cselib_redundant_set_p): Declare.
+	* cselib.c: Include alias.h
+	(cselib_redundant_set_p): New function.
+	* cfgcleanup.c: (mark_effect): Use cselib_redundant_set_p instead
+	of rtx_equal_for_cselib_p.
+	* postreload.c (reload_cse_simplify): Use cselib_redundant_set_p.
+	(reload_cse_noop_set_p): Delete.
+
+2022-09-02  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2022-05-13  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/105463
+	* config/arm/mve.md (*movmisalign<mode>_mve_store): Use
+	mve_memory_operand.
+	(*movmisalign<mode>_mve_load): Likewise.
+	* config/arm/vec-common.md (movmisalign<mode>): Convert to generator
+	form...
+	(@movmisalign<mode>): ... thus.  Use generic predicates and then
+	rework operands if they are not valid.  For MVE rework to a
+	narrower element size if the alignment is not high enough.
+
+2022-08-30  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-08-28  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/106017
+	* config/rs6000/rs6000.c (rs6000_invalid_conversion): Remove handling
+	of MMA pointer conversions.
+
+2022-08-24  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	Backported from master:
+	2022-08-16  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	PR target/103353
+	* config/rs6000/mma.md (define_expand movoo): Move TARGET_MMA condition
+	check to preparation statements and add handlings for !TARGET_MMA.
+	(define_expand movxo): Likewise.
+
+2022-08-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/106492
+	* omp-low.c (lower_rec_input_clauses): Add missing folding
+	to data type of linear-clause list item.
+
+2022-08-16  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/103197
+	PR target/102146
+	* config/rs6000/rs6000.md (zero_extendqi<mode>2 for EXTQI): Disparage
+	the "Z" alternatives in {l,st}{f,xs}iwzx.
+	(zero_extendhi<mode>2 for EXTHI): Ditto.
+	(zero_extendsi<mode>2 for EXTSI): Ditto.
+	(*movsi_internal1): Ditto.
+	(*mov<mode>_internal1 for QHI): Ditto.
+	(movsd_hardfloat): Ditto.
+
+2022-08-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR c/106016
+	* expr.c (count_type_elements): Handle OPAQUE_TYPE.
+
+2022-08-08   Michael Meissner  <meissner@linux.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Remove code
+	setting -mblock-ops-vector-pair.  Patch back ported from trunk, August
+	3rd, 2022.
+
+2022-08-02  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-07-25  Peter Bergner  <bergner@linux.ibm.com>
+		    Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/106345
+	* config/rs6000/rs6000.h (DRIVER_SELF_SPECS): Adjust -mdejagnu-cpu
+	to filter out all -mtune options.
+
+2022-08-02  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106091
+	* config/rs6000/rs6000-p8swap.c (replace_swapped_aligned_store): Copy
+	REG_EH_REGION when replacing one store insn having it.
+	(replace_swapped_aligned_load): Likewise.
+
+2022-07-27  Maciej W. Rozycki  <macro@embecosm.com>
+
+	Backported from master:
+	2022-07-27  Maciej W. Rozycki  <macro@embecosm.com>
+
+	* config/riscv/riscv.md (stack_protect_set_<mode>): Remove
+	duplicate backslashes.
+
+2022-07-25  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backported from master:
+	2022-07-25  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rs6000/rtems.h (CPLUSPLUS_CPP_SPEC): Undef.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105618
+	* tree-ssa-sink.c (statement_sink_location): For virtual
+	PHI uses ignore those defining the used virtual operand.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2021-11-24  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/103193
+	* match.pd: Avoid canonicalizing (le/ge @0 @0) to (eq @0 @0)
+	with NaNs and -ftrapping-math.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/103116
+	* tree-vect-stmts.c (get_group_load_store_type): Handle the
+	case we need peeling for gaps even though GROUP_GAP is zero.
+
+2022-07-21  Surya Kumari Jangala  <jskumari@linux.vnet.ibm.com>
+
+	Backported from master:
+	2022-06-14  Surya Kumari Jangala  <jskumari@linux.ibm.com>
+
+	PR rtl-optimization/105041
+	* regrename.c (check_new_reg_p): Use nregs value from du chain.
+
+2022-07-14   Michael Meissner  <meissner@linux.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Do
+	not generate block copies with vector pair instructions if we are
+	tuning for power10.  Back port from master branch.
+
+2022-07-12  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-07-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/105860
+	* tree-sra.c (build_reconstructed_reference): Start expr
+	traversal only just below the outermost union.
+
+2022-07-04  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-03-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/104869
+	* rtl-ssa/accesses.h (clobber_group::prev_clobber): Declare.
+	(clobber_group::next_clobber): Likewise.
+	(def_lookup::prev_def): Rename to...
+	(def_lookup::last_def_of_prev_group): ...this.
+	(def_lookup::next_def): Rename to...
+	(def_lookup::first_def_of_next_group): ...this.
+	(def_lookup::matching_or_prev_def): Rename to...
+	(def_lookup::matching_set_or_last_def_of_prev_group): ...this.
+	(def_lookup::matching_or_next_def): Rename to...
+	(def_lookup::matching_set_or_first_def_of_next_group): ...this.
+	(def_lookup::prev_def): New function, taking the lookup insn as
+	argument.
+	(def_lookup::next_def): Likewise.
+	* rtl-ssa/member-fns.inl (def_lookup::prev_def): Rename to...
+	(def_lookup::last_def_of_prev_group): ...this.
+	(def_lookup::next_def): Rename to...
+	(def_lookup::first_def_of_next_group): ...this.
+	(def_lookup::matching_or_prev_def): Rename to...
+	(def_lookup::matching_set_or_last_def_of_prev_group): ...this.
+	(def_lookup::matching_or_next_def): Rename to...
+	(def_lookup::matching_set_or_first_def_of_next_group): ...this.
+	* rtl-ssa/movement.h (restrict_movement_for_dead_range): Update after
+	above renaming.
+	* rtl-ssa/accesses.cc (clobber_group::prev_clobber): New function.
+	(clobber_group::next_clobber): Likewise.
+	(def_lookup::prev_def): Likewise.
+	(def_lookup::next_def): Likewise.
+	(function_info::make_use_available): Pass the lookup insn to
+	def_lookup::prev_def and def_lookup::next_def.
+
+2022-06-24  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-24  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* config/tilepro/gen-mul-tables.cc (tilegx_emit): Adjust loop
+	condition to avoid overflow.
+
+2022-06-23  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2022-06-23  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/105600
+	* ipa-icf.c (sem_item_optimizer::filter_removed_items):
+	Skip variables with body_removed.
+
+2022-06-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-06-17  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/105209
+	* config/alpha/alpha-protos.h (alpha_store_data_bypass_p): New.
+	* config/alpha/alpha.c (alpha_store_data_bypass_p): New function.
+	(alpha_store_data_bypass_p_1): Ditto.
+	* config/alpha/ev4.md: Use alpha_store_data_bypass_p instead
+	of generic store_data_bypass_p.
+	(ev4_ist_c): Remove insn reservation.
+
+2022-06-20  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-03-12  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/104829
+	* config/rs6000/rs6000.c (rs6000_machine_from_flags): Don't output
+	"ppc" and "ppc64" based on rs6000_cpu.
+
+2022-06-20  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-03-04  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/rs6000.c (rs6000_machine_from_flags): Restructure a
+	bit.  Handle most older CPUs.
+
+2022-06-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-06-17  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/105970
+	* config/i386/i386.c (ix86_function_arg): Assert that
+	the mode of pointer argumet is equal to ptr_mode, not Pmode.
+
+2022-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/105998
+	* varasm.c (narrowing_initializer_constant_valid_p): Check
+	SCALAR_INT_MODE_P instead of INTEGRAL_MODE_P, also break on
+	! INTEGRAL_TYPE_P and do the same check also on op{0,1}'s type.
+
+2022-06-20  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2022-06-14  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/105739
+	* ipa-prop.c (ipa_load_from_parm_agg): Punt on volatile loads.
+
+2022-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105729
+	* fold-const.c (fold_unary_loc): Don't optimize (X &) ((Y *) z + w)
+	to (X &) z + w if -fsanitize=null during GENERIC folding.
+
+2022-06-16  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backported from master:
+	2022-06-15  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/105981
+	* config/arm/arm.c (gen_cpymem_ldrd_strd): Rename low_reg and hi_reg
+	to first_reg and second_reg respectively.  Initialize them correctly
+	when generating big-endian code.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* common.opt (static-libphobos): Add option.
+	* config/darwin.h (LINK_SPEC): Substitute -lgphobos with libgphobos.a
+	when linking statically.
+	* gcc.c (driver_handle_option): Set -static-libphobos as always valid.
+
+2022-06-15  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105726
+	* gimple-ssa-warn-restrict.c (builtin_memref::set_base_and_offset):
+	Constrain array-of-flexarray case more.
+
+2022-06-14  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/104637
+	* lra-assigns.c (lra_split_hard_reg_for): Split hard regs as many
+	as possible on one subpass.
+
+2022-06-14  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-06-13  H.J. Lu  <hjl.tools@gmail.com>
+
+	* common/config/i386/cpuinfo.h (get_available_features): Require
+	AVX for F16C and VAES.
+
+2022-06-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backported from master:
+	2022-06-08  Max Filippov  <jcmvbkbc@gmail.com>
+
+	PR target/105879
+	* config/xtensa/xtensa.md (movdi): Rename 'first' and 'second'
+	to 'lowpart' and 'highpart' so that they match 'gen_lowpart' and
+	'gen_highpart' bitwise semantics and fix order of highpart and
+	lowpart depending on target endianness.
+
+2022-06-08  liuhongt  <hongtao.liu@intel.com>
+
+	PR target/105854
+	* config/i386/sse.md (ssse3_palignrdi): Change alternative 2
+	from Yv to Yw.
+
+2022-06-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105437
+	* tree-vect-slp.c (vect_schedule_slp_node): Handle the
+	case where last_stmt alters control flow.
+
+2022-05-26  Simon Cook  <simon.cook@embecosm.com>
+
+	Backported from master:
+	2022-05-25  Simon Cook  <simon.cook@embecosm.com>
+
+	* config/riscv/arch-canonicalize: Only add mafd extension if
+	base was rv32/rv64g.
+
+2022-05-26  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backported from master:
+	2022-05-09  Kito Cheng  <kito.cheng@sifive.com>
+
+	* config/riscv/arch-canonicalize: Handle g correctly.
+
+2022-05-24  Qing Zhao  <qing.zhao@oracle.com>
+
+	Backported from master:
+	2022-05-09  Qing Zhao  <qing.zhao@oracle.com>
+
+	PR target/101891
+	* config/i386/i386.c (zero_call_used_regno_mode): use V2SImode
+	as a generic MMX mode instead of V4HImode.
+	(zero_all_mm_registers): Use SET to zero instead of MOV for
+	zeroing scratch registers.
+	(ix86_zero_call_used_regs): Likewise.
+
+2022-05-23  Paul A. Clarke  <pc@us.ibm.com>
+
+	PR target/104257
+	* config/rs6000/bmi2intrin.h: Uglify local variables.
+	* config/rs6000/emmintrin.h: Likewise.
+	* config/rs6000/mm_malloc.h: Likewise.
+	* config/rs6000/mmintrin.h: Likewise.
+	* config/rs6000/pmmintrin.h: Likewise.
+	* config/rs6000/smmintrin.h: Likewise.
+	* config/rs6000/tmmintrin.h: Likewise.
+	* config/rs6000/xmmintrin.h: Likewise.
+
+2022-05-19  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2022-05-06  Michael Meissner  <meissner@linux.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/102059
+	* config/rs6000/rs6000.c (rs6000_can_inline_p): Ignore -mpower8-fusion
+	and -mpower10-fusion options for inlining purposes.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-11  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/105559
+	* cfgrtl.c (delete_insn_and_edges): Only perform search to BB_END
+	for non-debug insns.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105431
+	* tree-ssa-math-opts.c (powi_as_mults_1): Make n unsigned.
+	(powi_as_mults): Use absu_hwi.
+	(gimple_expand_builtin_powi): Remove now pointless n != -n
+	check.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105368
+	* tree-ssa-math-opts.c (powi_cost): Use absu_hwi.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-20  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105312
+	* gimple-isel.cc (gimple_expand_vec_cond_expr): Query both
+	VCOND and VCONDU for EQ and NE.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105263
+	* tree-ssa-reassoc.c (try_special_add_to_ops): Do not consume
+	negates in multiplication chains with DFP.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105173
+	* tree-ssa-reassoc.c (find_insert_point): Get extra
+	insert_before output argument and compute it.
+	(insert_stmt_before_use): Adjust.
+	(rewrite_expr_tree): Likewise.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105163
+	* tree-ssa-reassoc.c (repropagate_negates): Avoid propagating
+	negated abnormals.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105148
+	* tree-ssa-loop-ivopts.c (idx_record_use): Walk raw operands
+	2 and 3 of ARRAY_REFs.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105250
+	* fold-const.c (fold_convertible_p): Revert
+	r12-7979-geaaf77dd85c333, instead check for size equality
+	of the vector types involved.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105140
+	* fold-const.c (fold_convertible_p): Allow a TYPE_P arg.
+
+2022-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-04-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/100413
+	* cgraph.c (cgraph_node::remove): Release body of the node this
+	is clone_of if appropriate.
+
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* config/aarch64/aarch64-protos.h (atomic_ool_names): Increase dimension
+	of str array.
+	* config/aarch64/aarch64.c (aarch64_atomic_ool_func): Call
+	memmodel_from_int and handle MEMMODEL_SYNC_*.
+	(DEF0): Add __aarch64_*_sync functions.
+
+2022-05-16  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2021-11-10  Jan Hubicka  <jh@suse.cz>
+
+	* ipa-modref-tree.h (modref_tree::remap_params): Fix off-by-one error.
+
+2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/105528
+	* gimple-isel.cc (gimple_expand_vec_set_expr): After gsi_remove
+	set *gsi to gsi_for_stmt (ass_stmt).  Fix up function comment.
+
+2022-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/105292
+	* config/sparc/sparc.c (sparc_vectorize_vec_perm_const): Return
+	true only for 8-byte vector modes.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105331
+	* config/i386/i386.c (ix86_gimplify_va_arg): Mark va_arg_tmp
+	temporary TREE_ADDRESSABLE before trying to gimplify ADDR_EXPR
+	of it.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105396
+	* asan.c (asan_redzone_buffer::emit_redzone_byte): Handle the case
+	where offset is bigger than off but smaller than m_prev_offset + 32
+	bits by pushing one or more 0 bytes.  Sink the
+	m_shadow_bytes.safe_push (value); flush_if_full (); statements from
+	all cases to the end of the function.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/105333
+	* rtlanal.c (replace_rtx): Use simplify_subreg or
+	simplify_unary_operation if CONST_SCALAR_INT_P rather than just
+	CONST_INT_P.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* config/i386/avx512fintrin.h (_mm512_scalef_round_pd):
+	Add parentheses for parameters and djust format.
+	(_mm512_mask_scalef_round_pd): Ditto.
+	(_mm512_maskz_scalef_round_pd): Ditto.
+	(_mm512_scalef_round_ps): Ditto.
+	(_mm512_mask_scalef_round_ps): Ditto.
+	(_mm512_maskz_scalef_round_ps): Ditto.
+	(_mm_scalef_round_sd): Use _mm_undefined_pd.
+	(_mm_scalef_round_ss): Use _mm_undefined_ps.
+	(_mm_mask_scalef_round_sd): New macro.
+	(_mm_mask_scalef_round_ss): Ditto.
+	(_mm_maskz_scalef_round_sd): Ditto.
+	(_mm_maskz_scalef_round_ss): Ditto.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* config/sparc/sparc.c (epilogue_renumber): If ORIGINAL_REGNO,
+	use gen_raw_REG instead of gen_rtx_REG and copy over also
+	ORIGINAL_REGNO.  Use return 0; instead of /* fallthrough */.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/105203
+	* emit-rtl.c (emit_copy_of_insn_after): Don't call mark_jump_label
+	on DEBUG_INSNs.
+
+2022-04-21  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-04-19  Sergei Trofimovich  <siarheit@google.com>
+
+	PR gcov-profile/105282
+	* value-prof.c (stream_out_histogram_value): Allow negative counts
+	on HIST_TYPE_INDIR_CALL.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 9c36606130e..e14eb1cdf63 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/alias.c b/gcc/alias.c
index 69e1eb89ac6..ba4aa4dc8d9 100644
--- a/gcc/alias.c
+++ b/gcc/alias.c
@@ -389,6 +389,20 @@ refs_same_for_tbaa_p (tree earlier, tree later)
 	  || alias_set_subset_of (later_base_set, earlier_base_set));
 }
 
+/* Similar to refs_same_for_tbaa_p() but for use on MEM rtxs.  */
+bool
+mems_same_for_tbaa_p (rtx earlier, rtx later)
+{
+  gcc_assert (MEM_P (earlier));
+  gcc_assert (MEM_P (later));
+
+  return ((MEM_ALIAS_SET (earlier) == MEM_ALIAS_SET (later)
+	   || alias_set_subset_of (MEM_ALIAS_SET (later),
+				   MEM_ALIAS_SET (earlier)))
+	  && (!MEM_EXPR (earlier)
+	      || refs_same_for_tbaa_p (MEM_EXPR (earlier), MEM_EXPR (later))));
+}
+
 /* Returns a pointer to the alias set entry for ALIAS_SET, if there is
    such an entry, or NULL otherwise.  */
 
diff --git a/gcc/alias.h b/gcc/alias.h
index f427698a8e1..f38da75e040 100644
--- a/gcc/alias.h
+++ b/gcc/alias.h
@@ -40,6 +40,7 @@ tree reference_alias_ptr_type_1 (tree *);
 bool alias_ptr_types_compatible_p (tree, tree);
 int compare_base_decls (tree, tree);
 bool refs_same_for_tbaa_p (tree, tree);
+bool mems_same_for_tbaa_p (rtx, rtx);
 
 /* This alias set can be used to force a memory to conflict with all
    other memories, creating a barrier across which no memory reference
diff --git a/gcc/analyzer/ChangeLog b/gcc/analyzer/ChangeLog
index 7ae3901445e..f3ca1866d56 100644
--- a/gcc/analyzer/ChangeLog
+++ b/gcc/analyzer/ChangeLog
@@ -1,3 +1,24 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105365
+	PR analyzer/105366
+	* svalue.cc
+	(cmp_cst): Rename to...
+	(cmp_csts_same_type): ...this.  Convert all recursive calls to
+	calls to...
+	(cmp_csts_and_types): ....this new function.
+	(svalue::cmp_ptr): Update for renaming of cmp_cst
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105252
+	* svalue.cc (cmp_cst): When comparing VECTOR_CSTs, compare the
+	types of the encoded elements before calling cmp_cst on them.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/analyzer/svalue.cc b/gcc/analyzer/svalue.cc
index a16563d912a..fa33e956d41 100644
--- a/gcc/analyzer/svalue.cc
+++ b/gcc/analyzer/svalue.cc
@@ -59,6 +59,8 @@ along with GCC; see the file COPYING3.  If not see
 
 namespace ana {
 
+static int cmp_csts_and_types (const_tree cst1, const_tree cst2);
+
 /* class svalue and its various subclasses.  */
 
 /* class svalue.  */
@@ -276,7 +278,7 @@ svalue::implicitly_live_p (const svalue_set *, const region_model *) const
    of the same type.  */
 
 static int
-cmp_cst (const_tree cst1, const_tree cst2)
+cmp_csts_same_type (const_tree cst1, const_tree cst2)
 {
   gcc_assert (TREE_TYPE (cst1) == TREE_TYPE (cst2));
   gcc_assert (TREE_CODE (cst1) == TREE_CODE (cst2));
@@ -295,9 +297,10 @@ cmp_cst (const_tree cst1, const_tree cst2)
 		     TREE_REAL_CST_PTR (cst2),
 		     sizeof (real_value));
     case COMPLEX_CST:
-      if (int cmp_real = cmp_cst (TREE_REALPART (cst1), TREE_REALPART (cst2)))
+      if (int cmp_real = cmp_csts_and_types (TREE_REALPART (cst1),
+					     TREE_REALPART (cst2)))
 	return cmp_real;
-      return cmp_cst (TREE_IMAGPART (cst1), TREE_IMAGPART (cst2));
+      return cmp_csts_and_types (TREE_IMAGPART (cst1), TREE_IMAGPART (cst2));
     case VECTOR_CST:
       if (int cmp_log2_npatterns
 	    = ((int)VECTOR_CST_LOG2_NPATTERNS (cst1)
@@ -309,13 +312,29 @@ cmp_cst (const_tree cst1, const_tree cst2)
 	return cmp_nelts_per_pattern;
       unsigned encoded_nelts = vector_cst_encoded_nelts (cst1);
       for (unsigned i = 0; i < encoded_nelts; i++)
-	if (int el_cmp = cmp_cst (VECTOR_CST_ENCODED_ELT (cst1, i),
-				  VECTOR_CST_ENCODED_ELT (cst2, i)))
-	  return el_cmp;
+	{
+	  const_tree elt1 = VECTOR_CST_ENCODED_ELT (cst1, i);
+	  const_tree elt2 = VECTOR_CST_ENCODED_ELT (cst2, i);
+	  if (int el_cmp = cmp_csts_and_types (elt1, elt2))
+	    return el_cmp;
+	}
       return 0;
     }
 }
 
+/* Comparator for imposing a deterministic order on constants that might
+   not be of the same type.  */
+
+static int
+cmp_csts_and_types (const_tree cst1, const_tree cst2)
+{
+  int t1 = TYPE_UID (TREE_TYPE (cst1));
+  int t2 = TYPE_UID (TREE_TYPE (cst2));
+  if (int cmp_type = t1 - t2)
+    return cmp_type;
+  return cmp_csts_same_type (cst1, cst2);
+}
+
 /* Comparator for imposing a deterministic order on svalues.  */
 
 int
@@ -347,7 +366,7 @@ svalue::cmp_ptr (const svalue *sval1, const svalue *sval2)
 	const constant_svalue *constant_sval2 = (const constant_svalue *)sval2;
 	const_tree cst1 = constant_sval1->get_constant ();
 	const_tree cst2 = constant_sval2->get_constant ();
-	return cmp_cst (cst1, cst2);
+	return cmp_csts_same_type (cst1, cst2);
       }
       break;
     case SK_UNKNOWN:
diff --git a/gcc/asan.c b/gcc/asan.c
index ca036767134..ca3020f463c 100644
--- a/gcc/asan.c
+++ b/gcc/asan.c
@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-inline.h"
 #include "tree-ssa.h"
 #include "tree-eh.h"
+#include "diagnostic-core.h"
 
 /* AddressSanitizer finds out-of-bounds and use-after-free bugs
    with <2x slowdown on average.
@@ -1497,10 +1498,14 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,
   HOST_WIDE_INT off
     = m_prev_offset + ASAN_SHADOW_GRANULARITY * m_shadow_bytes.length ();
   if (off == offset)
+    /* Consecutive shadow memory byte.  */;
+  else if (offset < m_prev_offset + (HOST_WIDE_INT) (ASAN_SHADOW_GRANULARITY
+						     * RZ_BUFFER_SIZE)
+	   && !m_shadow_bytes.is_empty ())
     {
-      /* Consecutive shadow memory byte.  */
-      m_shadow_bytes.safe_push (value);
-      flush_if_full ();
+      /* Shadow memory byte with a small gap.  */
+      for (; off < offset; off += ASAN_SHADOW_GRANULARITY)
+	m_shadow_bytes.safe_push (0);
     }
   else
     {
@@ -1521,9 +1526,9 @@ asan_redzone_buffer::emit_redzone_byte (HOST_WIDE_INT offset,
       m_shadow_mem = adjust_address (m_shadow_mem, VOIDmode,
 				     diff >> ASAN_SHADOW_SHIFT);
       m_prev_offset = offset;
-      m_shadow_bytes.safe_push (value);
-      flush_if_full ();
     }
+  m_shadow_bytes.safe_push (value);
+  flush_if_full ();
 }
 
 /* Emit RTX emission of the content of the buffer.  */
@@ -1801,6 +1806,11 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,
   tree str_cst, decl, id;
   int use_after_return_class = -1;
 
+  /* Don't emit anything when doing error recovery, the assertions
+     might fail e.g. if a function had a frame offset overflow.  */
+  if (seen_error ())
+    return NULL;
+
   if (shadow_ptr_types[0] == NULL_TREE)
     asan_init_shadow_ptr_types ();
 
diff --git a/gcc/bb-reorder.c b/gcc/bb-reorder.c
index 58d585d8466..cde14eb3244 100644
--- a/gcc/bb-reorder.c
+++ b/gcc/bb-reorder.c
@@ -1998,6 +1998,7 @@ fix_up_fall_thru_edges (void)
 		     becomes EDGE_CROSSING.  */
 
 		  fall_thru->flags &= ~EDGE_CROSSING;
+		  unsigned old_count = EDGE_COUNT (cur_bb->succs);
 		  basic_block new_bb = force_nonfallthru (fall_thru);
 
 		  if (new_bb)
@@ -2009,7 +2010,25 @@ fix_up_fall_thru_edges (void)
 		      gcc_assert (BB_PARTITION (new_bb)
                                   == BB_PARTITION (cur_bb));
 
-		      single_succ_edge (new_bb)->flags |= EDGE_CROSSING;
+		      edge e = single_succ_edge (new_bb);
+		      e->flags |= EDGE_CROSSING;
+		      if (EDGE_COUNT (cur_bb->succs) > old_count)
+			{
+			  /* If asm goto has a crossing fallthrough edge
+			     and at least one of the labels to the same bb,
+			     force_nonfallthru can result in the fallthrough
+			     edge being redirected and a new edge added for the
+			     label or more labels to e->dest.  As we've
+			     temporarily cleared EDGE_CROSSING flag on the
+			     fallthrough edge, we need to restore it again.
+			     See PR108596.  */
+			  rtx_insn *j = BB_END (cur_bb);
+			  gcc_checking_assert (JUMP_P (j)
+					       && asm_noperands (PATTERN (j)));
+			  edge e2 = find_edge (cur_bb, e->dest);
+			  if (e2)
+			    e2->flags |= EDGE_CROSSING;
+			}
 		    }
 		  else
 		    {
diff --git a/gcc/brig/ChangeLog b/gcc/brig/ChangeLog
index 840215c790b..77ce0c04a78 100644
--- a/gcc/brig/ChangeLog
+++ b/gcc/brig/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/builtins.c b/gcc/builtins.c
index 64f4999ab07..627a89b3c45 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -2110,7 +2110,7 @@ expand_builtin_prefetch (tree exp)
 static rtx
 get_memory_rtx (tree exp, tree len)
 {
-  tree orig_exp = exp;
+  tree orig_exp = exp, base;
   rtx addr, mem;
 
   /* When EXP is not resolved SAVE_EXPR, MEM_ATTRS can be still derived
@@ -2141,10 +2141,11 @@ get_memory_rtx (tree exp, tree len)
   if (is_gimple_mem_ref_addr (TREE_OPERAND (exp, 0)))
     set_mem_attributes (mem, exp, 0);
   else if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR
-	   && (exp = get_base_address (TREE_OPERAND (TREE_OPERAND (exp, 0),
-						     0))))
+	   && (base = get_base_address (TREE_OPERAND (TREE_OPERAND (exp, 0),
+						      0))))
     {
-      exp = build_fold_addr_expr (exp);
+      unsigned int align = get_pointer_alignment (TREE_OPERAND (exp, 0));
+      exp = build_fold_addr_expr (base);
       exp = fold_build2 (MEM_REF,
 			 build_array_type (char_type_node,
 					   build_range_type (sizetype,
@@ -2152,6 +2153,10 @@ get_memory_rtx (tree exp, tree len)
 							     NULL)),
 			 exp, build_int_cst (ptr_type_node, 0));
       set_mem_attributes (mem, exp, 0);
+      /* Since we stripped parts make sure the offset is unknown and the
+	 alignment is computed from the original address.  */
+      clear_mem_offset (mem);
+      set_mem_align (mem, align);
     }
   set_mem_alias_set (mem, 0);
   return mem;
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index dff48ba4655..d781d0f18ca 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,65 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/109151
+	* c-ubsan.c (ubsan_instrument_division): Handle all scalar integral
+	types rather than just INTEGER_TYPE.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107465
+	* c-warn.c (warn_for_sign_compare): Don't warn for unset bits
+	above innermost zero extension of BIT_NOT_EXPR result.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107465
+	* c-warn.c (warn_for_sign_compare): If c_common_get_narrower
+	doesn't return a narrower result, use TYPE_UNSIGNED to set unsignedp0
+	and unsignedp1.  For the one BIT_NOT_EXPR case vs. one without,
+	only check for constant in the non-BIT_NOT_EXPR operand, use std::swap
+	to simplify the code, only warn if BIT_NOT_EXPR operand is extended
+	from narrower unsigned, fix up computation of mask for the constant
+	cases and for unsigned other operand case handle differently
+	BIT_NOT_EXPR result being sign vs. zero extended.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-23  Andrew Pinski  <apinski@marvell.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107127
+	* c-gimplify.c (c_genericize): Use walk_tree_without_duplicates
+	instead of walk_tree for c_genericize_control_r.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/107163
+	* c-common.c (verify_tree): Don't use sequenced handling
+	for COMPONENT_REF.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105304
+	* c-common.c (verify_tree) [restart]: Move up to before the
+	NULL test.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 7b8f49d78dc..9417b7fb4d1 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -1854,12 +1854,12 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,
   enum tree_code code;
   enum tree_code_class cl;
 
+ restart:
   /* X may be NULL if it is the operand of an empty statement expression
      ({ }).  */
   if (x == NULL)
     return;
 
- restart:
   code = TREE_CODE (x);
   cl = TREE_CODE_CLASS (code);
 
@@ -2023,12 +2023,17 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,
 
     case LSHIFT_EXPR:
     case RSHIFT_EXPR:
-    case COMPONENT_REF:
     case ARRAY_REF:
       if (cxx_dialect >= cxx17)
 	goto sequenced_binary;
       goto do_default;
 
+    case COMPONENT_REF:
+      /* Treat as unary, the other operands aren't evaluated.  */
+      x = TREE_OPERAND (x, 0);
+      writer = 0;
+      goto restart;
+
     default:
     do_default:
       /* For other expressions, simply recurse on their operands.
diff --git a/gcc/c-family/c-gimplify.c b/gcc/c-family/c-gimplify.c
index 39c969d8f40..10a971001c4 100644
--- a/gcc/c-family/c-gimplify.c
+++ b/gcc/c-family/c-gimplify.c
@@ -570,8 +570,8 @@ c_genericize (tree fndecl)
       bc_state_t save_state;
       push_cfun (DECL_STRUCT_FUNCTION (fndecl));
       save_bc_state (&save_state);
-      walk_tree (&DECL_SAVED_TREE (fndecl), c_genericize_control_r,
-		 NULL, NULL);
+      walk_tree_without_duplicates (&DECL_SAVED_TREE (fndecl),
+				    c_genericize_control_r, NULL);
       restore_bc_state (&save_state);
       pop_cfun ();
     }
diff --git a/gcc/c-family/c-ubsan.c b/gcc/c-family/c-ubsan.c
index e771da108ee..43a45218574 100644
--- a/gcc/c-family/c-ubsan.c
+++ b/gcc/c-family/c-ubsan.c
@@ -53,7 +53,7 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)
   op0 = unshare_expr (op0);
   op1 = unshare_expr (op1);
 
-  if (TREE_CODE (type) == INTEGER_TYPE
+  if (INTEGRAL_TYPE_P (type)
       && sanitize_flags_p (SANITIZE_DIVIDE))
     t = fold_build2 (EQ_EXPR, boolean_type_node,
 		     op1, build_int_cst (type, 0));
@@ -68,7 +68,7 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)
     return NULL_TREE;
 
   /* We check INT_MIN / -1 only for signed types.  */
-  if (TREE_CODE (type) == INTEGER_TYPE
+  if (INTEGRAL_TYPE_P (type)
       && sanitize_flags_p (SANITIZE_DIVIDE)
       && !TYPE_UNSIGNED (type))
     {
diff --git a/gcc/c-family/c-warn.c b/gcc/c-family/c-warn.c
index ac9a64108ec..3b85dd1aff8 100644
--- a/gcc/c-family/c-warn.c
+++ b/gcc/c-family/c-warn.c
@@ -2330,42 +2330,63 @@ warn_for_sign_compare (location_t location,
      have all bits set that are set in the ~ operand when it is
      extended.  */
 
-  op0 = c_common_get_narrower (op0, &unsignedp0);
-  op1 = c_common_get_narrower (op1, &unsignedp1);
+  /* bits0 is the bit index of op0 extended to result_type, which will
+     be always 0 and so all bits above it.  If there is a BIT_NOT_EXPR
+     in that operand possibly sign or zero extended to op0 and then
+     possibly further sign or zero extended to result_type, bits0 will
+     be the precision of result type if all the extensions involved
+     if any are sign extensions, and will be the place of the innermost
+     zero extension otherwise.  We warn only if BIT_NOT_EXPR's operand is
+     zero extended from some even smaller precision, in that case after
+     BIT_NOT_EXPR some bits below bits0 will be guaranteed to be set.
+     Similarly for bits1.  */
+  int bits0 = TYPE_PRECISION (result_type);
+  if (TYPE_UNSIGNED (TREE_TYPE (op0)))
+    bits0 = TYPE_PRECISION (TREE_TYPE (op0));
+  tree arg0 = c_common_get_narrower (op0, &unsignedp0);
+  if (TYPE_PRECISION (TREE_TYPE (arg0)) == TYPE_PRECISION (TREE_TYPE (op0)))
+    unsignedp0 = TYPE_UNSIGNED (TREE_TYPE (op0));
+  else if (unsignedp0)
+    bits0 = TYPE_PRECISION (TREE_TYPE (arg0));
+  op0 = arg0;
+  int bits1 = TYPE_PRECISION (result_type);
+  if (TYPE_UNSIGNED (TREE_TYPE (op1)))
+    bits1 = TYPE_PRECISION (TREE_TYPE (op1));
+  tree arg1 = c_common_get_narrower (op1, &unsignedp1);
+  if (TYPE_PRECISION (TREE_TYPE (arg1)) == TYPE_PRECISION (TREE_TYPE (op1)))
+    unsignedp1 = TYPE_UNSIGNED (TREE_TYPE (op1));
+  else if (unsignedp1)
+    bits1 = TYPE_PRECISION (TREE_TYPE (arg1));
+  op1 = arg1;
 
   if ((TREE_CODE (op0) == BIT_NOT_EXPR)
       ^ (TREE_CODE (op1) == BIT_NOT_EXPR))
     {
-      if (TREE_CODE (op0) == BIT_NOT_EXPR)
-	op0 = c_common_get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);
       if (TREE_CODE (op1) == BIT_NOT_EXPR)
-	op1 = c_common_get_narrower (TREE_OPERAND (op1, 0), &unsignedp1);
-
-      if (tree_fits_shwi_p (op0) || tree_fits_shwi_p (op1))
 	{
-	  tree primop;
-	  HOST_WIDE_INT constant, mask;
-	  int unsignedp;
-	  unsigned int bits;
+	  std::swap (op0, op1);
+	  std::swap (unsignedp0, unsignedp1);
+	  std::swap (bits0, bits1);
+	}
 
-	  if (tree_fits_shwi_p (op0))
-	    {
-	      primop = op1;
-	      unsignedp = unsignedp1;
-	      constant = tree_to_shwi (op0);
-	    }
-	  else
-	    {
-	      primop = op0;
-	      unsignedp = unsignedp0;
-	      constant = tree_to_shwi (op1);
-	    }
+      int unsignedp;
+      arg0 = c_common_get_narrower (TREE_OPERAND (op0, 0), &unsignedp);
 
-	  bits = TYPE_PRECISION (TREE_TYPE (primop));
-	  if (bits < TYPE_PRECISION (result_type)
-	      && bits < HOST_BITS_PER_LONG && unsignedp)
+      /* For these warnings, we need BIT_NOT_EXPR operand to be
+	 zero extended from narrower type to BIT_NOT_EXPR's type.
+	 In that case, all those bits above the narrower's type
+	 are after BIT_NOT_EXPR set to 1.  */
+      if (tree_fits_shwi_p (op1))
+	{
+	  HOST_WIDE_INT constant = tree_to_shwi (op1);
+	  unsigned int bits = TYPE_PRECISION (TREE_TYPE (arg0));
+	  if (unsignedp
+	      && bits < TYPE_PRECISION (TREE_TYPE (op0))
+	      && bits < HOST_BITS_PER_WIDE_INT)
 	    {
-	      mask = HOST_WIDE_INT_M1U << bits;
+	      HOST_WIDE_INT mask = HOST_WIDE_INT_M1U << bits;
+	      if (bits0 < HOST_BITS_PER_WIDE_INT)
+		mask &= ~(HOST_WIDE_INT_M1U << bits0);
 	      if ((mask & constant) != mask)
 		{
 		  if (constant == 0)
@@ -2379,11 +2400,11 @@ warn_for_sign_compare (location_t location,
 		}
 	    }
 	}
-      else if (unsignedp0 && unsignedp1
-	       && (TYPE_PRECISION (TREE_TYPE (op0))
-		   < TYPE_PRECISION (result_type))
-	       && (TYPE_PRECISION (TREE_TYPE (op1))
-		   < TYPE_PRECISION (result_type)))
+      else if ((TYPE_PRECISION (TREE_TYPE (arg0))
+		< TYPE_PRECISION (TREE_TYPE (op0)))
+	       && unsignedp
+	       && unsignedp1
+	       && TYPE_PRECISION (TREE_TYPE (op1)) < bits0)
 	warning_at (location, OPT_Wsign_compare,
 		    "comparison of promoted bitwise complement "
 		    "of an unsigned value with unsigned");
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
index 8d0dffcaa10..c6a2e86aa3f 100644
--- a/gcc/c/ChangeLog
+++ b/gcc/c/ChangeLog
@@ -1,3 +1,35 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/107358
+	* c-typeck.c (build_binary_op): Pass operands before excess precision
+	promotions to scalar_to_vector call.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/106981
+	* c-typeck.c (c_tree_equal): Only strip NON_LVALUE_EXPRs at the
+	start.  For CONSTANT_CLASS_P or CASE_CONVERT: return false if t1 and
+	t2 have different types.
+
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* c-parser.c (c_parser_pragma): Set input_location to the
+	location of the pragma, rather than the start of the line.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index 7690977f6b8..407c22afa6f 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -12289,6 +12289,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)
   unsigned int id;
   const char *construct = NULL;
 
+  input_location = c_parser_peek_token (parser)->location;
   id = c_parser_peek_token (parser)->pragma_kind;
   gcc_assert (id != PRAGMA_NONE);
 
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index a0fbe47d87f..84b44081f0e 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -11764,8 +11764,8 @@ build_binary_op (location_t location, enum tree_code code,
   if ((gnu_vector_type_p (type0) && code1 != VECTOR_TYPE)
       || (gnu_vector_type_p (type1) && code0 != VECTOR_TYPE))
     {
-      enum stv_conv convert_flag = scalar_to_vector (location, code, op0, op1,
-						     true);
+      enum stv_conv convert_flag = scalar_to_vector (location, code, orig_op0,
+						     orig_op1, true);
 
       switch (convert_flag)
 	{
@@ -15562,14 +15562,10 @@ c_tree_equal (tree t1, tree t2)
   if (!t1 || !t2)
     return false;
 
-  for (code1 = TREE_CODE (t1);
-       CONVERT_EXPR_CODE_P (code1)
-	 || code1 == NON_LVALUE_EXPR;
+  for (code1 = TREE_CODE (t1); code1 == NON_LVALUE_EXPR;
        code1 = TREE_CODE (t1))
     t1 = TREE_OPERAND (t1, 0);
-  for (code2 = TREE_CODE (t2);
-       CONVERT_EXPR_CODE_P (code2)
-	 || code2 == NON_LVALUE_EXPR;
+  for (code2 = TREE_CODE (t2); code2 == NON_LVALUE_EXPR;
        code2 = TREE_CODE (t2))
     t2 = TREE_OPERAND (t2, 0);
 
@@ -15580,6 +15576,9 @@ c_tree_equal (tree t1, tree t2)
   if (code1 != code2)
     return false;
 
+  if (CONSTANT_CLASS_P (t1) && !comptypes (TREE_TYPE (t1), TREE_TYPE (t2)))
+    return false;
+
   switch (code1)
     {
     case INTEGER_CST:
@@ -15699,6 +15698,11 @@ c_tree_equal (tree t1, tree t2)
 	return true;
       }
 
+    CASE_CONVERT:
+      if (!comptypes (TREE_TYPE (t1), TREE_TYPE (t2)))
+	return false;
+      break;
+
     default:
       break;
     }
diff --git a/gcc/cfgbuild.c b/gcc/cfgbuild.c
index 41654ec8ed6..8d122ceae59 100644
--- a/gcc/cfgbuild.c
+++ b/gcc/cfgbuild.c
@@ -445,6 +445,7 @@ find_bb_boundaries (basic_block bb)
   rtx_insn *debug_insn = NULL;
   edge fallthru = NULL;
   bool skip_purge;
+  bool seen_note_after_debug = false;
 
   if (insn == end)
     return;
@@ -492,7 +493,10 @@ find_bb_boundaries (basic_block bb)
       if (code == DEBUG_INSN)
 	{
 	  if (flow_transfer_insn && !debug_insn)
-	    debug_insn = insn;
+	    {
+	      debug_insn = insn;
+	      seen_note_after_debug = false;
+	    }
 	}
       /* In case we've previously seen an insn that effects a control
 	 flow transfer, split the block.  */
@@ -506,7 +510,40 @@ find_bb_boundaries (basic_block bb)
 	     insn instead of before the non-debug insn, so that the debug
 	     insns are not lost.  */
 	  if (debug_insn && code != CODE_LABEL && code != BARRIER)
-	    prev = PREV_INSN (debug_insn);
+	    {
+	      prev = PREV_INSN (debug_insn);
+	      if (seen_note_after_debug)
+		{
+		  /* Though, if there are NOTEs intermixed with DEBUG_INSNs,
+		     move the NOTEs before the DEBUG_INSNs and split after
+		     the last NOTE.  */
+		  rtx_insn *first = NULL, *last = NULL;
+		  for (x = debug_insn; x != insn; x = NEXT_INSN (x))
+		    {
+		      if (NOTE_P (x))
+			{
+			  if (first == NULL)
+			    first = x;
+			  last = x;
+			}
+		      else
+			{
+			  gcc_assert (DEBUG_INSN_P (x));
+			  if (first)
+			    {
+			      reorder_insns_nobb (first, last, prev);
+			      prev = last;
+			      first = last = NULL;
+			    }
+			}
+		    }
+		  if (first)
+		    {
+		      reorder_insns_nobb (first, last, prev);
+		      prev = last;
+		    }
+		}
+	    }
 	  fallthru = split_block (bb, prev);
 	  if (flow_transfer_insn)
 	    {
@@ -547,6 +584,14 @@ find_bb_boundaries (basic_block bb)
 	    flow_transfer_insn = prev_nonnote_nondebug_insn_bb (insn);
 	  debug_insn = NULL;
 	}
+      else if (debug_insn)
+	{
+	  if (code == NOTE)
+	    seen_note_after_debug = true;
+	  else
+	    /* Jump tables.  */
+	    debug_insn = NULL;
+	}
 
       if (control_flow_insn_p (insn))
 	flow_transfer_insn = insn;
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
index 4086b647585..06586ddf083 100644
--- a/gcc/cfgcleanup.c
+++ b/gcc/cfgcleanup.c
@@ -208,7 +208,7 @@ mark_effect (rtx exp, regset nonequal)
       return false;
 
     case SET:
-      if (rtx_equal_for_cselib_p (SET_DEST (exp), SET_SRC (exp)))
+      if (cselib_redundant_set_p (exp))
 	return false;
       dest = SET_DEST (exp);
       if (dest == pc_rtx)
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index 3c1fe867bd3..a607ad50d2b 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -5356,6 +5356,10 @@ expand_debug_expr (tree exp)
     case VEC_WIDEN_MULT_ODD_EXPR:
     case VEC_WIDEN_LSHIFT_HI_EXPR:
     case VEC_WIDEN_LSHIFT_LO_EXPR:
+    case VEC_WIDEN_PLUS_HI_EXPR:
+    case VEC_WIDEN_PLUS_LO_EXPR:
+    case VEC_WIDEN_MINUS_HI_EXPR:
+    case VEC_WIDEN_MINUS_LO_EXPR:
     case VEC_PERM_EXPR:
     case VEC_DUPLICATE_EXPR:
     case VEC_SERIES_EXPR:
@@ -5392,6 +5396,8 @@ expand_debug_expr (tree exp)
     case WIDEN_MULT_EXPR:
     case WIDEN_MULT_PLUS_EXPR:
     case WIDEN_MULT_MINUS_EXPR:
+    case WIDEN_PLUS_EXPR:
+    case WIDEN_MINUS_EXPR:
       if (SCALAR_INT_MODE_P (GET_MODE (op0))
 	  && SCALAR_INT_MODE_P (mode))
 	{
@@ -5404,6 +5410,10 @@ expand_debug_expr (tree exp)
 	    op1 = simplify_gen_unary (ZERO_EXTEND, mode, op1, inner_mode);
 	  else
 	    op1 = simplify_gen_unary (SIGN_EXTEND, mode, op1, inner_mode);
+	  if (TREE_CODE (exp) == WIDEN_PLUS_EXPR)
+	    return simplify_gen_binary (PLUS, mode, op0, op1);
+	  else if (TREE_CODE (exp) == WIDEN_MINUS_EXPR)
+	    return simplify_gen_binary (MINUS, mode, op0, op1);
 	  op0 = simplify_gen_binary (MULT, mode, op0, op1);
 	  if (TREE_CODE (exp) == WIDEN_MULT_EXPR)
 	    return op0;
diff --git a/gcc/cfgrtl.c b/gcc/cfgrtl.c
index 8fd128b471c..4fb145ee4c4 100644
--- a/gcc/cfgrtl.c
+++ b/gcc/cfgrtl.c
@@ -233,7 +233,7 @@ delete_insn_and_edges (rtx_insn *insn)
 {
   bool purge = false;
 
-  if (INSN_P (insn) && BLOCK_FOR_INSN (insn))
+  if (NONDEBUG_INSN_P (insn) && BLOCK_FOR_INSN (insn))
     {
       basic_block bb = BLOCK_FOR_INSN (insn);
       if (BB_END (bb) == insn)
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index d7c78d518bc..6e523e14e05 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -1906,7 +1906,21 @@ cgraph_node::remove (void)
   if (prev_sibling_clone)
     prev_sibling_clone->next_sibling_clone = next_sibling_clone;
   else if (clone_of)
-    clone_of->clones = next_sibling_clone;
+    {
+      clone_of->clones = next_sibling_clone;
+      if (!clones)
+	{
+	  bool need_body = false;
+	  for (cgraph_node *n = clone_of; n; n = n->clone_of)
+	    if (n->analyzed || n->clones)
+	      {
+		need_body = true;
+		break;
+	      }
+	  if (!need_body)
+	    clone_of->release_body ();
+	}
+    }
   if (next_sibling_clone)
     next_sibling_clone->prev_sibling_clone = prev_sibling_clone;
   if (clones)
diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
index 9f86463b42d..f4b0c484e94 100644
--- a/gcc/cgraphclones.c
+++ b/gcc/cgraphclones.c
@@ -217,7 +217,17 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)
       body_adj.modify_formal_parameters ();
     }
   else
-    new_decl = copy_node (thunk->decl);
+    {
+      new_decl = copy_node (thunk->decl);
+      for (tree *arg = &DECL_ARGUMENTS (new_decl);
+	   *arg; arg = &DECL_CHAIN (*arg))
+	{
+	  tree next = DECL_CHAIN (*arg);
+	  *arg = copy_node (*arg);
+	  DECL_CONTEXT (*arg) = new_decl;
+	  DECL_CHAIN (*arg) = next;
+	}
+    }
 
   gcc_checking_assert (!DECL_STRUCT_FUNCTION (new_decl));
   gcc_checking_assert (!DECL_INITIAL (new_decl));
diff --git a/gcc/cgraphunit.c b/gcc/cgraphunit.c
index 0b70e4d4fde..802b01d3b97 100644
--- a/gcc/cgraphunit.c
+++ b/gcc/cgraphunit.c
@@ -1749,7 +1749,7 @@ cgraph_node::assemble_thunks_and_aliases (void)
 	cgraph_node *thunk = e->caller;
 
 	e = e->next_caller;
-	expand_thunk (thunk, true, false);
+	expand_thunk (thunk, !rtl_dump_and_exit, false);
 	thunk->assemble_thunks_and_aliases ();
       }
     else
diff --git a/gcc/common.opt b/gcc/common.opt
index a75b44ee47e..4a3f09d9e1f 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -3446,6 +3446,10 @@ static-libgfortran
 Driver
 ; Documented for Fortran, but always accepted by driver.
 
+static-libphobos
+Driver
+; Documented for D, but always accepted by driver.
+
 static-libstdc++
 Driver
 
diff --git a/gcc/common/config/i386/cpuinfo.h b/gcc/common/config/i386/cpuinfo.h
index 58294b7d7ac..d42cdecdd26 100644
--- a/gcc/common/config/i386/cpuinfo.h
+++ b/gcc/common/config/i386/cpuinfo.h
@@ -606,8 +606,6 @@ get_available_features (struct __processor_model *cpu_model,
     set_feature (FEATURE_MOVBE);
   if (ecx & bit_AES)
     set_feature (FEATURE_AES);
-  if (ecx & bit_F16C)
-    set_feature (FEATURE_F16C);
   if (ecx & bit_RDRND)
     set_feature (FEATURE_RDRND);
   if (ecx & bit_XSAVE)
@@ -618,12 +616,16 @@ get_available_features (struct __processor_model *cpu_model,
 	set_feature (FEATURE_AVX);
       if (ecx & bit_FMA)
 	set_feature (FEATURE_FMA);
+      if (ecx & bit_F16C)
+	set_feature (FEATURE_F16C);
     }
 
   /* Get Advanced Features at level 7 (eax = 7, ecx = 0/1). */
   if (max_cpuid_level >= 7)
     {
-      __cpuid_count (7, 0, eax, ebx, ecx, edx);
+      unsigned int max_subleaf_level;
+
+      __cpuid_count (7, 0, max_subleaf_level, ebx, ecx, edx);
       if (ebx & bit_BMI)
 	set_feature (FEATURE_BMI);
       if (ebx & bit_SGX)
@@ -638,6 +640,8 @@ get_available_features (struct __processor_model *cpu_model,
 	    set_feature (FEATURE_AVX2);
 	  if (ecx & bit_VPCLMULQDQ)
 	    set_feature (FEATURE_VPCLMULQDQ);
+	  if (ecx & bit_VAES)
+	    set_feature (FEATURE_VAES);
 	}
       if (ebx & bit_BMI2)
 	set_feature (FEATURE_BMI2);
@@ -660,8 +664,6 @@ get_available_features (struct __processor_model *cpu_model,
 	set_feature (FEATURE_PKU);
       if (ecx & bit_RDPID)
 	set_feature (FEATURE_RDPID);
-      if (ecx & bit_VAES)
-	set_feature (FEATURE_VAES);
       if (ecx & bit_GFNI)
 	set_feature (FEATURE_GFNI);
       if (ecx & bit_MOVDIRI)
@@ -733,18 +735,21 @@ get_available_features (struct __processor_model *cpu_model,
 	    set_feature (FEATURE_AVX512VP2INTERSECT);
 	}
 
-      __cpuid_count (7, 1, eax, ebx, ecx, edx);
-      if (eax & bit_HRESET)
-	set_feature (FEATURE_HRESET);
-      if (avx_usable)
+      if (max_subleaf_level >= 1)
 	{
-	  if (eax & bit_AVXVNNI)
-	    set_feature (FEATURE_AVXVNNI);
-	}
-      if (avx512_usable)
-	{
-	  if (eax & bit_AVX512BF16)
-	    set_feature (FEATURE_AVX512BF16);
+	  __cpuid_count (7, 1, eax, ebx, ecx, edx);
+	  if (eax & bit_HRESET)
+	    set_feature (FEATURE_HRESET);
+	  if (avx_usable)
+	    {
+	      if (eax & bit_AVXVNNI)
+		set_feature (FEATURE_AVXVNNI);
+	    }
+	  if (avx512_usable)
+	    {
+	      if (eax & bit_AVX512BF16)
+		set_feature (FEATURE_AVX512BF16);
+	    }
 	}
     }
 
@@ -882,6 +887,10 @@ cpu_indicator_init (struct __processor_model *cpu_model,
   extended_model = (eax >> 12) & 0xf0;
   extended_family = (eax >> 20) & 0xff;
 
+  /* Find available features. */
+  get_available_features (cpu_model, cpu_model2, cpu_features2,
+			  ecx, edx);
+
   if (vendor == signature_INTEL_ebx)
     {
       /* Adjust model and family for Intel CPUS. */
@@ -896,9 +905,6 @@ cpu_indicator_init (struct __processor_model *cpu_model,
       cpu_model2->__cpu_family = family;
       cpu_model2->__cpu_model = model;
 
-      /* Find available features. */
-      get_available_features (cpu_model, cpu_model2, cpu_features2,
-			      ecx, edx);
       /* Get CPU type.  */
       get_intel_cpu (cpu_model, cpu_model2, cpu_features2);
       cpu_model->__cpu_vendor = VENDOR_INTEL;
@@ -915,9 +921,6 @@ cpu_indicator_init (struct __processor_model *cpu_model,
       cpu_model2->__cpu_family = family;
       cpu_model2->__cpu_model = model;
 
-      /* Find available features. */
-      get_available_features (cpu_model, cpu_model2, cpu_features2,
-			      ecx, edx);
       /* Get CPU type.  */
       get_amd_cpu (cpu_model, cpu_model2, cpu_features2);
       cpu_model->__cpu_vendor = VENDOR_AMD;
diff --git a/gcc/common/config/i386/i386-cpuinfo.h b/gcc/common/config/i386/i386-cpuinfo.h
index e68dd656046..102ee8a1218 100644
--- a/gcc/common/config/i386/i386-cpuinfo.h
+++ b/gcc/common/config/i386/i386-cpuinfo.h
@@ -33,8 +33,10 @@ enum processor_vendor
   VENDOR_CENTAUR,
   VENDOR_CYRIX,
   VENDOR_NSC,
-  BUILTIN_VENDOR_MAX = VENDOR_OTHER,
-  VENDOR_MAX
+
+  /* Maximum values must be at the end of this enum.  */
+  VENDOR_MAX,
+  BUILTIN_VENDOR_MAX = VENDOR_OTHER
 };
 
 /* Any new types or subtypes have to be inserted at the end. */
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 5636acc2270..bf809ef9545 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -699,6 +699,20 @@ case ${target} in
     macos_min=0
   fi
   def_ld64=85.2
+  # Tools hosted on earlier versions of Darwin constrained all object
+  # alignment to be 2^15 or smaller.  From Darwin11 (macOS 10.7) the
+  # alignment of non-common is allowed to be up to 2^28.  Note that the
+  # larger alignment is permitted when targeting 10.6 from 10.7 so that
+  # the constraint only need be applied per host (and only if the host
+  # is Darwin).
+  case ${host} in
+      *-*-darwin[4-9]* | *-*-darwin10*)
+          tm_defines="$tm_defines L2_MAX_OFILE_ALIGNMENT=15U"
+          ;;
+      *)
+          tm_defines="$tm_defines L2_MAX_OFILE_ALIGNMENT=28U"
+          ;;
+  esac
   case ${target} in
       # Darwin 4 to 19 correspond to macOS 10.0 to 10.15
       *-*-darwin[4-9]* | *-*-darwin1[0-9]*)
@@ -1872,7 +1886,7 @@ hppa[12]*-*-hpux11*)
 		dwarf2=no
 	fi
 	;;
-i[34567]86-*-darwin1[89]*)
+i[34567]86-*-darwin1[89]* | i[34567]86-*-darwin2*)
 	echo "Error: 32bit target is not supported after Darwin17" 1>&2
 	;;
 i[34567]86-*-darwin*)
@@ -1882,7 +1896,7 @@ i[34567]86-*-darwin*)
 	tmake_file="${tmake_file} ${cpu_type}/t-darwin32-biarch t-slibgcc"
 	tm_file="${tm_file} ${cpu_type}/darwin32-biarch.h"
 	;;
-x86_64-*-darwin1[89]* | x86_64-*-darwin2[01]*)
+x86_64-*-darwin1[89]* | x86_64-*-darwin2*)
 	# Only 64b from now
 	with_cpu=${with_cpu:-core2}
 	tmake_file="${tmake_file} t-slibgcc"
diff --git a/gcc/config/aarch64/aarch64-builtins.c b/gcc/config/aarch64/aarch64-builtins.c
index acdea2a0601..f9a8c0aa6a0 100644
--- a/gcc/config/aarch64/aarch64-builtins.c
+++ b/gcc/config/aarch64/aarch64-builtins.c
@@ -523,6 +523,12 @@ enum aarch64_builtins
   AARCH64_MEMTAG_BUILTIN_SET_TAG,
   AARCH64_MEMTAG_BUILTIN_GET_TAG,
   AARCH64_MEMTAG_BUILTIN_END,
+  AARCH64_REV16,
+  AARCH64_REV16L,
+  AARCH64_REV16LL,
+  AARCH64_RBIT,
+  AARCH64_RBITL,
+  AARCH64_RBITLL,
   AARCH64_BUILTIN_MAX
 };
 
@@ -1421,6 +1427,37 @@ aarch64_init_fpsr_fpcr_builtins (void)
 				   AARCH64_BUILTIN_SET_FPSR64);
 }
 
+static void
+aarch64_init_data_intrinsics (void)
+{
+  tree uint32_fntype = build_function_type_list (uint32_type_node,
+                                                uint32_type_node, NULL_TREE);
+  tree ulong_fntype = build_function_type_list (long_unsigned_type_node,
+						long_unsigned_type_node,
+						NULL_TREE);
+  tree uint64_fntype = build_function_type_list (uint64_type_node,
+						 uint64_type_node, NULL_TREE);
+  aarch64_builtin_decls[AARCH64_REV16]
+    = aarch64_general_add_builtin ("__builtin_aarch64_rev16", uint32_fntype,
+				   AARCH64_REV16);
+  aarch64_builtin_decls[AARCH64_REV16L]
+    = aarch64_general_add_builtin ("__builtin_aarch64_rev16l", ulong_fntype,
+				   AARCH64_REV16L);
+  aarch64_builtin_decls[AARCH64_REV16LL]
+    = aarch64_general_add_builtin ("__builtin_aarch64_rev16ll", uint64_fntype,
+				   AARCH64_REV16LL);
+  aarch64_builtin_decls[AARCH64_RBIT]
+    = aarch64_general_add_builtin ("__builtin_aarch64_rbit", uint32_fntype,
+				   AARCH64_RBIT);
+  aarch64_builtin_decls[AARCH64_RBITL]
+    = aarch64_general_add_builtin ("__builtin_aarch64_rbitl", ulong_fntype,
+				   AARCH64_RBITL);
+  aarch64_builtin_decls[AARCH64_RBITLL]
+    = aarch64_general_add_builtin ("__builtin_aarch64_rbitll", uint64_fntype,
+				   AARCH64_RBITLL);
+}
+
+
 /* Initialize all builtins in the AARCH64_BUILTIN_GENERAL group.  */
 
 void
@@ -1438,6 +1475,7 @@ aarch64_general_init_builtins (void)
   aarch64_init_crc32_builtins ();
   aarch64_init_builtin_rsqrt ();
   aarch64_init_rng_builtins ();
+  aarch64_init_data_intrinsics ();
 
   tree ftype_jcvt
     = build_function_type_list (intSI_type_node, double_type_node, NULL);
@@ -2032,6 +2070,38 @@ aarch64_expand_builtin_memtag (int fcode, tree exp, rtx target)
   return target;
 }
 
+/* Function to expand an expression EXP which calls one of the ACLE Data
+   Intrinsic builtins FCODE with the result going to TARGET.  */
+static rtx
+aarch64_expand_builtin_data_intrinsic (unsigned int fcode, tree exp, rtx target)
+{
+  expand_operand ops[2];
+  machine_mode mode = GET_MODE (target);
+  create_output_operand (&ops[0], target, mode);
+  create_input_operand (&ops[1], expand_normal (CALL_EXPR_ARG (exp, 0)), mode);
+  enum insn_code icode;
+
+  switch (fcode)
+    {
+    case AARCH64_REV16:
+    case AARCH64_REV16L:
+    case AARCH64_REV16LL:
+      icode = code_for_aarch64_rev16 (mode);
+      break;
+    case AARCH64_RBIT:
+    case AARCH64_RBITL:
+    case AARCH64_RBITLL:
+      icode = code_for_aarch64_rbit (mode);
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  expand_insn (icode, 2, ops);
+  return ops[0].value;
+}
+
+
 /* Expand an expression EXP as fpsr or fpcr setter (depending on
    UNSPEC) using MODE.  */
 static void
@@ -2184,6 +2254,10 @@ aarch64_general_expand_builtin (unsigned int fcode, tree exp, rtx target,
       && fcode <= AARCH64_MEMTAG_BUILTIN_END)
     return aarch64_expand_builtin_memtag (fcode, exp, target);
 
+  if (fcode >= AARCH64_REV16
+      && fcode <= AARCH64_RBITLL)
+    return aarch64_expand_builtin_data_intrinsic (fcode, exp, target);
+
   gcc_unreachable ();
 }
 
diff --git a/gcc/config/aarch64/aarch64-c.c b/gcc/config/aarch64/aarch64-c.c
index 8eeef588559..05869463e4b 100644
--- a/gcc/config/aarch64/aarch64-c.c
+++ b/gcc/config/aarch64/aarch64-c.c
@@ -200,6 +200,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)
 			"__ARM_FEATURE_BF16_VECTOR_ARITHMETIC", pfile);
   aarch64_def_or_undef (TARGET_BF16_FP,
 			"__ARM_FEATURE_BF16_SCALAR_ARITHMETIC", pfile);
+  aarch64_def_or_undef (AARCH64_ISA_RCPC, "__ARM_FEATURE_RCPC", pfile);
 
   /* Not for ACLE, but required to keep "float.h" correct if we switch
      target between implementations that do or do not support ARMv8.2-A
diff --git a/gcc/config/aarch64/aarch64-cores.def b/gcc/config/aarch64/aarch64-cores.def
index 4643e0e2795..9e8dc958078 100644
--- a/gcc/config/aarch64/aarch64-cores.def
+++ b/gcc/config/aarch64/aarch64-cores.def
@@ -69,7 +69,8 @@ AARCH64_CORE("thunderxt81",   thunderxt81,   thunderx,  8A,  AARCH64_FL_FOR_ARCH
 AARCH64_CORE("thunderxt83",   thunderxt83,   thunderx,  8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, thunderx,  0x43, 0x0a3, -1)
 
 /* Ampere Computing ('\xC0') cores. */
-AARCH64_CORE("ampere1", ampere1, cortexa57, 8_6A, AARCH64_FL_FOR_ARCH8_6, ampere1, 0xC0, 0xac3, -1)
+AARCH64_CORE("ampere1", ampere1, cortexa57, 8_6A, AARCH64_FL_FOR_ARCH8_6 | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_RNG | AARCH64_FL_SHA3, ampere1, 0xC0, 0xac3, -1)
+AARCH64_CORE("ampere1a", ampere1a, cortexa57, 8_6A, AARCH64_FL_FOR_ARCH8_6 | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_RNG | AARCH64_FL_SHA3 | AARCH64_FL_MEMTAG, ampere1a, 0xC0, 0xac4, -1)
 /* Do not swap around "emag" and "xgene1",
    this order is required to handle variant correctly. */
 AARCH64_CORE("emag",        emag,      xgene1,    8A,  AARCH64_FL_FOR_ARCH8 | AARCH64_FL_CRC | AARCH64_FL_CRYPTO, emag, 0x50, 0x000, 3)
@@ -133,20 +134,21 @@ AARCH64_CORE("tsv110",  tsv110, tsv110, 8_2A,  AARCH64_FL_FOR_ARCH8_2 | AARCH64_
 /* ARMv8.3-A Architecture Processors.  */
 
 /* Marvell cores (TX3). */
-AARCH64_CORE("thunderx3t110",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC | AARCH64_FL_SM4 | AARCH64_FL_SHA3 | AARCH64_FL_F16FML | AARCH64_FL_RCPC8_4, thunderx3t110, 0x43, 0x0b8, 0x0a)
+AARCH64_CORE("thunderx3t110",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_CRYPTO | AARCH64_FL_SM4 | AARCH64_FL_SHA3 | AARCH64_FL_F16FML | AARCH64_FL_RCPC8_4, thunderx3t110, 0x43, 0x0b8, 0x0a)
 
 /* ARMv8.4-A Architecture Processors.  */
 
 /* Arm ('A') cores.  */
-AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
-AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
-AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoverse512tvb, INVALID_IMP, INVALID_CORE, -1)
+AARCH64_CORE("zeus", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
+AARCH64_CORE("neoverse-v1", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)
+AARCH64_CORE("neoverse-512tvb", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoverse512tvb, INVALID_IMP, INVALID_CORE, -1)
 
 /* Qualcomm ('Q') cores. */
-AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)
+AARCH64_CORE("saphira",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO, saphira,   0x51, 0xC01, -1)
 
 /* Armv8.5-A Architecture Processors.  */
 AARCH64_CORE("neoverse-n2", neoversen2, cortexa57, 8_5A, AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG, neoversen2, 0x41, 0xd49, -1)
+AARCH64_CORE("neoverse-v2", neoversev2, cortexa57, 8_5A, AARCH64_FL_FOR_ARCH8_5 | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_SVE | AARCH64_FL_SVE2 | AARCH64_FL_SVE2_BITPERM | AARCH64_FL_RNG | AARCH64_FL_MEMTAG, neoverse512tvb, 0x41, 0xd4f, -1)
 
 /* ARMv8-A big.LITTLE implementations.  */
 
diff --git a/gcc/config/aarch64/aarch64-cost-tables.h b/gcc/config/aarch64/aarch64-cost-tables.h
index 4b7e4e034a2..a8a4c03604d 100644
--- a/gcc/config/aarch64/aarch64-cost-tables.h
+++ b/gcc/config/aarch64/aarch64-cost-tables.h
@@ -754,4 +754,108 @@ const struct cpu_cost_table ampere1_extra_costs =
   }
 };
 
+const struct cpu_cost_table ampere1a_extra_costs =
+{
+  /* ALU */
+  {
+    0,                 /* arith.  */
+    0,                 /* logical.  */
+    0,                 /* shift.  */
+    COSTS_N_INSNS (1), /* shift_reg.  */
+    0,                 /* arith_shift.  */
+    COSTS_N_INSNS (1), /* arith_shift_reg.  */
+    0,                 /* log_shift.  */
+    COSTS_N_INSNS (1), /* log_shift_reg.  */
+    0,                 /* extend.  */
+    COSTS_N_INSNS (1), /* extend_arith.  */
+    0,                 /* bfi.  */
+    0,                 /* bfx.  */
+    0,                 /* clz.  */
+    0,                 /* rev.  */
+    0,                 /* non_exec.  */
+    true               /* non_exec_costs_exec.  */
+  },
+  {
+    /* MULT SImode */
+    {
+      COSTS_N_INSNS (3),       /* simple.  */
+      COSTS_N_INSNS (3),       /* flag_setting.  */
+      COSTS_N_INSNS (3),       /* extend.  */
+      COSTS_N_INSNS (4),       /* add.  */
+      COSTS_N_INSNS (4),       /* extend_add.  */
+      COSTS_N_INSNS (19)       /* idiv.  */
+    },
+    /* MULT DImode */
+    {
+      COSTS_N_INSNS (3),       /* simple.  */
+      0,                       /* flag_setting (N/A).  */
+      COSTS_N_INSNS (3),       /* extend.  */
+      COSTS_N_INSNS (4),       /* add.  */
+      COSTS_N_INSNS (4),       /* extend_add.  */
+      COSTS_N_INSNS (35)       /* idiv.  */
+    }
+  },
+  /* LD/ST */
+  {
+    COSTS_N_INSNS (4),         /* load.  */
+    COSTS_N_INSNS (4),         /* load_sign_extend.  */
+    0,                         /* ldrd (n/a).  */
+    0,                         /* ldm_1st.  */
+    0,                         /* ldm_regs_per_insn_1st.  */
+    0,                         /* ldm_regs_per_insn_subsequent.  */
+    COSTS_N_INSNS (5),         /* loadf.  */
+    COSTS_N_INSNS (5),         /* loadd.  */
+    COSTS_N_INSNS (5),         /* load_unaligned.  */
+    0,                         /* store.  */
+    0,                         /* strd.  */
+    0,                         /* stm_1st.  */
+    0,                         /* stm_regs_per_insn_1st.  */
+    0,                         /* stm_regs_per_insn_subsequent.  */
+    COSTS_N_INSNS (2),         /* storef.  */
+    COSTS_N_INSNS (2),         /* stored.  */
+    COSTS_N_INSNS (2),         /* store_unaligned.  */
+    COSTS_N_INSNS (3),         /* loadv.  */
+    COSTS_N_INSNS (3)          /* storev.  */
+  },
+  {
+    /* FP SFmode */
+    {
+      COSTS_N_INSNS (25),      /* div.  */
+      COSTS_N_INSNS (4),       /* mult.  */
+      COSTS_N_INSNS (4),       /* mult_addsub.  */
+      COSTS_N_INSNS (4),       /* fma.  */
+      COSTS_N_INSNS (4),       /* addsub.  */
+      COSTS_N_INSNS (2),       /* fpconst.  */
+      COSTS_N_INSNS (4),       /* neg.  */
+      COSTS_N_INSNS (4),       /* compare.  */
+      COSTS_N_INSNS (4),       /* widen.  */
+      COSTS_N_INSNS (4),       /* narrow.  */
+      COSTS_N_INSNS (4),       /* toint.  */
+      COSTS_N_INSNS (4),       /* fromint.  */
+      COSTS_N_INSNS (4)        /* roundint.  */
+    },
+    /* FP DFmode */
+    {
+      COSTS_N_INSNS (34),      /* div.  */
+      COSTS_N_INSNS (5),       /* mult.  */
+      COSTS_N_INSNS (5),       /* mult_addsub.  */
+      COSTS_N_INSNS (5),       /* fma.  */
+      COSTS_N_INSNS (5),       /* addsub.  */
+      COSTS_N_INSNS (2),       /* fpconst.  */
+      COSTS_N_INSNS (5),       /* neg.  */
+      COSTS_N_INSNS (5),       /* compare.  */
+      COSTS_N_INSNS (5),       /* widen.  */
+      COSTS_N_INSNS (5),       /* narrow.  */
+      COSTS_N_INSNS (6),       /* toint.  */
+      COSTS_N_INSNS (6),       /* fromint.  */
+      COSTS_N_INSNS (5)        /* roundint.  */
+    }
+  },
+  /* Vector */
+  {
+    COSTS_N_INSNS (3),  /* alu.  */
+    COSTS_N_INSNS (3)   /* mult.  */
+  }
+};
+
 #endif
diff --git a/gcc/config/aarch64/aarch64-fusion-pairs.def b/gcc/config/aarch64/aarch64-fusion-pairs.def
index d6be7304dc0..14bcfa8c71c 100644
--- a/gcc/config/aarch64/aarch64-fusion-pairs.def
+++ b/gcc/config/aarch64/aarch64-fusion-pairs.def
@@ -36,5 +36,6 @@ AARCH64_FUSION_PAIR ("cmp+branch", CMP_BRANCH)
 AARCH64_FUSION_PAIR ("aes+aesmc", AES_AESMC)
 AARCH64_FUSION_PAIR ("alu+branch", ALU_BRANCH)
 AARCH64_FUSION_PAIR ("alu+cbz", ALU_CBZ)
+AARCH64_FUSION_PAIR ("addsub_2reg_const1", ADDSUB_2REG_CONST1)
 
 #undef AARCH64_FUSION_PAIR
diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index b91eeeba101..fdc79b1dced 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -1034,7 +1034,7 @@ bool aarch64_high_bits_all_ones_p (HOST_WIDE_INT);
 
 struct atomic_ool_names
 {
-    const char *str[5][4];
+    const char *str[5][5];
 };
 
 rtx aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
@@ -1052,4 +1052,6 @@ const char *aarch64_indirect_call_asm (rtx);
 extern bool aarch64_harden_sls_retbr_p (void);
 extern bool aarch64_harden_sls_blr_p (void);
 
+extern void aarch64_output_patchable_area (unsigned int, bool);
+
 #endif /* GCC_AARCH64_PROTOS_H */
diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
index 629c47a97dc..4edcb27e3f3 100644
--- a/gcc/config/aarch64/aarch64-simd.md
+++ b/gcc/config/aarch64/aarch64-simd.md
@@ -8290,7 +8290,7 @@
   [(set (match_operand:V4SF 0 "register_operand" "=w")
         (plus: V4SF (match_operand:V4SF 1 "register_operand" "0")
                     (unspec:V4SF [(match_operand:V8BF 2 "register_operand" "w")
-                                  (match_operand:VBF 3 "register_operand" "w")
+                                  (match_operand:VBF 3 "register_operand" "x")
                                   (match_operand:SI 4 "const_int_operand" "n")]
                      BF_MLA)))]
   "TARGET_BF16_SIMD"
diff --git a/gcc/config/aarch64/aarch64-sve-builtins.cc b/gcc/config/aarch64/aarch64-sve-builtins.cc
index f44f81f1375..fcc458af3d6 100644
--- a/gcc/config/aarch64/aarch64-sve-builtins.cc
+++ b/gcc/config/aarch64/aarch64-sve-builtins.cc
@@ -530,7 +530,8 @@ static CONSTEXPR const function_group_info function_groups[] = {
 };
 
 /* The scalar type associated with each vector type.  */
-GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
+extern GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
+tree scalar_types[NUM_VECTOR_TYPES];
 
 /* The single-predicate and single-vector types, with their built-in
    "__SV..._t" name.  Allow an index of NUM_VECTOR_TYPES, which always
@@ -538,13 +539,16 @@ GTY(()) tree scalar_types[NUM_VECTOR_TYPES];
 static GTY(()) tree abi_vector_types[NUM_VECTOR_TYPES + 1];
 
 /* Same, but with the arm_sve.h "sv..._t" name.  */
-GTY(()) tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
+extern GTY(()) tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
+tree acle_vector_types[MAX_TUPLE_SIZE][NUM_VECTOR_TYPES + 1];
 
 /* The svpattern enum type.  */
-GTY(()) tree acle_svpattern;
+extern GTY(()) tree acle_svpattern;
+tree acle_svpattern;
 
 /* The svprfop enum type.  */
-GTY(()) tree acle_svprfop;
+extern GTY(()) tree acle_svprfop;
+tree acle_svprfop;
 
 /* The list of all registered function decls, indexed by code.  */
 static GTY(()) vec<registered_function *, va_gc> *registered_functions;
diff --git a/gcc/config/aarch64/aarch64-sve.md b/gcc/config/aarch64/aarch64-sve.md
index 8eb9ec24909..509b7120a1b 100644
--- a/gcc/config/aarch64/aarch64-sve.md
+++ b/gcc/config/aarch64/aarch64-sve.md
@@ -9430,45 +9430,41 @@
 (define_insn "*aarch64_brk<brk_op>_cc"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
-	  [(match_operand:VNx16BI 1 "register_operand" "Upa, Upa")
+	  [(match_operand:VNx16BI 1 "register_operand" "Upa")
 	   (match_dup 1)
 	   (match_operand:SI 4 "aarch64_sve_ptrue_flag")
 	   (unspec:VNx16BI
 	     [(match_dup 1)
-	      (match_operand:VNx16BI 2 "register_operand" "Upa, Upa")
-	      (match_operand:VNx16BI 3 "aarch64_simd_reg_or_zero" "Dz, 0")]
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "aarch64_simd_imm_zero")]
 	     SVE_BRK_UNARY)]
 	  UNSPEC_PTEST))
-   (set (match_operand:VNx16BI 0 "register_operand" "=Upa, Upa")
+   (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
 	(unspec:VNx16BI
 	  [(match_dup 1)
 	   (match_dup 2)
 	   (match_dup 3)]
 	  SVE_BRK_UNARY))]
   "TARGET_SVE"
-  "@
-   brk<brk_op>s\t%0.b, %1/z, %2.b
-   brk<brk_op>s\t%0.b, %1/m, %2.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b"
 )
 
 ;; Same, but with only the flags result being interesting.
 (define_insn "*aarch64_brk<brk_op>_ptest"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
-	  [(match_operand:VNx16BI 1 "register_operand" "Upa, Upa")
+	  [(match_operand:VNx16BI 1 "register_operand" "Upa")
 	   (match_dup 1)
 	   (match_operand:SI 4 "aarch64_sve_ptrue_flag")
 	   (unspec:VNx16BI
 	     [(match_dup 1)
-	      (match_operand:VNx16BI 2 "register_operand" "Upa, Upa")
-	      (match_operand:VNx16BI 3 "aarch64_simd_reg_or_zero" "Dz, 0")]
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "aarch64_simd_imm_zero")]
 	     SVE_BRK_UNARY)]
 	  UNSPEC_PTEST))
-   (clobber (match_scratch:VNx16BI 0 "=Upa, Upa"))]
+   (clobber (match_scratch:VNx16BI 0 "=Upa"))]
   "TARGET_SVE"
-  "@
-   brk<brk_op>s\t%0.b, %1/z, %2.b
-   brk<brk_op>s\t%0.b, %1/m, %2.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b"
 )
 
 ;; -------------------------------------------------------------------------
@@ -9495,7 +9491,61 @@
   "brk<brk_op>\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
 )
 
-;; Same, but also producing a flags result.
+;; BRKN, producing both a predicate and a flags result.  Unlike other
+;; flag-setting instructions, these flags are always set wrt a ptrue.
+(define_insn_and_rewrite "*aarch64_brkn_cc"
+  [(set (reg:CC_NZC CC_REGNUM)
+	(unspec:CC_NZC
+	  [(match_operand:VNx16BI 4)
+	   (match_operand:VNx16BI 5)
+	   (const_int SVE_KNOWN_PTRUE)
+	   (unspec:VNx16BI
+	     [(match_operand:VNx16BI 1 "register_operand" "Upa")
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "register_operand" "0")]
+	     UNSPEC_BRKN)]
+	  UNSPEC_PTEST))
+   (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
+	(unspec:VNx16BI
+	  [(match_dup 1)
+	   (match_dup 2)
+	   (match_dup 3)]
+	  UNSPEC_BRKN))]
+  "TARGET_SVE"
+  "brkns\t%0.b, %1/z, %2.b, %0.b"
+  "&& (operands[4] != CONST0_RTX (VNx16BImode)
+       || operands[5] != CONST0_RTX (VNx16BImode))"
+  {
+    operands[4] = CONST0_RTX (VNx16BImode);
+    operands[5] = CONST0_RTX (VNx16BImode);
+  }
+)
+
+;; Same, but with only the flags result being interesting.
+(define_insn_and_rewrite "*aarch64_brkn_ptest"
+  [(set (reg:CC_NZC CC_REGNUM)
+	(unspec:CC_NZC
+	  [(match_operand:VNx16BI 4)
+	   (match_operand:VNx16BI 5)
+	   (const_int SVE_KNOWN_PTRUE)
+	   (unspec:VNx16BI
+	     [(match_operand:VNx16BI 1 "register_operand" "Upa")
+	      (match_operand:VNx16BI 2 "register_operand" "Upa")
+	      (match_operand:VNx16BI 3 "register_operand" "0")]
+	     UNSPEC_BRKN)]
+	  UNSPEC_PTEST))
+   (clobber (match_scratch:VNx16BI 0 "=Upa"))]
+  "TARGET_SVE"
+  "brkns\t%0.b, %1/z, %2.b, %0.b"
+  "&& (operands[4] != CONST0_RTX (VNx16BImode)
+       || operands[5] != CONST0_RTX (VNx16BImode))"
+  {
+    operands[4] = CONST0_RTX (VNx16BImode);
+    operands[5] = CONST0_RTX (VNx16BImode);
+  }
+)
+
+;; BRKPA and BRKPB, producing both a predicate and a flags result.
 (define_insn "*aarch64_brk<brk_op>_cc"
   [(set (reg:CC_NZC CC_REGNUM)
 	(unspec:CC_NZC
@@ -9505,17 +9555,17 @@
 	   (unspec:VNx16BI
 	     [(match_dup 1)
 	      (match_operand:VNx16BI 2 "register_operand" "Upa")
-	      (match_operand:VNx16BI 3 "register_operand" "<brk_reg_con>")]
-	     SVE_BRK_BINARY)]
+	      (match_operand:VNx16BI 3 "register_operand" "Upa")]
+	     SVE_BRKP)]
 	  UNSPEC_PTEST))
    (set (match_operand:VNx16BI 0 "register_operand" "=Upa")
 	(unspec:VNx16BI
 	  [(match_dup 1)
 	   (match_dup 2)
 	   (match_dup 3)]
-	  SVE_BRK_BINARY))]
+	  SVE_BRKP))]
   "TARGET_SVE"
-  "brk<brk_op>s\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b, %3.b"
 )
 
 ;; Same, but with only the flags result being interesting.
@@ -9528,12 +9578,12 @@
 	   (unspec:VNx16BI
 	     [(match_dup 1)
 	      (match_operand:VNx16BI 2 "register_operand" "Upa")
-	      (match_operand:VNx16BI 3 "register_operand" "<brk_reg_con>")]
-	     SVE_BRK_BINARY)]
+	      (match_operand:VNx16BI 3 "register_operand" "Upa")]
+	     SVE_BRKP)]
 	  UNSPEC_PTEST))
    (clobber (match_scratch:VNx16BI 0 "=Upa"))]
   "TARGET_SVE"
-  "brk<brk_op>s\t%0.b, %1/z, %2.b, %<brk_reg_opno>.b"
+  "brk<brk_op>s\t%0.b, %1/z, %2.b, %3.b"
 )
 
 ;; -------------------------------------------------------------------------
diff --git a/gcc/config/aarch64/aarch64-tune.md b/gcc/config/aarch64/aarch64-tune.md
index 2beac8c8353..b5f35c68e23 100644
--- a/gcc/config/aarch64/aarch64-tune.md
+++ b/gcc/config/aarch64/aarch64-tune.md
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from aarch64-cores.def
 (define_attr "tune"
-	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,ampere1,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa78,cortexa78ae,cortexa78c,cortexa65,cortexa65ae,cortexx1,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55,cortexr82"
+	"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,ampere1,ampere1a,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa78,cortexa78ae,cortexa78c,cortexa65,cortexa65ae,cortexx1,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,neoversev2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55,cortexr82"
 	(const (symbol_ref "((enum attr_tune) aarch64_tune)")))
diff --git a/gcc/config/aarch64/aarch64-tuning-flags.def b/gcc/config/aarch64/aarch64-tuning-flags.def
index 65b4c37d652..dcb96d71a1c 100644
--- a/gcc/config/aarch64/aarch64-tuning-flags.def
+++ b/gcc/config/aarch64/aarch64-tuning-flags.def
@@ -44,6 +44,9 @@ AARCH64_EXTRA_TUNING_OPTION ("cheap_shift_extend", CHEAP_SHIFT_EXTEND)
 /* Disallow load/store pair instructions on Q-registers.  */
 AARCH64_EXTRA_TUNING_OPTION ("no_ldp_stp_qregs", NO_LDP_STP_QREGS)
 
+/* Disallow load-pair instructions to be formed in combine/peephole.  */
+AARCH64_EXTRA_TUNING_OPTION ("no_ldp_combine", NO_LDP_COMBINE)
+
 AARCH64_EXTRA_TUNING_OPTION ("rename_load_regs", RENAME_LOAD_REGS)
 
 AARCH64_EXTRA_TUNING_OPTION ("cse_sve_vl_constants", CSE_SVE_VL_CONSTANTS)
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index c155f4883cf..3ccfd3c30fc 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -1070,7 +1070,7 @@ static const struct cpu_vector_cost thunderx3t110_vector_cost =
 
 static const advsimd_vec_cost ampere1_advsimd_vector_cost =
 {
-  3, /* int_stmt_cost  */
+  1, /* int_stmt_cost  */
   3, /* fp_stmt_cost  */
   0, /* ld2_st2_permute_cost  */
   0, /* ld3_st3_permute_cost  */
@@ -1086,17 +1086,17 @@ static const advsimd_vec_cost ampere1_advsimd_vector_cost =
   8, /* store_elt_extra_cost  */
   6, /* vec_to_scalar_cost  */
   7, /* scalar_to_vec_cost  */
-  5, /* align_load_cost  */
-  5, /* unalign_load_cost  */
-  2, /* unalign_store_cost  */
-  2  /* store_cost  */
+  4, /* align_load_cost  */
+  4, /* unalign_load_cost  */
+  1, /* unalign_store_cost  */
+  1  /* store_cost  */
 };
 
 /* Ampere-1 costs for vector insn classes.  */
 static const struct cpu_vector_cost ampere1_vector_cost =
 {
   1, /* scalar_int_stmt_cost  */
-  1, /* scalar_fp_stmt_cost  */
+  3, /* scalar_fp_stmt_cost  */
   4, /* scalar_load_cost  */
   1, /* scalar_store_cost  */
   1, /* cond_taken_branch_cost  */
@@ -1745,7 +1745,38 @@ static const struct tune_params ampere1_tunings =
   2,	/* min_div_recip_mul_df.  */
   0,	/* max_case_values.  */
   tune_params::AUTOPREFETCHER_WEAK,	/* autoprefetcher_model.  */
-  (AARCH64_EXTRA_TUNE_NONE),		/* tune_flags.  */
+  (AARCH64_EXTRA_TUNE_NO_LDP_COMBINE),	/* tune_flags.  */
+  &ampere1_prefetch_tune
+};
+
+static const struct tune_params ampere1a_tunings =
+{
+  &ampere1a_extra_costs,
+  &generic_addrcost_table,
+  &generic_regmove_cost,
+  &ampere1_vector_cost,
+  &generic_branch_cost,
+  &generic_approx_modes,
+  SVE_NOT_IMPLEMENTED, /* sve_width  */
+  4, /* memmov_cost  */
+  4, /* issue_rate  */
+  (AARCH64_FUSE_ADRP_ADD | AARCH64_FUSE_AES_AESMC |
+   AARCH64_FUSE_MOV_MOVK | AARCH64_FUSE_MOVK_MOVK |
+   AARCH64_FUSE_ALU_BRANCH /* adds, ands, bics, ccmp, ccmn */ |
+   AARCH64_FUSE_CMP_BRANCH | AARCH64_FUSE_ALU_CBZ |
+   AARCH64_FUSE_ADDSUB_2REG_CONST1),
+  /* fusible_ops  */
+  "32",		/* function_align.  */
+  "4",		/* jump_align.  */
+  "32:16",	/* loop_align.  */
+  2,	/* int_reassoc_width.  */
+  4,	/* fp_reassoc_width.  */
+  2,	/* vec_reassoc_width.  */
+  2,	/* min_div_recip_mul_sf.  */
+  2,	/* min_div_recip_mul_df.  */
+  0,	/* max_case_values.  */
+  tune_params::AUTOPREFETCHER_WEAK,	/* autoprefetcher_model.  */
+  (AARCH64_EXTRA_TUNE_NO_LDP_COMBINE),	/* tune_flags.  */
   &ampere1_prefetch_tune
 };
 
@@ -6547,9 +6578,9 @@ aarch64_vfp_is_call_candidate (cumulative_args_t pcum_v, machine_mode mode,
 /* Given MODE and TYPE of a function argument, return the alignment in
    bits.  The idea is to suppress any stronger alignment requested by
    the user and opt for the natural alignment (specified in AAPCS64 \S
-   4.1).  ABI_BREAK is set to true if the alignment was incorrectly
-   calculated in versions of GCC prior to GCC-9.  This is a helper
-   function for local use only.  */
+   4.1).  ABI_BREAK is set to the old alignment if the alignment was
+   incorrectly calculated in versions of GCC prior to GCC-9.  This is
+   a helper function for local use only.  */
 
 static unsigned int
 aarch64_function_arg_alignment (machine_mode mode, const_tree type,
@@ -6625,11 +6656,24 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)
   if (pcum->aapcs_arg_processed)
     return;
 
+  bool warn_pcs_change
+    = (warn_psabi
+       && !pcum->silent_p
+       && (currently_expanding_function_start
+	   || currently_expanding_gimple_stmt));
+
+  unsigned int alignment
+    = aarch64_function_arg_alignment (mode, type, &abi_break);
+  gcc_assert (!alignment || abi_break < alignment);
+
   pcum->aapcs_arg_processed = true;
 
   pure_scalable_type_info pst_info;
   if (type && pst_info.analyze_registers (type))
     {
+      /* aarch64_function_arg_alignment has never had an effect on
+	 this case.  */
+
       /* The PCS says that it is invalid to pass an SVE value to an
 	 unprototyped function.  There is no ABI-defined location we
 	 can return in this case, so we have no real choice but to raise
@@ -6700,6 +6744,8 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)
      and homogenous short-vector aggregates (HVA).  */
   if (allocate_nvrn)
     {
+      /* aarch64_function_arg_alignment has never had an effect on
+	 this case.  */
       if (!pcum->silent_p && !TARGET_FLOAT)
 	aarch64_err_no_fpadvsimd (mode);
 
@@ -6758,7 +6804,7 @@ aarch64_layout_arg (cumulative_args_t pcum_v, const function_arg_info &arg)
 	  && (aarch64_function_arg_alignment (mode, type, &abi_break)
 	      == 16 * BITS_PER_UNIT))
 	{
-	  if (abi_break && warn_psabi && currently_expanding_gimple_stmt)
+	  if (warn_pcs_change && abi_break)
 	    inform (input_location, "parameter passing for argument of type "
 		    "%qT changed in GCC 9.1", type);
 	  ++ncrn;
@@ -6821,7 +6867,7 @@ on_stack:
       int new_size = ROUND_UP (pcum->aapcs_stack_size, 16 / UNITS_PER_WORD);
       if (pcum->aapcs_stack_size != new_size)
 	{
-	  if (abi_break && warn_psabi && currently_expanding_gimple_stmt)
+	  if (warn_pcs_change && abi_break)
 	    inform (input_location, "parameter passing for argument of type "
 		    "%qT changed in GCC 9.1", type);
 	  pcum->aapcs_stack_size = new_size;
@@ -6941,14 +6987,13 @@ aarch64_function_arg_boundary (machine_mode mode, const_tree type)
   unsigned int alignment = aarch64_function_arg_alignment (mode, type,
 							   &abi_break);
   alignment = MIN (MAX (alignment, PARM_BOUNDARY), STACK_BOUNDARY);
-  if (abi_break & warn_psabi)
+  if (abi_break && warn_psabi)
     {
       abi_break = MIN (MAX (abi_break, PARM_BOUNDARY), STACK_BOUNDARY);
       if (alignment != abi_break)
 	inform (input_location, "parameter passing for argument of type "
 		"%qT changed in GCC 9.1", type);
     }
-
   return alignment;
 }
 
@@ -7347,18 +7392,32 @@ aarch64_needs_frame_chain (void)
   return aarch64_use_frame_pointer;
 }
 
+/* Return true if the current function should save registers above
+   the locals area, rather than below it.  */
+
+static bool
+aarch64_save_regs_above_locals_p ()
+{
+  /* When using stack smash protection, make sure that the canary slot
+     comes between the locals and the saved registers.  Otherwise,
+     it would be possible for a carefully sized smash attack to change
+     the saved registers (particularly LR and FP) without reaching the
+     canary.  */
+  return crtl->stack_protect_guard;
+}
+
 /* Mark the registers that need to be saved by the callee and calculate
    the size of the callee-saved registers area and frame record (both FP
    and LR may be omitted).  */
 static void
 aarch64_layout_frame (void)
 {
-  poly_int64 offset = 0;
   int regno, last_fp_reg = INVALID_REGNUM;
   machine_mode vector_save_mode = aarch64_reg_save_mode (V8_REGNUM);
   poly_int64 vector_save_size = GET_MODE_SIZE (vector_save_mode);
   bool frame_related_fp_reg_p = false;
   aarch64_frame &frame = cfun->machine->frame;
+  poly_int64 top_of_locals = -1;
 
   frame.emit_frame_chain = aarch64_needs_frame_chain ();
 
@@ -7425,11 +7484,18 @@ aarch64_layout_frame (void)
 	&& !crtl->abi->clobbers_full_reg_p (regno))
       frame.reg_offset[regno] = SLOT_REQUIRED;
 
-  /* With stack-clash, LR must be saved in non-leaf functions.  The saving of
-     LR counts as an implicit probe which allows us to maintain the invariant
-     described in the comment at expand_prologue.  */
-  gcc_assert (crtl->is_leaf
-	      || maybe_ne (frame.reg_offset[R30_REGNUM], SLOT_NOT_REQUIRED));
+  bool regs_at_top_p = aarch64_save_regs_above_locals_p ();
+
+  poly_int64 offset = crtl->outgoing_args_size;
+  gcc_assert (multiple_p (offset, STACK_BOUNDARY / BITS_PER_UNIT));
+  if (regs_at_top_p)
+    {
+      offset += get_frame_size ();
+      offset = aligned_upper_bound (offset, STACK_BOUNDARY / BITS_PER_UNIT);
+      top_of_locals = offset;
+    }
+  frame.bytes_below_saved_regs = offset;
+  frame.sve_save_and_probe = INVALID_REGNUM;
 
   /* Now assign stack slots for the registers.  Start with the predicate
      registers, since predicate LDR and STR have a relatively small
@@ -7437,11 +7503,14 @@ aarch64_layout_frame (void)
   for (regno = P0_REGNUM; regno <= P15_REGNUM; regno++)
     if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))
       {
+	if (frame.sve_save_and_probe == INVALID_REGNUM)
+	  frame.sve_save_and_probe = regno;
 	frame.reg_offset[regno] = offset;
 	offset += BYTES_PER_SVE_PRED;
       }
 
-  if (maybe_ne (offset, 0))
+  poly_int64 saved_prs_size = offset - frame.bytes_below_saved_regs;
+  if (maybe_ne (saved_prs_size, 0))
     {
       /* If we have any vector registers to save above the predicate registers,
 	 the offset of the vector register save slots need to be a multiple
@@ -7459,10 +7528,10 @@ aarch64_layout_frame (void)
 	offset = aligned_upper_bound (offset, STACK_BOUNDARY / BITS_PER_UNIT);
       else
 	{
-	  if (known_le (offset, vector_save_size))
-	    offset = vector_save_size;
-	  else if (known_le (offset, vector_save_size * 2))
-	    offset = vector_save_size * 2;
+	  if (known_le (saved_prs_size, vector_save_size))
+	    offset = frame.bytes_below_saved_regs + vector_save_size;
+	  else if (known_le (saved_prs_size, vector_save_size * 2))
+	    offset = frame.bytes_below_saved_regs + vector_save_size * 2;
 	  else
 	    gcc_unreachable ();
 	}
@@ -7473,34 +7542,53 @@ aarch64_layout_frame (void)
     for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)
       if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))
 	{
+	  if (frame.sve_save_and_probe == INVALID_REGNUM)
+	    frame.sve_save_and_probe = regno;
 	  frame.reg_offset[regno] = offset;
 	  offset += vector_save_size;
 	}
 
   /* OFFSET is now the offset of the hard frame pointer from the bottom
      of the callee save area.  */
-  bool saves_below_hard_fp_p = maybe_ne (offset, 0);
-  frame.below_hard_fp_saved_regs_size = offset;
+  auto below_hard_fp_saved_regs_size = offset - frame.bytes_below_saved_regs;
+  bool saves_below_hard_fp_p = maybe_ne (below_hard_fp_saved_regs_size, 0);
+  gcc_assert (!saves_below_hard_fp_p
+	      || (frame.sve_save_and_probe != INVALID_REGNUM
+		  && known_eq (frame.reg_offset[frame.sve_save_and_probe],
+			       frame.bytes_below_saved_regs)));
+
+  frame.bytes_below_hard_fp = offset;
+  frame.hard_fp_save_and_probe = INVALID_REGNUM;
+
+  auto allocate_gpr_slot = [&](unsigned int regno)
+    {
+      if (frame.hard_fp_save_and_probe == INVALID_REGNUM)
+	frame.hard_fp_save_and_probe = regno;
+      frame.reg_offset[regno] = offset;
+      if (frame.wb_candidate1 == INVALID_REGNUM)
+	frame.wb_candidate1 = regno;
+      else if (frame.wb_candidate2 == INVALID_REGNUM)
+	frame.wb_candidate2 = regno;
+      offset += UNITS_PER_WORD;
+    };
+
   if (frame.emit_frame_chain)
     {
       /* FP and LR are placed in the linkage record.  */
-      frame.reg_offset[R29_REGNUM] = offset;
-      frame.wb_candidate1 = R29_REGNUM;
-      frame.reg_offset[R30_REGNUM] = offset + UNITS_PER_WORD;
-      frame.wb_candidate2 = R30_REGNUM;
-      offset += 2 * UNITS_PER_WORD;
+      allocate_gpr_slot (R29_REGNUM);
+      allocate_gpr_slot (R30_REGNUM);
     }
+  else if (flag_stack_clash_protection
+	   && known_eq (frame.reg_offset[R30_REGNUM], SLOT_REQUIRED))
+    /* Put the LR save slot first, since it makes a good choice of probe
+       for stack clash purposes.  The idea is that the link register usually
+       has to be saved before a call anyway, and so we lose little by
+       stopping it from being individually shrink-wrapped.  */
+    allocate_gpr_slot (R30_REGNUM);
 
   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)
     if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))
-      {
-	frame.reg_offset[regno] = offset;
-	if (frame.wb_candidate1 == INVALID_REGNUM)
-	  frame.wb_candidate1 = regno;
-	else if (frame.wb_candidate2 == INVALID_REGNUM)
-	  frame.wb_candidate2 = regno;
-	offset += UNITS_PER_WORD;
-      }
+      allocate_gpr_slot (regno);
 
   poly_int64 max_int_offset = offset;
   offset = aligned_upper_bound (offset, STACK_BOUNDARY / BITS_PER_UNIT);
@@ -7509,6 +7597,8 @@ aarch64_layout_frame (void)
   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)
     if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))
       {
+	if (frame.hard_fp_save_and_probe == INVALID_REGNUM)
+	  frame.hard_fp_save_and_probe = regno;
 	/* If there is an alignment gap between integer and fp callee-saves,
 	   allocate the last fp register to it if possible.  */
 	if (regno == last_fp_reg
@@ -7531,30 +7621,36 @@ aarch64_layout_frame (void)
 
   offset = aligned_upper_bound (offset, STACK_BOUNDARY / BITS_PER_UNIT);
 
-  frame.saved_regs_size = offset;
+  auto saved_regs_size = offset - frame.bytes_below_saved_regs;
+  gcc_assert (known_eq (saved_regs_size, below_hard_fp_saved_regs_size)
+	      || (frame.hard_fp_save_and_probe != INVALID_REGNUM
+		  && known_eq (frame.reg_offset[frame.hard_fp_save_and_probe],
+			       frame.bytes_below_hard_fp)));
 
-  poly_int64 varargs_and_saved_regs_size = offset + frame.saved_varargs_size;
+  /* With stack-clash, a register must be saved in non-leaf functions.
+     The saving of the bottommost register counts as an implicit probe,
+     which allows us to maintain the invariant described in the comment
+     at expand_prologue.  */
+  gcc_assert (crtl->is_leaf || maybe_ne (saved_regs_size, 0));
 
-  poly_int64 above_outgoing_args
-    = aligned_upper_bound (varargs_and_saved_regs_size
-			   + get_frame_size (),
-			   STACK_BOUNDARY / BITS_PER_UNIT);
+  if (!regs_at_top_p)
+    {
+      offset += get_frame_size ();
+      offset = aligned_upper_bound (offset, STACK_BOUNDARY / BITS_PER_UNIT);
+      top_of_locals = offset;
+    }
+  offset += frame.saved_varargs_size;
+  gcc_assert (multiple_p (offset, STACK_BOUNDARY / BITS_PER_UNIT));
+  frame.frame_size = offset;
 
-  frame.hard_fp_offset
-    = above_outgoing_args - frame.below_hard_fp_saved_regs_size;
-
-  /* Both these values are already aligned.  */
-  gcc_assert (multiple_p (crtl->outgoing_args_size,
-			  STACK_BOUNDARY / BITS_PER_UNIT));
-  frame.frame_size = above_outgoing_args + crtl->outgoing_args_size;
-
-  frame.locals_offset = frame.saved_varargs_size;
+  frame.bytes_above_hard_fp = frame.frame_size - frame.bytes_below_hard_fp;
+  gcc_assert (known_ge (top_of_locals, 0));
+  frame.bytes_above_locals = frame.frame_size - top_of_locals;
 
   frame.initial_adjust = 0;
   frame.final_adjust = 0;
   frame.callee_adjust = 0;
   frame.sve_callee_adjust = 0;
-  frame.callee_offset = 0;
 
   HOST_WIDE_INT max_push_offset = 0;
   if (frame.wb_candidate2 != INVALID_REGNUM)
@@ -7562,70 +7658,68 @@ aarch64_layout_frame (void)
   else if (frame.wb_candidate1 != INVALID_REGNUM)
     max_push_offset = 256;
 
-  HOST_WIDE_INT const_size, const_outgoing_args_size, const_fp_offset;
+  HOST_WIDE_INT const_size, const_below_saved_regs, const_above_fp;
   HOST_WIDE_INT const_saved_regs_size;
-  if (frame.frame_size.is_constant (&const_size)
-      && const_size < max_push_offset
-      && known_eq (frame.hard_fp_offset, const_size))
+  if (known_eq (saved_regs_size, 0))
+    frame.initial_adjust = frame.frame_size;
+  else if (frame.frame_size.is_constant (&const_size)
+	   && const_size < max_push_offset
+	   && known_eq (frame.bytes_above_hard_fp, const_size))
     {
-      /* Simple, small frame with no outgoing arguments:
+      /* Simple, small frame with no data below the saved registers.
 
 	 stp reg1, reg2, [sp, -frame_size]!
 	 stp reg3, reg4, [sp, 16]  */
       frame.callee_adjust = const_size;
     }
-  else if (crtl->outgoing_args_size.is_constant (&const_outgoing_args_size)
-	   && frame.saved_regs_size.is_constant (&const_saved_regs_size)
-	   && const_outgoing_args_size + const_saved_regs_size < 512
-	   /* We could handle this case even with outgoing args, provided
-	      that the number of args left us with valid offsets for all
-	      predicate and vector save slots.  It's such a rare case that
-	      it hardly seems worth the effort though.  */
-	   && (!saves_below_hard_fp_p || const_outgoing_args_size == 0)
+  else if (frame.bytes_below_saved_regs.is_constant (&const_below_saved_regs)
+	   && saved_regs_size.is_constant (&const_saved_regs_size)
+	   && const_below_saved_regs + const_saved_regs_size < 512
+	   /* We could handle this case even with data below the saved
+	      registers, provided that that data left us with valid offsets
+	      for all predicate and vector save slots.  It's such a rare
+	      case that it hardly seems worth the effort though.  */
+	   && (!saves_below_hard_fp_p || const_below_saved_regs == 0)
 	   && !(cfun->calls_alloca
-		&& frame.hard_fp_offset.is_constant (&const_fp_offset)
-		&& const_fp_offset < max_push_offset))
+		&& frame.bytes_above_hard_fp.is_constant (&const_above_fp)
+		&& const_above_fp < max_push_offset))
     {
-      /* Frame with small outgoing arguments:
+      /* Frame with small area below the saved registers:
 
 	 sub sp, sp, frame_size
-	 stp reg1, reg2, [sp, outgoing_args_size]
-	 stp reg3, reg4, [sp, outgoing_args_size + 16]  */
+	 stp reg1, reg2, [sp, bytes_below_saved_regs]
+	 stp reg3, reg4, [sp, bytes_below_saved_regs + 16]  */
       frame.initial_adjust = frame.frame_size;
-      frame.callee_offset = const_outgoing_args_size;
     }
   else if (saves_below_hard_fp_p
-	   && known_eq (frame.saved_regs_size,
-			frame.below_hard_fp_saved_regs_size))
+	   && known_eq (saved_regs_size, below_hard_fp_saved_regs_size))
     {
       /* Frame in which all saves are SVE saves:
 
-	 sub sp, sp, hard_fp_offset + below_hard_fp_saved_regs_size
+	 sub sp, sp, frame_size - bytes_below_saved_regs
 	 save SVE registers relative to SP
-	 sub sp, sp, outgoing_args_size  */
-      frame.initial_adjust = (frame.hard_fp_offset
-			      + frame.below_hard_fp_saved_regs_size);
-      frame.final_adjust = crtl->outgoing_args_size;
+	 sub sp, sp, bytes_below_saved_regs  */
+      frame.initial_adjust = frame.frame_size - frame.bytes_below_saved_regs;
+      frame.final_adjust = frame.bytes_below_saved_regs;
     }
-  else if (frame.hard_fp_offset.is_constant (&const_fp_offset)
-	   && const_fp_offset < max_push_offset)
+  else if (frame.bytes_above_hard_fp.is_constant (&const_above_fp)
+	   && const_above_fp < max_push_offset)
     {
-      /* Frame with large outgoing arguments or SVE saves, but with
-	 a small local area:
+      /* Frame with large area below the saved registers, or with SVE saves,
+	 but with a small area above:
 
 	 stp reg1, reg2, [sp, -hard_fp_offset]!
 	 stp reg3, reg4, [sp, 16]
 	 [sub sp, sp, below_hard_fp_saved_regs_size]
 	 [save SVE registers relative to SP]
-	 sub sp, sp, outgoing_args_size  */
-      frame.callee_adjust = const_fp_offset;
-      frame.sve_callee_adjust = frame.below_hard_fp_saved_regs_size;
-      frame.final_adjust = crtl->outgoing_args_size;
+	 sub sp, sp, bytes_below_saved_regs  */
+      frame.callee_adjust = const_above_fp;
+      frame.sve_callee_adjust = below_hard_fp_saved_regs_size;
+      frame.final_adjust = frame.bytes_below_saved_regs;
     }
   else
     {
-      /* Frame with large local area and outgoing arguments or SVE saves,
-	 using frame pointer:
+      /* General case:
 
 	 sub sp, sp, hard_fp_offset
 	 stp x29, x30, [sp, 0]
@@ -7633,10 +7727,29 @@ aarch64_layout_frame (void)
 	 stp reg3, reg4, [sp, 16]
 	 [sub sp, sp, below_hard_fp_saved_regs_size]
 	 [save SVE registers relative to SP]
-	 sub sp, sp, outgoing_args_size  */
-      frame.initial_adjust = frame.hard_fp_offset;
-      frame.sve_callee_adjust = frame.below_hard_fp_saved_regs_size;
-      frame.final_adjust = crtl->outgoing_args_size;
+	 sub sp, sp, bytes_below_saved_regs  */
+      frame.initial_adjust = frame.bytes_above_hard_fp;
+      frame.sve_callee_adjust = below_hard_fp_saved_regs_size;
+      frame.final_adjust = frame.bytes_below_saved_regs;
+    }
+
+  /* The frame is allocated in pieces, with each non-final piece
+     including a register save at offset 0 that acts as a probe for
+     the following piece.  In addition, the save of the bottommost register
+     acts as a probe for callees and allocas.  Roll back any probes that
+     aren't needed.
+
+     A probe isn't needed if it is associated with the final allocation
+     (including callees and allocas) that happens before the epilogue is
+     executed.  */
+  if (crtl->is_leaf
+      && !cfun->calls_alloca
+      && known_eq (frame.final_adjust, 0))
+    {
+      if (maybe_ne (frame.sve_callee_adjust, 0))
+	frame.sve_save_and_probe = INVALID_REGNUM;
+      else
+	frame.hard_fp_save_and_probe = INVALID_REGNUM;
     }
 
   /* Make sure the individual adjustments add up to the full frame size.  */
@@ -7940,15 +8053,17 @@ aarch64_add_cfa_expression (rtx_insn *insn, rtx reg,
 }
 
 /* Emit code to save the callee-saved registers from register number START
-   to LIMIT to the stack at the location starting at offset START_OFFSET,
-   skipping any write-back candidates if SKIP_WB is true.  HARD_FP_VALID_P
-   is true if the hard frame pointer has been set up.  */
+   to LIMIT to the stack.  The stack pointer is currently BYTES_BELOW_SP
+   bytes above the bottom of the static frame.  Skip any write-back
+   candidates if SKIP_WB is true.  HARD_FP_VALID_P is true if the hard
+   frame pointer has been set up.  */
 
 static void
-aarch64_save_callee_saves (poly_int64 start_offset,
+aarch64_save_callee_saves (poly_int64 bytes_below_sp,
 			   unsigned start, unsigned limit, bool skip_wb,
 			   bool hard_fp_valid_p)
 {
+  aarch64_frame &frame = cfun->machine->frame;
   rtx_insn *insn;
   unsigned regno;
   unsigned regno2;
@@ -7963,8 +8078,8 @@ aarch64_save_callee_saves (poly_int64 start_offset,
       bool frame_related_p = aarch64_emit_cfi_for_reg_p (regno);
 
       if (skip_wb
-	  && (regno == cfun->machine->frame.wb_candidate1
-	      || regno == cfun->machine->frame.wb_candidate2))
+	  && (regno == frame.wb_candidate1
+	      || regno == frame.wb_candidate2))
 	continue;
 
       if (cfun->machine->reg_is_wrapped_separately[regno])
@@ -7972,7 +8087,7 @@ aarch64_save_callee_saves (poly_int64 start_offset,
 
       machine_mode mode = aarch64_reg_save_mode (regno);
       reg = gen_rtx_REG (mode, regno);
-      offset = start_offset + cfun->machine->frame.reg_offset[regno];
+      offset = frame.reg_offset[regno] - bytes_below_sp;
       rtx base_rtx = stack_pointer_rtx;
       poly_int64 sp_offset = offset;
 
@@ -7983,9 +8098,7 @@ aarch64_save_callee_saves (poly_int64 start_offset,
       else if (GP_REGNUM_P (regno)
 	       && (!offset.is_constant (&const_offset) || const_offset >= 512))
 	{
-	  gcc_assert (known_eq (start_offset, 0));
-	  poly_int64 fp_offset
-	    = cfun->machine->frame.below_hard_fp_saved_regs_size;
+	  poly_int64 fp_offset = frame.bytes_below_hard_fp - bytes_below_sp;
 	  if (hard_fp_valid_p)
 	    base_rtx = hard_frame_pointer_rtx;
 	  else
@@ -8007,8 +8120,7 @@ aarch64_save_callee_saves (poly_int64 start_offset,
 	  && (regno2 = aarch64_next_callee_save (regno + 1, limit)) <= limit
 	  && !cfun->machine->reg_is_wrapped_separately[regno2]
 	  && known_eq (GET_MODE_SIZE (mode),
-		       cfun->machine->frame.reg_offset[regno2]
-		       - cfun->machine->frame.reg_offset[regno]))
+		       frame.reg_offset[regno2] - frame.reg_offset[regno]))
 	{
 	  rtx reg2 = gen_rtx_REG (mode, regno2);
 	  rtx mem2;
@@ -8050,14 +8162,16 @@ aarch64_save_callee_saves (poly_int64 start_offset,
 }
 
 /* Emit code to restore the callee registers from register number START
-   up to and including LIMIT.  Restore from the stack offset START_OFFSET,
-   skipping any write-back candidates if SKIP_WB is true.  Write the
-   appropriate REG_CFA_RESTORE notes into CFI_OPS.  */
+   up to and including LIMIT.  The stack pointer is currently BYTES_BELOW_SP
+   bytes above the bottom of the static frame.  Skip any write-back
+   candidates if SKIP_WB is true.  Write the appropriate REG_CFA_RESTORE
+   notes into CFI_OPS.  */
 
 static void
-aarch64_restore_callee_saves (poly_int64 start_offset, unsigned start,
+aarch64_restore_callee_saves (poly_int64 bytes_below_sp, unsigned start,
 			      unsigned limit, bool skip_wb, rtx *cfi_ops)
 {
+  aarch64_frame &frame = cfun->machine->frame;
   unsigned regno;
   unsigned regno2;
   poly_int64 offset;
@@ -8074,13 +8188,13 @@ aarch64_restore_callee_saves (poly_int64 start_offset, unsigned start,
       rtx reg, mem;
 
       if (skip_wb
-	  && (regno == cfun->machine->frame.wb_candidate1
-	      || regno == cfun->machine->frame.wb_candidate2))
+	  && (regno == frame.wb_candidate1
+	      || regno == frame.wb_candidate2))
 	continue;
 
       machine_mode mode = aarch64_reg_save_mode (regno);
       reg = gen_rtx_REG (mode, regno);
-      offset = start_offset + cfun->machine->frame.reg_offset[regno];
+      offset = frame.reg_offset[regno] - bytes_below_sp;
       rtx base_rtx = stack_pointer_rtx;
       if (mode == VNx2DImode && BYTES_BIG_ENDIAN)
 	aarch64_adjust_sve_callee_save_base (mode, base_rtx, anchor_reg,
@@ -8091,8 +8205,7 @@ aarch64_restore_callee_saves (poly_int64 start_offset, unsigned start,
 	  && (regno2 = aarch64_next_callee_save (regno + 1, limit)) <= limit
 	  && !cfun->machine->reg_is_wrapped_separately[regno2]
 	  && known_eq (GET_MODE_SIZE (mode),
-		       cfun->machine->frame.reg_offset[regno2]
-		       - cfun->machine->frame.reg_offset[regno]))
+		       frame.reg_offset[regno2] - frame.reg_offset[regno]))
 	{
 	  rtx reg2 = gen_rtx_REG (mode, regno2);
 	  rtx mem2;
@@ -8197,6 +8310,7 @@ offset_12bit_unsigned_scaled_p (machine_mode mode, poly_int64 offset)
 static sbitmap
 aarch64_get_separate_components (void)
 {
+  aarch64_frame &frame = cfun->machine->frame;
   sbitmap components = sbitmap_alloc (LAST_SAVED_REGNUM + 1);
   bitmap_clear (components);
 
@@ -8213,20 +8327,11 @@ aarch64_get_separate_components (void)
 	if (mode == VNx2DImode && BYTES_BIG_ENDIAN)
 	  continue;
 
-	poly_int64 offset = cfun->machine->frame.reg_offset[regno];
-
-	/* If the register is saved in the first SVE save slot, we use
-	   it as a stack probe for -fstack-clash-protection.  */
-	if (flag_stack_clash_protection
-	    && maybe_ne (cfun->machine->frame.below_hard_fp_saved_regs_size, 0)
-	    && known_eq (offset, 0))
-	  continue;
+	poly_int64 offset = frame.reg_offset[regno];
 
 	/* Get the offset relative to the register we'll use.  */
 	if (frame_pointer_needed)
-	  offset -= cfun->machine->frame.below_hard_fp_saved_regs_size;
-	else
-	  offset += crtl->outgoing_args_size;
+	  offset -= frame.bytes_below_hard_fp;
 
 	/* Check that we can access the stack slot of the register with one
 	   direct load with no adjustments needed.  */
@@ -8243,11 +8348,11 @@ aarch64_get_separate_components (void)
   /* If the spare predicate register used by big-endian SVE code
      is call-preserved, it must be saved in the main prologue
      before any saves that use it.  */
-  if (cfun->machine->frame.spare_pred_reg != INVALID_REGNUM)
-    bitmap_clear_bit (components, cfun->machine->frame.spare_pred_reg);
+  if (frame.spare_pred_reg != INVALID_REGNUM)
+    bitmap_clear_bit (components, frame.spare_pred_reg);
 
-  unsigned reg1 = cfun->machine->frame.wb_candidate1;
-  unsigned reg2 = cfun->machine->frame.wb_candidate2;
+  unsigned reg1 = frame.wb_candidate1;
+  unsigned reg2 = frame.wb_candidate2;
   /* If registers have been chosen to be stored/restored with
      writeback don't interfere with them to avoid having to output explicit
      stack adjustment instructions.  */
@@ -8258,6 +8363,13 @@ aarch64_get_separate_components (void)
 
   bitmap_clear_bit (components, LR_REGNUM);
   bitmap_clear_bit (components, SP_REGNUM);
+  if (flag_stack_clash_protection)
+    {
+      if (frame.sve_save_and_probe != INVALID_REGNUM)
+	bitmap_clear_bit (components, frame.sve_save_and_probe);
+      if (frame.hard_fp_save_and_probe != INVALID_REGNUM)
+	bitmap_clear_bit (components, frame.hard_fp_save_and_probe);
+    }
 
   return components;
 }
@@ -8356,6 +8468,7 @@ aarch64_get_next_set_bit (sbitmap bmp, unsigned int start)
 static void
 aarch64_process_components (sbitmap components, bool prologue_p)
 {
+  aarch64_frame &frame = cfun->machine->frame;
   rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed
 			     ? HARD_FRAME_POINTER_REGNUM
 			     : STACK_POINTER_REGNUM);
@@ -8370,11 +8483,9 @@ aarch64_process_components (sbitmap components, bool prologue_p)
       machine_mode mode = aarch64_reg_save_mode (regno);
       
       rtx reg = gen_rtx_REG (mode, regno);
-      poly_int64 offset = cfun->machine->frame.reg_offset[regno];
+      poly_int64 offset = frame.reg_offset[regno];
       if (frame_pointer_needed)
-	offset -= cfun->machine->frame.below_hard_fp_saved_regs_size;
-      else
-	offset += crtl->outgoing_args_size;
+	offset -= frame.bytes_below_hard_fp;
 
       rtx addr = plus_constant (Pmode, ptr_reg, offset);
       rtx mem = gen_frame_mem (mode, addr);
@@ -8397,14 +8508,14 @@ aarch64_process_components (sbitmap components, bool prologue_p)
 	  break;
 	}
 
-      poly_int64 offset2 = cfun->machine->frame.reg_offset[regno2];
+      poly_int64 offset2 = frame.reg_offset[regno2];
       /* The next register is not of the same class or its offset is not
 	 mergeable with the current one into a pair.  */
       if (aarch64_sve_mode_p (mode)
 	  || !satisfies_constraint_Ump (mem)
 	  || GP_REGNUM_P (regno) != GP_REGNUM_P (regno2)
 	  || (crtl->abi->id () == ARM_PCS_SIMD && FP_REGNUM_P (regno))
-	  || maybe_ne ((offset2 - cfun->machine->frame.reg_offset[regno]),
+	  || maybe_ne ((offset2 - frame.reg_offset[regno]),
 		       GET_MODE_SIZE (mode)))
 	{
 	  insn = emit_insn (set);
@@ -8426,9 +8537,7 @@ aarch64_process_components (sbitmap components, bool prologue_p)
       /* REGNO2 can be saved/restored in a pair with REGNO.  */
       rtx reg2 = gen_rtx_REG (mode, regno2);
       if (frame_pointer_needed)
-	offset2 -= cfun->machine->frame.below_hard_fp_saved_regs_size;
-      else
-	offset2 += crtl->outgoing_args_size;
+	offset2 -= frame.bytes_below_hard_fp;
       rtx addr2 = plus_constant (Pmode, ptr_reg, offset2);
       rtx mem2 = gen_frame_mem (mode, addr2);
       rtx set2 = prologue_p ? gen_rtx_SET (mem2, reg2)
@@ -8502,10 +8611,10 @@ aarch64_stack_clash_protection_alloca_probe_range (void)
    registers.  If POLY_SIZE is not large enough to require a probe this function
    will only adjust the stack.  When allocating the stack space
    FRAME_RELATED_P is then used to indicate if the allocation is frame related.
-   FINAL_ADJUSTMENT_P indicates whether we are allocating the outgoing
-   arguments.  If we are then we ensure that any allocation larger than the ABI
-   defined buffer needs a probe so that the invariant of having a 1KB buffer is
-   maintained.
+   FINAL_ADJUSTMENT_P indicates whether we are allocating the area below
+   the saved registers.  If we are then we ensure that any allocation
+   larger than the ABI defined buffer needs a probe so that the
+   invariant of having a 1KB buffer is maintained.
 
    We emit barriers after each stack adjustment to prevent optimizations from
    breaking the invariant that we never drop the stack more than a page.  This
@@ -8521,45 +8630,26 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,
 					bool frame_related_p,
 					bool final_adjustment_p)
 {
+  aarch64_frame &frame = cfun->machine->frame;
   HOST_WIDE_INT guard_size
     = 1 << param_stack_clash_protection_guard_size;
   HOST_WIDE_INT guard_used_by_caller = STACK_CLASH_CALLER_GUARD;
+  HOST_WIDE_INT byte_sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;
+  gcc_assert (multiple_p (poly_size, byte_sp_alignment));
   HOST_WIDE_INT min_probe_threshold
     = (final_adjustment_p
-       ? guard_used_by_caller
+       ? guard_used_by_caller + byte_sp_alignment
        : guard_size - guard_used_by_caller);
-  /* When doing the final adjustment for the outgoing arguments, take into
-     account any unprobed space there is above the current SP.  There are
-     two cases:
-
-     - When saving SVE registers below the hard frame pointer, we force
-       the lowest save to take place in the prologue before doing the final
-       adjustment (i.e. we don't allow the save to be shrink-wrapped).
-       This acts as a probe at SP, so there is no unprobed space.
-
-     - When there are no SVE register saves, we use the store of the link
-       register as a probe.  We can't assume that LR was saved at position 0
-       though, so treat any space below it as unprobed.  */
-  if (final_adjustment_p
-      && known_eq (cfun->machine->frame.below_hard_fp_saved_regs_size, 0))
-    {
-      poly_int64 lr_offset = cfun->machine->frame.reg_offset[LR_REGNUM];
-      if (known_ge (lr_offset, 0))
-	min_probe_threshold -= lr_offset.to_constant ();
-      else
-	gcc_assert (!flag_stack_clash_protection || known_eq (poly_size, 0));
-    }
-
-  poly_int64 frame_size = cfun->machine->frame.frame_size;
+  poly_int64 frame_size = frame.frame_size;
 
   /* We should always have a positive probe threshold.  */
   gcc_assert (min_probe_threshold > 0);
 
   if (flag_stack_clash_protection && !final_adjustment_p)
     {
-      poly_int64 initial_adjust = cfun->machine->frame.initial_adjust;
-      poly_int64 sve_callee_adjust = cfun->machine->frame.sve_callee_adjust;
-      poly_int64 final_adjust = cfun->machine->frame.final_adjust;
+      poly_int64 initial_adjust = frame.initial_adjust;
+      poly_int64 sve_callee_adjust = frame.sve_callee_adjust;
+      poly_int64 final_adjust = frame.final_adjust;
 
       if (known_eq (frame_size, 0))
 	{
@@ -8713,7 +8803,7 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,
   /* Handle any residuals.  Residuals of at least MIN_PROBE_THRESHOLD have to
      be probed.  This maintains the requirement that each page is probed at
      least once.  For initial probing we probe only if the allocation is
-     more than GUARD_SIZE - buffer, and for the outgoing arguments we probe
+     more than GUARD_SIZE - buffer, and below the saved registers we probe
      if the amount is larger than buffer.  GUARD_SIZE - buffer + buffer ==
      GUARD_SIZE.  This works that for any allocation that is large enough to
      trigger a probe here, we'll have at least one, and if they're not large
@@ -8723,16 +8813,12 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,
      are still safe.  */
   if (residual)
     {
-      HOST_WIDE_INT residual_probe_offset = guard_used_by_caller;
+      gcc_assert (guard_used_by_caller + byte_sp_alignment <= size);
+
       /* If we're doing final adjustments, and we've done any full page
 	 allocations then any residual needs to be probed.  */
       if (final_adjustment_p && rounded_size != 0)
 	min_probe_threshold = 0;
-      /* If doing a small final adjustment, we always probe at offset 0.
-	 This is done to avoid issues when LR is not at position 0 or when
-	 the final adjustment is smaller than the probing offset.  */
-      else if (final_adjustment_p && rounded_size == 0)
-	residual_probe_offset = 0;
 
       aarch64_sub_sp (temp1, temp2, residual, frame_related_p);
       if (residual >= min_probe_threshold)
@@ -8743,8 +8829,8 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,
 		     HOST_WIDE_INT_PRINT_DEC " bytes, probing will be required."
 		     "\n", residual);
 
-	    emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,
-					     residual_probe_offset));
+	  emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,
+					   guard_used_by_caller));
 	  emit_insn (gen_blockage ());
 	}
     }
@@ -8782,20 +8868,24 @@ aarch64_epilogue_uses (int regno)
 	|  for register varargs         |
 	|                               |
 	+-------------------------------+
-	|  local variables              | <-- frame_pointer_rtx
+	|  local variables (1)          | <-- frame_pointer_rtx
 	|                               |
 	+-------------------------------+
-	|  padding                      | \
-	+-------------------------------+  |
-	|  callee-saved registers       |  | frame.saved_regs_size
-	+-------------------------------+  |
-	|  LR'                          |  |
-	+-------------------------------+  |
-	|  FP'                          |  |
-	+-------------------------------+  |<- hard_frame_pointer_rtx (aligned)
-	|  SVE vector registers         |  | \
-	+-------------------------------+  |  | below_hard_fp_saved_regs_size
-	|  SVE predicate registers      | /  /
+	|  padding (1)                  |
+	+-------------------------------+
+	|  callee-saved registers       |
+	+-------------------------------+
+	|  LR'                          |
+	+-------------------------------+
+	|  FP'                          |
+	+-------------------------------+ <-- hard_frame_pointer_rtx (aligned)
+	|  SVE vector registers         |
+	+-------------------------------+
+	|  SVE predicate registers      |
+	+-------------------------------+
+	|  local variables (2)          |
+	+-------------------------------+
+	|  padding (2)                  |
 	+-------------------------------+
 	|  dynamic allocation           |
 	+-------------------------------+
@@ -8806,6 +8896,9 @@ aarch64_epilogue_uses (int regno)
 	+-------------------------------+
 	|                               | <-- stack_pointer_rtx (aligned)
 
+   The regions marked (1) and (2) are mutually exclusive.  (2) is used
+   when aarch64_save_regs_above_locals_p is true.
+
    Dynamic stack allocations via alloca() decrease stack_pointer_rtx
    but leave frame_pointer_rtx and hard_frame_pointer_rtx
    unchanged.
@@ -8820,8 +8913,8 @@ aarch64_epilogue_uses (int regno)
    When probing is needed, we emit a probe at the start of the prologue
    and every PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE bytes thereafter.
 
-   We have to track how much space has been allocated and the only stores
-   to the stack we track as implicit probes are the FP/LR stores.
+   We can also use register saves as probes.  These are stored in
+   sve_save_and_probe and hard_fp_save_and_probe.
 
    For outgoing arguments we probe if the size is larger than 1KB, such that
    the ABI specified buffer is maintained for the next callee.
@@ -8848,17 +8941,15 @@ aarch64_epilogue_uses (int regno)
 void
 aarch64_expand_prologue (void)
 {
-  poly_int64 frame_size = cfun->machine->frame.frame_size;
-  poly_int64 initial_adjust = cfun->machine->frame.initial_adjust;
-  HOST_WIDE_INT callee_adjust = cfun->machine->frame.callee_adjust;
-  poly_int64 final_adjust = cfun->machine->frame.final_adjust;
-  poly_int64 callee_offset = cfun->machine->frame.callee_offset;
-  poly_int64 sve_callee_adjust = cfun->machine->frame.sve_callee_adjust;
-  poly_int64 below_hard_fp_saved_regs_size
-    = cfun->machine->frame.below_hard_fp_saved_regs_size;
-  unsigned reg1 = cfun->machine->frame.wb_candidate1;
-  unsigned reg2 = cfun->machine->frame.wb_candidate2;
-  bool emit_frame_chain = cfun->machine->frame.emit_frame_chain;
+  aarch64_frame &frame = cfun->machine->frame;
+  poly_int64 frame_size = frame.frame_size;
+  poly_int64 initial_adjust = frame.initial_adjust;
+  HOST_WIDE_INT callee_adjust = frame.callee_adjust;
+  poly_int64 final_adjust = frame.final_adjust;
+  poly_int64 sve_callee_adjust = frame.sve_callee_adjust;
+  unsigned reg1 = frame.wb_candidate1;
+  unsigned reg2 = frame.wb_candidate2;
+  bool emit_frame_chain = frame.emit_frame_chain;
   rtx_insn *insn;
 
   if (flag_stack_clash_protection && known_eq (callee_adjust, 0))
@@ -8922,21 +9013,21 @@ aarch64_expand_prologue (void)
   if (callee_adjust != 0)
     aarch64_push_regs (reg1, reg2, callee_adjust);
 
-  /* The offset of the frame chain record (if any) from the current SP.  */
-  poly_int64 chain_offset = (initial_adjust + callee_adjust
-			     - cfun->machine->frame.hard_fp_offset);
-  gcc_assert (known_ge (chain_offset, 0));
-
-  /* The offset of the bottom of the save area from the current SP.  */
-  poly_int64 saved_regs_offset = chain_offset - below_hard_fp_saved_regs_size;
+  /* The offset of the current SP from the bottom of the static frame.  */
+  poly_int64 bytes_below_sp = frame_size - initial_adjust - callee_adjust;
 
   if (emit_frame_chain)
     {
+      /* The offset of the frame chain record (if any) from the current SP.  */
+      poly_int64 chain_offset = (initial_adjust + callee_adjust
+				 - frame.bytes_above_hard_fp);
+      gcc_assert (known_ge (chain_offset, 0));
+
       if (callee_adjust == 0)
 	{
 	  reg1 = R29_REGNUM;
 	  reg2 = R30_REGNUM;
-	  aarch64_save_callee_saves (saved_regs_offset, reg1, reg2,
+	  aarch64_save_callee_saves (bytes_below_sp, reg1, reg2,
 				     false, false);
 	}
       else
@@ -8961,8 +9052,7 @@ aarch64_expand_prologue (void)
 	     implicit.  */
 	  if (!find_reg_note (insn, REG_CFA_ADJUST_CFA, NULL_RTX))
 	    {
-	      rtx src = plus_constant (Pmode, stack_pointer_rtx,
-				       callee_offset);
+	      rtx src = plus_constant (Pmode, stack_pointer_rtx, chain_offset);
 	      add_reg_note (insn, REG_CFA_ADJUST_CFA,
 			    gen_rtx_SET (hard_frame_pointer_rtx, src));
 	    }
@@ -8977,7 +9067,7 @@ aarch64_expand_prologue (void)
       emit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));
     }
 
-  aarch64_save_callee_saves (saved_regs_offset, R0_REGNUM, R30_REGNUM,
+  aarch64_save_callee_saves (bytes_below_sp, R0_REGNUM, R30_REGNUM,
 			     callee_adjust != 0 || emit_frame_chain,
 			     emit_frame_chain);
   if (maybe_ne (sve_callee_adjust, 0))
@@ -8987,18 +9077,21 @@ aarch64_expand_prologue (void)
       aarch64_allocate_and_probe_stack_space (tmp1_rtx, tmp0_rtx,
 					      sve_callee_adjust,
 					      !frame_pointer_needed, false);
-      saved_regs_offset += sve_callee_adjust;
+      bytes_below_sp -= sve_callee_adjust;
     }
-  aarch64_save_callee_saves (saved_regs_offset, P0_REGNUM, P15_REGNUM,
+  aarch64_save_callee_saves (bytes_below_sp, P0_REGNUM, P15_REGNUM,
 			     false, emit_frame_chain);
-  aarch64_save_callee_saves (saved_regs_offset, V0_REGNUM, V31_REGNUM,
+  aarch64_save_callee_saves (bytes_below_sp, V0_REGNUM, V31_REGNUM,
 			     callee_adjust != 0 || emit_frame_chain,
 			     emit_frame_chain);
 
   /* We may need to probe the final adjustment if it is larger than the guard
      that is assumed by the called.  */
+  gcc_assert (known_eq (bytes_below_sp, final_adjust));
   aarch64_allocate_and_probe_stack_space (tmp1_rtx, tmp0_rtx, final_adjust,
 					  !frame_pointer_needed, true);
+  if (emit_frame_chain && maybe_ne (final_adjust, 0))
+    emit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));
 }
 
 /* Return TRUE if we can use a simple_return insn.
@@ -9027,15 +9120,14 @@ aarch64_use_return_insn_p (void)
 void
 aarch64_expand_epilogue (bool for_sibcall)
 {
-  poly_int64 initial_adjust = cfun->machine->frame.initial_adjust;
-  HOST_WIDE_INT callee_adjust = cfun->machine->frame.callee_adjust;
-  poly_int64 final_adjust = cfun->machine->frame.final_adjust;
-  poly_int64 callee_offset = cfun->machine->frame.callee_offset;
-  poly_int64 sve_callee_adjust = cfun->machine->frame.sve_callee_adjust;
-  poly_int64 below_hard_fp_saved_regs_size
-    = cfun->machine->frame.below_hard_fp_saved_regs_size;
-  unsigned reg1 = cfun->machine->frame.wb_candidate1;
-  unsigned reg2 = cfun->machine->frame.wb_candidate2;
+  aarch64_frame &frame = cfun->machine->frame;
+  poly_int64 initial_adjust = frame.initial_adjust;
+  HOST_WIDE_INT callee_adjust = frame.callee_adjust;
+  poly_int64 final_adjust = frame.final_adjust;
+  poly_int64 sve_callee_adjust = frame.sve_callee_adjust;
+  poly_int64 bytes_below_hard_fp = frame.bytes_below_hard_fp;
+  unsigned reg1 = frame.wb_candidate1;
+  unsigned reg2 = frame.wb_candidate2;
   rtx cfi_ops = NULL;
   rtx_insn *insn;
   /* A stack clash protection prologue may not have left EP0_REGNUM or
@@ -9068,7 +9160,7 @@ aarch64_expand_epilogue (bool for_sibcall)
   /* We need to add memory barrier to prevent read from deallocated stack.  */
   bool need_barrier_p
     = maybe_ne (get_frame_size ()
-		+ cfun->machine->frame.saved_varargs_size, 0);
+		+ frame.saved_varargs_size, 0);
 
   /* Emit a barrier to prevent loads from a deallocated stack.  */
   if (maybe_gt (final_adjust, crtl->outgoing_args_size)
@@ -9089,7 +9181,7 @@ aarch64_expand_epilogue (bool for_sibcall)
        is restored on the instruction doing the writeback.  */
     aarch64_add_offset (Pmode, stack_pointer_rtx,
 			hard_frame_pointer_rtx,
-			-callee_offset - below_hard_fp_saved_regs_size,
+			-bytes_below_hard_fp + final_adjust,
 			tmp1_rtx, tmp0_rtx, callee_adjust == 0);
   else
      /* The case where we need to re-use the register here is very rare, so
@@ -9099,13 +9191,13 @@ aarch64_expand_epilogue (bool for_sibcall)
 
   /* Restore the vector registers before the predicate registers,
      so that we can use P4 as a temporary for big-endian SVE frames.  */
-  aarch64_restore_callee_saves (callee_offset, V0_REGNUM, V31_REGNUM,
+  aarch64_restore_callee_saves (final_adjust, V0_REGNUM, V31_REGNUM,
 				callee_adjust != 0, &cfi_ops);
-  aarch64_restore_callee_saves (callee_offset, P0_REGNUM, P15_REGNUM,
+  aarch64_restore_callee_saves (final_adjust, P0_REGNUM, P15_REGNUM,
 				false, &cfi_ops);
   if (maybe_ne (sve_callee_adjust, 0))
     aarch64_add_sp (NULL_RTX, NULL_RTX, sve_callee_adjust, true);
-  aarch64_restore_callee_saves (callee_offset - sve_callee_adjust,
+  aarch64_restore_callee_saves (final_adjust + sve_callee_adjust,
 				R0_REGNUM, R30_REGNUM,
 				callee_adjust != 0, &cfi_ops);
 
@@ -11699,24 +11791,24 @@ aarch64_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)
 poly_int64
 aarch64_initial_elimination_offset (unsigned from, unsigned to)
 {
+  aarch64_frame &frame = cfun->machine->frame;
+
   if (to == HARD_FRAME_POINTER_REGNUM)
     {
       if (from == ARG_POINTER_REGNUM)
-	return cfun->machine->frame.hard_fp_offset;
+	return frame.bytes_above_hard_fp;
 
       if (from == FRAME_POINTER_REGNUM)
-	return cfun->machine->frame.hard_fp_offset
-	       - cfun->machine->frame.locals_offset;
+	return frame.bytes_above_hard_fp - frame.bytes_above_locals;
     }
 
   if (to == STACK_POINTER_REGNUM)
     {
       if (from == FRAME_POINTER_REGNUM)
-	  return cfun->machine->frame.frame_size
-		 - cfun->machine->frame.locals_offset;
+	return frame.frame_size - frame.bytes_above_locals;
     }
 
-  return cfun->machine->frame.frame_size;
+  return frame.frame_size;
 }
 
 
@@ -21508,30 +21600,56 @@ aarch64_declare_function_name (FILE *stream, const char* name,
   cfun->machine->label_is_assembled = true;
 }
 
-/* Implement PRINT_PATCHABLE_FUNCTION_ENTRY.  Check if the patch area is after
-   the function label and emit a BTI if necessary.  */
+/* Implement PRINT_PATCHABLE_FUNCTION_ENTRY.  */
 
 void
 aarch64_print_patchable_function_entry (FILE *file,
 					unsigned HOST_WIDE_INT patch_area_size,
 					bool record_p)
 {
-  if (cfun->machine->label_is_assembled
-      && aarch64_bti_enabled ()
-      && !cgraph_node::get (cfun->decl)->only_called_directly_p ())
+  if (!cfun->machine->label_is_assembled)
     {
-      /* Remove the BTI that follows the patch area and insert a new BTI
-	 before the patch area right after the function label.  */
-      rtx_insn *insn = next_real_nondebug_insn (get_insns ());
-      if (insn
-	  && INSN_P (insn)
-	  && GET_CODE (PATTERN (insn)) == UNSPEC_VOLATILE
-	  && XINT (PATTERN (insn), 1) == UNSPECV_BTI_C)
-	delete_insn (insn);
-      asm_fprintf (file, "\thint\t34 // bti c\n");
+      /* Emit the patching area before the entry label, if any.  */
+      default_print_patchable_function_entry (file, patch_area_size,
+					      record_p);
+      return;
     }
 
-  default_print_patchable_function_entry (file, patch_area_size, record_p);
+  rtx pa = gen_patchable_area (GEN_INT (patch_area_size),
+			       GEN_INT (record_p));
+  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;
+
+  if (!aarch64_bti_enabled ()
+      || cgraph_node::get (cfun->decl)->only_called_directly_p ())
+    {
+      /* Emit the patchable_area at the beginning of the function.  */
+      rtx_insn *insn = emit_insn_before (pa, BB_HEAD (bb));
+      INSN_ADDRESSES_NEW (insn, -1);
+      return;
+    }
+
+  rtx_insn *insn = next_real_nondebug_insn (get_insns ());
+  if (!insn
+      || !INSN_P (insn)
+      || GET_CODE (PATTERN (insn)) != UNSPEC_VOLATILE
+      || XINT (PATTERN (insn), 1) != UNSPECV_BTI_C)
+    {
+      /* Emit a BTI_C.  */
+      insn = emit_insn_before (gen_bti_c (), BB_HEAD (bb));
+    }
+
+  /* Emit the patchable_area after BTI_C.  */
+  insn = emit_insn_after (pa, insn);
+  INSN_ADDRESSES_NEW (insn, -1);
+}
+
+/* Output patchable area.  */
+
+void
+aarch64_output_patchable_area (unsigned int patch_area_size, bool record_p)
+{
+  default_print_patchable_function_entry (asm_out_file, patch_area_size,
+					  record_p);
 }
 
 /* Implement ASM_OUTPUT_DEF_FROM_DECLS.  Output .variant_pcs for aliases.  */
@@ -21627,14 +21745,14 @@ aarch64_emit_unlikely_jump (rtx insn)
   add_reg_br_prob_note (jump, profile_probability::very_unlikely ());
 }
 
-/* We store the names of the various atomic helpers in a 5x4 array.
+/* We store the names of the various atomic helpers in a 5x5 array.
    Return the libcall function given MODE, MODEL and NAMES.  */
 
 rtx
 aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
 			const atomic_ool_names *names)
 {
-  memmodel model = memmodel_base (INTVAL (model_rtx));
+  memmodel model = memmodel_from_int (INTVAL (model_rtx));
   int mode_idx, model_idx;
 
   switch (mode)
@@ -21674,6 +21792,11 @@ aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
     case MEMMODEL_SEQ_CST:
       model_idx = 3;
       break;
+    case MEMMODEL_SYNC_ACQUIRE:
+    case MEMMODEL_SYNC_RELEASE:
+    case MEMMODEL_SYNC_SEQ_CST:
+      model_idx = 4;
+      break;
     default:
       gcc_unreachable ();
     }
@@ -21686,7 +21809,8 @@ aarch64_atomic_ool_func(machine_mode mode, rtx model_rtx,
   { "__aarch64_" #B #N "_relax", \
     "__aarch64_" #B #N "_acq", \
     "__aarch64_" #B #N "_rel", \
-    "__aarch64_" #B #N "_acq_rel" }
+    "__aarch64_" #B #N "_acq_rel", \
+    "__aarch64_" #B #N "_sync" }
 
 #define DEF4(B)  DEF0(B, 1), DEF0(B, 2), DEF0(B, 4), DEF0(B, 8), \
 		 { NULL, NULL, NULL, NULL }
@@ -24282,6 +24406,34 @@ aarch_macro_fusion_pair_p (rtx_insn *prev, rtx_insn *curr)
 	}
     }
 
+  /* Fuse A+B+1 and A-B-1 */
+  if (simple_sets_p
+      && aarch64_fusion_enabled_p (AARCH64_FUSE_ADDSUB_2REG_CONST1))
+    {
+      /* We're trying to match:
+	  prev == (set (r0) (plus (r0) (r1)))
+	  curr == (set (r0) (plus (r0) (const_int 1)))
+	or:
+	  prev == (set (r0) (minus (r0) (r1)))
+	  curr == (set (r0) (plus (r0) (const_int -1))) */
+
+      rtx prev_src = SET_SRC (prev_set);
+      rtx curr_src = SET_SRC (curr_set);
+
+      int polarity = 1;
+      if (GET_CODE (prev_src) == MINUS)
+	polarity = -1;
+
+      if (GET_CODE (curr_src) == PLUS
+	  && (GET_CODE (prev_src) == PLUS || GET_CODE (prev_src) == MINUS)
+	  && CONST_INT_P (XEXP (curr_src, 1))
+	  && INTVAL (XEXP (curr_src, 1)) == polarity
+	  && REG_P (XEXP (curr_src, 0))
+	  && REG_P (SET_DEST (prev_set))
+	  && REGNO (SET_DEST (prev_set)) == REGNO (XEXP (curr_src, 0)))
+	return true;
+    }
+
   return false;
 }
 
@@ -24469,6 +24621,12 @@ aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,
   enum reg_class rclass_1, rclass_2;
   rtx mem_1, mem_2, reg_1, reg_2, base_1, base_2, offset_1, offset_2;
 
+  /* Allow the tuning structure to disable LDP instruction formation
+     from combining instructions (e.g., in peephole2).  */
+  if (load && (aarch64_tune_params.extra_tuning_flags
+	       & AARCH64_EXTRA_TUNE_NO_LDP_COMBINE))
+    return false;
+
   if (load)
     {
       mem_1 = operands[1];
diff --git a/gcc/config/aarch64/aarch64.h b/gcc/config/aarch64/aarch64.h
index bfffbcd6abf..9084b1cfb9d 100644
--- a/gcc/config/aarch64/aarch64.h
+++ b/gcc/config/aarch64/aarch64.h
@@ -245,7 +245,8 @@ extern unsigned aarch64_architecture_version;
 #define AARCH64_FL_FOR_ARCH8_2			\
   (AARCH64_FL_FOR_ARCH8_1 | AARCH64_FL_V8_2)
 #define AARCH64_FL_FOR_ARCH8_3			\
-  (AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_V8_3 | AARCH64_FL_PAUTH)
+  (AARCH64_FL_FOR_ARCH8_2 | AARCH64_FL_V8_3 | AARCH64_FL_PAUTH \
+   | AARCH64_FL_RCPC)
 #define AARCH64_FL_FOR_ARCH8_4			\
   (AARCH64_FL_FOR_ARCH8_3 | AARCH64_FL_V8_4 | AARCH64_FL_F16FML \
    | AARCH64_FL_DOTPROD | AARCH64_FL_RCPC8_4 | AARCH64_FL_FLAGM)
@@ -282,6 +283,7 @@ extern unsigned aarch64_architecture_version;
 #define AARCH64_ISA_SM4	           (aarch64_isa_flags & AARCH64_FL_SM4)
 #define AARCH64_ISA_SHA3	   (aarch64_isa_flags & AARCH64_FL_SHA3)
 #define AARCH64_ISA_F16FML	   (aarch64_isa_flags & AARCH64_FL_F16FML)
+#define AARCH64_ISA_RCPC	   (aarch64_isa_flags & AARCH64_FL_RCPC)
 #define AARCH64_ISA_RCPC8_4	   (aarch64_isa_flags & AARCH64_FL_RCPC8_4)
 #define AARCH64_ISA_RNG		   (aarch64_isa_flags & AARCH64_FL_RNG)
 #define AARCH64_ISA_V8_5	   (aarch64_isa_flags & AARCH64_FL_V8_5)
@@ -824,6 +826,9 @@ extern enum aarch64_processor aarch64_tune;
 #ifdef HAVE_POLY_INT_H
 struct GTY (()) aarch64_frame
 {
+  /* The offset from the bottom of the static frame (the bottom of the
+     outgoing arguments) of each register save slot, or -2 if no save is
+     needed.  */
   poly_int64 reg_offset[LAST_SAVED_REGNUM + 1];
 
   /* The number of extra stack bytes taken up by register varargs.
@@ -832,25 +837,28 @@ struct GTY (()) aarch64_frame
      STACK_BOUNDARY.  */
   HOST_WIDE_INT saved_varargs_size;
 
-  /* The size of the callee-save registers with a slot in REG_OFFSET.  */
-  poly_int64 saved_regs_size;
+  /* The number of bytes between the bottom of the static frame (the bottom
+     of the outgoing arguments) and the bottom of the register save area.
+     This value is always a multiple of STACK_BOUNDARY.  */
+  poly_int64 bytes_below_saved_regs;
 
-  /* The size of the callee-save registers with a slot in REG_OFFSET that
-     are saved below the hard frame pointer.  */
-  poly_int64 below_hard_fp_saved_regs_size;
+  /* The number of bytes between the bottom of the static frame (the bottom
+     of the outgoing arguments) and the hard frame pointer.  This value is
+     always a multiple of STACK_BOUNDARY.  */
+  poly_int64 bytes_below_hard_fp;
 
-  /* Offset from the base of the frame (incomming SP) to the
-     top of the locals area.  This value is always a multiple of
+  /* The number of bytes between the top of the locals area and the top
+     of the frame (the incomming SP).  This value is always a multiple of
      STACK_BOUNDARY.  */
-  poly_int64 locals_offset;
+  poly_int64 bytes_above_locals;
 
-  /* Offset from the base of the frame (incomming SP) to the
-     hard_frame_pointer.  This value is always a multiple of
+  /* The number of bytes between the hard_frame_pointer and the top of
+     the frame (the incomming SP).  This value is always a multiple of
      STACK_BOUNDARY.  */
-  poly_int64 hard_fp_offset;
+  poly_int64 bytes_above_hard_fp;
 
-  /* The size of the frame.  This value is the offset from base of the
-     frame (incomming SP) to the stack_pointer.  This value is always
+  /* The size of the frame, i.e. the number of bytes between the bottom
+     of the outgoing arguments and the incoming SP.  This value is always
      a multiple of STACK_BOUNDARY.  */
   poly_int64 frame_size;
 
@@ -861,10 +869,6 @@ struct GTY (()) aarch64_frame
      It is zero when no push is used.  */
   HOST_WIDE_INT callee_adjust;
 
-  /* The offset from SP to the callee-save registers after initial_adjust.
-     It may be non-zero if no push is used (ie. callee_adjust == 0).  */
-  poly_int64 callee_offset;
-
   /* The size of the stack adjustment before saving or after restoring
      SVE registers.  */
   poly_int64 sve_callee_adjust;
@@ -900,6 +904,14 @@ struct GTY (()) aarch64_frame
      This is the register they should use.  */
   unsigned spare_pred_reg;
 
+  /* An SVE register that is saved below the hard frame pointer and that acts
+     as a probe for later allocations, or INVALID_REGNUM if none.  */
+  unsigned sve_save_and_probe;
+
+  /* A register that is saved at the hard frame pointer and that acts
+     as a probe for later allocations, or INVALID_REGNUM if none.  */
+  unsigned hard_fp_save_and_probe;
+
   bool laid_out;
 };
 
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index aef6da9732d..1cca0f5c79f 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -294,6 +294,7 @@
     UNSPEC_TAG_SPACE		; Translate address to MTE tag address space.
     UNSPEC_LD1RO
     UNSPEC_SALT_ADDR
+    UNSPECV_PATCHABLE_AREA
 ])
 
 (define_c_enum "unspecv" [
@@ -4762,7 +4763,7 @@
     rtx ccreg = aarch64_gen_compare_reg (EQ, operands[1], const0_rtx);
     rtx x = gen_rtx_NE (VOIDmode, ccreg, const0_rtx);
 
-    emit_insn (gen_rbit<mode>2 (operands[0], operands[1]));
+    emit_insn (gen_aarch64_rbit (<MODE>mode, operands[0], operands[1]));
     emit_insn (gen_clz<mode>2 (operands[0], operands[0]));
     emit_insn (gen_csinc3<mode>_insn (operands[0], x, operands[0], const0_rtx));
     DONE;
@@ -4808,7 +4809,7 @@
   [(set_attr "type" "clz")]
 )
 
-(define_insn "rbit<mode>2"
+(define_insn "@aarch64_rbit<mode>"
   [(set (match_operand:GPI 0 "register_operand" "=r")
 	(unspec:GPI [(match_operand:GPI 1 "register_operand" "r")] UNSPEC_RBIT))]
   ""
@@ -4829,7 +4830,7 @@
   "reload_completed"
   [(const_int 0)]
   "
-  emit_insn (gen_rbit<mode>2 (operands[0], operands[1]));
+  emit_insn (gen_aarch64_rbit (<MODE>mode, operands[0], operands[1]));
   emit_insn (gen_clz<mode>2 (operands[0], operands[0]));
   DONE;
 ")
@@ -5819,6 +5820,13 @@
   [(set_attr "type" "rev")]
 )
 
+(define_insn "@aarch64_rev16<mode>"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(unspec:GPI [(match_operand:GPI 1 "register_operand" "r")] UNSPEC_REV))]
+  ""
+  "rev16\\t%<w>0, %<w>1"
+  [(set_attr "type" "rev")])
+
 (define_insn "*aarch64_bfxil<mode>"
   [(set (match_operand:GPI 0 "register_operand" "=r,r")
     (ior:GPI (and:GPI (match_operand:GPI 1 "register_operand" "r,0")
@@ -7515,6 +7523,19 @@
   [(set_attr "type" "memtag")]
 )
 
+(define_insn "patchable_area"
+  [(unspec_volatile [(match_operand 0 "const_int_operand")
+		     (match_operand 1 "const_int_operand")]
+		    UNSPECV_PATCHABLE_AREA)]
+  ""
+{
+  aarch64_output_patchable_area (INTVAL (operands[0]),
+			         INTVAL (operands[1]) != 0);
+  return "";
+}
+  [(set (attr "length") (symbol_ref "INTVAL (operands[0])"))]
+)
+
 ;; AdvSIMD Stuff
 (include "aarch64-simd.md")
 
diff --git a/gcc/config/aarch64/arm_acle.h b/gcc/config/aarch64/arm_acle.h
index 73b29f4b8dc..2f419351706 100644
--- a/gcc/config/aarch64/arm_acle.h
+++ b/gcc/config/aarch64/arm_acle.h
@@ -28,11 +28,64 @@
 #define _GCC_ARM_ACLE_H
 
 #include <stdint.h>
+#include <stddef.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+#define _GCC_ARM_ACLE_ROR_FN(NAME, TYPE)				  \
+__extension__ extern __inline TYPE					  \
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))	  \
+NAME (TYPE __value, uint32_t __rotate)					  \
+{									  \
+  size_t __size = sizeof (TYPE) * __CHAR_BIT__;				  \
+  __rotate = __rotate % __size;						  \
+  return __value >> __rotate | __value << ((__size - __rotate) % __size); \
+}
+
+_GCC_ARM_ACLE_ROR_FN (__ror, uint32_t)
+_GCC_ARM_ACLE_ROR_FN (__rorl, unsigned long)
+_GCC_ARM_ACLE_ROR_FN (__rorll, uint64_t)
+
+#undef _GCC_ARM_ACLE_ROR_FN
+
+#define _GCC_ARM_ACLE_DATA_FN(NAME, BUILTIN, ITYPE, RTYPE)	    \
+__extension__ extern __inline RTYPE				    \
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__)) \
+__##NAME (ITYPE __value)					    \
+{								    \
+  return __builtin_##BUILTIN (__value);				    \
+}
+
+_GCC_ARM_ACLE_DATA_FN (clz, clz, uint32_t, unsigned int)
+_GCC_ARM_ACLE_DATA_FN (clzl, clzl, unsigned long, unsigned int)
+_GCC_ARM_ACLE_DATA_FN (clzll, clzll, uint64_t, unsigned int)
+_GCC_ARM_ACLE_DATA_FN (cls, clrsb, uint32_t, unsigned int)
+_GCC_ARM_ACLE_DATA_FN (clsl, clrsbl, unsigned long, unsigned int)
+_GCC_ARM_ACLE_DATA_FN (clsll, clrsbll, uint64_t, unsigned int)
+_GCC_ARM_ACLE_DATA_FN (rev16, aarch64_rev16, uint32_t, uint32_t)
+_GCC_ARM_ACLE_DATA_FN (rev16l, aarch64_rev16l, unsigned long, unsigned long)
+_GCC_ARM_ACLE_DATA_FN (rev16ll, aarch64_rev16ll, uint64_t, uint64_t)
+_GCC_ARM_ACLE_DATA_FN (rbit, aarch64_rbit, uint32_t, uint32_t)
+_GCC_ARM_ACLE_DATA_FN (rbitl, aarch64_rbitl, unsigned long, unsigned long)
+_GCC_ARM_ACLE_DATA_FN (rbitll, aarch64_rbitll, uint64_t, uint64_t)
+_GCC_ARM_ACLE_DATA_FN (revsh, bswap16, int16_t, int16_t)
+_GCC_ARM_ACLE_DATA_FN (rev, bswap32, uint32_t, uint32_t)
+_GCC_ARM_ACLE_DATA_FN (revll, bswap64, uint64_t, uint64_t)
+
+#undef _GCC_ARM_ACLE_DATA_FN
+
+__extension__ extern __inline unsigned long
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+__revl (unsigned long __value)
+{
+  if (sizeof (unsigned long) == 8)
+    return __revll (__value);
+  else
+    return __rev (__value);
+}
+
 #pragma GCC push_options
 #pragma GCC target ("arch=armv8.3-a")
 __extension__ static __inline int32_t __attribute__ ((__always_inline__))
diff --git a/gcc/config/aarch64/driver-aarch64.c b/gcc/config/aarch64/driver-aarch64.c
index e2935a11564..5505e117515 100644
--- a/gcc/config/aarch64/driver-aarch64.c
+++ b/gcc/config/aarch64/driver-aarch64.c
@@ -200,9 +200,9 @@ readline (FILE *f)
 	return std::string ();
       /* If we're not at the end of the line then override the
 	 \0 added by fgets.  */
-      last = strnlen (buf, size) - 1;
+      last = strnlen (buf, size);
     }
-  while (!feof (f) && buf[last] != '\n');
+  while (!feof (f) && last > 0 && buf[last - 1] != '\n');
 
   std::string result (buf);
   free (buf);
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index cac33ae812b..c9ec6265e7c 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -2764,6 +2764,8 @@
 
 (define_int_iterator SVE_BRK_UNARY [UNSPEC_BRKA UNSPEC_BRKB])
 
+(define_int_iterator SVE_BRKP [UNSPEC_BRKPA UNSPEC_BRKPB])
+
 (define_int_iterator SVE_BRK_BINARY [UNSPEC_BRKN UNSPEC_BRKPA UNSPEC_BRKPB])
 
 (define_int_iterator SVE_PITER [UNSPEC_PFIRST UNSPEC_PNEXT])
diff --git a/gcc/config/alpha/alpha-protos.h b/gcc/config/alpha/alpha-protos.h
index b2fa3d2fc11..13faf53fb05 100644
--- a/gcc/config/alpha/alpha-protos.h
+++ b/gcc/config/alpha/alpha-protos.h
@@ -73,6 +73,8 @@ extern void alpha_end_function (FILE *, const char *, tree);
 
 extern bool alpha_find_lo_sum_using_gp (rtx);
 
+extern int alpha_store_data_bypass_p (rtx_insn *, rtx_insn *);
+
 #ifdef REAL_VALUE_TYPE
 extern int check_float_value (machine_mode, REAL_VALUE_TYPE *, int);
 #endif
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
index 335f1db5335..9c05ce5a804 100644
--- a/gcc/config/alpha/alpha.c
+++ b/gcc/config/alpha/alpha.c
@@ -7564,6 +7564,75 @@ alpha_does_function_need_gp (void)
   return 0;
 }
 
+/* Helper function for alpha_store_data_bypass_p, handle just a single SET
+   IN_SET.  */
+
+static bool
+alpha_store_data_bypass_p_1 (rtx_insn *out_insn, rtx in_set)
+{
+  if (!MEM_P (SET_DEST (in_set)))
+    return false;
+
+  rtx out_set = single_set (out_insn);
+  if (out_set)
+    return !reg_mentioned_p (SET_DEST (out_set), SET_DEST (in_set));
+
+  rtx out_pat = PATTERN (out_insn);
+  if (GET_CODE (out_pat) != PARALLEL)
+    return false;
+
+  for (int i = 0; i < XVECLEN (out_pat, 0); i++)
+    {
+      rtx out_exp = XVECEXP (out_pat, 0, i);
+
+      if (GET_CODE (out_exp) == CLOBBER || GET_CODE (out_exp) == USE
+	  || GET_CODE (out_exp) == TRAP_IF)
+	continue;
+
+      gcc_assert (GET_CODE (out_exp) == SET);
+
+      if (reg_mentioned_p (SET_DEST (out_exp), SET_DEST (in_set)))
+	return false;
+    }
+
+  return true;
+}
+
+/* True if the dependency between OUT_INSN and IN_INSN is on the store
+   data not the address operand(s) of the store.  IN_INSN and OUT_INSN
+   must be either a single_set or a PARALLEL with SETs inside.
+
+   This alpha-specific version of store_data_bypass_p ignores TRAP_IF
+   that would result in assertion failure (and internal compiler error)
+   in the generic store_data_bypass_p function.  */
+
+int
+alpha_store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)
+{
+  rtx in_set = single_set (in_insn);
+  if (in_set)
+    return alpha_store_data_bypass_p_1 (out_insn, in_set);
+
+  rtx in_pat = PATTERN (in_insn);
+  if (GET_CODE (in_pat) != PARALLEL)
+    return false;
+
+  for (int i = 0; i < XVECLEN (in_pat, 0); i++)
+    {
+      rtx in_exp = XVECEXP (in_pat, 0, i);
+
+      if (GET_CODE (in_exp) == CLOBBER || GET_CODE (in_exp) == USE
+	  || GET_CODE (in_exp) == TRAP_IF)
+	continue;
+
+      gcc_assert (GET_CODE (in_exp) == SET);
+
+      if (!alpha_store_data_bypass_p_1 (out_insn, in_exp))
+	return false;
+    }
+
+  return true;
+}
 
 /* Helper function to set RTX_FRAME_RELATED_P on instructions, including
    sequences.  */
diff --git a/gcc/config/alpha/ev4.md b/gcc/config/alpha/ev4.md
index c22d0ba2903..2f70f1a6ffc 100644
--- a/gcc/config/alpha/ev4.md
+++ b/gcc/config/alpha/ev4.md
@@ -44,14 +44,7 @@
 ; Stores can issue before the data (but not address) is ready.
 (define_insn_reservation "ev4_ist" 1
   (and (eq_attr "tune" "ev4")
-       (eq_attr "type" "ist"))
-  "ev4_ib1+ev4_abox")
-
-; ??? Separate from ev4_ist because store_data_bypass_p can't handle
-; the patterns with multiple sets, like store-conditional.
-(define_insn_reservation "ev4_ist_c" 1
-  (and (eq_attr "tune" "ev4")
-       (eq_attr "type" "st_c"))
+       (eq_attr "type" "ist,st_c"))
   "ev4_ib1+ev4_abox")
 
 (define_insn_reservation "ev4_fst" 1
@@ -110,7 +103,7 @@
 (define_bypass 0
   "ev4_iaddlog,ev4_shiftcm,ev4_icmp"
   "ev4_ist"
-  "store_data_bypass_p")
+  "alpha_store_data_bypass_p")
 
 ; Multiplies use a non-pipelined imul unit.  Also, "no [ebox] insn can
 ; be issued exactly three cycles before an integer multiply completes".
@@ -121,7 +114,7 @@
 	    (eq_attr "opsize" "si")))
   "ev4_ib0+ev4_imul,ev4_imul*18,ev4_ebox")
 
-(define_bypass 20 "ev4_imulsi" "ev4_ist" "store_data_bypass_p")
+(define_bypass 20 "ev4_imulsi" "ev4_ist" "alpha_store_data_bypass_p")
 
 (define_insn_reservation "ev4_imuldi" 23
   (and (eq_attr "tune" "ev4")
@@ -129,7 +122,7 @@
 	    (eq_attr "opsize" "!si")))
   "ev4_ib0+ev4_imul,ev4_imul*20,ev4_ebox")
 
-(define_bypass 22 "ev4_imuldi" "ev4_ist" "store_data_bypass_p")
+(define_bypass 22 "ev4_imuldi" "ev4_ist" "alpha_store_data_bypass_p")
 
 ; Most FP insns have a 6 cycle latency, but with a 4 cycle bypass back in.
 (define_insn_reservation "ev4_fpop" 6
diff --git a/gcc/config/arm/arm-protos.h b/gcc/config/arm/arm-protos.h
index 08d152e67ac..d5dc40a7a90 100644
--- a/gcc/config/arm/arm-protos.h
+++ b/gcc/config/arm/arm-protos.h
@@ -122,6 +122,7 @@ extern int arm_coproc_mem_operand_wb (rtx, int);
 extern int neon_vector_mem_operand (rtx, int, bool);
 extern int mve_vector_mem_operand (machine_mode, rtx, bool);
 extern int neon_struct_mem_operand (rtx);
+extern int mve_struct_mem_operand (rtx);
 
 extern rtx *neon_vcmla_lane_prepare_operands (rtx *);
 
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
index 9e549285d0c..96d62b2164e 100644
--- a/gcc/config/arm/arm.c
+++ b/gcc/config/arm/arm.c
@@ -13532,6 +13532,24 @@ neon_vector_mem_operand (rtx op, int type, bool strict)
   return FALSE;
 }
 
+/* Return TRUE if OP is a mem suitable for loading/storing an MVE struct
+   type.  */
+int
+mve_struct_mem_operand (rtx op)
+{
+  rtx ind = XEXP (op, 0);
+
+  /* Match: (mem (reg)).  */
+  if (REG_P (ind))
+    return arm_address_register_rtx_p (ind, 0);
+
+  /* Allow only post-increment by the mode size.  */
+  if (GET_CODE (ind) == POST_INC)
+    return arm_address_register_rtx_p (XEXP (ind, 0), 0);
+
+  return FALSE;
+}
+
 /* Return TRUE if OP is a mem suitable for loading/storing a Neon struct
    type.  */
 int
@@ -15546,13 +15564,21 @@ gen_cpymem_ldrd_strd (rtx *operands)
     {
       len -= 8;
       reg0 = gen_reg_rtx (DImode);
-      rtx low_reg = NULL_RTX;
-      rtx hi_reg = NULL_RTX;
+      rtx first_reg = NULL_RTX;
+      rtx second_reg = NULL_RTX;
 
       if (!src_aligned || !dst_aligned)
 	{
-	  low_reg = gen_lowpart (SImode, reg0);
-	  hi_reg = gen_highpart_mode (SImode, DImode, reg0);
+	  if (BYTES_BIG_ENDIAN)
+	    {
+	      second_reg = gen_lowpart (SImode, reg0);
+	      first_reg = gen_highpart_mode (SImode, DImode, reg0);
+	    }
+	  else
+	    {
+	      first_reg = gen_lowpart (SImode, reg0);
+	      second_reg = gen_highpart_mode (SImode, DImode, reg0);
+	    }
 	}
       if (MEM_ALIGN (src) >= 2 * BITS_PER_WORD)
 	emit_move_insn (reg0, src);
@@ -15560,9 +15586,9 @@ gen_cpymem_ldrd_strd (rtx *operands)
 	emit_insn (gen_unaligned_loaddi (reg0, src));
       else
 	{
-	  emit_insn (gen_unaligned_loadsi (low_reg, src));
+	  emit_insn (gen_unaligned_loadsi (first_reg, src));
 	  src = next_consecutive_mem (src);
-	  emit_insn (gen_unaligned_loadsi (hi_reg, src));
+	  emit_insn (gen_unaligned_loadsi (second_reg, src));
 	}
 
       if (MEM_ALIGN (dst) >= 2 * BITS_PER_WORD)
@@ -15571,9 +15597,9 @@ gen_cpymem_ldrd_strd (rtx *operands)
 	emit_insn (gen_unaligned_storedi (dst, reg0));
       else
 	{
-	  emit_insn (gen_unaligned_storesi (dst, low_reg));
+	  emit_insn (gen_unaligned_storesi (dst, first_reg));
 	  dst = next_consecutive_mem (dst);
-	  emit_insn (gen_unaligned_storesi (dst, hi_reg));
+	  emit_insn (gen_unaligned_storesi (dst, second_reg));
 	}
 
       src = next_consecutive_mem (src);
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 5d3f21b91c4..6b833d2cc10 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -7466,7 +7466,7 @@
       && !arm_const_double_rtx (operands[1])
       && !(TARGET_VFP_DOUBLE && vfp3_const_double_rtx (operands[1])))
     {
-      rtx clobreg = gen_reg_rtx (DFmode);
+      rtx clobreg = gen_reg_rtx (DImode);
       emit_insn (gen_no_literal_pool_df_immediate (operands[0], operands[1],
 						   clobreg));
       DONE;
diff --git a/gcc/config/arm/constraints.md b/gcc/config/arm/constraints.md
index a5a19a7ed5b..c7b65701030 100644
--- a/gcc/config/arm/constraints.md
+++ b/gcc/config/arm/constraints.md
@@ -460,6 +460,11 @@
  (and (match_code "mem")
       (match_test "TARGET_32BIT && arm_coproc_mem_operand (op, FALSE)")))
 
+(define_memory_constraint "Ug"
+ "@internal
+  In Thumb-2 state a valid MVE struct load/store address."
+ (match_operand 0 "mve_struct_operand"))
+
 (define_memory_constraint "Uj"
  "@internal
   In ARM/Thumb-2 state a VFP load/store address that supports writeback
diff --git a/gcc/config/arm/mve.md b/gcc/config/arm/mve.md
index 5c11885fb73..1935813e474 100644
--- a/gcc/config/arm/mve.md
+++ b/gcc/config/arm/mve.md
@@ -92,7 +92,7 @@
 ;; [vst4q])
 ;;
 (define_insn "mve_vst4q<mode>"
-  [(set (match_operand:XI 0 "neon_struct_operand" "=Um")
+  [(set (match_operand:XI 0 "mve_struct_operand" "=Ug")
 	(unspec:XI [(match_operand:XI 1 "s_register_operand" "w")
 		    (unspec:MVE_VLD_ST [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	 VST4Q))
@@ -10312,7 +10312,7 @@
 ;; [vst2q])
 ;;
 (define_insn "mve_vst2q<mode>"
-  [(set (match_operand:OI 0 "neon_struct_operand" "=Um")
+  [(set (match_operand:OI 0 "mve_struct_operand" "=Ug")
 	(unspec:OI [(match_operand:OI 1 "s_register_operand" "w")
 		    (unspec:MVE_VLD_ST [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	 VST2Q))
@@ -10341,7 +10341,7 @@
 ;;
 (define_insn "mve_vld2q<mode>"
   [(set (match_operand:OI 0 "s_register_operand" "=w")
-	(unspec:OI [(match_operand:OI 1 "neon_struct_operand" "Um")
+	(unspec:OI [(match_operand:OI 1 "mve_struct_operand" "Ug")
 		    (unspec:MVE_VLD_ST [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	 VLD2Q))
   ]
@@ -10369,7 +10369,7 @@
 ;;
 (define_insn "mve_vld4q<mode>"
   [(set (match_operand:XI 0 "s_register_operand" "=w")
-	(unspec:XI [(match_operand:XI 1 "neon_struct_operand" "Um")
+	(unspec:XI [(match_operand:XI 1 "mve_struct_operand" "Ug")
 		    (unspec:MVE_VLD_ST [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]
 	 VLD4Q))
   ]
@@ -10822,7 +10822,7 @@
 )
 
 (define_insn "*movmisalign<mode>_mve_store"
-  [(set (match_operand:MVE_VLD_ST 0 "neon_permissive_struct_operand"	     "=Ux")
+  [(set (match_operand:MVE_VLD_ST 0 "mve_memory_operand"	     "=Ux")
 	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "s_register_operand" " w")]
 	 UNSPEC_MISALIGNED_ACCESS))]
   "((TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))
@@ -10835,7 +10835,7 @@
 
 (define_insn "*movmisalign<mode>_mve_load"
   [(set (match_operand:MVE_VLD_ST 0 "s_register_operand"				 "=w")
-	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "neon_permissive_struct_operand" " Ux")]
+	(unspec:MVE_VLD_ST [(match_operand:MVE_VLD_ST 1 "mve_memory_operand" " Ux")]
 	 UNSPEC_MISALIGNED_ACCESS))]
   "((TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))
     || (TARGET_HAVE_MVE_FLOAT && VALID_MVE_SF_MODE (<MODE>mode)))
diff --git a/gcc/config/arm/predicates.md b/gcc/config/arm/predicates.md
index c661f015fc5..4cc46142671 100644
--- a/gcc/config/arm/predicates.md
+++ b/gcc/config/arm/predicates.md
@@ -872,6 +872,10 @@
   (and (match_code "mem")
        (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 2, true)")))
 
+(define_predicate "mve_struct_operand"
+  (and (match_code "mem")
+       (match_test "TARGET_HAVE_MVE && mve_struct_mem_operand (op)")))
+
 (define_predicate "neon_permissive_struct_operand"
   (and (match_code "mem")
        (match_test "TARGET_32BIT && neon_vector_mem_operand (op, 2, false)")))
diff --git a/gcc/config/arm/vec-common.md b/gcc/config/arm/vec-common.md
index 9212937380f..581b05f845e 100644
--- a/gcc/config/arm/vec-common.md
+++ b/gcc/config/arm/vec-common.md
@@ -280,29 +280,81 @@
   DONE;
 })
 
-(define_expand "movmisalign<mode>"
- [(set (match_operand:VDQX 0 "neon_perm_struct_or_reg_operand")
-	(unspec:VDQX [(match_operand:VDQX 1 "neon_perm_struct_or_reg_operand")]
+(define_expand "@movmisalign<mode>"
+ [(set (match_operand:VDQX 0 "nonimmediate_operand")
+	(unspec:VDQX [(match_operand:VDQX 1 "general_operand")]
 	 UNSPEC_MISALIGNED_ACCESS))]
  "ARM_HAVE_<MODE>_LDST && !BYTES_BIG_ENDIAN
   && unaligned_access && !TARGET_REALLY_IWMMXT"
 {
- rtx adjust_mem;
- /* This pattern is not permitted to fail during expansion: if both arguments
-    are non-registers (e.g. memory := constant, which can be created by the
-    auto-vectorizer), force operand 1 into a register.  */
- if (!s_register_operand (operands[0], <MODE>mode)
-     && !s_register_operand (operands[1], <MODE>mode))
-   operands[1] = force_reg (<MODE>mode, operands[1]);
+  rtx *memloc;
+  bool for_store = false;
+  /* This pattern is not permitted to fail during expansion: if both arguments
+     are non-registers (e.g. memory := constant, which can be created by the
+     auto-vectorizer), force operand 1 into a register.  */
+  if (!s_register_operand (operands[0], <MODE>mode)
+      && !s_register_operand (operands[1], <MODE>mode))
+    operands[1] = force_reg (<MODE>mode, operands[1]);
 
- if (s_register_operand (operands[0], <MODE>mode))
-   adjust_mem = operands[1];
- else
-   adjust_mem = operands[0];
+  if (s_register_operand (operands[0], <MODE>mode))
+    memloc = &operands[1];
+  else
+    {
+      memloc = &operands[0];
+      for_store = true;
+    }
 
- /* Legitimize address.  */
- if (!neon_vector_mem_operand (adjust_mem, 2, true))
-   XEXP (adjust_mem, 0) = force_reg (Pmode, XEXP (adjust_mem, 0));
+  /* For MVE, vector loads/stores must be aligned to the element size.  If the
+     alignment is less than that convert the load/store to a suitable mode.  */
+  if (TARGET_HAVE_MVE
+      && (MEM_ALIGN (*memloc)
+	  < GET_MODE_ALIGNMENT (GET_MODE_INNER (<MODE>mode))))
+    {
+      scalar_mode new_smode;
+      switch (MEM_ALIGN (*memloc))
+	{
+	case 64:
+	case 32:
+	  new_smode = SImode;
+	  break;
+	case 16:
+	  new_smode = HImode;
+	  break;
+	default:
+	  new_smode = QImode;
+	  break;
+	}
+      machine_mode new_mode
+	= mode_for_vector (new_smode,
+			   GET_MODE_SIZE (<MODE>mode)
+			   / GET_MODE_SIZE (new_smode)).require ();
+      rtx new_mem = adjust_address (*memloc, new_mode, 0);
+
+      if (!for_store)
+	{
+	  rtx reg = gen_reg_rtx (new_mode);
+	  emit_insn (gen_movmisalign (new_mode, reg, new_mem));
+	  emit_move_insn (operands[0], gen_lowpart (<MODE>mode, reg));
+	  DONE;
+	}
+      emit_insn (gen_movmisalign (new_mode, new_mem,
+				  gen_lowpart (new_mode, operands[1])));
+      DONE;
+    }
+
+  /* Legitimize address.  */
+  if ((TARGET_HAVE_MVE
+       && !mve_vector_mem_operand (<MODE>mode, XEXP (*memloc, 0), false))
+      || (!TARGET_HAVE_MVE
+	  && !neon_vector_mem_operand (*memloc, 2, false)))
+    {
+      rtx new_mem
+	= replace_equiv_address (*memloc,
+				 force_reg (Pmode, XEXP (*memloc, 0)),
+				 false);
+      gcc_assert (MEM_ALIGN (new_mem) == MEM_ALIGN (*memloc));
+      *memloc = new_mem;
+    }
 })
 
 (define_insn "mve_vshlq_<supf><mode>"
diff --git a/gcc/config/arm/vfp.md b/gcc/config/arm/vfp.md
index c9f2f12b51e..374630d26f6 100644
--- a/gcc/config/arm/vfp.md
+++ b/gcc/config/arm/vfp.md
@@ -2128,7 +2128,7 @@
 (define_insn_and_split "no_literal_pool_df_immediate"
   [(set (match_operand:DF 0 "s_register_operand" "=w")
 	(match_operand:DF 1 "const_double_operand" "F"))
-   (clobber (match_operand:DF 2 "s_register_operand" "=r"))]
+   (clobber (match_operand:DI 2 "s_register_operand" "=r"))]
   "arm_disable_literal_pool
    && TARGET_VFP_BASE
    && !arm_const_double_rtx (operands[1])
@@ -2143,8 +2143,9 @@
   unsigned HOST_WIDE_INT ival = zext_hwi (buf[order], 32);
   ival |= (zext_hwi (buf[1 - order], 32) << 32);
   rtx cst = gen_int_mode (ival, DImode);
-  emit_move_insn (simplify_gen_subreg (DImode, operands[2], DFmode, 0), cst);
-  emit_move_insn (operands[0], operands[2]);
+  emit_move_insn (operands[2], cst);
+  emit_move_insn (operands[0],
+		  simplify_gen_subreg (DFmode, operands[2], DImode, 0));
   DONE;
 }
 )
diff --git a/gcc/config/darwin-c.c b/gcc/config/darwin-c.c
index 8b3dec25476..8c9c9171dec 100644
--- a/gcc/config/darwin-c.c
+++ b/gcc/config/darwin-c.c
@@ -691,7 +691,8 @@ macosx_version_as_macro (void)
   if (!version_array)
     goto fail;
 
-  if (version_array[MAJOR] < 10 || version_array[MAJOR] > 12)
+  /* System tools accept up to 99 as a major version.  */
+  if (version_array[MAJOR] < 10 || version_array[MAJOR] > 99)
     goto fail;
 
   if (version_array[MAJOR] == 10 && version_array[MINOR] < 10)
diff --git a/gcc/config/darwin-driver.c b/gcc/config/darwin-driver.c
index e48dd4559eb..61cbdff089f 100644
--- a/gcc/config/darwin-driver.c
+++ b/gcc/config/darwin-driver.c
@@ -64,7 +64,8 @@ validate_macosx_version_min (const char *version_str)
 
   major = strtoul (version_str, &end, 10);
 
-  if (major < 10 || major > 12 ) /* macOS 10, 11, and 12 are known. */
+  /* macOS 10, 11, and 12 are known. clang accepts up to 99.  */
+  if (major < 10 || major > 99)
     return NULL;
 
   /* Skip a separating period, if there's one.  */
@@ -159,20 +160,13 @@ darwin_find_version_from_kernel (void)
     goto parse_failed;
 
   /* Darwin20 sees a transition to macOS 11.  In this, it seems that the
-     mapping to macOS minor version is now shifted to the kernel minor
-     version - 1 (at least for the initial releases).  At this stage, we
-     don't know what macOS version will correspond to Darwin21.  */
+     mapping to macOS minor version and patch level is now always 0, 0
+     (at least for macOS 11 and 12).  */
   if (major_vers >= 20)
     {
-      int minor_vers = *version_p++ - '0';
-      if (ISDIGIT (*version_p))
-	minor_vers = minor_vers * 10 + (*version_p++ - '0');
-      if (*version_p++ != '.')
-	goto parse_failed;
-      if (minor_vers > 0)
-	minor_vers -= 1; /* Kernel 20.3 => macOS 11.2.  */
-      /* It's not yet clear whether patch level will be considered.  */
-      asprintf (&new_flag, "%d.%02d.00", major_vers - 9, minor_vers);
+      /* Apple clang doesn't include the minor version or the patch level
+	 in the object file, nor does it pass it to ld  */
+      asprintf (&new_flag, "%d.00.00", major_vers - 9);
     }
   else if (major_vers - 4 <= 4)
     /* On 10.4 and earlier, the old linker is used which does not
diff --git a/gcc/config/darwin.c b/gcc/config/darwin.c
index 0dc26a9f252..b79c0d1d2b4 100644
--- a/gcc/config/darwin.c
+++ b/gcc/config/darwin.c
@@ -2556,7 +2556,6 @@ darwin_emit_common (FILE *fp, const char *name,
     rounded = (size + (align-1)) & ~(align-1);
 
   l2align = floor_log2 (align);
-  gcc_assert (l2align <= L2_MAX_OFILE_ALIGNMENT);
 
   in_section = comm_section;
   /* We mustn't allow multiple public symbols to share an address when using
@@ -2707,6 +2706,10 @@ darwin_asm_output_aligned_decl_common (FILE *fp, tree decl, const char *name,
 #ifdef DEBUG_DARWIN_MEM_ALLOCATORS
 fprintf (fp, "# adcom: %s (%d,%d) decl=0x0\n", name, (int)size, (int)align);
 #endif
+     /* Common variables are limited to a maximum alignment of 2^15.  */
+      if (align > 32768)
+	error_at (UNKNOWN_LOCATION, "common variables must have an alignment"
+		  " of 32678 or less");
       darwin_emit_common (fp, name, size, align);
       return;
     }
@@ -2734,7 +2737,7 @@ fprintf (fp, "# adcom: %s (%lld,%d) ro %d cst %d stat %d com %d pub %d"
     }
 
   /* We shouldn't be messing with this if the decl has a section name.  */
-  gcc_assert (DECL_SECTION_NAME (decl) == NULL);
+  gcc_checking_assert (DECL_SECTION_NAME (decl) == NULL);
 
   /* We would rather not have to check this here - but it seems that we might
      be passed a decl that should be in coalesced space.  */
@@ -2763,10 +2766,16 @@ fprintf (fp, "# adcom: %s (%lld,%d) ro %d cst %d stat %d com %d pub %d"
 
   l2align = floor_log2 (align / BITS_PER_UNIT);
   /* Check we aren't asking for more aligment than the platform allows.  */
-  gcc_assert (l2align <= L2_MAX_OFILE_ALIGNMENT);
+  gcc_checking_assert (l2align <= L2_MAX_OFILE_ALIGNMENT);
 
   if (TREE_PUBLIC (decl) != 0)
-    darwin_emit_common (fp, name, size, align);
+    {
+      /* Common variables are limited to a maximum alignment of 2^15.  */
+      if (l2align > 15)
+	error_at (DECL_SOURCE_LOCATION (decl), "common variables must have"
+		  " an alignment of 32678 or less");
+      darwin_emit_common (fp, name, size, align);
+    }
   else
     darwin_emit_local_bss (fp, decl, name, size, l2align);
 }
diff --git a/gcc/config/darwin.h b/gcc/config/darwin.h
index 3206b70c7c2..504dfcec4da 100644
--- a/gcc/config/darwin.h
+++ b/gcc/config/darwin.h
@@ -141,10 +141,7 @@ extern GTY(()) int darwin_ms_struct;
    Right now there's no mechanism to split up the "variable portion" (%*) of
    the matched spec string, so where we have some driver specs that take 2
    or 3 arguments, these cannot be processed here, but are deferred until the
-   LINK_SPEC, where they are copied verbatim.
-   We have a "safe" version of the MacOS version string, that's been sanity-
-   checked and truncated to minor version.  If the 'tiny' (3rd) portion of the
-   value is not significant, it's better to use this in version-compare().  */
+   LINK_SPEC, where they are copied verbatim.  */
 
 #undef SUBTARGET_DRIVER_SELF_SPECS
 #define SUBTARGET_DRIVER_SELF_SPECS					\
@@ -218,13 +215,8 @@ extern GTY(()) int darwin_ms_struct;
   "%{image_base*:-Xlinker -image_base -Xlinker %*} %<image_base*",	\
   "%{init*:-Xlinker -init -Xlinker %*} %<init*",			\
   "%{multi_module:-Xlinker -multi_module} %<multi_module",		\
-  "%{multiply_defined*:-Xlinker -multiply_defined -Xlinker %*; \
-     :%{shared-libgcc: \
-       %:version-compare(< 10.5 asm_macosx_version_min= -Xlinker) \
-       %:version-compare(< 10.5 asm_macosx_version_min= -multiply_defined) \
-       %:version-compare(< 10.5 asm_macosx_version_min= -Xlinker) \
-       %:version-compare(< 10.5 asm_macosx_version_min= suppress)}} \
-     %<multiply_defined*",						\
+  "%{multiply_defined*:-Xlinker -multiply_defined -Xlinker %*} \
+     %<multiply_defined* ",						\
   "%{multiplydefinedunused*:\
      -Xlinker -multiply_defined_unused -Xlinker %*} \
      %<multiplydefinedunused* ",					\
@@ -445,12 +437,16 @@ extern GTY(()) int darwin_ms_struct;
                      %:replace-outfile(-lobjc libobjc-gnu.a%s); \
                     :%:replace-outfile(-lobjc -lobjc-gnu )}}\
    %{static|static-libgcc|static-libgfortran:%:replace-outfile(-lgfortran libgfortran.a%s)}\
+   %{static|static-libgcc|static-libphobos:%:replace-outfile(-lgphobos libgphobos.a%s)}\
    %{static|static-libgcc|static-libstdc++|static-libgfortran:%:replace-outfile(-lgomp libgomp.a%s)}\
    %{static|static-libgcc|static-libstdc++:%:replace-outfile(-lstdc++ libstdc++.a%s)}\
    %{force_cpusubtype_ALL:-arch %(darwin_arch)} \
    %{!force_cpusubtype_ALL:-arch %(darwin_subarch)} "\
    LINK_SYSROOT_SPEC \
   "%{mmacosx-version-min=*:-macosx_version_min %*} \
+   %{!multiply_defined*:%{shared-libgcc: \
+     %:version-compare(< 10.5 mmacosx-version-min= -multiply_defined) \
+     %:version-compare(< 10.5 mmacosx-version-min= suppress) }} \
    %{sectalign*} %{sectcreate*} %{sectobjectsymbols*}  %{sectorder*} \
    %{segaddr*} %{segcreate*} %{segprot*} "
 
@@ -867,13 +863,12 @@ int darwin_label_is_anonymous_local_objc_name (const char *name);
   if ((LOG) != 0)			\
     fprintf (FILE, "\t%s\t%d\n", ALIGN_ASM_OP, (LOG))
 
-/* The maximum alignment which the object file format can support in
-   bits.  For Mach-O, this is 2^15 bytes.  */
+/* The maximum alignment which the object file format can support in bits
+   which depends on the OS version and whether the object is a common
+   variable.  */
 
 #undef	MAX_OFILE_ALIGNMENT
-#define MAX_OFILE_ALIGNMENT (0x8000 * 8)
-
-#define L2_MAX_OFILE_ALIGNMENT 15
+#define MAX_OFILE_ALIGNMENT ((1U << L2_MAX_OFILE_ALIGNMENT) * 8U)
 
 /*  These are the three variants that emit referenced blank space.  */
 #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)		\
diff --git a/gcc/config/i386/avx512fintrin.h b/gcc/config/i386/avx512fintrin.h
index 515ee0c1728..1ce6bade1b4 100644
--- a/gcc/config/i386/avx512fintrin.h
+++ b/gcc/config/i386/avx512fintrin.h
@@ -3244,31 +3244,67 @@ _mm_maskz_scalef_round_ss (__mmask8 __U, __m128 __A, __m128 __B, const int __R)
 						      (__mmask8) __U, __R);
 }
 #else
-#define _mm512_scalef_round_pd(A, B, C)            \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_undefined_pd(), -1, C)
+#define _mm512_scalef_round_pd(A, B, C)					\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_undefined_pd(),	\
+				   -1, (C)))
 
-#define _mm512_mask_scalef_round_pd(W, U, A, B, C) \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, W, U, C)
+#define _mm512_mask_scalef_round_pd(W, U, A, B, C)			\
+  ((__m512d) __builtin_ia32_scalefpd512_mask((A), (B), (W), (U), (C)))
 
-#define _mm512_maskz_scalef_round_pd(U, A, B, C)   \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_setzero_pd(), U, C)
+#define _mm512_maskz_scalef_round_pd(U, A, B, C)			\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_setzero_pd(),	\
+				   (U), (C)))
 
-#define _mm512_scalef_round_ps(A, B, C)            \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_undefined_ps(), -1, C)
+#define _mm512_scalef_round_ps(A, B, C)					\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_undefined_ps(),	\
+				   -1, (C)))
 
-#define _mm512_mask_scalef_round_ps(W, U, A, B, C) \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, W, U, C)
+#define _mm512_mask_scalef_round_ps(W, U, A, B, C)			\
+  ((__m512) __builtin_ia32_scalefps512_mask((A), (B), (W), (U), (C)))
 
-#define _mm512_maskz_scalef_round_ps(U, A, B, C)   \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_setzero_ps(), U, C)
+#define _mm512_maskz_scalef_round_ps(U, A, B, C)			\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_setzero_ps(),	\
+				   (U), (C)))
 
-#define _mm_scalef_round_sd(A, B, C)            \
-    (__m128d)__builtin_ia32_scalefsd_mask_round (A, B, \
-	(__v2df)_mm_setzero_pd (), -1, C)
+#define _mm_scalef_round_sd(A, B, C)					\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_undefined_pd (),	\
+				       -1, (C)))
 
-#define _mm_scalef_round_ss(A, B, C)            \
-    (__m128)__builtin_ia32_scalefss_mask_round (A, B, \
-	(__v4sf)_mm_setzero_ps (), -1, C)
+#define _mm_scalef_round_ss(A, B, C)					\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_undefined_ps (),	\
+				       -1, (C)))
+
+#define _mm_mask_scalef_round_sd(W, U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B), (W), (U), (C)))
+
+#define _mm_mask_scalef_round_ss(W, U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B), (W), (U), (C)))
+
+#define _mm_maskz_scalef_round_sd(U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_setzero_pd (),	\
+				       (U), (C)))
+
+#define _mm_maskz_scalef_round_ss(U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_setzero_ps (),	\
+				       (U), (C)))
 #endif
 
 #define _mm_mask_scalef_sd(W, U, A, B) \
diff --git a/gcc/config/i386/cygwin.h b/gcc/config/i386/cygwin.h
index 71fb6135c2c..596379e3120 100644
--- a/gcc/config/i386/cygwin.h
+++ b/gcc/config/i386/cygwin.h
@@ -57,7 +57,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef ENDFILE_SPEC
 #define ENDFILE_SPEC \
-  "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s}\
+  "%{mdaz-ftz:crtfastmath.o%s;Ofast|ffast-math|funsafe-math-optimizations:%{!mno-daz-ftz:crtfastmath.o%s}} \
    %{!shared:%:if-exists(default-manifest.o%s)}\
    %{fvtable-verify=none:%s; \
     fvtable-verify=preinit:vtv_end.o%s; \
diff --git a/gcc/config/i386/darwin.h b/gcc/config/i386/darwin.h
index d4a7520240f..7c2211ffaff 100644
--- a/gcc/config/i386/darwin.h
+++ b/gcc/config/i386/darwin.h
@@ -123,7 +123,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef ENDFILE_SPEC
 #define ENDFILE_SPEC \
-  "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
+  "%{mdaz-ftz:crtfastmath.o%s;Ofast|ffast-math|funsafe-math-optimizations:%{!mno-daz-ftz:crtfastmath.o%s}} \
    %{mpc32:crtprec32.o%s} \
    %{mpc64:crtprec64.o%s} \
    %{mpc80:crtprec80.o%s}" TM_DESTRUCTOR
diff --git a/gcc/config/i386/gnu-user-common.h b/gcc/config/i386/gnu-user-common.h
index 00226f5a455..f776c796934 100644
--- a/gcc/config/i386/gnu-user-common.h
+++ b/gcc/config/i386/gnu-user-common.h
@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see
 
 /* Similar to standard GNU userspace, but adding -ffast-math support.  */
 #define GNU_USER_TARGET_MATHFILE_SPEC \
-  "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
+  "%{mdaz-ftz:crtfastmath.o%s;Ofast|ffast-math|funsafe-math-optimizations:%{!mno-daz-ftz:crtfastmath.o%s}} \
    %{mpc32:crtprec32.o%s} \
    %{mpc64:crtprec64.o%s} \
    %{mpc80:crtprec80.o%s}"
diff --git a/gcc/config/i386/i386-builtin.def b/gcc/config/i386/i386-builtin.def
index ea509c67ddb..5c7f436ac17 100644
--- a/gcc/config/i386/i386-builtin.def
+++ b/gcc/config/i386/i386-builtin.def
@@ -2742,30 +2742,30 @@ BDESC (0, OPTION_MASK_ISA2_VAES, CODE_FOR_vaesenclast_v64qi, "__builtin_ia32_vae
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v32hi, "__builtin_ia32_cvtne2ps2bf16_v32hi", IX86_BUILTIN_CVTNE2PS2HI16_V32HI, UNKNOWN, (int) V32HI_FTYPE_V16SF_V16SF)
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v32hi_mask, "__builtin_ia32_cvtne2ps2bf16_v32hi_mask", IX86_BUILTIN_CVTNE2PS2HI16_V32HI_MASK, UNKNOWN, (int) V32HI_FTYPE_V16SF_V16SF_V32HI_USI)
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v32hi_maskz, "__builtin_ia32_cvtne2ps2bf16_v32hi_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V32HI_MASKZ, UNKNOWN, (int) V32HI_FTYPE_V16SF_V16SF_USI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v16hi, "__builtin_ia32_cvtne2ps2bf16_v16hi", IX86_BUILTIN_CVTNE2PS2HI16_V16HI, UNKNOWN, (int) V16HI_FTYPE_V8SF_V8SF)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v16hi_mask, "__builtin_ia32_cvtne2ps2bf16_v16hi_mask", IX86_BUILTIN_CVTNE2PS2HI16_V16HI_MASK, UNKNOWN, (int) V16HI_FTYPE_V8SF_V8SF_V16HI_UHI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v16hi_maskz, "__builtin_ia32_cvtne2ps2bf16_v16hi_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V16HI_MASKZ, UNKNOWN, (int) V16HI_FTYPE_V8SF_V8SF_UHI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v8hi, "__builtin_ia32_cvtne2ps2bf16_v8hi", IX86_BUILTIN_CVTNE2PS2HI16_V8HI, UNKNOWN, (int) V8HI_FTYPE_V4SF_V4SF)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v8hi_mask, "__builtin_ia32_cvtne2ps2bf16_v8hi_mask", IX86_BUILTIN_CVTNE2PS2HI16_V8HI_MASK, UNKNOWN, (int) V8HI_FTYPE_V4SF_V4SF_V8HI_UQI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v8hi_maskz, "__builtin_ia32_cvtne2ps2bf16_v8hi_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V8HI_MASKZ, UNKNOWN, (int) V8HI_FTYPE_V4SF_V4SF_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v16hi, "__builtin_ia32_cvtne2ps2bf16_v16hi", IX86_BUILTIN_CVTNE2PS2HI16_V16HI, UNKNOWN, (int) V16HI_FTYPE_V8SF_V8SF)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v16hi_mask, "__builtin_ia32_cvtne2ps2bf16_v16hi_mask", IX86_BUILTIN_CVTNE2PS2HI16_V16HI_MASK, UNKNOWN, (int) V16HI_FTYPE_V8SF_V8SF_V16HI_UHI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v16hi_maskz, "__builtin_ia32_cvtne2ps2bf16_v16hi_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V16HI_MASKZ, UNKNOWN, (int) V16HI_FTYPE_V8SF_V8SF_UHI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v8hi, "__builtin_ia32_cvtne2ps2bf16_v8hi", IX86_BUILTIN_CVTNE2PS2HI16_V8HI, UNKNOWN, (int) V8HI_FTYPE_V4SF_V4SF)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v8hi_mask, "__builtin_ia32_cvtne2ps2bf16_v8hi_mask", IX86_BUILTIN_CVTNE2PS2HI16_V8HI_MASK, UNKNOWN, (int) V8HI_FTYPE_V4SF_V4SF_V8HI_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtne2ps2bf16_v8hi_maskz, "__builtin_ia32_cvtne2ps2bf16_v8hi_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V8HI_MASKZ, UNKNOWN, (int) V8HI_FTYPE_V4SF_V4SF_UQI)
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v16sf, "__builtin_ia32_cvtneps2bf16_v16sf", IX86_BUILTIN_CVTNEPS2HI16_V16SF, UNKNOWN, (int) V16HI_FTYPE_V16SF)
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v16sf_mask, "__builtin_ia32_cvtneps2bf16_v16sf_mask", IX86_BUILTIN_CVTNEPS2HI16_V16SF_MASK, UNKNOWN, (int) V16HI_FTYPE_V16SF_V16HI_UHI)
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v16sf_maskz, "__builtin_ia32_cvtneps2bf16_v16sf_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V16SF_MASKZ, UNKNOWN, (int) V16HI_FTYPE_V16SF_UHI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v8sf, "__builtin_ia32_cvtneps2bf16_v8sf", IX86_BUILTIN_CVTNEPS2HI16_V8SF, UNKNOWN, (int) V8HI_FTYPE_V8SF)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v8sf_mask, "__builtin_ia32_cvtneps2bf16_v8sf_mask", IX86_BUILTIN_CVTNEPS2HI16_V8SF_MASK, UNKNOWN, (int) V8HI_FTYPE_V8SF_V8HI_UQI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v8sf_maskz, "__builtin_ia32_cvtneps2bf16_v8sf_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V8SF_MASKZ, UNKNOWN, (int) V8HI_FTYPE_V8SF_UQI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v4sf, "__builtin_ia32_cvtneps2bf16_v4sf", IX86_BUILTIN_CVTNEPS2HI16_V4SF, UNKNOWN, (int) V8HI_FTYPE_V4SF)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v4sf_mask, "__builtin_ia32_cvtneps2bf16_v4sf_mask", IX86_BUILTIN_CVTNEPS2HI16_V4SF_MASK, UNKNOWN, (int) V8HI_FTYPE_V4SF_V8HI_UQI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v4sf_maskz, "__builtin_ia32_cvtneps2bf16_v4sf_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V4SF_MASKZ, UNKNOWN, (int) V8HI_FTYPE_V4SF_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v8sf, "__builtin_ia32_cvtneps2bf16_v8sf", IX86_BUILTIN_CVTNEPS2HI16_V8SF, UNKNOWN, (int) V8HI_FTYPE_V8SF)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v8sf_mask, "__builtin_ia32_cvtneps2bf16_v8sf_mask", IX86_BUILTIN_CVTNEPS2HI16_V8SF_MASK, UNKNOWN, (int) V8HI_FTYPE_V8SF_V8HI_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v8sf_maskz, "__builtin_ia32_cvtneps2bf16_v8sf_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V8SF_MASKZ, UNKNOWN, (int) V8HI_FTYPE_V8SF_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v4sf, "__builtin_ia32_cvtneps2bf16_v4sf", IX86_BUILTIN_CVTNEPS2HI16_V4SF, UNKNOWN, (int) V8HI_FTYPE_V4SF)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v4sf_mask, "__builtin_ia32_cvtneps2bf16_v4sf_mask", IX86_BUILTIN_CVTNEPS2HI16_V4SF_MASK, UNKNOWN, (int) V8HI_FTYPE_V4SF_V8HI_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_cvtneps2bf16_v4sf_maskz, "__builtin_ia32_cvtneps2bf16_v4sf_maskz", IX86_BUILTIN_CVTNE2PS2HI16_V4SF_MASKZ, UNKNOWN, (int) V8HI_FTYPE_V4SF_UQI)
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v16sf, "__builtin_ia32_dpbf16ps_v16sf", IX86_BUILTIN_DPHI16PS_V16SF, UNKNOWN, (int) V16SF_FTYPE_V16SF_V32HI_V32HI)
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v16sf_mask, "__builtin_ia32_dpbf16ps_v16sf_mask", IX86_BUILTIN_DPHI16PS_V16SF_MASK, UNKNOWN, (int) V16SF_FTYPE_V16SF_V32HI_V32HI_UHI)
 BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v16sf_maskz, "__builtin_ia32_dpbf16ps_v16sf_maskz", IX86_BUILTIN_DPHI16PS_V16SF_MASKZ, UNKNOWN, (int) V16SF_FTYPE_V16SF_V32HI_V32HI_UHI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v8sf, "__builtin_ia32_dpbf16ps_v8sf", IX86_BUILTIN_DPHI16PS_V8SF, UNKNOWN, (int) V8SF_FTYPE_V8SF_V16HI_V16HI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v8sf_mask, "__builtin_ia32_dpbf16ps_v8sf_mask", IX86_BUILTIN_DPHI16PS_V8SF_MASK, UNKNOWN, (int) V8SF_FTYPE_V8SF_V16HI_V16HI_UQI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v8sf_maskz, "__builtin_ia32_dpbf16ps_v8sf_maskz", IX86_BUILTIN_DPHI16PS_V8SF_MASKZ, UNKNOWN, (int) V8SF_FTYPE_V8SF_V16HI_V16HI_UQI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v4sf, "__builtin_ia32_dpbf16ps_v4sf", IX86_BUILTIN_DPHI16PS_V4SF, UNKNOWN, (int) V4SF_FTYPE_V4SF_V8HI_V8HI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v4sf_mask, "__builtin_ia32_dpbf16ps_v4sf_mask", IX86_BUILTIN_DPHI16PS_V4SF_MASK, UNKNOWN, (int) V4SF_FTYPE_V4SF_V8HI_V8HI_UQI)
-BDESC (0, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v4sf_maskz, "__builtin_ia32_dpbf16ps_v4sf_maskz", IX86_BUILTIN_DPHI16PS_V4SF_MASKZ, UNKNOWN, (int) V4SF_FTYPE_V4SF_V8HI_V8HI_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v8sf, "__builtin_ia32_dpbf16ps_v8sf", IX86_BUILTIN_DPHI16PS_V8SF, UNKNOWN, (int) V8SF_FTYPE_V8SF_V16HI_V16HI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v8sf_mask, "__builtin_ia32_dpbf16ps_v8sf_mask", IX86_BUILTIN_DPHI16PS_V8SF_MASK, UNKNOWN, (int) V8SF_FTYPE_V8SF_V16HI_V16HI_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v8sf_maskz, "__builtin_ia32_dpbf16ps_v8sf_maskz", IX86_BUILTIN_DPHI16PS_V8SF_MASKZ, UNKNOWN, (int) V8SF_FTYPE_V8SF_V16HI_V16HI_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v4sf, "__builtin_ia32_dpbf16ps_v4sf", IX86_BUILTIN_DPHI16PS_V4SF, UNKNOWN, (int) V4SF_FTYPE_V4SF_V8HI_V8HI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v4sf_mask, "__builtin_ia32_dpbf16ps_v4sf_mask", IX86_BUILTIN_DPHI16PS_V4SF_MASK, UNKNOWN, (int) V4SF_FTYPE_V4SF_V8HI_V8HI_UQI)
+BDESC (OPTION_MASK_ISA_AVX512VL, OPTION_MASK_ISA2_AVX512BF16, CODE_FOR_avx512f_dpbf16ps_v4sf_maskz, "__builtin_ia32_dpbf16ps_v4sf_maskz", IX86_BUILTIN_DPHI16PS_V4SF_MASKZ, UNKNOWN, (int) V4SF_FTYPE_V4SF_V8HI_V8HI_UQI)
 
 /* Builtins with rounding support.  */
 BDESC_END (ARGS, ROUND_ARGS)
diff --git a/gcc/config/i386/i386-expand.c b/gcc/config/i386/i386-expand.c
index 31eae75d277..d95adaf962b 100644
--- a/gcc/config/i386/i386-expand.c
+++ b/gcc/config/i386/i386-expand.c
@@ -11028,7 +11028,7 @@ ix86_expand_vec_set_builtin (tree exp)
   op1 = expand_expr (arg1, NULL_RTX, mode1, EXPAND_NORMAL);
   elt = get_element_number (TREE_TYPE (arg0), arg2);
 
-  if (GET_MODE (op1) != mode1 && GET_MODE (op1) != VOIDmode)
+  if (GET_MODE (op1) != mode1)
     op1 = convert_modes (mode1, GET_MODE (op1), op1, true);
 
   op0 = force_reg (tmode, op0);
diff --git a/gcc/config/i386/i386-features.c b/gcc/config/i386/i386-features.c
index 77783a154b6..19033dc3df5 100644
--- a/gcc/config/i386/i386-features.c
+++ b/gcc/config/i386/i386-features.c
@@ -1837,9 +1837,7 @@ ix86_add_reg_usage_to_vzerouppers (void)
 static unsigned int
 rest_of_handle_insert_vzeroupper (void)
 {
-  if (TARGET_VZEROUPPER
-      && flag_expensive_optimizations
-      && !optimize_size)
+  if (TARGET_VZEROUPPER)
     {
       /* vzeroupper instructions are inserted immediately after reload to
 	 account for possible spills from 256bit or 512bit registers.  The pass
@@ -1883,9 +1881,7 @@ public:
   virtual bool gate (function *)
     {
       return TARGET_AVX
-	     && ((TARGET_VZEROUPPER
-		  && flag_expensive_optimizations
-		  && !optimize_size)
+	     && (TARGET_VZEROUPPER
 		 || cfun->machine->has_explicit_vzeroupper);
     }
 
diff --git a/gcc/config/i386/i386-options.c b/gcc/config/i386/i386-options.c
index 19632b5fd6b..e3450345b5a 100644
--- a/gcc/config/i386/i386-options.c
+++ b/gcc/config/i386/i386-options.c
@@ -137,6 +137,11 @@ along with GCC; see the file COPYING3.  If not see
 #define m_GOLDMONT_PLUS (HOST_WIDE_INT_1U<<PROCESSOR_GOLDMONT_PLUS)
 #define m_TREMONT (HOST_WIDE_INT_1U<<PROCESSOR_TREMONT)
 #define m_INTEL (HOST_WIDE_INT_1U<<PROCESSOR_INTEL)
+/* Gather Data Sampling / CVE-2022-40982 / INTEL-SA-00828.
+   Software mitigation.  */
+#define m_GDS (m_SKYLAKE | m_SKYLAKE_AVX512 | m_CANNONLAKE \
+	       | m_ICELAKE_CLIENT | m_ICELAKE_SERVER | m_CASCADELAKE \
+	       | m_TIGERLAKE | m_COOPERLAKE | m_ROCKETLAKE)
 
 #define m_GEODE (HOST_WIDE_INT_1U<<PROCESSOR_GEODE)
 #define m_K6 (HOST_WIDE_INT_1U<<PROCESSOR_K6)
@@ -656,7 +661,6 @@ ix86_function_specific_save (struct cl_target_option *ptr,
   ptr->x_recip_mask_explicit = opts->x_recip_mask_explicit;
   ptr->x_ix86_arch_string = opts->x_ix86_arch_string;
   ptr->x_ix86_tune_string = opts->x_ix86_tune_string;
-  ptr->x_ix86_abi = opts->x_ix86_abi;
   ptr->x_ix86_asm_dialect = opts->x_ix86_asm_dialect;
   ptr->x_ix86_branch_cost = opts->x_ix86_branch_cost;
   ptr->x_ix86_dump_tunes = opts->x_ix86_dump_tunes;
@@ -787,7 +791,6 @@ ix86_function_specific_restore (struct gcc_options *opts,
   opts->x_recip_mask_explicit = ptr->x_recip_mask_explicit;
   opts->x_ix86_arch_string = ptr->x_ix86_arch_string;
   opts->x_ix86_tune_string = ptr->x_ix86_tune_string;
-  opts->x_ix86_abi = ptr->x_ix86_abi;
   opts->x_ix86_asm_dialect = ptr->x_ix86_asm_dialect;
   opts->x_ix86_branch_cost = ptr->x_ix86_branch_cost;
   opts->x_ix86_dump_tunes = ptr->x_ix86_dump_tunes;
@@ -2851,7 +2854,9 @@ ix86_option_override_internal (bool main_args_p,
     sorry ("%<-mcall-ms2sysv-xlogues%> isn%'t currently supported with SEH");
 
   if (!(opts_set->x_target_flags & MASK_VZEROUPPER)
-      && TARGET_EMIT_VZEROUPPER)
+      && TARGET_EMIT_VZEROUPPER
+      && flag_expensive_optimizations
+      && !optimize_size)
     opts->x_target_flags |= MASK_VZEROUPPER;
   if (!(opts_set->x_target_flags & MASK_STV))
     opts->x_target_flags |= MASK_STV;
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 48300af9a09..e9fcb0a16a6 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -3249,7 +3249,7 @@ ix86_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)
       if (POINTER_TYPE_P (arg.type))
 	{
 	  /* This is the pointer argument.  */
-	  gcc_assert (TYPE_MODE (arg.type) == Pmode);
+	  gcc_assert (TYPE_MODE (arg.type) == ptr_mode);
 	  /* It is at -WORD(AP) in the current frame in interrupt and
 	     exception handlers.  */
 	  reg = plus_constant (Pmode, arg_pointer_rtx, -UNITS_PER_WORD);
@@ -3607,7 +3607,7 @@ zero_call_used_regno_mode (const unsigned int regno)
   else if (MASK_REGNO_P (regno))
     return HImode;
   else if (MMX_REGNO_P (regno))
-    return V4HImode;
+    return V2SImode;
   else
     gcc_unreachable ();
 }
@@ -3726,19 +3726,12 @@ zero_all_mm_registers (HARD_REG_SET need_zeroed_hardregs,
   if (!need_zero_all_mm)
     return false;
 
-  rtx zero_mmx = NULL_RTX;
-  machine_mode mode = V4HImode;
+  machine_mode mode = V2SImode;
   for (unsigned int regno = FIRST_MMX_REG; regno <= LAST_MMX_REG; regno++)
     if (regno != ret_mmx_regno)
       {
 	rtx reg = gen_rtx_REG (mode, regno);
-	if (zero_mmx == NULL_RTX)
-	  {
-	    zero_mmx = reg;
-	    emit_insn (gen_rtx_SET (reg, CONST0_RTX (mode)));
-	  }
-	else
-	  emit_move_insn (reg, zero_mmx);
+	emit_insn (gen_rtx_SET (reg, CONST0_RTX (mode)));
       }
   return true;
 }
@@ -3800,11 +3793,6 @@ ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)
 
   /* Now, generate instructions to zero all the other registers.  */
 
-  rtx zero_gpr = NULL_RTX;
-  rtx zero_vector = NULL_RTX;
-  rtx zero_mask = NULL_RTX;
-  rtx zero_mmx = NULL_RTX;
-
   for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
     {
       if (!TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))
@@ -3815,59 +3803,34 @@ ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)
 
       SET_HARD_REG_BIT (zeroed_hardregs, regno);
 
-      rtx reg, tmp, zero_rtx;
       machine_mode mode = zero_call_used_regno_mode (regno);
 
-      reg = gen_rtx_REG (mode, regno);
-      zero_rtx = CONST0_RTX (mode);
+      rtx reg = gen_rtx_REG (mode, regno);
+      rtx tmp = gen_rtx_SET (reg, CONST0_RTX (mode));
 
-      if (mode == SImode)
-	if (zero_gpr == NULL_RTX)
-	  {
-	    zero_gpr = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    if (!TARGET_USE_MOV0 || optimize_insn_for_size_p ())
-	      {
-		rtx clob = gen_rtx_CLOBBER (VOIDmode,
-					    gen_rtx_REG (CCmode,
-							 FLAGS_REG));
-		tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
-							     tmp,
-							     clob));
-	      }
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_gpr);
-      else if (mode == V4SFmode)
-	if (zero_vector == NULL_RTX)
-	  {
-	    zero_vector = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_vector);
-      else if (mode == HImode)
-	if (zero_mask == NULL_RTX)
-	  {
-	    zero_mask = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_mask);
-      else if (mode == V4HImode)
-	if (zero_mmx == NULL_RTX)
-	  {
-	    zero_mmx = reg;
-	    tmp = gen_rtx_SET (reg, zero_rtx);
-	    emit_insn (tmp);
-	  }
-	else
-	  emit_move_insn (reg, zero_mmx);
-      else
-	gcc_unreachable ();
+      switch (mode)
+	{
+	case E_SImode:
+	  if (!TARGET_USE_MOV0 || optimize_insn_for_size_p ())
+	    {
+	      rtx clob = gen_rtx_CLOBBER (VOIDmode,
+					  gen_rtx_REG (CCmode,
+						       FLAGS_REG));
+	      tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,
+							   tmp,
+							   clob));
+	    }
+	  /* FALLTHRU.  */
+
+	case E_V4SFmode:
+	case E_HImode:
+	case E_V2SImode:
+	  emit_insn (tmp);
+	  break;
+
+	default:
+	  gcc_unreachable ();
+	}
     }
   return zeroed_hardregs;
 }
@@ -4754,6 +4717,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,
 	{
 	  int i, prev_size = 0;
 	  tree temp = create_tmp_var (type, "va_arg_tmp");
+	  TREE_ADDRESSABLE (temp) = 1;
 
 	  /* addr = &temp; */
 	  t = build1 (ADDR_EXPR, build_pointer_type (type), temp);
@@ -6653,7 +6617,9 @@ ix86_compute_frame_layout (void)
 	 stack clash protections are enabled and the allocated frame is
 	 larger than the probe interval, then use pushes to save
 	 callee saved registers.  */
-      || (flag_stack_clash_protection && to_allocate > get_probe_interval ()))
+      || (flag_stack_clash_protection
+	  && !ix86_target_stack_probe ()
+	  && to_allocate > get_probe_interval ()))
     frame->save_regs_using_mov = false;
 
   if (ix86_using_red_zone ()
@@ -8528,8 +8494,11 @@ ix86_expand_prologue (void)
       sse_registers_saved = true;
     }
 
-  /* If stack clash protection is requested, then probe the stack.  */
-  if (allocate >= 0 && flag_stack_clash_protection)
+  /* If stack clash protection is requested, then probe the stack, unless it
+     is already probed on the target.  */
+  if (allocate >= 0
+      && flag_stack_clash_protection
+      && !ix86_target_stack_probe ())
     {
       ix86_adjust_stack_and_probe (allocate, int_registers_saved, false);
       allocate = 0;
@@ -12009,8 +11978,8 @@ output_pic_addr_const (FILE *file, rtx x, int code)
       assemble_name (asm_out_file, buf);
       break;
 
-    case CONST_INT:
-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));
+    CASE_CONST_SCALAR_INT:
+      output_addr_const (file, x);
       break;
 
     case CONST:
@@ -16248,10 +16217,18 @@ assign_386_stack_local (machine_mode mode, enum ix86_stack_slot n)
     if (s->mode == mode && s->n == n)
       return validize_mem (copy_rtx (s->rtl));
 
+  int align = 0;
+  /* For DImode with SLOT_FLOATxFDI_387 use 32-bit
+     alignment with -m32 -mpreferred-stack-boundary=2.  */
+  if (mode == DImode
+      && !TARGET_64BIT
+      && n == SLOT_FLOATxFDI_387
+      && ix86_preferred_stack_boundary < GET_MODE_ALIGNMENT (DImode))
+    align = 32;
   s = ggc_alloc<stack_local_entry> ();
   s->n = n;
   s->mode = mode;
-  s->rtl = assign_stack_local (mode, GET_MODE_SIZE (mode), 0);
+  s->rtl = assign_stack_local (mode, GET_MODE_SIZE (mode), align);
 
   s->next = ix86_stack_locals;
   ix86_stack_locals = s;
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 238ce09672e..39b04861064 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -3361,9 +3361,9 @@
 ;; Possible store forwarding (partial memory) stall in alternatives 4, 6 and 7.
 (define_insn "*movdf_internal"
   [(set (match_operand:DF 0 "nonimmediate_operand"
-    "=Yf*f,m   ,Yf*f,?r ,!o,?*r ,!o,!o,?r,?m,?r,?r,v,v,v,m,*x,*x,*x,m ,r ,v,r  ,o ,r  ,m")
+    "=Yf*f,m   ,Yf*f,?r ,!o,?*r ,!o,!o,?r,?m,?r,?r,v,v,v,m,*x,*x,*x,m ,?r,?v,r  ,o ,r  ,m")
 	(match_operand:DF 1 "general_operand"
-    "Yf*fm,Yf*f,G   ,roF,r ,*roF,*r,F ,rm,rC,C ,F ,C,v,m,v,C ,*x,m ,*x,v,r ,roF,rF,rmF,rC"))]
+    "Yf*fm,Yf*f,G   ,roF,r ,*roF,*r,F ,rm,rC,C ,F ,C,v,m,v,C ,*x,m ,*x, v, r,roF,rF,rmF,rC"))]
   "!(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (lra_in_progress || reload_completed
        || !CONST_DOUBLE_P (operands[1])
diff --git a/gcc/config/i386/i386.opt b/gcc/config/i386/i386.opt
index f62b0ebd3b4..9381025b667 100644
--- a/gcc/config/i386/i386.opt
+++ b/gcc/config/i386/i386.opt
@@ -109,8 +109,8 @@ TargetVariable
 enum cmodel ix86_cmodel = CM_32
 
 ;; -mabi=
-TargetSave
-enum calling_abi x_ix86_abi
+TargetVariable
+enum calling_abi ix86_abi = SYSV_ABI
 
 ;; -masm=
 TargetSave
@@ -416,6 +416,10 @@ mpc80
 Target RejectNegative
 Set 80387 floating-point precision to 80-bit.
 
+mdaz-ftz
+Target
+Set the FTZ and DAZ Flags.
+
 mpreferred-stack-boundary=
 Target RejectNegative Joined UInteger Var(ix86_preferred_stack_boundary_arg)
 Attempt to keep stack aligned to this power of 2.
@@ -1190,3 +1194,7 @@ Emit GNU_PROPERTY_X86_ISA_1_NEEDED GNU property.
 mmwait
 Target Mask(ISA2_MWAIT) Var(ix86_isa_flags2) Save
 Support MWAIT and MONITOR built-in functions and code generation.
+
+mgather
+Target Alias(mtune-ctrl=, use_gather, ^use_gather)
+Enable vectorization for gather instruction.
diff --git a/gcc/config/i386/mingw32.h b/gcc/config/i386/mingw32.h
index 779c9335711..05ffcfec755 100644
--- a/gcc/config/i386/mingw32.h
+++ b/gcc/config/i386/mingw32.h
@@ -197,7 +197,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #undef ENDFILE_SPEC
 #define ENDFILE_SPEC \
-  "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
+  "%{mdaz-ftz:crtfastmath.o%s;Ofast|ffast-math|funsafe-math-optimizations:%{!mno-daz-ftz:crtfastmath.o%s}} \
    %{!shared:%:if-exists(default-manifest.o%s)}\
    %{fvtable-verify=none:%s; \
     fvtable-verify=preinit:vtv_end.o%s; \
diff --git a/gcc/config/i386/predicates.md b/gcc/config/i386/predicates.md
index b815aca0da7..58aebd416f4 100644
--- a/gcc/config/i386/predicates.md
+++ b/gcc/config/i386/predicates.md
@@ -1851,11 +1851,11 @@
   for(i = 4; i < 7; i++)
     {
       elt = XVECEXP (op, 0, i);
-      if (GET_CODE (elt) != SET
-	  || GET_CODE (SET_DEST (elt)) != REG
-	  || GET_MODE (SET_DEST (elt)) != V2DImode
-	  || REGNO (SET_DEST (elt)) != GET_SSE_REGNO (i)
-	  || SET_SRC (elt) != CONST0_RTX (V2DImode))
+      if (GET_CODE (elt) != CLOBBER
+	  || GET_MODE (elt) != VOIDmode
+	  || GET_CODE (XEXP (elt, 0)) != REG
+	  || GET_MODE (XEXP (elt, 0)) != V2DImode
+	  || REGNO (XEXP (elt, 0)) != GET_SSE_REGNO (i))
 	return false;
     }
 
@@ -1901,11 +1901,11 @@
   for(i = 4; i < 7; i++)
     {
       elt = XVECEXP (op, 0, i + 1);
-      if (GET_CODE (elt) != SET
-	  || GET_CODE (SET_DEST (elt)) != REG
-	  || GET_MODE (SET_DEST (elt)) != V2DImode
-	  || REGNO (SET_DEST (elt)) != GET_SSE_REGNO (i)
-	  || SET_SRC (elt) != CONST0_RTX (V2DImode))
+      if (GET_CODE (elt) != CLOBBER
+	  || GET_MODE (elt) != VOIDmode
+	  || GET_CODE (XEXP (elt, 0)) != REG
+	  || GET_MODE (XEXP (elt, 0)) != V2DImode
+	  || REGNO (XEXP (elt, 0)) != GET_SSE_REGNO (i))
 	return false;
     }
 
diff --git a/gcc/config/i386/smmintrin.h b/gcc/config/i386/smmintrin.h
index f8c4c920790..183df7f1833 100644
--- a/gcc/config/i386/smmintrin.h
+++ b/gcc/config/i386/smmintrin.h
@@ -365,17 +365,18 @@ _mm_insert_ps (__m128 __D, __m128 __S, const int __N)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_extract_ps (__m128 __X, const int __N)
 {
-  union { int i; float f; } __tmp;
-  __tmp.f = __builtin_ia32_vec_ext_v4sf ((__v4sf)__X, __N);
-  return __tmp.i;
+  union { int __i; float __f; } __tmp;
+  __tmp.__f = __builtin_ia32_vec_ext_v4sf ((__v4sf)__X, __N);
+  return __tmp.__i;
 }
 #else
 #define _mm_extract_ps(X, N)						\
   (__extension__							\
    ({									\
-     union { int i; float f; } __tmp;					\
-     __tmp.f = __builtin_ia32_vec_ext_v4sf ((__v4sf)(__m128)(X), (int)(N)); \
-     __tmp.i;								\
+     union { int __i; float __f; } __tmp;				\
+     __tmp.__f = __builtin_ia32_vec_ext_v4sf ((__v4sf)(__m128)(X),	\
+					      (int)(N));		\
+     __tmp.__i;								\
    }))
 #endif
 
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
index fcfcba0134d..45d5d1e4dc5 100644
--- a/gcc/config/i386/sse.md
+++ b/gcc/config/i386/sse.md
@@ -1293,7 +1293,7 @@
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
 
-(define_insn "<avx512>_store<mode>_mask"
+(define_insn "*<avx512>_store<mode>_mask"
   [(set (match_operand:V48_AVX512VL 0 "memory_operand" "=m")
 	(vec_merge:V48_AVX512VL
 	  (match_operand:V48_AVX512VL 1 "register_operand" "v")
@@ -1321,7 +1321,7 @@
    (set_attr "memory" "store")
    (set_attr "mode" "<sseinsnmode>")])
 
-(define_insn "<avx512>_store<mode>_mask"
+(define_insn "*<avx512>_store<mode>_mask"
   [(set (match_operand:VI12_AVX512VL 0 "memory_operand" "=m")
 	(vec_merge:VI12_AVX512VL
 	  (match_operand:VI12_AVX512VL 1 "register_operand" "v")
@@ -17256,9 +17256,9 @@
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn_and_split "ssse3_palignrdi"
-  [(set (match_operand:DI 0 "register_operand" "=y,x,Yv")
-	(unspec:DI [(match_operand:DI 1 "register_operand" "0,0,Yv")
-		    (match_operand:DI 2 "register_mmxmem_operand" "ym,x,Yv")
+  [(set (match_operand:DI 0 "register_operand" "=y,x,Yw")
+	(unspec:DI [(match_operand:DI 1 "register_operand" "0,0,Yw")
+		    (match_operand:DI 2 "register_mmxmem_operand" "ym,x,Yw")
 		    (match_operand:SI 3 "const_0_to_255_mul_8_operand" "n,n,n")]
 		   UNSPEC_PALIGNR))]
   "(TARGET_MMX || TARGET_MMX_WITH_SSE) && TARGET_SSSE3"
@@ -19495,7 +19495,7 @@
 	  (match_operand:VF_128 2 "register_operand" "v")
 	  (const_int 1)))]
   "TARGET_AVX512ER"
-  "vrcp28<ssescalarmodesuffix>\t{<round_saeonly_mask_op3>%1, %2, %0<mask_operand3>|<mask_opernad3>%0, %2, %<iptr>1<round_saeonly_mask_op3>}"
+  "vrcp28<ssescalarmodesuffix>\t{<round_saeonly_mask_op3>%1, %2, %0<mask_operand3>|<mask_operand3>%0, %2, %<iptr>1<round_saeonly_mask_op3>}"
   [(set_attr "length_immediate" "1")
    (set_attr "prefix" "evex")
    (set_attr "type" "sse")
@@ -21857,7 +21857,9 @@
 (define_expand "maskload<mode><avx512fmaskmodelower>"
   [(set (match_operand:V48_AVX512VL 0 "register_operand")
 	(vec_merge:V48_AVX512VL
-	  (match_operand:V48_AVX512VL 1 "memory_operand")
+	  (unspec:V48_AVX512VL
+	    [(match_operand:V48_AVX512VL 1 "memory_operand")]
+	    UNSPEC_MASKLOAD)
 	  (match_dup 0)
 	  (match_operand:<avx512fmaskmode> 2 "register_operand")))]
   "TARGET_AVX512F")
@@ -21865,7 +21867,9 @@
 (define_expand "maskload<mode><avx512fmaskmodelower>"
   [(set (match_operand:VI12_AVX512VL 0 "register_operand")
 	(vec_merge:VI12_AVX512VL
-	  (match_operand:VI12_AVX512VL 1 "memory_operand")
+	  (unspec:VI12_AVX512VL
+	    [(match_operand:VI12_AVX512VL 1 "memory_operand")]
+	    UNSPEC_MASKLOAD)
 	  (match_dup 0)
 	  (match_operand:<avx512fmaskmode> 2 "register_operand")))]
   "TARGET_AVX512BW")
@@ -21881,20 +21885,65 @@
 
 (define_expand "maskstore<mode><avx512fmaskmodelower>"
   [(set (match_operand:V48_AVX512VL 0 "memory_operand")
-	(vec_merge:V48_AVX512VL
-	  (match_operand:V48_AVX512VL 1 "register_operand")
-	  (match_dup 0)
-	  (match_operand:<avx512fmaskmode> 2 "register_operand")))]
+	(unspec:V48_AVX512VL
+	  [(match_operand:V48_AVX512VL 1 "register_operand")
+	   (match_dup 0)
+	   (match_operand:<avx512fmaskmode> 2 "register_operand")]
+	  UNSPEC_MASKMOV))]
   "TARGET_AVX512F")
 
 (define_expand "maskstore<mode><avx512fmaskmodelower>"
   [(set (match_operand:VI12_AVX512VL 0 "memory_operand")
-	(vec_merge:VI12_AVX512VL
-	  (match_operand:VI12_AVX512VL 1 "register_operand")
-	  (match_dup 0)
-	  (match_operand:<avx512fmaskmode> 2 "register_operand")))]
+	(unspec:VI12_AVX512VL
+	  [(match_operand:VI12_AVX512VL 1 "register_operand")
+	   (match_dup 0)
+	   (match_operand:<avx512fmaskmode> 2 "register_operand")]
+	  UNSPEC_MASKMOV))]
   "TARGET_AVX512BW")
 
+(define_insn "<avx512>_store<mode>_mask"
+  [(set (match_operand:V48_AVX512VL 0 "memory_operand" "=m")
+	(unspec:V48_AVX512VL
+	  [(match_operand:V48_AVX512VL 1 "register_operand" "v")
+	   (match_dup 0)
+	   (match_operand:<avx512fmaskmode> 2 "register_operand" "Yk")]
+	  UNSPEC_MASKMOV))]
+  "TARGET_AVX512F"
+{
+  if (FLOAT_MODE_P (GET_MODE_INNER (<MODE>mode)))
+    {
+      if (misaligned_operand (operands[0], <MODE>mode))
+	return "vmovu<ssemodesuffix>\t{%1, %0%{%2%}|%0%{%2%}, %1}";
+      else
+	return "vmova<ssemodesuffix>\t{%1, %0%{%2%}|%0%{%2%}, %1}";
+    }
+  else
+    {
+      if (misaligned_operand (operands[0], <MODE>mode))
+	return "vmovdqu<ssescalarsize>\t{%1, %0%{%2%}|%0%{%2%}, %1}";
+      else
+	return "vmovdqa<ssescalarsize>\t{%1, %0%{%2%}|%0%{%2%}, %1}";
+    }
+}
+  [(set_attr "type" "ssemov")
+   (set_attr "prefix" "evex")
+   (set_attr "memory" "store")
+   (set_attr "mode" "<sseinsnmode>")])
+
+(define_insn "<avx512>_store<mode>_mask"
+  [(set (match_operand:VI12_AVX512VL 0 "memory_operand" "=m")
+	(unspec:VI12_AVX512VL
+	  [(match_operand:VI12_AVX512VL 1 "register_operand" "v")
+	   (match_dup 0)
+	   (match_operand:<avx512fmaskmode> 2 "register_operand" "Yk")]
+	   UNSPEC_MASKMOV))]
+  "TARGET_AVX512BW"
+  "vmovdqu<ssescalarsize>\t{%1, %0%{%2%}|%0%{%2%}, %1}"
+  [(set_attr "type" "ssemov")
+   (set_attr "prefix" "evex")
+   (set_attr "memory" "store")
+   (set_attr "mode" "<sseinsnmode>")])
+
 (define_expand "cbranch<mode>4"
   [(set (reg:CC FLAGS_REG)
 	(compare:CC (match_operand:VI48_AVX 1 "register_operand")
@@ -24127,7 +24176,7 @@
 
   for (i = 4; i < 7; i++)
     XVECEXP (operands[2], 0, i)
-      = gen_rtx_SET (xmm_regs[i], CONST0_RTX (V2DImode));
+      = gen_rtx_CLOBBER (VOIDmode, xmm_regs[i]);
 
   XVECEXP (operands[2], 0, 7)
     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));
@@ -24184,7 +24233,7 @@
 
   for (i = 4; i < 7; i++)
     XVECEXP (operands[2], 0, i + 1)
-      = gen_rtx_SET (xmm_regs[i], CONST0_RTX (V2DImode));
+      = gen_rtx_CLOBBER (VOIDmode, xmm_regs[i]);
 
   XVECEXP (operands[2], 0, 8)
     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));
diff --git a/gcc/config/i386/t-i386 b/gcc/config/i386/t-i386
index 66d5a8cd79b..04b54252222 100644
--- a/gcc/config/i386/t-i386
+++ b/gcc/config/i386/t-i386
@@ -61,7 +61,12 @@ i386-features.o: $(srcdir)/config/i386/i386-features.c
 	$(COMPILE) $<
 	$(POSTCOMPILE)
 
+# i386-builtin-types.inc is included into i386-builtins.h.
+# Below are direct users of i386-builtins.h:
 i386.o: i386-builtin-types.inc
+i386-builtins.o: i386-builtin-types.inc
+i386-expand.o: i386-builtin-types.inc
+i386-features.o: i386-builtin-types.inc
 
 i386-builtin-types.inc: s-i386-bt ; @true
 s-i386-bt: $(srcdir)/config/i386/i386-builtin-types.awk \
diff --git a/gcc/config/i386/x86-tune.def b/gcc/config/i386/x86-tune.def
index eb057a67750..b390b29843a 100644
--- a/gcc/config/i386/x86-tune.def
+++ b/gcc/config/i386/x86-tune.def
@@ -442,7 +442,7 @@ DEF_TUNE (X86_TUNE_AVOID_4BYTE_PREFIXES, "avoid_4byte_prefixes",
 
 /* X86_TUNE_USE_GATHER: Use gather instructions.  */
 DEF_TUNE (X86_TUNE_USE_GATHER, "use_gather",
-	  ~(m_ZNVER1 | m_ZNVER2 | m_GENERIC))
+	  ~(m_ZNVER1 | m_ZNVER2 | m_GENERIC | m_GDS))
 
 /* X86_TUNE_AVOID_128FMA_CHAINS: Avoid creating loops with tight 128bit or
    smaller FMA chain.  */
diff --git a/gcc/config/nvptx/nvptx.c b/gcc/config/nvptx/nvptx.c
index 7a7a9130e84..d25ddf45408 100644
--- a/gcc/config/nvptx/nvptx.c
+++ b/gcc/config/nvptx/nvptx.c
@@ -4503,6 +4503,7 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
   rtx_insn *neuter_start = NULL;
   rtx_insn *worker_label = NULL, *vector_label = NULL;
   rtx_insn *worker_jump = NULL, *vector_jump = NULL;
+  rtx_insn *warp_sync = NULL;
   for (mode = GOMP_DIM_WORKER; mode <= GOMP_DIM_VECTOR; mode++)
     if (GOMP_DIM_MASK (mode) & skip_mask)
       {
@@ -4535,11 +4536,29 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
 	if (tail_branch)
 	  {
 	    label_insn = emit_label_before (label, before);
+	    if (mode == GOMP_DIM_VECTOR)
+	      {
+		if (TARGET_PTX_6_0)
+		  warp_sync = emit_insn_after (gen_nvptx_warpsync (),
+					       label_insn);
+		else
+		  warp_sync = emit_insn_after (gen_nvptx_uniform_warp_check (),
+					       label_insn);
+	      }
 	    before = label_insn;
 	  }
 	else
 	  {
 	    label_insn = emit_label_after (label, tail);
+	    if (mode == GOMP_DIM_VECTOR)
+	      {
+		if (TARGET_PTX_6_0)
+		  warp_sync = emit_insn_after (gen_nvptx_warpsync (),
+					       label_insn);
+		else
+		  warp_sync = emit_insn_after (gen_nvptx_uniform_warp_check (),
+					       label_insn);
+	      }
 	    if ((mode == GOMP_DIM_VECTOR || mode == GOMP_DIM_WORKER)
 		&& CALL_P (tail) && find_reg_note (tail, REG_NORETURN, NULL))
 	      emit_insn_after (gen_exit (), label_insn);
@@ -4607,6 +4626,8 @@ nvptx_single (unsigned mask, basic_block from, basic_block to)
 		 setp.ne.u32 %rcond,%rcondu32,0;
 	  */
 	  rtx_insn *label = PREV_INSN (tail);
+	  if (label == warp_sync)
+	    label = PREV_INSN (label);
 	  gcc_assert (label && LABEL_P (label));
 	  rtx tmp = gen_reg_rtx (BImode);
 	  emit_insn_before (gen_movbi (tmp, const0_rtx),
diff --git a/gcc/config/nvptx/nvptx.h b/gcc/config/nvptx/nvptx.h
index 2451703e77f..f1965d91fdd 100644
--- a/gcc/config/nvptx/nvptx.h
+++ b/gcc/config/nvptx/nvptx.h
@@ -27,7 +27,7 @@
 
 /* Run-time Target.  */
 
-#define STARTFILE_SPEC "%{mmainkernel:crt0.o}"
+#define STARTFILE_SPEC "%{mmainkernel:crt0.o%s}"
 
 /* Default needs to be in sync with default for misa in nvptx.opt.
    We add a default here to work around a hard-coded sm_30 default in
@@ -98,6 +98,9 @@
 
 #define TARGET_SM35 (ptx_isa_option >= PTX_ISA_SM35)
 
+/* 'TARGET_PTX_*' not applicable before GCC 12.  */
+#define TARGET_PTX_6_0 false
+
 /* Registers.  Since ptx is a virtual target, we just define a few
    hard registers for special purposes and leave pseudos unallocated.
    We have to have some available hard registers, to keep gcc setup
diff --git a/gcc/config/nvptx/nvptx.md b/gcc/config/nvptx/nvptx.md
index 0f15609ee4b..f1b32e285d7 100644
--- a/gcc/config/nvptx/nvptx.md
+++ b/gcc/config/nvptx/nvptx.md
@@ -55,6 +55,8 @@
    UNSPECV_CAS
    UNSPECV_XCHG
    UNSPECV_BARSYNC
+   UNSPECV_WARPSYNC
+   UNSPECV_UNIFORM_WARP_CHECK
    UNSPECV_MEMBAR
    UNSPECV_MEMBAR_CTA
    UNSPECV_DIM_POS
@@ -1718,6 +1720,29 @@
   }
   [(set_attr "predicable" "false")])
 
+(define_insn "nvptx_warpsync"
+  [(unspec_volatile [(const_int 0)] UNSPECV_WARPSYNC)]
+  "TARGET_PTX_6_0"
+  "\\tbar.warp.sync\\t0xffffffff;"
+  [(set_attr "predicable" "false")])
+
+(define_insn "nvptx_uniform_warp_check"
+  [(unspec_volatile [(const_int 0)] UNSPECV_UNIFORM_WARP_CHECK)]
+  ""
+  {
+    output_asm_insn ("{", NULL);
+    output_asm_insn ("\\t"	 ".reg.b32"	   "\\t" "act;", NULL);
+    output_asm_insn ("\\t"	 "vote.ballot.b32" "\\t" "act,1;", NULL);
+    output_asm_insn ("\\t"	 ".reg.pred"	   "\\t" "uni;", NULL);
+    output_asm_insn ("\\t"	 "setp.eq.b32"	   "\\t" "uni,act,0xffffffff;",
+		     NULL);
+    output_asm_insn ("@ !uni\\t" "trap;", NULL);
+    output_asm_insn ("@ !uni\\t" "exit;", NULL);
+    output_asm_insn ("}", NULL);
+    return "";
+  }
+  [(set_attr "predicable" "false")])
+
 (define_expand "memory_barrier"
   [(set (match_dup 0)
 	(unspec_volatile:BLK [(match_dup 0)] UNSPECV_MEMBAR))]
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
index 31e3b1bff80..3e0bfb09da2 100644
--- a/gcc/config/pa/pa.md
+++ b/gcc/config/pa/pa.md
@@ -5071,23 +5071,25 @@
 						    (match_dup 2))))
 		       (const_int 0))])]
   ""
-  "")
+  "
+{
+  if (TARGET_64BIT)
+    operands[2] = force_reg (DImode, operands[2]);
+}")
 
 (define_insn ""
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
-	(plus:DI (match_operand:DI 1 "reg_or_0_operand" "%rM,rM")
-		 (match_operand:DI 2 "arith11_operand" "r,I")))
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(plus:DI (match_operand:DI 1 "reg_or_0_operand" "%rM")
+		 (match_operand:DI 2 "register_operand" "r")))
    (trap_if (ne (plus:TI (sign_extend:TI (match_dup 1))
 			 (sign_extend:TI (match_dup 2)))
 		(sign_extend:TI (plus:DI (match_dup 1)
 					 (match_dup 2))))
 	    (const_int 0))]
   "TARGET_64BIT"
-  "@
-  add,tsv,* %2,%1,%0
-  addi,tsv,* %2,%1,%0"
-  [(set_attr "type" "binary,binary")
-   (set_attr "length" "4,4")])
+  "add,tsv,* %2,%1,%0"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r")
@@ -5262,23 +5264,25 @@
 						     (match_dup 2))))
 		       (const_int 0))])]
   ""
-  "")
+  "
+{
+  if (TARGET_64BIT)
+    operands[1] = force_reg (DImode, operands[1]);
+}")
 
 (define_insn ""
-  [(set (match_operand:DI 0 "register_operand" "=r,r")
-	(minus:DI (match_operand:DI 1 "arith11_operand" "r,I")
-		  (match_operand:DI 2 "reg_or_0_operand" "rM,rM")))
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(minus:DI (match_operand:DI 1 "register_operand" "r")
+		  (match_operand:DI 2 "reg_or_0_operand" "rM")))
    (trap_if (ne (minus:TI (sign_extend:TI (match_dup 1))
 			  (sign_extend:TI (match_dup 2)))
 		(sign_extend:TI (minus:DI (match_dup 1)
 					  (match_dup 2))))
 	    (const_int 0))]
   "TARGET_64BIT"
-  "@
-  {subo|sub,tsv} %1,%2,%0
-  {subio|subi,tsv} %1,%2,%0"
-  [(set_attr "type" "binary,binary")
-   (set_attr "length" "4,4")])
+  "sub,tsv,* %1,%2,%0"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=r,&r")
diff --git a/gcc/config/pru/pru.h b/gcc/config/pru/pru.h
index 4c35a7d7ee3..41260b9450d 100644
--- a/gcc/config/pru/pru.h
+++ b/gcc/config/pru/pru.h
@@ -562,8 +562,9 @@ do {									\
 
 #define CASE_VECTOR_MODE Pmode
 
-/* See definition of clz pattern for rationale of value -1.  */
-#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = -1, 2)
+/* See definition of clz pattern for rationale of the value.  */
+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)	\
+	((VALUE) = GET_MODE_BITSIZE (MODE) - 1 - 32, 2)
 
 /* Jumps are cheap on PRU.  */
 #define LOGICAL_OP_NON_SHORT_CIRCUIT		0
diff --git a/gcc/config/pru/pru.md b/gcc/config/pru/pru.md
index e6cfa8ec3bf..c5661adb6c4 100644
--- a/gcc/config/pru/pru.md
+++ b/gcc/config/pru/pru.md
@@ -1035,8 +1035,16 @@
   [(set_attr "type" "control")])
 
 ;; Count Leading Zeros implemented using LMBD.
-;; LMBD returns 32 if bit value is not present, and we subtract 31 to get CLZ.
-;; Hence we get a defined value -1 for CLZ_DEFINED_VALUE_AT_ZERO.
+;;
+;; LMBD returns 32 if bit value is not present, for any kind of input MODE.
+;; The LMBD's search result for a "1" bit is subtracted from the
+;; mode bit size minus one, in order to get CLZ.
+;;
+;; Hence for SImode we get a defined value -1 for CLZ_DEFINED_VALUE_AT_ZERO.
+;;
+;; The QImode and HImode defined values for zero inputs end up to be
+;; non-standard (-25 and -17).  But this is considered acceptable in
+;; order to keep the CLZ expansion to only two instructions.
 (define_expand "clz<mode>2"
   [(set (match_operand:QISI 0 "register_operand")
 	(clz:QISI (match_operand:QISI 1 "register_operand")))]
@@ -1047,7 +1055,8 @@
   rtx tmpval = gen_reg_rtx (<MODE>mode);
 
   emit_insn (gen_pru_lmbd (<MODE>mode, tmpval, src, const1_rtx));
-  emit_insn (gen_sub3_insn (dst, GEN_INT (31), tmpval));
+  int msb_bitn = GET_MODE_BITSIZE (<MODE>mode) - 1;
+  emit_insn (gen_sub3_insn (dst, GEN_INT (msb_bitn), tmpval));
   DONE;
 })
 
diff --git a/gcc/config/riscv/arch-canonicalize b/gcc/config/riscv/arch-canonicalize
index 3a91cfe687f..0bdf6aafe35 100755
--- a/gcc/config/riscv/arch-canonicalize
+++ b/gcc/config/riscv/arch-canonicalize
@@ -45,9 +45,11 @@ def arch_canonicalize(arch, isa_spec):
   is_isa_spec_2p2 = isa_spec == '2.2'
   new_arch = ""
   extra_long_ext = []
+  std_exts = []
   if arch[:5] in ['rv32e', 'rv32i', 'rv32g', 'rv64i', 'rv64g']:
-    new_arch = arch[:5].replace("g", "imafd")
+    new_arch = arch[:5].replace("g", "i")
     if arch[:5] in ['rv32g', 'rv64g']:
+      std_exts = ['m', 'a', 'f', 'd']
       if not is_isa_spec_2p2:
         extra_long_ext = ['zicsr', 'zifencei']
   else:
@@ -61,10 +63,10 @@ def arch_canonicalize(arch, isa_spec):
   if long_ext_prefixes_idx:
     first_long_ext_idx = min(long_ext_prefixes_idx)
     long_exts = arch[first_long_ext_idx:].split("_")
-    std_exts = list(arch[5:first_long_ext_idx])
+    std_exts += list(arch[5:first_long_ext_idx])
   else:
     long_exts = []
-    std_exts = list(arch[5:])
+    std_exts += list(arch[5:])
 
   long_exts += extra_long_ext
 
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index c3687d57047..3af34de063c 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -2558,7 +2558,7 @@
 	 UNSPEC_SSP_SET))
    (set (match_scratch:GPR 2 "=&r") (const_int 0))]
   ""
-  "<load>\\t%2, %1\;<store>\\t%2, %0\;li\t%2, 0"
+  "<load>\t%2, %1\;<store>\t%2, %0\;li\t%2, 0"
   [(set_attr "length" "12")])
 
 (define_expand "stack_protect_test"
diff --git a/gcc/config/riscv/t-rtems b/gcc/config/riscv/t-rtems
index 41f5927fc87..19b12030895 100644
--- a/gcc/config/riscv/t-rtems
+++ b/gcc/config/riscv/t-rtems
@@ -1,8 +1,8 @@
 MULTILIB_OPTIONS	=
 MULTILIB_DIRNAMES	=
 
-MULTILIB_OPTIONS	+= march=rv32i/march=rv32im/march=rv32imafd/march=rv32iac/march=rv32imac/march=rv32imafc/march=rv64imafd/march=rv64imac/march=rv64imafdc
-MULTILIB_DIRNAMES	+= rv32i       rv32im       rv32imafd       rv32iac       rv32imac       rv32imafc       rv64imafd       rv64imac       rv64imafdc
+MULTILIB_OPTIONS	+= march=rv32i/march=rv32iac/march=rv32im/march=rv32ima/march=rv32imac/march=rv32imaf/march=rv32imafc/march=rv32imafd/march=rv32imafdc/march=rv64ima/march=rv64imac/march=rv64imafd/march=rv64imafdc
+MULTILIB_DIRNAMES	+= rv32i       rv32iac       rv32im       rv32ima       rv32imac       rv32imaf       rv32imafc       rv32imafd       rv32imafdc       rv64ima       rv64imac       rv64imafd       rv64imafdc
 
 MULTILIB_OPTIONS	+= mabi=ilp32/mabi=ilp32f/mabi=ilp32d/mabi=lp64/mabi=lp64d
 MULTILIB_DIRNAMES	+= ilp32      ilp32f      ilp32d      lp64      lp64d
@@ -12,14 +12,15 @@ MULTILIB_DIRNAMES	+= medany
 
 MULTILIB_REQUIRED	=
 MULTILIB_REQUIRED	+= march=rv32i/mabi=ilp32
-MULTILIB_REQUIRED	+= march=rv32im/mabi=ilp32
-MULTILIB_REQUIRED	+= march=rv32imafd/mabi=ilp32d
 MULTILIB_REQUIRED	+= march=rv32iac/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32im/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32ima/mabi=ilp32
 MULTILIB_REQUIRED	+= march=rv32imac/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imaf/mabi=ilp32f
 MULTILIB_REQUIRED	+= march=rv32imafc/mabi=ilp32f
-MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d
-MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d/mcmodel=medany
-MULTILIB_REQUIRED	+= march=rv64imac/mabi=lp64
+MULTILIB_REQUIRED	+= march=rv32imafd/mabi=ilp32d
+MULTILIB_REQUIRED	+= march=rv32imafdc/mabi=ilp32d
+MULTILIB_REQUIRED	+= march=rv64ima/mabi=lp64/mcmodel=medany
 MULTILIB_REQUIRED	+= march=rv64imac/mabi=lp64/mcmodel=medany
-MULTILIB_REQUIRED	+= march=rv64imafdc/mabi=lp64d
+MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d/mcmodel=medany
 MULTILIB_REQUIRED	+= march=rv64imafdc/mabi=lp64d/mcmodel=medany
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
index 44fce835e87..9fb69a639d3 100644
--- a/gcc/config/rs6000/altivec.md
+++ b/gcc/config/rs6000/altivec.md
@@ -3870,7 +3870,7 @@
 		      (match_operand:QI 4 "u8bit_cint_operand" "n")]
 		     UNSPEC_XXEVAL))]
    "TARGET_POWER10"
-   "xxeval %0,%1,%2,%3,%4"
+   "xxeval %x0,%x1,%x2,%x3,%4"
    [(set_attr "type" "vecperm")
     (set_attr "prefixed" "yes")])
 
@@ -4507,9 +4507,11 @@
   [(set_attr "type" "vecsimple")])
 
 ;; Vector parity
-(define_insn "*p9v_parity<mode>2"
-  [(set (match_operand:VParity 0 "register_operand" "=v")
-        (parity:VParity (match_operand:VParity 1 "register_operand" "v")))]
+(define_insn "rs6000_vprtyb<mode>2"
+  [(set (match_operand:VEC_IP 0 "register_operand" "=v")
+        (unspec:VEC_IP
+          [(match_operand:VEC_IP 1 "register_operand" "v")]
+          UNSPEC_PARITY))]
   "TARGET_P9_VECTOR"
   "vprtyb<wd> %0,%1"
   [(set_attr "type" "vecsimple")])
diff --git a/gcc/config/rs6000/bmi2intrin.h b/gcc/config/rs6000/bmi2intrin.h
index 5b7b761b9d5..03299e6cccd 100644
--- a/gcc/config/rs6000/bmi2intrin.h
+++ b/gcc/config/rs6000/bmi2intrin.h
@@ -77,39 +77,39 @@ extern __inline unsigned long long
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _pdep_u64 (unsigned long long __X, unsigned long long __M)
 {
-  unsigned long result = 0x0UL;
-  const unsigned long mask = 0x8000000000000000UL;
-  unsigned long m = __M;
-  unsigned long c, t;
-  unsigned long p;
+  unsigned long __result = 0x0UL;
+  const unsigned long __mask = 0x8000000000000000UL;
+  unsigned long __m = __M;
+  unsigned long __c, __t;
+  unsigned long __p;
 
   /* The pop-count of the mask gives the number of the bits from
    source to process.  This is also needed to shift bits from the
    source into the correct position for the result.  */
-  p = 64 - __builtin_popcountl (__M);
+  __p = 64 - __builtin_popcountl (__M);
 
   /* The loop is for the number of '1' bits in the mask and clearing
    each mask bit as it is processed.  */
-  while (m != 0)
+  while (__m != 0)
     {
-      c = __builtin_clzl (m);
-      t = __X << (p - c);
-      m ^= (mask >> c);
-      result |= (t & (mask >> c));
-      p++;
+      __c = __builtin_clzl (__m);
+      __t = __X << (__p - __c);
+      __m ^= (__mask >> __c);
+      __result |= (__t & (__mask >> __c));
+      __p++;
     }
-  return (result);
+  return __result;
 }
 
 extern __inline unsigned long long
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _pext_u64 (unsigned long long __X, unsigned long long __M)
 {
-  unsigned long p = 0x4040404040404040UL; // initial bit permute control
-  const unsigned long mask = 0x8000000000000000UL;
-  unsigned long m = __M;
-  unsigned long c;
-  unsigned long result;
+  unsigned long __p = 0x4040404040404040UL; // initial bit permute control
+  const unsigned long __mask = 0x8000000000000000UL;
+  unsigned long __m = __M;
+  unsigned long __c;
+  unsigned long __result;
 
   /* if the mask is constant and selects 8 bits or less we can use
    the Power8 Bit permute instruction.  */
@@ -118,34 +118,34 @@ _pext_u64 (unsigned long long __X, unsigned long long __M)
       /* Also if the pext mask is constant, then the popcount is
        constant, we can evaluate the following loop at compile
        time and use a constant bit permute vector.  */
-      for (long i = 0; i < __builtin_popcountl (__M); i++)
+      for (long __i = 0; __i < __builtin_popcountl (__M); __i++)
 	{
-	  c = __builtin_clzl (m);
-	  p = (p << 8) | c;
-	  m ^= (mask >> c);
+	  __c = __builtin_clzl (__m);
+	  __p = (__p << 8) | __c;
+	  __m ^= (__mask >> __c);
 	}
-      result = __builtin_bpermd (p, __X);
+      __result = __builtin_bpermd (__p, __X);
     }
   else
     {
-      p = 64 - __builtin_popcountl (__M);
-      result = 0;
+      __p = 64 - __builtin_popcountl (__M);
+      __result = 0;
       /* We could a use a for loop here, but that combined with
        -funroll-loops can expand to a lot of code.  The while
        loop avoids unrolling and the compiler commons the xor
-       from clearing the mask bit with the (m != 0) test.  The
+       from clearing the mask bit with the (__m != 0) test.  The
        result is a more compact loop setup and body.  */
-      while (m != 0)
+      while (__m != 0)
 	{
-	  unsigned long t;
-	  c = __builtin_clzl (m);
-	  t = (__X & (mask >> c)) >> (p - c);
-	  m ^= (mask >> c);
-	  result |= (t);
-	  p++;
+	  unsigned long __t;
+	  __c = __builtin_clzl (__m);
+	  __t = (__X & (__mask >> __c)) >> (__p - __c);
+	  __m ^= (__mask >> __c);
+	  __result |= (__t);
+	  __p++;
 	}
     }
-  return (result);
+  return __result;
 }
 
 /* these 32-bit implementations depend on 64-bit pdep/pext
diff --git a/gcc/config/rs6000/emmintrin.h b/gcc/config/rs6000/emmintrin.h
index ce1287edf78..991368095dd 100644
--- a/gcc/config/rs6000/emmintrin.h
+++ b/gcc/config/rs6000/emmintrin.h
@@ -141,9 +141,9 @@ _mm_setzero_pd (void)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_move_sd (__m128d __A, __m128d __B)
 {
-  __v2df result = (__v2df) __A;
-  result [0] = ((__v2df) __B)[0];
-  return (__m128d) result;
+  __v2df __result = (__v2df) __A;
+  __result [0] = ((__v2df) __B)[0];
+  return (__m128d) __result;
 }
 
 /* Load two DPFP values from P.  The address must be 16-byte aligned.  */
@@ -329,9 +329,9 @@ _mm_sqrt_pd (__m128d __A)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sqrt_sd (__m128d __A, __m128d __B)
 {
-  __v2df c;
-  c = vec_sqrt ((__v2df) _mm_set1_pd (__B[0]));
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __c;
+  __c = vec_sqrt ((__v2df) _mm_set1_pd (__B[0]));
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -343,11 +343,11 @@ _mm_min_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_sd (__m128d __A, __m128d __B)
 {
-  __v2df a, b, c;
-  a = vec_splats (__A[0]);
-  b = vec_splats (__B[0]);
-  c = vec_min (a, b);
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __a, __b, __c;
+  __a = vec_splats (__A[0]);
+  __b = vec_splats (__B[0]);
+  __c = vec_min (__a, __b);
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -359,11 +359,11 @@ _mm_max_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_sd (__m128d __A, __m128d __B)
 {
-  __v2df a, b, c;
-  a = vec_splats (__A[0]);
-  b = vec_splats (__B[0]);
-  c = vec_max (a, b);
-  return (__m128d) _mm_setr_pd (c[0], __A[1]);
+  __v2df __a, __b, __c;
+  __a = vec_splats (__A[0]);
+  __b = vec_splats (__B[0]);
+  __c = vec_max (__a, __b);
+  return (__m128d) _mm_setr_pd (__c[0], __A[1]);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -399,8 +399,8 @@ _mm_cmpge_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_pd (__m128d __A, __m128d __B)
 {
-  __v2df temp = (__v2df) vec_cmpeq ((__v2df) __A, (__v2df)__B);
-  return ((__m128d)vec_nor (temp, temp));
+  __v2df __temp = (__v2df) vec_cmpeq ((__v2df) __A, (__v2df)__B);
+  return ((__m128d)vec_nor (__temp, __temp));
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -427,26 +427,18 @@ _mm_cmpnge_pd (__m128d __A, __m128d __B)
   return ((__m128d)vec_cmplt ((__v2df) __A, (__v2df) __B));
 }
 
+#if _ARCH_PWR8
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_pd (__m128d __A, __m128d __B)
 {
-#if _ARCH_PWR8
   __v2du c, d;
   /* Compare against self will return false (0's) if NAN.  */
   c = (__v2du)vec_cmpeq (__A, __A);
   d = (__v2du)vec_cmpeq (__B, __B);
-#else
-  __v2du a, b;
-  __v2du c, d;
-  const __v2du double_exp_mask  = {0x7ff0000000000000, 0x7ff0000000000000};
-  a = (__v2du)vec_abs ((__v2df)__A);
-  b = (__v2du)vec_abs ((__v2df)__B);
-  c = (__v2du)vec_cmpgt (double_exp_mask, a);
-  d = (__v2du)vec_cmpgt (double_exp_mask, b);
-#endif
   /* A != NAN and B != NAN.  */
   return ((__m128d)vec_and(c, d));
 }
+#endif
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_pd (__m128d __A, __m128d __B)
@@ -583,6 +575,7 @@ _mm_cmpnge_sd (__m128d __A, __m128d __B)
   return (__m128d) _mm_setr_pd (c[0], __A[1]);
 }
 
+#if _ARCH_PWR8
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_sd (__m128d __A, __m128d __B)
 {
@@ -590,6 +583,7 @@ _mm_cmpord_sd (__m128d __A, __m128d __B)
   r = (__v2df)_mm_cmpord_pd (vec_splats (__A[0]), vec_splats (__B[0]));
   return (__m128d) _mm_setr_pd (r[0], ((__v2df)__A)[1]);
 }
+#endif
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_sd (__m128d __A, __m128d __B)
@@ -855,12 +849,12 @@ _mm_setzero_si128 (void)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtepi32_pd (__m128i __A)
 {
-  __v2di val;
+  __v2di __val;
   /* For LE need to generate Vector Unpack Low Signed Word.
      Which is generated from unpackh.  */
-  val = (__v2di)vec_unpackh ((__v4si)__A);
+  __val = (__v2di)vec_unpackh ((__v4si)__A);
 
-  return (__m128d)vec_ctf (val, 0);
+  return (__m128d)vec_ctf (__val, 0);
 }
 #endif
 
@@ -873,116 +867,116 @@ _mm_cvtepi32_ps (__m128i __A)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_epi32 (__m128d __A)
 {
-  __v2df rounded = vec_rint (__A);
-  __v4si result, temp;
-  const __v4si vzero =
+  __v2df __rounded = vec_rint (__A);
+  __v4si __result, __temp;
+  const __v4si __vzero =
     { 0, 0, 0, 0 };
 
   /* VSX Vector truncate Double-Precision to integer and Convert to
    Signed Integer Word format with Saturate.  */
   __asm__(
       "xvcvdpsxws %x0,%x1"
-      : "=wa" (temp)
-      : "wa" (rounded)
+      : "=wa" (__temp)
+      : "wa" (__rounded)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4si) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4si) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4si) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4si) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_pi32 (__m128d __A)
 {
-  __m128i result = _mm_cvtpd_epi32(__A);
+  __m128i __result = _mm_cvtpd_epi32(__A);
 
-  return (__m64) result[0];
+  return (__m64) __result[0];
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpd_ps (__m128d __A)
 {
-  __v4sf result;
-  __v4si temp;
-  const __v4si vzero = { 0, 0, 0, 0 };
+  __v4sf __result;
+  __v4si __temp;
+  const __v4si __vzero = { 0, 0, 0, 0 };
 
   __asm__(
       "xvcvdpsp %x0,%x1"
-      : "=wa" (temp)
+      : "=wa" (__temp)
       : "wa" (__A)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4sf) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4sf) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4sf) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4sf) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
-  return ((__m128)result);
+  return ((__m128)__result);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttpd_epi32 (__m128d __A)
 {
-  __v4si result;
-  __v4si temp;
-  const __v4si vzero = { 0, 0, 0, 0 };
+  __v4si __result;
+  __v4si __temp;
+  const __v4si __vzero = { 0, 0, 0, 0 };
 
   /* VSX Vector truncate Double-Precision to integer and Convert to
    Signed Integer Word format with Saturate.  */
   __asm__(
       "xvcvdpsxws %x0,%x1"
-      : "=wa" (temp)
+      : "=wa" (__temp)
       : "wa" (__A)
       : );
 
 #ifdef _ARCH_PWR8
 #ifdef __LITTLE_ENDIAN__
-  temp = vec_mergeo (temp, temp);
+  __temp = vec_mergeo (__temp, __temp);
 #else
-  temp = vec_mergee (temp, temp);
+  __temp = vec_mergee (__temp, __temp);
 #endif
-  result = (__v4si) vec_vpkudum ((__vector long long) temp,
-				 (__vector long long) vzero);
+  __result = (__v4si) vec_vpkudum ((__vector long long) __temp,
+				 (__vector long long) __vzero);
 #else
   {
-    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
+    const __v16qu __pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,
 	0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };
-    result = (__v4si) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);
+    __result = (__v4si) vec_perm ((__v16qu) __temp, (__v16qu) __vzero, __pkperm);
   }
 #endif
 
-  return ((__m128i) result);
+  return ((__m128i) __result);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttpd_pi32 (__m128d __A)
 {
-  __m128i result = _mm_cvttpd_epi32 (__A);
+  __m128i __result = _mm_cvttpd_epi32 (__A);
 
-  return (__m64) result[0];
+  return (__m64) __result[0];
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -995,35 +989,35 @@ _mm_cvtsi128_si32 (__m128i __A)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32_pd (__m64 __A)
 {
-  __v4si temp;
-  __v2di tmp2;
-  __v2df result;
+  __v4si __temp;
+  __v2di __tmp2;
+  __v2df __result;
 
-  temp = (__v4si)vec_splats (__A);
-  tmp2 = (__v2di)vec_unpackl (temp);
-  result = vec_ctf ((__vector signed long long) tmp2, 0);
-  return (__m128d)result;
+  __temp = (__v4si)vec_splats (__A);
+  __tmp2 = (__v2di)vec_unpackl (__temp);
+  __result = vec_ctf ((__vector signed long long) __tmp2, 0);
+  return (__m128d)__result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_epi32 (__m128 __A)
 {
-  __v4sf rounded;
-  __v4si result;
+  __v4sf __rounded;
+  __v4si __result;
 
-  rounded = vec_rint((__v4sf) __A);
-  result = vec_cts (rounded, 0);
-  return (__m128i) result;
+  __rounded = vec_rint((__v4sf) __A);
+  __result = vec_cts (__rounded, 0);
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttps_epi32 (__m128 __A)
 {
-  __v4si result;
+  __v4si __result;
 
-  result = vec_cts ((__v4sf) __A, 0);
-  return (__m128i) result;
+  __result = vec_cts ((__v4sf) __A, 0);
+  return (__m128i) __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1035,48 +1029,48 @@ _mm_cvtps_pd (__m128 __A)
 #else
   /* Otherwise the compiler is not current and so need to generate the
      equivalent code.  */
-  __v4sf a = (__v4sf)__A;
-  __v4sf temp;
-  __v2df result;
+  __v4sf __a = (__v4sf)__A;
+  __v4sf __temp;
+  __v2df __result;
 #ifdef __LITTLE_ENDIAN__
   /* The input float values are in elements {[0], [1]} but the convert
      instruction needs them in elements {[1], [3]}, So we use two
      shift left double vector word immediates to get the elements
      lined up.  */
-  temp = __builtin_vsx_xxsldwi (a, a, 3);
-  temp = __builtin_vsx_xxsldwi (a, temp, 2);
+  __temp = __builtin_vsx_xxsldwi (__a, __a, 3);
+  __temp = __builtin_vsx_xxsldwi (__a, __temp, 2);
 #else
   /* The input float values are in elements {[0], [1]} but the convert
      instruction needs them in elements {[0], [2]}, So we use two
      shift left double vector word immediates to get the elements
      lined up.  */
-  temp = vec_vmrghw (a, a);
+  __temp = vec_vmrghw (__a, __a);
 #endif
   __asm__(
       " xvcvspdp %x0,%x1"
-      : "=wa" (result)
-      : "wa" (temp)
+      : "=wa" (__result)
+      : "wa" (__temp)
       : );
-  return (__m128d) result;
+  return (__m128d) __result;
 #endif
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_si32 (__m128d __A)
 {
-  __v2df rounded = vec_rint((__v2df) __A);
-  int result = ((__v2df)rounded)[0];
+  __v2df __rounded = vec_rint((__v2df) __A);
+  int __result = ((__v2df)__rounded)[0];
 
-  return result;
+  return __result;
 }
 /* Intel intrinsic.  */
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_si64 (__m128d __A)
 {
-  __v2df rounded = vec_rint ((__v2df) __A );
-  long long result = ((__v2df) rounded)[0];
+  __v2df __rounded = vec_rint ((__v2df) __A );
+  long long __result = ((__v2df) __rounded)[0];
 
-  return result;
+  return __result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1089,18 +1083,18 @@ _mm_cvtsd_si64x (__m128d __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttsd_si32 (__m128d __A)
 {
-  int result = ((__v2df)__A)[0];
+  int __result = ((__v2df)__A)[0];
 
-  return result;
+  return __result;
 }
 
 /* Intel intrinsic.  */
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttsd_si64 (__m128d __A)
 {
-  long long result = ((__v2df)__A)[0];
+  long long __result = ((__v2df)__A)[0];
 
-  return result;
+  return __result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1113,46 +1107,46 @@ _mm_cvttsd_si64x (__m128d __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsd_ss (__m128 __A, __m128d __B)
 {
-  __v4sf result = (__v4sf)__A;
+  __v4sf __result = (__v4sf)__A;
 
 #ifdef __LITTLE_ENDIAN__
-  __v4sf temp_s;
+  __v4sf __temp_s;
   /* Copy double element[0] to element [1] for conversion.  */
-  __v2df temp_b = vec_splat((__v2df)__B, 0);
+  __v2df __temp_b = vec_splat((__v2df)__B, 0);
 
   /* Pre-rotate __A left 3 (logically right 1) elements.  */
-  result = __builtin_vsx_xxsldwi (result, result, 3);
+  __result = __builtin_vsx_xxsldwi (__result, __result, 3);
   /* Convert double to single float scalar in a vector.  */
   __asm__(
       "xscvdpsp %x0,%x1"
-      : "=wa" (temp_s)
-      : "wa" (temp_b)
+      : "=wa" (__temp_s)
+      : "wa" (__temp_b)
       : );
   /* Shift the resulting scalar into vector element [0].  */
-  result = __builtin_vsx_xxsldwi (result, temp_s, 1);
+  __result = __builtin_vsx_xxsldwi (__result, __temp_s, 1);
 #else
-  result [0] = ((__v2df)__B)[0];
+  __result [0] = ((__v2df)__B)[0];
 #endif
-  return (__m128) result;
+  return (__m128) __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi32_sd (__m128d __A, int __B)
 {
-  __v2df result = (__v2df)__A;
-  double db = __B;
-  result [0] = db;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  double __db = __B;
+  __result [0] = __db;
+  return (__m128d)__result;
 }
 
 /* Intel intrinsic.  */
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi64_sd (__m128d __A, long long __B)
 {
-  __v2df result = (__v2df)__A;
-  double db = __B;
-  result [0] = db;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  double __db = __B;
+  __result [0] = __db;
+  return (__m128d)__result;
 }
 
 /* Microsoft intrinsic.  */
@@ -1167,45 +1161,45 @@ _mm_cvtss_sd (__m128d __A, __m128 __B)
 {
 #ifdef __LITTLE_ENDIAN__
   /* Use splat to move element [0] into position for the convert. */
-  __v4sf temp = vec_splat ((__v4sf)__B, 0);
-  __v2df res;
+  __v4sf __temp = vec_splat ((__v4sf)__B, 0);
+  __v2df __res;
   /* Convert single float scalar to double in a vector.  */
   __asm__(
       "xscvspdp %x0,%x1"
-      : "=wa" (res)
-      : "wa" (temp)
+      : "=wa" (__res)
+      : "wa" (__temp)
       : );
-  return (__m128d) vec_mergel (res, (__v2df)__A);
+  return (__m128d) vec_mergel (__res, (__v2df)__A);
 #else
-  __v2df res = (__v2df)__A;
-  res [0] = ((__v4sf)__B) [0];
-  return (__m128d) res;
+  __v2df __res = (__v2df)__A;
+  __res [0] = ((__v4sf)__B) [0];
+  return (__m128d) __res;
 #endif
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_pd(__m128d __A, __m128d __B, const int __mask)
 {
-  __vector double result;
-  const int litmsk = __mask & 0x3;
+  __vector double __result;
+  const int __litmsk = __mask & 0x3;
 
-  if (litmsk == 0)
-    result = vec_mergeh (__A, __B);
+  if (__litmsk == 0)
+    __result = vec_mergeh (__A, __B);
 #if __GNUC__ < 6
-  else if (litmsk == 1)
-    result = vec_xxpermdi (__B, __A, 2);
-  else if (litmsk == 2)
-    result = vec_xxpermdi (__B, __A, 1);
+  else if (__litmsk == 1)
+    __result = vec_xxpermdi (__B, __A, 2);
+  else if (__litmsk == 2)
+    __result = vec_xxpermdi (__B, __A, 1);
 #else
-  else if (litmsk == 1)
-    result = vec_xxpermdi (__A, __B, 2);
-  else if (litmsk == 2)
-    result = vec_xxpermdi (__A, __B, 1);
+  else if (__litmsk == 1)
+    __result = vec_xxpermdi (__A, __B, 2);
+  else if (__litmsk == 2)
+    __result = vec_xxpermdi (__A, __B, 1);
 #endif
   else
-    result = vec_mergel (__A, __B);
+    __result = vec_mergel (__A, __B);
 
-  return result;
+  return __result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1223,17 +1217,17 @@ _mm_unpacklo_pd (__m128d __A, __m128d __B)
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_loadh_pd (__m128d __A, double const *__B)
 {
-  __v2df result = (__v2df)__A;
-  result [1] = *__B;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  __result [1] = *__B;
+  return (__m128d)__result;
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_loadl_pd (__m128d __A, double const *__B)
 {
-  __v2df result = (__v2df)__A;
-  result [0] = *__B;
-  return (__m128d)result;
+  __v2df __result = (__v2df)__A;
+  __result [0] = *__B;
+  return (__m128d)__result;
 }
 
 #ifdef _ARCH_PWR8
@@ -1243,8 +1237,8 @@ _mm_loadl_pd (__m128d __A, double const *__B)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_pd (__m128d  __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned int perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned int __perm_mask =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x80800040, 0x80808080, 0x80808080, 0x80808080
@@ -1253,14 +1247,14 @@ _mm_movemask_pd (__m128d  __A)
 #endif
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -1432,17 +1426,17 @@ _mm_subs_epu16 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_madd_epi16 (__m128i __A, __m128i __B)
 {
-  __vector signed int zero = {0, 0, 0, 0};
+  __vector signed int __zero = {0, 0, 0, 0};
 
-  return (__m128i) vec_vmsumshm ((__v8hi)__A, (__v8hi)__B, zero);
+  return (__m128i) vec_vmsumshm ((__v8hi)__A, (__v8hi)__B, __zero);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_epi16 (__m128i __A, __m128i __B)
 {
-  __vector signed int w0, w1;
+  __vector signed int __w0, __w1;
 
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1452,9 +1446,9 @@ _mm_mulhi_epi16 (__m128i __A, __m128i __B)
 #endif
     };
 
-  w0 = vec_vmulesh ((__v8hi)__A, (__v8hi)__B);
-  w1 = vec_vmulosh ((__v8hi)__A, (__v8hi)__B);
-  return (__m128i) vec_perm (w0, w1, xform1);
+  __w0 = vec_vmulesh ((__v8hi)__A, (__v8hi)__B);
+  __w1 = vec_vmulosh ((__v8hi)__A, (__v8hi)__B);
+  return (__m128i) vec_perm (__w0, __w1, __xform1);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1466,34 +1460,34 @@ _mm_mullo_epi16 (__m128i __A, __m128i __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mul_su32 (__m64 __A, __m64 __B)
 {
-  unsigned int a = __A;
-  unsigned int b = __B;
+  unsigned int __a = __A;
+  unsigned int __b = __B;
 
-  return ((__m64)a * (__m64)b);
+  return ((__m64)__a * (__m64)__b);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mul_epu32 (__m128i __A, __m128i __B)
 {
-#if __GNUC__ < 8
-  __v2du result;
+#if __GNUC__ < 8 || !defined (_ARCH_PWR8)
+  __v2du __result;
 
 #ifdef __LITTLE_ENDIAN__
   /* VMX Vector Multiply Odd Unsigned Word.  */
   __asm__(
       "vmulouw %0,%1,%2"
-      : "=v" (result)
+      : "=v" (__result)
       : "v" (__A), "v" (__B)
       : );
 #else
   /* VMX Vector Multiply Even Unsigned Word.  */
   __asm__(
       "vmuleuw %0,%1,%2"
-      : "=v" (result)
+      : "=v" (__result)
       : "v" (__A), "v" (__B)
       : );
 #endif
-  return (__m128i) result;
+  return (__m128i) __result;
 #else
   return (__m128i) vec_mule ((__v4su)__A, (__v4su)__B);
 #endif
@@ -1502,122 +1496,122 @@ _mm_mul_epu32 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi16 (__m128i __A, int __B)
 {
-  __v8hu lshift;
-  __v8hi result = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v8hu __lshift;
+  __v8hi __result = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__B >= 0 && __B < 16)
     {
       if (__builtin_constant_p(__B))
-	lshift = (__v8hu) vec_splat_s16(__B);
+	__lshift = (__v8hu) vec_splat_s16(__B);
       else
-	lshift = vec_splats ((unsigned short) __B);
+	__lshift = vec_splats ((unsigned short) __B);
 
-      result = vec_sl ((__v8hi) __A, lshift);
+      __result = vec_sl ((__v8hi) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi32 (__m128i __A, int __B)
 {
-  __v4su lshift;
-  __v4si result = { 0, 0, 0, 0 };
+  __v4su __lshift;
+  __v4si __result = { 0, 0, 0, 0 };
 
   if (__B >= 0 && __B < 32)
     {
       if (__builtin_constant_p(__B) && __B < 16)
-	lshift = (__v4su) vec_splat_s32(__B);
+	__lshift = (__v4su) vec_splat_s32(__B);
       else
-	lshift = vec_splats ((unsigned int) __B);
+	__lshift = vec_splats ((unsigned int) __B);
 
-      result = vec_sl ((__v4si) __A, lshift);
+      __result = vec_sl ((__v4si) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_epi64 (__m128i __A, int __B)
 {
-  __v2du lshift;
-  __v2di result = { 0, 0 };
+  __v2du __lshift;
+  __v2di __result = { 0, 0 };
 
   if (__B >= 0 && __B < 64)
     {
       if (__builtin_constant_p(__B) && __B < 16)
-	lshift = (__v2du) vec_splat_s32(__B);
+	__lshift = (__v2du) vec_splat_s32(__B);
       else
-	lshift = (__v2du) vec_splats ((unsigned int) __B);
+	__lshift = (__v2du) vec_splats ((unsigned int) __B);
 
-      result = vec_sl ((__v2di) __A, lshift);
+      __result = vec_sl ((__v2di) __A, __lshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srai_epi16 (__m128i __A, int __B)
 {
-  __v8hu rshift = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hi result;
+  __v8hu __rshift = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hi __result;
 
   if (__B < 16)
     {
       if (__builtin_constant_p(__B))
-	rshift = (__v8hu) vec_splat_s16(__B);
+	__rshift = (__v8hu) vec_splat_s16(__B);
       else
-	rshift = vec_splats ((unsigned short) __B);
+	__rshift = vec_splats ((unsigned short) __B);
     }
-  result = vec_sra ((__v8hi) __A, rshift);
+  __result = vec_sra ((__v8hi) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srai_epi32 (__m128i __A, int __B)
 {
-  __v4su rshift = { 31, 31, 31, 31 };
-  __v4si result;
+  __v4su __rshift = { 31, 31, 31, 31 };
+  __v4si __result;
 
   if (__B < 32)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v4su) vec_splat_s32(__B);
+	      __rshift = (__v4su) vec_splat_s32(__B);
 	    else
-	      rshift = (__v4su) vec_splats((unsigned int)__B);
+	      __rshift = (__v4su) vec_splats((unsigned int)__B);
 	}
       else
-	rshift = vec_splats ((unsigned int) __B);
+	__rshift = vec_splats ((unsigned int) __B);
     }
-  result = vec_sra ((__v4si) __A, rshift);
+  __result = vec_sra ((__v4si) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_bslli_si128 (__m128i __A, const int __N)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__N < 16)
-    result = vec_sld ((__v16qu) __A, zeros, __N);
+    __result = vec_sld ((__v16qu) __A, __zeros, __N);
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_bsrli_si128 (__m128i __A, const int __N)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__N < 16)
 #ifdef __LITTLE_ENDIAN__
@@ -1625,21 +1619,21 @@ _mm_bsrli_si128 (__m128i __A, const int __N)
       /* Would like to use Vector Shift Left Double by Octet
 	 Immediate here to use the immediate form and avoid
 	 load of __N * 8 value into a separate VR.  */
-      result = vec_sld (zeros, (__v16qu) __A, (16 - __N));
+      __result = vec_sld (__zeros, (__v16qu) __A, (16 - __N));
     else
 #endif
       {
-	__v16qu shift = vec_splats((unsigned char)(__N*8));
+	__v16qu __shift = vec_splats((unsigned char)(__N*8));
 #ifdef __LITTLE_ENDIAN__
-	result = vec_sro ((__v16qu)__A, shift);
+	__result = vec_sro ((__v16qu)__A, __shift);
 #else
-	result = vec_slo ((__v16qu)__A, shift);
+	__result = vec_slo ((__v16qu)__A, __shift);
 #endif
       }
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1651,239 +1645,239 @@ _mm_srli_si128 (__m128i __A, const int __N)
 extern __inline  __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_slli_si128 (__m128i __A, const int _imm5)
 {
-  __v16qu result;
-  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v16qu __result;
+  const __v16qu __zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (_imm5 < 16)
 #ifdef __LITTLE_ENDIAN__
-    result = vec_sld ((__v16qu) __A, zeros, _imm5);
+    __result = vec_sld ((__v16qu) __A, __zeros, _imm5);
 #else
-    result = vec_sld (zeros, (__v16qu) __A, (16 - _imm5));
+    __result = vec_sld (__zeros, (__v16qu) __A, (16 - _imm5));
 #endif
   else
-    result = zeros;
+    __result = __zeros;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 
 _mm_srli_epi16 (__m128i  __A, int __B)
 {
-  __v8hu rshift;
-  __v8hi result = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  __v8hu __rshift;
+  __v8hi __result = { 0, 0, 0, 0, 0, 0, 0, 0 };
 
   if (__B < 16)
     {
       if (__builtin_constant_p(__B))
-	rshift = (__v8hu) vec_splat_s16(__B);
+	__rshift = (__v8hu) vec_splat_s16(__B);
       else
-	rshift = vec_splats ((unsigned short) __B);
+	__rshift = vec_splats ((unsigned short) __B);
 
-      result = vec_sr ((__v8hi) __A, rshift);
+      __result = vec_sr ((__v8hi) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srli_epi32 (__m128i __A, int __B)
 {
-  __v4su rshift;
-  __v4si result = { 0, 0, 0, 0 };
+  __v4su __rshift;
+  __v4si __result = { 0, 0, 0, 0 };
 
   if (__B < 32)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v4su) vec_splat_s32(__B);
+	      __rshift = (__v4su) vec_splat_s32(__B);
 	    else
-	      rshift = (__v4su) vec_splats((unsigned int)__B);
+	      __rshift = (__v4su) vec_splats((unsigned int)__B);
 	}
       else
-	rshift = vec_splats ((unsigned int) __B);
+	__rshift = vec_splats ((unsigned int) __B);
 
-      result = vec_sr ((__v4si) __A, rshift);
+      __result = vec_sr ((__v4si) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srli_epi64 (__m128i __A, int __B)
 {
-  __v2du rshift;
-  __v2di result = { 0, 0 };
+  __v2du __rshift;
+  __v2di __result = { 0, 0 };
 
   if (__B < 64)
     {
       if (__builtin_constant_p(__B))
 	{
 	  if (__B < 16)
-	      rshift = (__v2du) vec_splat_s32(__B);
+	      __rshift = (__v2du) vec_splat_s32(__B);
 	    else
-	      rshift = (__v2du) vec_splats((unsigned long long)__B);
+	      __rshift = (__v2du) vec_splats((unsigned long long)__B);
 	}
       else
-	rshift = (__v2du) vec_splats ((unsigned int) __B);
+	__rshift = (__v2du) vec_splats ((unsigned int) __B);
 
-      result = vec_sr ((__v2di) __A, rshift);
+      __result = vec_sr ((__v2di) __A, __rshift);
     }
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi16 (__m128i __A, __m128i __B)
 {
-  __v8hu lshift;
-  __vector __bool short shmask;
-  const __v8hu shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu result;
+  __v8hu __lshift;
+  __vector __bool short __shmask;
+  const __v8hu __shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __result;
 
 #ifdef __LITTLE_ENDIAN__
-  lshift = vec_splat ((__v8hu) __B, 0);
+  __lshift = vec_splat ((__v8hu) __B, 0);
 #else
-  lshift = vec_splat ((__v8hu) __B, 3);
+  __lshift = vec_splat ((__v8hu) __B, 3);
 #endif
-  shmask = vec_cmple (lshift, shmax);
-  result = vec_sl ((__v8hu) __A, lshift);
-  result = vec_sel ((__v8hu) shmask, result, shmask);
+  __shmask = vec_cmple (__lshift, __shmax);
+  __result = vec_sl ((__v8hu) __A, __lshift);
+  __result = vec_sel ((__v8hu) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi32 (__m128i __A, __m128i __B)
 {
-  __v4su lshift;
-  __vector __bool int shmask;
-  const __v4su shmax = { 32, 32, 32, 32 };
-  __v4su result;
+  __v4su __lshift;
+  __vector __bool int __shmask;
+  const __v4su __shmax = { 32, 32, 32, 32 };
+  __v4su __result;
 #ifdef __LITTLE_ENDIAN__
-  lshift = vec_splat ((__v4su) __B, 0);
+  __lshift = vec_splat ((__v4su) __B, 0);
 #else
-  lshift = vec_splat ((__v4su) __B, 1);
+  __lshift = vec_splat ((__v4su) __B, 1);
 #endif
-  shmask = vec_cmplt (lshift, shmax);
-  result = vec_sl ((__v4su) __A, lshift);
-  result = vec_sel ((__v4su) shmask, result, shmask);
+  __shmask = vec_cmplt (__lshift, __shmax);
+  __result = vec_sl ((__v4su) __A, __lshift);
+  __result = vec_sel ((__v4su) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_epi64 (__m128i __A, __m128i __B)
 {
-  __v2du lshift;
-  __vector __bool long long shmask;
-  const __v2du shmax = { 64, 64 };
-  __v2du result;
+  __v2du __lshift;
+  __vector __bool long long __shmask;
+  const __v2du __shmax = { 64, 64 };
+  __v2du __result;
 
-  lshift = vec_splat ((__v2du) __B, 0);
-  shmask = vec_cmplt (lshift, shmax);
-  result = vec_sl ((__v2du) __A, lshift);
-  result = vec_sel ((__v2du) shmask, result, shmask);
+  __lshift = vec_splat ((__v2du) __B, 0);
+  __shmask = vec_cmplt (__lshift, __shmax);
+  __result = vec_sl ((__v2du) __A, __lshift);
+  __result = vec_sel ((__v2du) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_epi16 (__m128i __A, __m128i __B)
 {
-  const __v8hu rshmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu rshift;
-  __v8hi result;
+  const __v8hu __rshmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __rshift;
+  __v8hi __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v8hu)__B, 0);
+  __rshift = vec_splat ((__v8hu)__B, 0);
 #else
-  rshift = vec_splat ((__v8hu)__B, 3);
+  __rshift = vec_splat ((__v8hu)__B, 3);
 #endif
-  rshift = vec_min (rshift, rshmax);
-  result = vec_sra ((__v8hi) __A, rshift);
+  __rshift = vec_min (__rshift, __rshmax);
+  __result = vec_sra ((__v8hi) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_epi32 (__m128i __A, __m128i __B)
 {
-  const __v4su rshmax = { 31, 31, 31, 31 };
-  __v4su rshift;
-  __v4si result;
+  const __v4su __rshmax = { 31, 31, 31, 31 };
+  __v4su __rshift;
+  __v4si __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v4su)__B, 0);
+  __rshift = vec_splat ((__v4su)__B, 0);
 #else
-  rshift = vec_splat ((__v4su)__B, 1);
+  __rshift = vec_splat ((__v4su)__B, 1);
 #endif
-  rshift = vec_min (rshift, rshmax);
-  result = vec_sra ((__v4si) __A, rshift);
+  __rshift = vec_min (__rshift, __rshmax);
+  __result = vec_sra ((__v4si) __A, __rshift);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi16 (__m128i __A, __m128i __B)
 {
-  __v8hu rshift;
-  __vector __bool short shmask;
-  const __v8hu shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
-  __v8hu result;
+  __v8hu __rshift;
+  __vector __bool short __shmask;
+  const __v8hu __shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };
+  __v8hu __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v8hu) __B, 0);
+  __rshift = vec_splat ((__v8hu) __B, 0);
 #else
-  rshift = vec_splat ((__v8hu) __B, 3);
+  __rshift = vec_splat ((__v8hu) __B, 3);
 #endif
-  shmask = vec_cmple (rshift, shmax);
-  result = vec_sr ((__v8hu) __A, rshift);
-  result = vec_sel ((__v8hu) shmask, result, shmask);
+  __shmask = vec_cmple (__rshift, __shmax);
+  __result = vec_sr ((__v8hu) __A, __rshift);
+  __result = vec_sel ((__v8hu) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi32 (__m128i __A, __m128i __B)
 {
-  __v4su rshift;
-  __vector __bool int shmask;
-  const __v4su shmax = { 32, 32, 32, 32 };
-  __v4su result;
+  __v4su __rshift;
+  __vector __bool int __shmask;
+  const __v4su __shmax = { 32, 32, 32, 32 };
+  __v4su __result;
 
 #ifdef __LITTLE_ENDIAN__
-  rshift = vec_splat ((__v4su) __B, 0);
+  __rshift = vec_splat ((__v4su) __B, 0);
 #else
-  rshift = vec_splat ((__v4su) __B, 1);
+  __rshift = vec_splat ((__v4su) __B, 1);
 #endif
-  shmask = vec_cmplt (rshift, shmax);
-  result = vec_sr ((__v4su) __A, rshift);
-  result = vec_sel ((__v4su) shmask, result, shmask);
+  __shmask = vec_cmplt (__rshift, __shmax);
+  __result = vec_sr ((__v4su) __A, __rshift);
+  __result = vec_sel ((__v4su) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 #ifdef _ARCH_PWR8
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_epi64 (__m128i __A, __m128i __B)
 {
-  __v2du rshift;
-  __vector __bool long long shmask;
-  const __v2du shmax = { 64, 64 };
-  __v2du result;
+  __v2du __rshift;
+  __vector __bool long long __shmask;
+  const __v2du __shmax = { 64, 64 };
+  __v2du __result;
 
-  rshift = vec_splat ((__v2du) __B, 0);
-  shmask = vec_cmplt (rshift, shmax);
-  result = vec_sr ((__v2du) __A, rshift);
-  result = vec_sel ((__v2du) shmask, result, shmask);
+  __rshift = vec_splat ((__v2du) __B, 0);
+  __shmask = vec_cmplt (__rshift, __shmax);
+  __result = vec_sr ((__v2du) __A, __rshift);
+  __result = vec_sel ((__v2du) __shmask, __result, __shmask);
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 #endif
 
@@ -1998,11 +1992,11 @@ _mm_extract_epi16 (__m128i const __A, int const __N)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi16 (__m128i const __A, int const __D, int const __N)
 {
-  __v8hi result = (__v8hi)__A;
+  __v8hi __result = (__v8hi)__A;
 
-  result [(__N & 7)] = __D;
+  __result [(__N & 7)] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -2038,21 +2032,21 @@ _mm_min_epu8 (__m128i __A, __m128i __B)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_epi8 (__m128i __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned char perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned char __perm_mask =
     {
 	0x78, 0x70, 0x68, 0x60, 0x58, 0x50, 0x48, 0x40,
 	0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x08, 0x00
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -2060,8 +2054,8 @@ _mm_movemask_epi8 (__m128i __A)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_epu16 (__m128i __A, __m128i __B)
 {
-  __v4su w0, w1;
-  __v16qu xform1 = {
+  __v4su __w0, __w1;
+  __v16qu __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -2071,19 +2065,19 @@ _mm_mulhi_epu16 (__m128i __A, __m128i __B)
 #endif
     };
 
-  w0 = vec_vmuleuh ((__v8hu)__A, (__v8hu)__B);
-  w1 = vec_vmulouh ((__v8hu)__A, (__v8hu)__B);
-  return (__m128i) vec_perm (w0, w1, xform1);
+  __w0 = vec_vmuleuh ((__v8hu)__A, (__v8hu)__B);
+  __w1 = vec_vmulouh ((__v8hu)__A, (__v8hu)__B);
+  return (__m128i) vec_perm (__w0, __w1, __xform1);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shufflehi_epi16 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_98 = __mask & 0x03;
-  unsigned long element_selector_BA = (__mask >> 2) & 0x03;
-  unsigned long element_selector_DC = (__mask >> 4) & 0x03;
-  unsigned long element_selector_FE = (__mask >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_98 = __mask & 0x03;
+  unsigned long __element_selector_BA = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_DC = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_FE = (__mask >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0908, 0x0B0A, 0x0D0C, 0x0F0E
@@ -2091,33 +2085,33 @@ _mm_shufflehi_epi16 (__m128i __A, const int __mask)
 	      0x0809, 0x0A0B, 0x0C0D, 0x0E0F
 #endif
     };
-  __v2du pmask =
+  __v2du __pmask =
 #ifdef __LITTLE_ENDIAN__
       { 0x1716151413121110UL,  0UL};
 #else
       { 0x1011121314151617UL,  0UL};
 #endif
-  __m64_union t;
-  __v2du a, r;
+  __m64_union __t;
+  __v2du __a, __r;
 
-  t.as_short[0] = permute_selectors[element_selector_98];
-  t.as_short[1] = permute_selectors[element_selector_BA];
-  t.as_short[2] = permute_selectors[element_selector_DC];
-  t.as_short[3] = permute_selectors[element_selector_FE];
-  pmask[1] = t.as_m64;
-  a = (__v2du)__A;
-  r = vec_perm (a, a, (__vector unsigned char)pmask);
-  return (__m128i) r;
+  __t.as_short[0] = __permute_selectors[__element_selector_98];
+  __t.as_short[1] = __permute_selectors[__element_selector_BA];
+  __t.as_short[2] = __permute_selectors[__element_selector_DC];
+  __t.as_short[3] = __permute_selectors[__element_selector_FE];
+  __pmask[1] = __t.as_m64;
+  __a = (__v2du)__A;
+  __r = vec_perm (__a, __a, (__vector unsigned char)__pmask);
+  return (__m128i) __r;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shufflelo_epi16 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0100, 0x0302, 0x0504, 0x0706
@@ -2125,32 +2119,32 @@ _mm_shufflelo_epi16 (__m128i __A, const int __mask)
 	      0x0001, 0x0203, 0x0405, 0x0607
 #endif
     };
-  __v2du pmask =
+  __v2du __pmask =
 #ifdef __LITTLE_ENDIAN__
                  { 0UL,  0x1f1e1d1c1b1a1918UL};
 #else
                  { 0UL,  0x18191a1b1c1d1e1fUL};
 #endif
-  __m64_union t;
-  __v2du a, r;
-  t.as_short[0] = permute_selectors[element_selector_10];
-  t.as_short[1] = permute_selectors[element_selector_32];
-  t.as_short[2] = permute_selectors[element_selector_54];
-  t.as_short[3] = permute_selectors[element_selector_76];
-  pmask[0] = t.as_m64;
-  a = (__v2du)__A;
-  r = vec_perm (a, a, (__vector unsigned char)pmask);
-  return (__m128i) r;
+  __m64_union __t;
+  __v2du __a, __r;
+  __t.as_short[0] = __permute_selectors[__element_selector_10];
+  __t.as_short[1] = __permute_selectors[__element_selector_32];
+  __t.as_short[2] = __permute_selectors[__element_selector_54];
+  __t.as_short[3] = __permute_selectors[__element_selector_76];
+  __pmask[0] = __t.as_m64;
+  __a = (__v2du)__A;
+  __r = vec_perm (__a, __a, (__vector unsigned char)__pmask);
+  return (__m128i) __r;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_epi32 (__m128i __A, const int __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned int permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned int __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C
@@ -2158,26 +2152,26 @@ _mm_shuffle_epi32 (__m128i __A, const int __mask)
       0x00010203, 0x04050607, 0x08090A0B, 0x0C0D0E0F
 #endif
     };
-  __v4su t;
+  __v4su __t;
 
-  t[0] = permute_selectors[element_selector_10];
-  t[1] = permute_selectors[element_selector_32];
-  t[2] = permute_selectors[element_selector_54] + 0x10101010;
-  t[3] = permute_selectors[element_selector_76] + 0x10101010;
-  return (__m128i)vec_perm ((__v4si) __A, (__v4si)__A, (__vector unsigned char)t);
+  __t[0] = __permute_selectors[__element_selector_10];
+  __t[1] = __permute_selectors[__element_selector_32];
+  __t[2] = __permute_selectors[__element_selector_54] + 0x10101010;
+  __t[3] = __permute_selectors[__element_selector_76] + 0x10101010;
+  return (__m128i)vec_perm ((__v4si) __A, (__v4si)__A, (__vector unsigned char)__t);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)
 {
-  __v2du hibit = { 0x7f7f7f7f7f7f7f7fUL, 0x7f7f7f7f7f7f7f7fUL};
-  __v16qu mask, tmp;
-  __m128i_u *p = (__m128i_u*)__C;
+  __v2du __hibit = { 0x7f7f7f7f7f7f7f7fUL, 0x7f7f7f7f7f7f7f7fUL};
+  __v16qu __mask, __tmp;
+  __m128i_u *__p = (__m128i_u*)__C;
 
-  tmp = (__v16qu)_mm_loadu_si128(p);
-  mask = (__v16qu)vec_cmpgt ((__v16qu)__B, (__v16qu)hibit);
-  tmp = vec_sel (tmp, (__v16qu)__A, mask);
-  _mm_storeu_si128 (p, (__m128i)tmp);
+  __tmp = (__v16qu)_mm_loadu_si128(__p);
+  __mask = (__v16qu)vec_cmpgt ((__v16qu)__B, (__v16qu)__hibit);
+  __tmp = vec_sel (__tmp, (__v16qu)__A, __mask);
+  _mm_storeu_si128 (__p, (__m128i)__tmp);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -2196,29 +2190,29 @@ _mm_avg_epu16 (__m128i __A, __m128i __B)
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sad_epu8 (__m128i __A, __m128i __B)
 {
-  __v16qu a, b;
-  __v16qu vmin, vmax, vabsdiff;
-  __v4si vsum;
-  const __v4su zero = { 0, 0, 0, 0 };
-  __v4si result;
+  __v16qu __a, __b;
+  __v16qu __vmin, __vmax, __vabsdiff;
+  __v4si __vsum;
+  const __v4su __zero = { 0, 0, 0, 0 };
+  __v4si __result;
 
-  a = (__v16qu) __A;
-  b = (__v16qu) __B;
-  vmin = vec_min (a, b);
-  vmax = vec_max (a, b);
-  vabsdiff = vec_sub (vmax, vmin);
+  __a = (__v16qu) __A;
+  __b = (__v16qu) __B;
+  __vmin = vec_min (__a, __b);
+  __vmax = vec_max (__a, __b);
+  __vabsdiff = vec_sub (__vmax, __vmin);
   /* Sum four groups of bytes into integers.  */
-  vsum = (__vector signed int) vec_sum4s (vabsdiff, zero);
+  __vsum = (__vector signed int) vec_sum4s (__vabsdiff, __zero);
   /* Sum across four integers with two integer results.  */
-  result = vec_sum2s (vsum, (__vector signed int) zero);
+  __result = vec_sum2s (__vsum, (__vector signed int) __zero);
   /* Rotate the sums into the correct position.  */
 #ifdef __LITTLE_ENDIAN__
-  result = vec_sld (result, result, 4);
+  __result = vec_sld (__result, __result, 4);
 #else
-  result = vec_sld (result, result, 6);
+  __result = vec_sld (__result, __result, 6);
 #endif
   /* Rotate the sums into the correct position.  */
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/fusion.md b/gcc/config/rs6000/fusion.md
index 22b329af09d..6068125c217 100644
--- a/gcc/config/rs6000/fusion.md
+++ b/gcc/config/rs6000/fusion.md
@@ -22,7 +22,7 @@
 ;; load mode is DI result mode is clobber compare mode is CC extend is none
 (define_insn_and_split "*ld_cmpdi_cr0_DI_clobber_CC_none"
   [(set (match_operand:CC 2 "cc_reg_operand" "=x")
-        (compare:CC (match_operand:DI 1 "ds_form_mem_operand" "m")
+        (compare:CC (match_operand:DI 1 "non_update_memory_operand" "YZ")
                     (match_operand:DI 3 "const_m1_to_1_operand" "n")))
    (clobber (match_scratch:DI 0 "=r"))]
   "(TARGET_P10_FUSION)"
@@ -43,7 +43,7 @@
 ;; load mode is DI result mode is clobber compare mode is CCUNS extend is none
 (define_insn_and_split "*ld_cmpldi_cr0_DI_clobber_CCUNS_none"
   [(set (match_operand:CCUNS 2 "cc_reg_operand" "=x")
-        (compare:CCUNS (match_operand:DI 1 "ds_form_mem_operand" "m")
+        (compare:CCUNS (match_operand:DI 1 "non_update_memory_operand" "YZ")
                        (match_operand:DI 3 "const_0_to_1_operand" "n")))
    (clobber (match_scratch:DI 0 "=r"))]
   "(TARGET_P10_FUSION)"
@@ -64,7 +64,7 @@
 ;; load mode is DI result mode is DI compare mode is CC extend is none
 (define_insn_and_split "*ld_cmpdi_cr0_DI_DI_CC_none"
   [(set (match_operand:CC 2 "cc_reg_operand" "=x")
-        (compare:CC (match_operand:DI 1 "ds_form_mem_operand" "m")
+        (compare:CC (match_operand:DI 1 "non_update_memory_operand" "YZ")
                     (match_operand:DI 3 "const_m1_to_1_operand" "n")))
    (set (match_operand:DI 0 "gpc_reg_operand" "=r") (match_dup 1))]
   "(TARGET_P10_FUSION)"
@@ -85,7 +85,7 @@
 ;; load mode is DI result mode is DI compare mode is CCUNS extend is none
 (define_insn_and_split "*ld_cmpldi_cr0_DI_DI_CCUNS_none"
   [(set (match_operand:CCUNS 2 "cc_reg_operand" "=x")
-        (compare:CCUNS (match_operand:DI 1 "ds_form_mem_operand" "m")
+        (compare:CCUNS (match_operand:DI 1 "non_update_memory_operand" "YZ")
                        (match_operand:DI 3 "const_0_to_1_operand" "n")))
    (set (match_operand:DI 0 "gpc_reg_operand" "=r") (match_dup 1))]
   "(TARGET_P10_FUSION)"
@@ -104,17 +104,17 @@
 
 ;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10
 ;; load mode is SI result mode is clobber compare mode is CC extend is none
-(define_insn_and_split "*lwa_cmpdi_cr0_SI_clobber_CC_none"
+(define_insn_and_split "*lwz_cmpwi_cr0_SI_clobber_CC_none"
   [(set (match_operand:CC 2 "cc_reg_operand" "=x")
-        (compare:CC (match_operand:SI 1 "ds_form_mem_operand" "m")
+        (compare:CC (match_operand:SI 1 "non_update_memory_operand" "m")
                     (match_operand:SI 3 "const_m1_to_1_operand" "n")))
    (clobber (match_scratch:SI 0 "=r"))]
   "(TARGET_P10_FUSION)"
-  "lwa%X1 %0,%1\;cmpdi %2,%0,%3"
+  "lwz%X1 %0,%1\;cmpwi %2,%0,%3"
   "&& reload_completed
    && (cc_reg_not_cr0_operand (operands[2], CCmode)
        || !address_is_non_pfx_d_or_x (XEXP (operands[1], 0),
-                                      SImode, NON_PREFIXED_DS))"
+                                      SImode, NON_PREFIXED_D))"
   [(set (match_dup 0) (match_dup 1))
    (set (match_dup 2)
         (compare:CC (match_dup 0) (match_dup 3)))]
@@ -146,17 +146,17 @@
 
 ;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10
 ;; load mode is SI result mode is SI compare mode is CC extend is none
-(define_insn_and_split "*lwa_cmpdi_cr0_SI_SI_CC_none"
+(define_insn_and_split "*lwz_cmpwi_cr0_SI_SI_CC_none"
   [(set (match_operand:CC 2 "cc_reg_operand" "=x")
-        (compare:CC (match_operand:SI 1 "ds_form_mem_operand" "m")
+        (compare:CC (match_operand:SI 1 "non_update_memory_operand" "m")
                     (match_operand:SI 3 "const_m1_to_1_operand" "n")))
    (set (match_operand:SI 0 "gpc_reg_operand" "=r") (match_dup 1))]
   "(TARGET_P10_FUSION)"
-  "lwa%X1 %0,%1\;cmpdi %2,%0,%3"
+  "lwz%X1 %0,%1\;cmpwi %2,%0,%3"
   "&& reload_completed
    && (cc_reg_not_cr0_operand (operands[2], CCmode)
        || !address_is_non_pfx_d_or_x (XEXP (operands[1], 0),
-                                      SImode, NON_PREFIXED_DS))"
+                                      SImode, NON_PREFIXED_D))"
   [(set (match_dup 0) (match_dup 1))
    (set (match_dup 2)
         (compare:CC (match_dup 0) (match_dup 3)))]
@@ -190,7 +190,7 @@
 ;; load mode is SI result mode is EXTSI compare mode is CC extend is sign
 (define_insn_and_split "*lwa_cmpdi_cr0_SI_EXTSI_CC_sign"
   [(set (match_operand:CC 2 "cc_reg_operand" "=x")
-        (compare:CC (match_operand:SI 1 "ds_form_mem_operand" "m")
+        (compare:CC (match_operand:SI 1 "non_update_memory_operand" "YZ")
                     (match_operand:SI 3 "const_m1_to_1_operand" "n")))
    (set (match_operand:EXTSI 0 "gpc_reg_operand" "=r") (sign_extend:EXTSI (match_dup 1)))]
   "(TARGET_P10_FUSION)"
@@ -205,6 +205,7 @@
   ""
   [(set_attr "type" "fused_load_cmpi")
    (set_attr "cost" "8")
+   (set_attr "sign_extend" "yes")
    (set_attr "length" "8")])
 
 ;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10
diff --git a/gcc/config/rs6000/genfusion.pl b/gcc/config/rs6000/genfusion.pl
index badda5e8427..e728bdd8f2e 100755
--- a/gcc/config/rs6000/genfusion.pl
+++ b/gcc/config/rs6000/genfusion.pl
@@ -53,92 +53,136 @@ sub mode_to_ldst_char
     return '?';
 }
 
+sub gen_ld_cmpi_p10_one
+{
+  my ($lmode, $result, $ccmode) = @_;
+
+  my $np = "NON_PREFIXED_D";
+  my $mempred = "non_update_memory_operand";
+  my $extend;
+
+  # We need to special case lwa.  The prefixed_load_p function in rs6000.cc
+  # (which determines if a load instruction is prefixed) uses the fact that the
+  # register mode is different from the memory mode, and that the sign_extend
+  # attribute is set to use DS-form rules for the address instead of D-form.
+  # If the register size is the same, prefixed_load_p assumes we are doing a
+  # lwz.  We change to use an lwz and word compare if we don't need to sign
+  # extend the SImode value.  Otherwise if we need the value, we need to
+  # make sure the insn is marked as ds-form.
+  my $cmp_size_char = ($lmode eq "SI"
+		       && $ccmode eq "CC"
+		       && $result !~ /^EXT|^DI$/) ? "w" : "d";
+
+  if ($ccmode eq "CC") {
+    # ld and lwa are both DS-FORM.
+    ($lmode eq "DI") and $np = "NON_PREFIXED_DS";
+    ($lmode eq "SI" && $cmp_size_char eq "d") and $np = "NON_PREFIXED_DS";
+  } else {
+    if ($lmode eq "DI") {
+      # ld is DS-form, but lwz is not.
+      $np = "NON_PREFIXED_DS";
+    }
+  }
+
+  my $cmpl = ($ccmode eq "CC") ? "" : "l";
+  my $echr = ($ccmode eq "CC" && $cmp_size_char eq "d") ? "a" : "z";
+  if ($lmode eq "DI") { $echr = ""; }
+  my $constpred = ($ccmode eq "CC") ? "const_m1_to_1_operand"
+  				    : "const_0_to_1_operand";
+
+  # For clobber, we need a SI/DI reg in case we
+  # split because we have to sign/zero extend.
+  my $clobbermode = ($lmode =~ /^[QH]I$/) ? "GPR" : $lmode;
+  if ($result =~ /^EXT/ || $result eq "GPR" || $clobbermode eq "GPR") {
+    # We always need extension if result > lmode.
+    $extend = ($ccmode eq "CC") ? "sign" : "zero";
+  } else {
+    # Result of SI/DI does not need sign extension.
+    $extend = "none";
+  }
+
+  my $ldst = mode_to_ldst_char($lmode);
+
+  # DS-form addresses need YZ, and not m.
+  my $constraint = ($np eq "NON_PREFIXED_DS") ? "YZ" : "m";
+  print <<HERE;
+;; load-cmpi fusion pattern generated by gen_ld_cmpi_p10
+;; load mode is $lmode result mode is $result compare mode is $ccmode extend is $extend
+(define_insn_and_split "*l${ldst}${echr}_cmp${cmpl}${cmp_size_char}i_cr0_${lmode}_${result}_${ccmode}_${extend}"
+  [(set (match_operand:${ccmode} 2 "cc_reg_operand" "=x")
+        (compare:${ccmode} (match_operand:${lmode} 1 "${mempred}" "${constraint}")
+HERE
+  print "   " if $ccmode eq "CCUNS";
+print <<HERE;
+                    (match_operand:${lmode} 3 "${constpred}" "n")))
+HERE
+
+  if ($result eq "clobber") {
+    print <<HERE;
+   (clobber (match_scratch:${clobbermode} 0 "=r"))]
+HERE
+  } elsif ($result eq $lmode) {
+    print <<HERE;
+   (set (match_operand:${result} 0 "gpc_reg_operand" "=r") (match_dup 1))]
+HERE
+  } else {
+    print <<HERE;
+   (set (match_operand:${result} 0 "gpc_reg_operand" "=r") (${extend}_extend:${result} (match_dup 1)))]
+HERE
+  }
+
+  print <<HERE;
+  "(TARGET_P10_FUSION)"
+  "l${ldst}${echr}%X1 %0,%1\\;cmp${cmpl}${cmp_size_char}i %2,%0,%3"
+  "&& reload_completed
+   && (cc_reg_not_cr0_operand (operands[2], CCmode)
+       || !address_is_non_pfx_d_or_x (XEXP (operands[1], 0),
+                                      ${lmode}mode, ${np}))"
+HERE
+
+  if ($extend eq "none") {
+    print "  [(set (match_dup 0) (match_dup 1))\n";
+  } elsif ($result eq "clobber") {
+    print "  [(set (match_dup 0) (${extend}_extend:${clobbermode} (match_dup 1)))\n";
+  } else {
+    print "  [(set (match_dup 0) (${extend}_extend:${result} (match_dup 1)))\n";
+  }
+
+  print <<HERE;
+   (set (match_dup 2)
+        (compare:${ccmode} (match_dup 0) (match_dup 3)))]
+  ""
+  [(set_attr "type" "fused_load_cmpi")
+   (set_attr "cost" "8")
+HERE
+
+  if ($lmode eq "SI" && $ccmode eq "CC" && $cmp_size_char eq "d") {
+    # prefixed_load_p needs the sign_extend attribute to validate lwa as a
+    # DS-form instruction instead of D-form.
+    print "   (set_attr \"sign_extend\" \"yes\")\n";
+  }
+
+  print <<HERE
+   (set_attr "length" "8")])
+
+HERE
+}
+
 sub gen_ld_cmpi_p10
 {
-    my ($lmode, $ldst, $clobbermode, $result, $cmpl, $echr, $constpred,
-	$mempred, $ccmode, $np, $extend, $resultmode);
-  LMODE: foreach $lmode ('DI','SI','HI','QI') {
-      $ldst = mode_to_ldst_char($lmode);
-      $clobbermode = $lmode;
-      # For clobber, we need a SI/DI reg in case we
-      # split because we have to sign/zero extend.
-      if ($lmode eq 'HI' || $lmode eq 'QI') { $clobbermode = "GPR"; }
-    RESULT: foreach $result ('clobber', $lmode,  "EXT".$lmode) {
-	# EXTDI does not exist, and we cannot directly produce HI/QI results.
-	next RESULT if $result eq "EXTDI" || $result eq "HI" || $result eq "QI";
-	# Don't allow EXTQI because that would allow HI result which we can't do.
-	$result = "GPR" if $result eq "EXTQI";
-      CCMODE: foreach $ccmode ('CC','CCUNS') {
-	  $np = "NON_PREFIXED_D";
-	  $mempred = "non_update_memory_operand";
-	  if ( $ccmode eq 'CC' ) {
-	      next CCMODE if $lmode eq 'QI';
-	      if ( $lmode eq 'DI' || $lmode eq 'SI' ) {
-		  # ld and lwa are both DS-FORM.
-		  $np = "NON_PREFIXED_DS";
-		  $mempred = "ds_form_mem_operand";
-	      }
-	      $cmpl = "";
-	      $echr = "a";
-	      $constpred = "const_m1_to_1_operand";
-	  } else {
-	      if ( $lmode eq 'DI' ) {
-		  # ld is DS-form, but lwz is not.
-		  $np = "NON_PREFIXED_DS";
-		  $mempred = "ds_form_mem_operand";
-	      }
-	      $cmpl = "l";
-	      $echr = "z";
-	      $constpred = "const_0_to_1_operand";
-	  }
-	  if ($lmode eq 'DI') { $echr = ""; }
-	  if ($result =~ m/^EXT/ || $result eq 'GPR' || $clobbermode eq 'GPR') {
-	      # We always need extension if result > lmode.
-	      if ( $ccmode eq 'CC' ) {
-		  $extend = "sign";
-	      } else {
-		  $extend = "zero";
-	      }
-	  } else {
-	      # Result of SI/DI does not need sign extension.
-	      $extend = "none";
-	  }
-	  print ";; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n";
-	  print ";; load mode is $lmode result mode is $result compare mode is $ccmode extend is $extend\n";
+  foreach my $lmode (qw/DI SI HI QI/) {
+    foreach my $result ("clobber", $lmode,  "EXT$lmode") {
+      # EXTDI does not exist, and we cannot directly produce HI/QI results.
+      next if $result =~ /^(QI|HI|EXTDI)$/;
 
-	  print "(define_insn_and_split \"*l${ldst}${echr}_cmp${cmpl}di_cr0_${lmode}_${result}_${ccmode}_${extend}\"\n";
-	  print "  [(set (match_operand:${ccmode} 2 \"cc_reg_operand\" \"=x\")\n";
-	  print "        (compare:${ccmode} (match_operand:${lmode} 1 \"${mempred}\" \"m\")\n";
-	  if ($ccmode eq 'CCUNS') { print "   "; }
-	  print "                    (match_operand:${lmode} 3 \"${constpred}\" \"n\")))\n";
-	  if ($result eq 'clobber') {
-	      print "   (clobber (match_scratch:${clobbermode} 0 \"=r\"))]\n";
-	  } elsif ($result eq $lmode) {
-	      print "   (set (match_operand:${result} 0 \"gpc_reg_operand\" \"=r\") (match_dup 1))]\n";
-	  } else {
-	      print "   (set (match_operand:${result} 0 \"gpc_reg_operand\" \"=r\") (${extend}_extend:${result} (match_dup 1)))]\n";
-	  }
-	  print "  \"(TARGET_P10_FUSION)\"\n";
-	  print "  \"l${ldst}${echr}%X1 %0,%1\\;cmp${cmpl}di %2,%0,%3\"\n";
-	  print "  \"&& reload_completed\n";
-	  print "   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n";
-	  print "       || !address_is_non_pfx_d_or_x (XEXP (operands[1], 0),\n";
-	  print "                                      ${lmode}mode, ${np}))\"\n";
+      # Don't allow EXTQI because that would allow HI result which we can't do.
+      $result = "GPR" if $result eq "EXTQI";
 
-	  if ($extend eq "none") {
-	      print "  [(set (match_dup 0) (match_dup 1))\n";
-	  } else {
-	      $resultmode = $result;
-	      if ( $result eq 'clobber' ) { $resultmode = $clobbermode }
-	      print "  [(set (match_dup 0) (${extend}_extend:${resultmode} (match_dup 1)))\n";
-	  }
-	  print "   (set (match_dup 2)\n";
-	  print "        (compare:${ccmode} (match_dup 0) (match_dup 3)))]\n";
-	  print "  \"\"\n";
-	  print "  [(set_attr \"type\" \"fused_load_cmpi\")\n";
-	  print "   (set_attr \"cost\" \"8\")\n";
-	  print "   (set_attr \"length\" \"8\")])\n";
-	  print "\n";
+      foreach my $ccmode (qw/CC CCUNS/) {
+	# We do not have signed single-byte loads.
+	next if ($lmode eq "QI" and $ccmode eq "CC");
+
+	gen_ld_cmpi_p10_one($lmode, $result, $ccmode);
       }
     }
   }
diff --git a/gcc/config/rs6000/mm_malloc.h b/gcc/config/rs6000/mm_malloc.h
index c04348068e0..4503e75ce18 100644
--- a/gcc/config/rs6000/mm_malloc.h
+++ b/gcc/config/rs6000/mm_malloc.h
@@ -35,28 +35,28 @@ extern "C" int posix_memalign (void **, size_t, size_t) throw ();
 #endif
 
 static __inline void *
-_mm_malloc (size_t size, size_t alignment)
+_mm_malloc (size_t __size, size_t __alignment)
 {
   /* PowerPC64 ELF V2 ABI requires quadword alignment.  */
-  size_t vec_align = sizeof (__vector float);
+  size_t __vec_align = sizeof (__vector float);
   /* Linux GLIBC malloc alignment is at least 2 X ptr size.  */
-  size_t malloc_align = (sizeof (void *) + sizeof (void *));
-  void *ptr;
+  size_t __malloc_align = (sizeof (void *) + sizeof (void *));
+  void *__ptr;
 
-  if (alignment == malloc_align && alignment == vec_align)
-    return malloc (size);
-  if (alignment < vec_align)
-    alignment = vec_align;
-  if (posix_memalign (&ptr, alignment, size) == 0)
-    return ptr;
+  if (__alignment == __malloc_align && __alignment == __vec_align)
+    return malloc (__size);
+  if (__alignment < __vec_align)
+    __alignment = __vec_align;
+  if (posix_memalign (&__ptr, __alignment, __size) == 0)
+    return __ptr;
   else
     return NULL;
 }
 
 static __inline void
-_mm_free (void * ptr)
+_mm_free (void * __ptr)
 {
-  free (ptr);
+  free (__ptr);
 }
 
 #endif /* _MM_MALLOC_H_INCLUDED */
diff --git a/gcc/config/rs6000/mma.md b/gcc/config/rs6000/mma.md
index fa081608c4c..2bf4d1718e3 100644
--- a/gcc/config/rs6000/mma.md
+++ b/gcc/config/rs6000/mma.md
@@ -267,10 +267,28 @@
 (define_expand "movoo"
   [(set (match_operand:OO 0 "nonimmediate_operand")
 	(match_operand:OO 1 "input_operand"))]
-  "TARGET_MMA"
+  ""
 {
-  rs6000_emit_move (operands[0], operands[1], OOmode);
-  DONE;
+  if (TARGET_MMA)
+    {
+      rs6000_emit_move (operands[0], operands[1], OOmode);
+      DONE;
+    }
+  else if (currently_expanding_to_rtl && seen_error ())
+    {
+      /* PR103353 shows we may want to continue to expand the __builtin_vsx_lxvp
+	 built-in function, even if we have already emitted error messages about
+	 some missing required conditions.  As shown in that PR, without one
+	 explicit mov optab on OOmode provided, it would call emit_move_insn
+	 recursively.  So we allow this pattern to be generated when we are
+	 expanding to RTL and have seen errors.  It would not cause further ICEs
+	 as the compilation would stop soon after expanding.  */
+    }
+  else if (rs6000_opaque_type_invalid_use_p (currently_expanding_gimple_stmt))
+    ;
+  else
+    /* Catch unexpected cases.  */
+    gcc_assert (false);
 })
 
 (define_insn_and_split "*movoo"
@@ -299,10 +317,25 @@
 (define_expand "movxo"
   [(set (match_operand:XO 0 "nonimmediate_operand")
 	(match_operand:XO 1 "input_operand"))]
-  "TARGET_MMA"
+  ""
 {
-  rs6000_emit_move (operands[0], operands[1], XOmode);
-  DONE;
+  if (TARGET_MMA)
+    {
+      rs6000_emit_move (operands[0], operands[1], XOmode);
+      DONE;
+    }
+  else if (currently_expanding_to_rtl && seen_error ())
+    {
+      /* PR103353 shows we may want to continue to expand the __builtin_vsx_lxvp
+	 built-in function, even if we have already emitted error messages about
+	 some missing required conditions.  So do the same handlings for XOmode
+	 as OOmode here.  */
+    }
+  else if (rs6000_opaque_type_invalid_use_p (currently_expanding_gimple_stmt))
+    ;
+  else
+    /* Catch unexpected cases.  */
+    gcc_assert (false);
 })
 
 (define_insn_and_split "*movxo"
diff --git a/gcc/config/rs6000/mmintrin.h b/gcc/config/rs6000/mmintrin.h
index 0bd929c5afe..a826fdd0c7f 100644
--- a/gcc/config/rs6000/mmintrin.h
+++ b/gcc/config/rs6000/mmintrin.h
@@ -170,17 +170,17 @@ _mm_cvtsi64_si64x (__m64 __i)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short vm1;
-  __vector signed char vresult;
+  __vector signed short __vm1;
+  __vector signed char __vresult;
 
-  vm1 = (__vector signed short) (__vector unsigned long long)
+  __vm1 = (__vector signed short) (__vector unsigned long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
-  vresult = vec_packs (vm1, vm1);
-  return (__m64) ((__vector long long) vresult)[0];
+  __vresult = vec_packs (__vm1, __vm1);
+  return (__m64) ((__vector long long) __vresult)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -195,17 +195,17 @@ _m_packsswb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pi32 (__m64 __m1, __m64 __m2)
 {
-  __vector signed int vm1;
-  __vector signed short vresult;
+  __vector signed int __vm1;
+  __vector signed short __vresult;
 
-  vm1 = (__vector signed int) (__vector unsigned long long)
+  __vm1 = (__vector signed int) (__vector unsigned long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
-  vresult = vec_packs (vm1, vm1);
-  return (__m64) ((__vector long long) vresult)[0];
+  __vresult = vec_packs (__vm1, __vm1);
+  return (__m64) ((__vector long long) __vresult)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -220,19 +220,19 @@ _m_packssdw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_packs_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char r;
-  __vector signed short vm1 = (__vector signed short) (__vector long long)
+  __vector unsigned char __r;
+  __vector signed short __vm1 = (__vector signed short) (__vector long long)
 #ifdef __LITTLE_ENDIAN__
         { __m1, __m2 };
 #else
         { __m2, __m1 };
 #endif
   const __vector signed short __zero = { 0 };
-  __vector __bool short __select = vec_cmplt (vm1, __zero);
-  r = vec_packs ((__vector unsigned short) vm1, (__vector unsigned short) vm1);
-  __vector __bool char packsel = vec_pack (__select, __select);
-  r = vec_sel (r, (const __vector unsigned char) __zero, packsel);
-  return (__m64) ((__vector long long) r)[0];
+  __vector __bool short __select = vec_cmplt (__vm1, __zero);
+  __r = vec_packs ((__vector unsigned short) __vm1, (__vector unsigned short) __vm1);
+  __vector __bool char __packsel = vec_pack (__select, __select);
+  __r = vec_sel (__r, (const __vector unsigned char) __zero, __packsel);
+  return (__m64) ((__vector long long) __r)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -248,28 +248,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_mergel (a, b);
-  return (__m64) ((__vector long long) c)[1];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_mergel (__a, __b);
+  return (__m64) ((__vector long long) __c)[1];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[4];
-  res.as_char[1] = m2.as_char[4];
-  res.as_char[2] = m1.as_char[5];
-  res.as_char[3] = m2.as_char[5];
-  res.as_char[4] = m1.as_char[6];
-  res.as_char[5] = m2.as_char[6];
-  res.as_char[6] = m1.as_char[7];
-  res.as_char[7] = m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[4];
+  __res.as_char[1] = __mu2.as_char[4];
+  __res.as_char[2] = __mu1.as_char[5];
+  __res.as_char[3] = __mu2.as_char[5];
+  __res.as_char[4] = __mu1.as_char[6];
+  __res.as_char[5] = __mu2.as_char[6];
+  __res.as_char[6] = __mu1.as_char[7];
+  __res.as_char[7] = __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -284,17 +284,17 @@ _m_punpckhbw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[2];
-  res.as_short[1] = m2.as_short[2];
-  res.as_short[2] = m1.as_short[3];
-  res.as_short[3] = m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[2];
+  __res.as_short[1] = __mu2.as_short[2];
+  __res.as_short[2] = __mu1.as_short[3];
+  __res.as_short[3] = __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -307,15 +307,15 @@ _m_punpckhwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[1];
-  res.as_int[1] = m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[1];
+  __res.as_int[1] = __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -329,28 +329,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_mergel (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_mergel (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0];
-  res.as_char[1] = m2.as_char[0];
-  res.as_char[2] = m1.as_char[1];
-  res.as_char[3] = m2.as_char[1];
-  res.as_char[4] = m1.as_char[2];
-  res.as_char[5] = m2.as_char[2];
-  res.as_char[6] = m1.as_char[3];
-  res.as_char[7] = m2.as_char[3];
+  __res.as_char[0] = __mu1.as_char[0];
+  __res.as_char[1] = __mu2.as_char[0];
+  __res.as_char[2] = __mu1.as_char[1];
+  __res.as_char[3] = __mu2.as_char[1];
+  __res.as_char[4] = __mu1.as_char[2];
+  __res.as_char[5] = __mu2.as_char[2];
+  __res.as_char[6] = __mu1.as_char[3];
+  __res.as_char[7] = __mu2.as_char[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -364,17 +364,17 @@ _m_punpcklbw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0];
-  res.as_short[1] = m2.as_short[0];
-  res.as_short[2] = m1.as_short[1];
-  res.as_short[3] = m2.as_short[1];
+  __res.as_short[0] = __mu1.as_short[0];
+  __res.as_short[1] = __mu2.as_short[0];
+  __res.as_short[2] = __mu1.as_short[1];
+  __res.as_short[3] = __mu2.as_short[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -388,15 +388,15 @@ _m_punpcklwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)
 {
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0];
-  res.as_int[1] = m2.as_int[0];
+  __res.as_int[0] = __mu1.as_int[0];
+  __res.as_int[1] = __mu2.as_int[0];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -410,28 +410,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0] + m2.as_char[0];
-  res.as_char[1] = m1.as_char[1] + m2.as_char[1];
-  res.as_char[2] = m1.as_char[2] + m2.as_char[2];
-  res.as_char[3] = m1.as_char[3] + m2.as_char[3];
-  res.as_char[4] = m1.as_char[4] + m2.as_char[4];
-  res.as_char[5] = m1.as_char[5] + m2.as_char[5];
-  res.as_char[6] = m1.as_char[6] + m2.as_char[6];
-  res.as_char[7] = m1.as_char[7] + m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[0] + __mu2.as_char[0];
+  __res.as_char[1] = __mu1.as_char[1] + __mu2.as_char[1];
+  __res.as_char[2] = __mu1.as_char[2] + __mu2.as_char[2];
+  __res.as_char[3] = __mu1.as_char[3] + __mu2.as_char[3];
+  __res.as_char[4] = __mu1.as_char[4] + __mu2.as_char[4];
+  __res.as_char[5] = __mu1.as_char[5] + __mu2.as_char[5];
+  __res.as_char[6] = __mu1.as_char[6] + __mu2.as_char[6];
+  __res.as_char[7] = __mu1.as_char[7] + __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -446,24 +446,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0] + m2.as_short[0];
-  res.as_short[1] = m1.as_short[1] + m2.as_short[1];
-  res.as_short[2] = m1.as_short[2] + m2.as_short[2];
-  res.as_short[3] = m1.as_short[3] + m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[0] + __mu2.as_short[0];
+  __res.as_short[1] = __mu1.as_short[1] + __mu2.as_short[1];
+  __res.as_short[2] = __mu1.as_short[2] + __mu2.as_short[2];
+  __res.as_short[3] = __mu1.as_short[3] + __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -478,22 +478,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_add_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = vec_add (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = vec_add (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0] + m2.as_int[0];
-  res.as_int[1] = m1.as_int[1] + m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[0] + __mu2.as_int[0];
+  __res.as_int[1] = __mu1.as_int[1] + __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -508,28 +508,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = m1.as_char[0] - m2.as_char[0];
-  res.as_char[1] = m1.as_char[1] - m2.as_char[1];
-  res.as_char[2] = m1.as_char[2] - m2.as_char[2];
-  res.as_char[3] = m1.as_char[3] - m2.as_char[3];
-  res.as_char[4] = m1.as_char[4] - m2.as_char[4];
-  res.as_char[5] = m1.as_char[5] - m2.as_char[5];
-  res.as_char[6] = m1.as_char[6] - m2.as_char[6];
-  res.as_char[7] = m1.as_char[7] - m2.as_char[7];
+  __res.as_char[0] = __mu1.as_char[0] - __mu2.as_char[0];
+  __res.as_char[1] = __mu1.as_char[1] - __mu2.as_char[1];
+  __res.as_char[2] = __mu1.as_char[2] - __mu2.as_char[2];
+  __res.as_char[3] = __mu1.as_char[3] - __mu2.as_char[3];
+  __res.as_char[4] = __mu1.as_char[4] - __mu2.as_char[4];
+  __res.as_char[5] = __mu1.as_char[5] - __mu2.as_char[5];
+  __res.as_char[6] = __mu1.as_char[6] - __mu2.as_char[6];
+  __res.as_char[7] = __mu1.as_char[7] - __mu2.as_char[7];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -544,24 +544,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = m1.as_short[0] - m2.as_short[0];
-  res.as_short[1] = m1.as_short[1] - m2.as_short[1];
-  res.as_short[2] = m1.as_short[2] - m2.as_short[2];
-  res.as_short[3] = m1.as_short[3] - m2.as_short[3];
+  __res.as_short[0] = __mu1.as_short[0] - __mu2.as_short[0];
+  __res.as_short[1] = __mu1.as_short[1] - __mu2.as_short[1];
+  __res.as_short[2] = __mu1.as_short[2] - __mu2.as_short[2];
+  __res.as_short[3] = __mu1.as_short[3] - __mu2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -576,22 +576,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_sub_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = vec_sub (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = vec_sub (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = m1.as_int[0] - m2.as_int[0];
-  res.as_int[1] = m1.as_int[1] - m2.as_int[1];
+  __res.as_int[0] = __mu1.as_int[0] - __mu2.as_int[0];
+  __res.as_int[1] = __mu1.as_int[1] - __mu2.as_int[1];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -729,30 +729,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)
 {
 #if defined(_ARCH_PWR6) && defined(__powerpc64__)
-  __m64 res;
+  __m64 __res;
   __asm__(
       "cmpb %0,%1,%2;\n"
-      : "=r" (res)
+      : "=r" (__res)
       : "r" (__m1),
 	"r" (__m2)
       : );
-  return (res);
+  return (__res);
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = (m1.as_char[0] == m2.as_char[0])? -1: 0;
-  res.as_char[1] = (m1.as_char[1] == m2.as_char[1])? -1: 0;
-  res.as_char[2] = (m1.as_char[2] == m2.as_char[2])? -1: 0;
-  res.as_char[3] = (m1.as_char[3] == m2.as_char[3])? -1: 0;
-  res.as_char[4] = (m1.as_char[4] == m2.as_char[4])? -1: 0;
-  res.as_char[5] = (m1.as_char[5] == m2.as_char[5])? -1: 0;
-  res.as_char[6] = (m1.as_char[6] == m2.as_char[6])? -1: 0;
-  res.as_char[7] = (m1.as_char[7] == m2.as_char[7])? -1: 0;
+  __res.as_char[0] = (__mu1.as_char[0] == __mu2.as_char[0])? -1: 0;
+  __res.as_char[1] = (__mu1.as_char[1] == __mu2.as_char[1])? -1: 0;
+  __res.as_char[2] = (__mu1.as_char[2] == __mu2.as_char[2])? -1: 0;
+  __res.as_char[3] = (__mu1.as_char[3] == __mu2.as_char[3])? -1: 0;
+  __res.as_char[4] = (__mu1.as_char[4] == __mu2.as_char[4])? -1: 0;
+  __res.as_char[5] = (__mu1.as_char[5] == __mu2.as_char[5])? -1: 0;
+  __res.as_char[6] = (__mu1.as_char[6] == __mu2.as_char[6])? -1: 0;
+  __res.as_char[7] = (__mu1.as_char[7] == __mu2.as_char[7])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -766,28 +766,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = (__vector signed char)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = (__vector signed char)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_char[0] = (m1.as_char[0] > m2.as_char[0])? -1: 0;
-  res.as_char[1] = (m1.as_char[1] > m2.as_char[1])? -1: 0;
-  res.as_char[2] = (m1.as_char[2] > m2.as_char[2])? -1: 0;
-  res.as_char[3] = (m1.as_char[3] > m2.as_char[3])? -1: 0;
-  res.as_char[4] = (m1.as_char[4] > m2.as_char[4])? -1: 0;
-  res.as_char[5] = (m1.as_char[5] > m2.as_char[5])? -1: 0;
-  res.as_char[6] = (m1.as_char[6] > m2.as_char[6])? -1: 0;
-  res.as_char[7] = (m1.as_char[7] > m2.as_char[7])? -1: 0;
+  __res.as_char[0] = (__mu1.as_char[0] > __mu2.as_char[0])? -1: 0;
+  __res.as_char[1] = (__mu1.as_char[1] > __mu2.as_char[1])? -1: 0;
+  __res.as_char[2] = (__mu1.as_char[2] > __mu2.as_char[2])? -1: 0;
+  __res.as_char[3] = (__mu1.as_char[3] > __mu2.as_char[3])? -1: 0;
+  __res.as_char[4] = (__mu1.as_char[4] > __mu2.as_char[4])? -1: 0;
+  __res.as_char[5] = (__mu1.as_char[5] > __mu2.as_char[5])? -1: 0;
+  __res.as_char[6] = (__mu1.as_char[6] > __mu2.as_char[6])? -1: 0;
+  __res.as_char[7] = (__mu1.as_char[7] > __mu2.as_char[7])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -803,24 +803,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = (__vector signed short)vec_cmpeq (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = (__vector signed short)vec_cmpeq (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = (m1.as_short[0] == m2.as_short[0])? -1: 0;
-  res.as_short[1] = (m1.as_short[1] == m2.as_short[1])? -1: 0;
-  res.as_short[2] = (m1.as_short[2] == m2.as_short[2])? -1: 0;
-  res.as_short[3] = (m1.as_short[3] == m2.as_short[3])? -1: 0;
+  __res.as_short[0] = (__mu1.as_short[0] == __mu2.as_short[0])? -1: 0;
+  __res.as_short[1] = (__mu1.as_short[1] == __mu2.as_short[1])? -1: 0;
+  __res.as_short[2] = (__mu1.as_short[2] == __mu2.as_short[2])? -1: 0;
+  __res.as_short[3] = (__mu1.as_short[3] == __mu2.as_short[3])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -834,24 +834,24 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = (__vector signed short)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = (__vector signed short)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_short[0] = (m1.as_short[0] > m2.as_short[0])? -1: 0;
-  res.as_short[1] = (m1.as_short[1] > m2.as_short[1])? -1: 0;
-  res.as_short[2] = (m1.as_short[2] > m2.as_short[2])? -1: 0;
-  res.as_short[3] = (m1.as_short[3] > m2.as_short[3])? -1: 0;
+  __res.as_short[0] = (__mu1.as_short[0] > __mu2.as_short[0])? -1: 0;
+  __res.as_short[1] = (__mu1.as_short[1] > __mu2.as_short[1])? -1: 0;
+  __res.as_short[2] = (__mu1.as_short[2] > __mu2.as_short[2])? -1: 0;
+  __res.as_short[3] = (__mu1.as_short[3] > __mu2.as_short[3])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -867,22 +867,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = (__vector signed int)vec_cmpeq (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = (__vector signed int)vec_cmpeq (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = (m1.as_int[0] == m2.as_int[0])? -1: 0;
-  res.as_int[1] = (m1.as_int[1] == m2.as_int[1])? -1: 0;
+  __res.as_int[0] = (__mu1.as_int[0] == __mu2.as_int[0])? -1: 0;
+  __res.as_int[1] = (__mu1.as_int[1] == __mu2.as_int[1])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -896,22 +896,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)
 {
 #if _ARCH_PWR9
-  __vector signed int a, b, c;
+  __vector signed int __a, __b, __c;
 
-  a = (__vector signed int)vec_splats (__m1);
-  b = (__vector signed int)vec_splats (__m2);
-  c = (__vector signed int)vec_cmpgt (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed int)vec_splats (__m1);
+  __b = (__vector signed int)vec_splats (__m2);
+  __c = (__vector signed int)vec_cmpgt (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __mu1, __mu2, __res;
 
-  m1.as_m64 = __m1;
-  m2.as_m64 = __m2;
+  __mu1.as_m64 = __m1;
+  __mu2.as_m64 = __m2;
 
-  res.as_int[0] = (m1.as_int[0] > m2.as_int[0])? -1: 0;
-  res.as_int[1] = (m1.as_int[1] > m2.as_int[1])? -1: 0;
+  __res.as_int[0] = (__mu1.as_int[0] > __mu2.as_int[0])? -1: 0;
+  __res.as_int[1] = (__mu1.as_int[1] > __mu2.as_int[1])? -1: 0;
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -927,12 +927,12 @@ _m_pcmpgtd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pi8 (__m64 __m1, __m64 __m2)
 {
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -945,12 +945,12 @@ _m_paddsb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -963,12 +963,12 @@ _m_paddsw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pu8 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -982,12 +982,12 @@ _m_paddusb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_adds_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__m1);
-  b = (__vector unsigned short)vec_splats (__m2);
-  c = vec_adds (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__m1);
+  __b = (__vector unsigned short)vec_splats (__m2);
+  __c = vec_adds (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1001,12 +1001,12 @@ _m_paddusw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pi8 (__m64 __m1, __m64 __m2)
 {
-  __vector signed char a, b, c;
+  __vector signed char __a, __b, __c;
 
-  a = (__vector signed char)vec_splats (__m1);
-  b = (__vector signed char)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed char)vec_splats (__m1);
+  __b = (__vector signed char)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1020,12 +1020,12 @@ _m_psubsb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1039,12 +1039,12 @@ _m_psubsw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pu8 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__m1);
-  b = (__vector unsigned char)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__m1);
+  __b = (__vector unsigned char)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1058,12 +1058,12 @@ _m_psubusb (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_subs_pu16 (__m64 __m1, __m64 __m2)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__m1);
-  b = (__vector unsigned short)vec_splats (__m2);
-  c = vec_subs (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__m1);
+  __b = (__vector unsigned short)vec_splats (__m2);
+  __c = vec_subs (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1078,14 +1078,14 @@ _m_psubusw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_madd_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b;
-  __vector signed int c;
-  __vector signed int zero = {0, 0, 0, 0};
+  __vector signed short __a, __b;
+  __vector signed int __c;
+  __vector signed int __zero = {0, 0, 0, 0};
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = vec_vmsumshm (a, b, zero);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = vec_vmsumshm (__a, __b, __zero);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1098,10 +1098,10 @@ _m_pmaddwd (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b;
-  __vector signed short c;
-  __vector signed int w0, w1;
-  __vector unsigned char xform1 = {
+  __vector signed short __a, __b;
+  __vector signed short __c;
+  __vector signed int __w0, __w1;
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1111,14 +1111,14 @@ _mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
 #endif
     };
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
 
-  w0 = vec_vmulesh (a, b);
-  w1 = vec_vmulosh (a, b);
-  c = (__vector signed short)vec_perm (w0, w1, xform1);
+  __w0 = vec_vmulesh (__a, __b);
+  __w1 = vec_vmulosh (__a, __b);
+  __c = (__vector signed short)vec_perm (__w0, __w1, __xform1);
 
-  return (__m64) ((__vector long long) c)[0];
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1132,12 +1132,12 @@ _m_pmulhw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mullo_pi16 (__m64 __m1, __m64 __m2)
 {
-  __vector signed short a, b, c;
+  __vector signed short __a, __b, __c;
 
-  a = (__vector signed short)vec_splats (__m1);
-  b = (__vector signed short)vec_splats (__m2);
-  c = a * b;
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector signed short)vec_splats (__m1);
+  __b = (__vector signed short)vec_splats (__m2);
+  __c = __a * __b;
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1150,15 +1150,15 @@ _m_pmullw (__m64 __m1, __m64 __m2)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_pi16 (__m64 __m, __m64 __count)
 {
-  __vector signed short m, r;
-  __vector unsigned short c;
+  __vector signed short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-      m = (__vector signed short)vec_splats (__m);
-      c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-      r = vec_sl (m, (__vector unsigned short)c);
-      return (__m64) ((__vector long long) r)[0];
+      __r = (__vector signed short)vec_splats (__m);
+      __c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+      __r = vec_sl (__r, (__vector unsigned short)__c);
+      return (__m64) ((__vector long long) __r)[0];
     }
   else
   return (0);
@@ -1187,13 +1187,13 @@ _m_psllwi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sll_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = m.as_int[0] << __count;
-  res.as_int[1] = m.as_int[1] << __count;
-  return (res.as_m64);
+  __res.as_int[0] = __res.as_int[0] << __count;
+  __res.as_int[1] = __res.as_int[1] << __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1219,15 +1219,15 @@ _m_pslldi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_pi16 (__m64 __m, __m64 __count)
 {
-  __vector signed short m, r;
-  __vector unsigned short c;
+  __vector signed short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-	m = (__vector signed short)vec_splats (__m);
-	c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-	r = vec_sra (m, (__vector unsigned short)c);
-        return (__m64) ((__vector long long) r)[0];
+	__r = (__vector signed short)vec_splats (__m);
+	__c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+	__r = vec_sra (__r, (__vector unsigned short)__c);
+        return (__m64) ((__vector long long) __r)[0];
     }
   else
   return (0);
@@ -1256,13 +1256,13 @@ _m_psrawi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sra_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = m.as_int[0] >> __count;
-  res.as_int[1] = m.as_int[1] >> __count;
-  return (res.as_m64);
+  __res.as_int[0] = __res.as_int[0] >> __count;
+  __res.as_int[1] = __res.as_int[1] >> __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1288,15 +1288,15 @@ _m_psradi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_pi16 (__m64 __m, __m64 __count)
 {
-  __vector unsigned short m, r;
-  __vector unsigned short c;
+  __vector unsigned short __r;
+  __vector unsigned short __c;
 
   if (__count <= 15)
     {
-	m = (__vector unsigned short)vec_splats (__m);
-	c = (__vector unsigned short)vec_splats ((unsigned short)__count);
-	r = vec_sr (m, (__vector unsigned short)c);
-        return (__m64) ((__vector long long) r)[0];
+	__r = (__vector unsigned short)vec_splats (__m);
+	__c = (__vector unsigned short)vec_splats ((unsigned short)__count);
+	__r = vec_sr (__r, (__vector unsigned short)__c);
+        return (__m64) ((__vector long long) __r)[0];
     }
   else
     return (0);
@@ -1325,13 +1325,13 @@ _m_psrlwi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_srl_pi32 (__m64 __m, __m64 __count)
 {
-  __m64_union m, res;
+  __m64_union __res;
 
-  m.as_m64 = __m;
+  __res.as_m64 = __m;
 
-  res.as_int[0] = (unsigned int)m.as_int[0] >> __count;
-  res.as_int[1] = (unsigned int)m.as_int[1] >> __count;
-  return (res.as_m64);
+  __res.as_int[0] = (unsigned int)__res.as_int[0] >> __count;
+  __res.as_int[1] = (unsigned int)__res.as_int[1] >> __count;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1358,24 +1358,24 @@ _m_psrldi (__m64 __m, int __count)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set_pi32 (int __i1, int __i0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i0;
-  res.as_int[1] = __i1;
-  return (res.as_m64);
+  __res.as_int[0] = __i0;
+  __res.as_int[1] = __i1;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of four 16-bit values; W0 is least significant.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_short[0] = __w0;
-  res.as_short[1] = __w1;
-  res.as_short[2] = __w2;
-  res.as_short[3] = __w3;
-  return (res.as_m64);
+  __res.as_short[0] = __w0;
+  __res.as_short[1] = __w1;
+  __res.as_short[2] = __w2;
+  __res.as_short[3] = __w3;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of eight 8-bit values; B0 is least significant.  */
@@ -1383,28 +1383,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,
 	     char __b3, char __b2, char __b1, char __b0)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_char[0] = __b0;
-  res.as_char[1] = __b1;
-  res.as_char[2] = __b2;
-  res.as_char[3] = __b3;
-  res.as_char[4] = __b4;
-  res.as_char[5] = __b5;
-  res.as_char[6] = __b6;
-  res.as_char[7] = __b7;
-  return (res.as_m64);
+  __res.as_char[0] = __b0;
+  __res.as_char[1] = __b1;
+  __res.as_char[2] = __b2;
+  __res.as_char[3] = __b3;
+  __res.as_char[4] = __b4;
+  __res.as_char[5] = __b5;
+  __res.as_char[6] = __b6;
+  __res.as_char[7] = __b7;
+  return (__res.as_m64);
 }
 
 /* Similar, but with the arguments in reverse order.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_setr_pi32 (int __i0, int __i1)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i0;
-  res.as_int[1] = __i1;
-  return (res.as_m64);
+  __res.as_int[0] = __i0;
+  __res.as_int[1] = __i1;
+  return (__res.as_m64);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1424,11 +1424,11 @@ _mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set1_pi32 (int __i)
 {
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_int[0] = __i;
-  res.as_int[1] = __i;
-  return (res.as_m64);
+  __res.as_int[0] = __i;
+  __res.as_int[1] = __i;
+  return (__res.as_m64);
 }
 
 /* Creates a vector of four 16-bit values, all elements containing W.  */
@@ -1441,13 +1441,13 @@ _mm_set1_pi16 (short __w)
   w = (__vector signed short)vec_splats (__w);
   return (__m64) ((__vector long long) w)[0];
 #else
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_short[0] = __w;
-  res.as_short[1] = __w;
-  res.as_short[2] = __w;
-  res.as_short[3] = __w;
-  return (res.as_m64);
+  __res.as_short[0] = __w;
+  __res.as_short[1] = __w;
+  __res.as_short[2] = __w;
+  __res.as_short[3] = __w;
+  return (__res.as_m64);
 #endif
 }
 
@@ -1456,22 +1456,22 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_set1_pi8 (signed char __b)
 {
 #if _ARCH_PWR8
-  __vector signed char b;
+  __vector signed char __res;
 
-  b = (__vector signed char)vec_splats (__b);
-  return (__m64) ((__vector long long) b)[0];
+  __res = (__vector signed char)vec_splats (__b);
+  return (__m64) ((__vector long long) __res)[0];
 #else
-  __m64_union res;
+  __m64_union __res;
 
-  res.as_char[0] = __b;
-  res.as_char[1] = __b;
-  res.as_char[2] = __b;
-  res.as_char[3] = __b;
-  res.as_char[4] = __b;
-  res.as_char[5] = __b;
-  res.as_char[6] = __b;
-  res.as_char[7] = __b;
-  return (res.as_m64);
+  __res.as_char[0] = __b;
+  __res.as_char[1] = __b;
+  __res.as_char[2] = __b;
+  __res.as_char[3] = __b;
+  __res.as_char[4] = __b;
+  __res.as_char[5] = __b;
+  __res.as_char[6] = __b;
+  __res.as_char[7] = __b;
+  return (__res.as_m64);
 #endif
 }
 #endif /* _MMINTRIN_H_INCLUDED */
diff --git a/gcc/config/rs6000/pmmintrin.h b/gcc/config/rs6000/pmmintrin.h
index eab712fdfa6..4d7e14f312a 100644
--- a/gcc/config/rs6000/pmmintrin.h
+++ b/gcc/config/rs6000/pmmintrin.h
@@ -58,55 +58,55 @@
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_addsub_ps (__m128 __X, __m128 __Y)
 {
-  const __v4sf even_n0 = {-0.0, 0.0, -0.0, 0.0};
-  __v4sf even_neg_Y = vec_xor(__Y, even_n0);
-  return (__m128) vec_add (__X, even_neg_Y);
+  const __v4sf __even_n0 = {-0.0, 0.0, -0.0, 0.0};
+  __v4sf __even_neg_Y = vec_xor(__Y, __even_n0);
+  return (__m128) vec_add (__X, __even_neg_Y);
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_addsub_pd (__m128d __X, __m128d __Y)
 {
-  const __v2df even_n0 = {-0.0, 0.0};
-  __v2df even_neg_Y = vec_xor(__Y, even_n0);
-  return (__m128d) vec_add (__X, even_neg_Y);
+  const __v2df __even_n0 = {-0.0, 0.0};
+  __v2df __even_neg_Y = vec_xor(__Y, __even_n0);
+  return (__m128d) vec_add (__X, __even_neg_Y);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_hadd_ps (__m128 __X, __m128 __Y)
 {
-  __vector unsigned char xform2 = {
+  __vector unsigned char __xform2 = {
       0x00, 0x01, 0x02, 0x03,
       0x08, 0x09, 0x0A, 0x0B,
       0x10, 0x11, 0x12, 0x13,
       0x18, 0x19, 0x1A, 0x1B
     };
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
       0x04, 0x05, 0x06, 0x07,
       0x0C, 0x0D, 0x0E, 0x0F,
       0x14, 0x15, 0x16, 0x17,
       0x1C, 0x1D, 0x1E, 0x1F
     };
-  return (__m128) vec_add (vec_perm ((__v4sf) __X, (__v4sf) __Y, xform2),
-			   vec_perm ((__v4sf) __X, (__v4sf) __Y, xform1));
+  return (__m128) vec_add (vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform2),
+			   vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform1));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_hsub_ps (__m128 __X, __m128 __Y)
 {
-  __vector unsigned char xform2 = {
+  __vector unsigned char __xform2 = {
       0x00, 0x01, 0x02, 0x03,
       0x08, 0x09, 0x0A, 0x0B,
       0x10, 0x11, 0x12, 0x13,
       0x18, 0x19, 0x1A, 0x1B
     };
-  __vector unsigned char xform1 = {
+  __vector unsigned char __xform1 = {
       0x04, 0x05, 0x06, 0x07,
       0x0C, 0x0D, 0x0E, 0x0F,
       0x14, 0x15, 0x16, 0x17,
       0x1C, 0x1D, 0x1E, 0x1F
     };
-  return (__m128) vec_sub (vec_perm ((__v4sf) __X, (__v4sf) __Y, xform2),
-			   vec_perm ((__v4sf) __X, (__v4sf) __Y, xform1));
+  return (__m128) vec_sub (vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform2),
+			   vec_perm ((__v4sf) __X, (__v4sf) __Y, __xform1));
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/predicates.md b/gcc/config/rs6000/predicates.md
index f03560b9c06..edc8cab0e0e 100644
--- a/gcc/config/rs6000/predicates.md
+++ b/gcc/config/rs6000/predicates.md
@@ -992,20 +992,6 @@
   return INTVAL (offset) % 4 == 0;
 })
 
-;; Return 1 if the operand is a memory operand that has a valid address for
-;; a DS-form instruction. I.e. the address has to be either just a register,
-;; or register + const where the two low order bits of const are zero.
-(define_predicate "ds_form_mem_operand"
-  (match_code "subreg,mem")
-{
-  if (!any_memory_operand (op, mode))
-    return false;
-
-  rtx addr = XEXP (op, 0);
-
-  return address_to_insn_form (addr, mode, NON_PREFIXED_DS) == INSN_FORM_DS;
-})
-
 ;; Return 1 if the operand, used inside a MEM, is a SYMBOL_REF.
 (define_predicate "symbol_ref_operand"
   (and (match_code "symbol_ref")
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
index 6270444ef70..09098a70ff9 100644
--- a/gcc/config/rs6000/rs6000-builtin.def
+++ b/gcc/config/rs6000/rs6000-builtin.def
@@ -325,6 +325,14 @@
 		     | RS6000_BTC_SPECIAL),				\
 		    CODE_FOR_nothing)			/* ICODE */
 
+#define BU_VSX_MISC_2(ENUM, NAME, ATTR, ICODE)				\
+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,		/* ENUM */	\
+		    "__builtin_" NAME,			/* NAME */	\
+		    RS6000_BTM_VSX,			/* MASK */	\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */	\
+		     | RS6000_BTC_BINARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
+
 /* VSX overloaded builtin function macros.  */
 #define BU_VSX_OVERLOAD_1(ENUM, NAME)					\
   RS6000_BUILTIN_1 (VSX_BUILTIN_VEC_ ## ENUM,		/* ENUM */	\
@@ -2843,8 +2851,8 @@ BU_LDBL128_2 (UNPACK_TF,	"unpack_longdouble",	CONST,	unpacktf)
 BU_IBM128_2 (PACK_IF,		"pack_ibm128",		CONST,	packif)
 BU_IBM128_2 (UNPACK_IF,		"unpack_ibm128",	CONST,	unpackif)
 
-BU_P7_MISC_2 (PACK_V1TI,	"pack_vector_int128",	CONST,	packv1ti)
-BU_P7_MISC_2 (UNPACK_V1TI,	"unpack_vector_int128",	CONST,	unpackv1ti)
+BU_VSX_MISC_2 (PACK_V1TI,	"pack_vector_int128",	CONST,	packv1ti)
+BU_VSX_MISC_2 (UNPACK_V1TI,	"unpack_vector_int128",	CONST,	unpackv1ti)
 
 /* 2 argument DFP (Decimal Floating Point) functions added in ISA 3.0.  */
 BU_P9_DFP_MISC_2 (TSTSFI_LT_DD, "dtstsfi_lt_dd", CONST, dfptstsfi_lt_dd)
@@ -2881,9 +2889,9 @@ BU_P9V_AV_1 (VCTZB,		"vctzb",		CONST,  ctzv16qi2)
 BU_P9V_AV_1 (VCTZH,		"vctzh",		CONST,  ctzv8hi2)
 BU_P9V_AV_1 (VCTZW,		"vctzw",		CONST,  ctzv4si2)
 BU_P9V_AV_1 (VCTZD,		"vctzd",		CONST,  ctzv2di2)
-BU_P9V_AV_1 (VPRTYBD,		"vprtybd",		CONST,  parityv2di2)
-BU_P9V_AV_1 (VPRTYBQ,		"vprtybq",		CONST,  parityv1ti2)
-BU_P9V_AV_1 (VPRTYBW,		"vprtybw",		CONST,  parityv4si2)
+BU_P9V_AV_1 (VPRTYBD,		"vprtybd",		CONST,  rs6000_vprtybv2di2)
+BU_P9V_AV_1 (VPRTYBQ,		"vprtybq",		CONST,  rs6000_vprtybv1ti2)
+BU_P9V_AV_1 (VPRTYBW,		"vprtybw",		CONST,  rs6000_vprtybv4si2)
 
 /* ISA 3.0 vector overloaded 1 argument functions.  */
 BU_P9V_OVERLOAD_1 (VCTZ,	"vctz")
@@ -2910,11 +2918,11 @@ BU_P9_OVERLOAD_2 (CMPRB2,	"byte_in_either_range")
 BU_P9_OVERLOAD_2 (CMPEQB,	"byte_in_set")
 
 
-BU_P9V_AV_1 (VSIGNEXTSB2W,	"vsignextsb2w",		CONST,  vsignextend_qi_v4si)
-BU_P9V_AV_1 (VSIGNEXTSH2W,	"vsignextsh2w",		CONST,  vsignextend_hi_v4si)
-BU_P9V_AV_1 (VSIGNEXTSB2D,	"vsignextsb2d",		CONST,  vsignextend_qi_v2di)
-BU_P9V_AV_1 (VSIGNEXTSH2D,	"vsignextsh2d",		CONST,  vsignextend_hi_v2di)
-BU_P9V_AV_1 (VSIGNEXTSW2D,	"vsignextsw2d",		CONST,  vsignextend_si_v2di)
+BU_P9V_AV_1 (VSIGNEXTSB2W,	"vsignextsb2w",		CONST,  vsx_sign_extend_v16qi_v4si)
+BU_P9V_AV_1 (VSIGNEXTSH2W,	"vsignextsh2w",		CONST,  vsx_sign_extend_v8hi_v4si)
+BU_P9V_AV_1 (VSIGNEXTSB2D,	"vsignextsb2d",		CONST,  vsx_sign_extend_v16qi_v2di)
+BU_P9V_AV_1 (VSIGNEXTSH2D,	"vsignextsh2d",		CONST,  vsx_sign_extend_v8hi_v2di)
+BU_P9V_AV_1 (VSIGNEXTSW2D,	"vsignextsw2d",		CONST,  vsx_sign_extend_v4si_v2di)
 
 /* Builtins for scalar instructions added in ISA 3.1 (power10).  */
 BU_P10V_AV_P (VCMPEQUT_P,	"vcmpequt_p",	CONST,	vector_eq_v1ti_p)
@@ -2954,7 +2962,7 @@ BU_P10V_AV_2 (VNOR_V1TI,	"vnor_v1ti",	CONST,	norv1ti3)
 BU_P10V_AV_2 (VCMPNET_P,	"vcmpnet_p",	CONST,	vector_ne_v1ti_p)
 BU_P10V_AV_2 (VCMPAET_P,	"vcmpaet_p",	CONST,	vector_ae_v1ti_p)
 
-BU_P10V_AV_1 (VSIGNEXTSD2Q,	"vsignext",     CONST,  vsignextend_v2di_v1ti)
+BU_P10V_AV_1 (VSIGNEXTSD2Q,	"vsignext",     CONST,  vsx_sign_extend_v2di_v1ti)
 
 BU_P10V_AV_2 (VMULEUD,	"vmuleud",	CONST,	vec_widen_umult_even_v2di)
 BU_P10V_AV_2 (VMULESD,	"vmulesd",	CONST,	vec_widen_smult_even_v2di)
diff --git a/gcc/config/rs6000/rs6000-call.c b/gcc/config/rs6000/rs6000-call.c
index ef20cb30388..1be4797e834 100644
--- a/gcc/config/rs6000/rs6000-call.c
+++ b/gcc/config/rs6000/rs6000-call.c
@@ -7190,6 +7190,12 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,
 	{
 	  cum->vregno += n_elts;
 
+	  /* If we are not splitting Complex IEEE128 args then account for the
+	     fact that they are passed in 2 VSX regs. */
+	  if (!targetm.calls.split_complex_arg && type
+	      && TREE_CODE (type) == COMPLEX_TYPE && elt_mode == KCmode)
+	    cum->vregno++;
+
 	  if (!TARGET_ALTIVEC)
 	    error ("cannot pass argument in vector register because"
 		   " altivec instructions are disabled, use %qs"
@@ -11877,7 +11883,12 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)
       unsigned nvec = (fncode == MMA_BUILTIN_DISASSEMBLE_ACC) ? 4 : 2;
       tree dst_ptr = gimple_call_arg (stmt, 0);
       tree src_ptr = gimple_call_arg (stmt, 1);
-      tree src_type = TREE_TYPE (src_ptr);
+      tree src_type = (fncode == MMA_BUILTIN_DISASSEMBLE_ACC)
+		      ? build_pointer_type (vector_quad_type_node)
+		      : build_pointer_type (vector_pair_type_node);
+      if (TREE_TYPE (src_ptr) != src_type)
+	src_ptr = build1 (NOP_EXPR, src_type, src_ptr);
+
       tree src = create_tmp_reg_or_ssa_name (TREE_TYPE (src_type));
       gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);
 
diff --git a/gcc/config/rs6000/rs6000-logue.c b/gcc/config/rs6000/rs6000-logue.c
index 9965a8aa691..bdcb37c72f5 100644
--- a/gcc/config/rs6000/rs6000-logue.c
+++ b/gcc/config/rs6000/rs6000-logue.c
@@ -4924,7 +4924,7 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)
 	 a REG_CFA_DEF_CFA note, but that's OK;  A duplicate is
 	 discarded by dwarf2cfi.c/dwarf2out.c, and in any case would
 	 be harmless if emitted.  */
-      if (frame_pointer_needed)
+      if (frame_pointer_needed_indeed)
 	{
 	  insn = get_last_insn ();
 	  add_reg_note (insn, REG_CFA_DEF_CFA,
diff --git a/gcc/config/rs6000/rs6000-p8swap.c b/gcc/config/rs6000/rs6000-p8swap.c
index 903002a4576..4741d14d99f 100644
--- a/gcc/config/rs6000/rs6000-p8swap.c
+++ b/gcc/config/rs6000/rs6000-p8swap.c
@@ -1668,7 +1668,15 @@ replace_swapped_aligned_store (swap_web_entry *insn_entry,
   gcc_assert ((GET_CODE (new_body) == SET)
 	      && MEM_P (SET_DEST (new_body)));
 
-  set_block_for_insn (new_insn, BLOCK_FOR_INSN (store_insn));
+  basic_block bb = BLOCK_FOR_INSN (store_insn);
+  set_block_for_insn (new_insn, bb);
+  /* Handle REG_EH_REGION note.  */
+  if (cfun->can_throw_non_call_exceptions && BB_END (bb) == store_insn)
+    {
+      rtx note = find_reg_note (store_insn, REG_EH_REGION, NULL_RTX);
+      if (note)
+	add_reg_note (new_insn, REG_EH_REGION, XEXP (note, 0));
+    }
   df_insn_rescan (new_insn);
 
   df_insn_delete (store_insn);
@@ -1761,7 +1769,15 @@ replace_swapped_aligned_load (swap_web_entry *insn_entry, rtx swap_insn)
   gcc_assert ((GET_CODE (new_body) == SET)
 	      && MEM_P (SET_SRC (new_body)));
 
-  set_block_for_insn (new_insn, BLOCK_FOR_INSN (def_insn));
+  basic_block bb = BLOCK_FOR_INSN (def_insn);
+  set_block_for_insn (new_insn, bb);
+  /* Handle REG_EH_REGION note.  */
+  if (cfun->can_throw_non_call_exceptions && BB_END (bb) == def_insn)
+    {
+      rtx note = find_reg_note (def_insn, REG_EH_REGION, NULL_RTX);
+      if (note)
+	add_reg_note (new_insn, REG_EH_REGION, XEXP (note, 0));
+    }
   df_insn_rescan (new_insn);
 
   df_insn_delete (def_insn);
diff --git a/gcc/config/rs6000/rs6000-protos.h b/gcc/config/rs6000/rs6000-protos.h
index a06a147c339..3ebfdc0b86f 100644
--- a/gcc/config/rs6000/rs6000-protos.h
+++ b/gcc/config/rs6000/rs6000-protos.h
@@ -321,4 +321,6 @@ extern rtx rs6000_gen_lvx (enum machine_mode, rtx, rtx);
 extern rtx rs6000_gen_stvx (enum machine_mode, rtx, rtx);
 
 extern void rs6000_emit_xxspltidp_v2df (rtx, long value);
+extern gimple *currently_expanding_gimple_stmt;
+extern bool rs6000_opaque_type_invalid_use_p (gimple *);
 #endif  /* rs6000-protos.h */
diff --git a/gcc/config/rs6000/rs6000-string.c b/gcc/config/rs6000/rs6000-string.c
index cc75ca5848e..b7c77372c70 100644
--- a/gcc/config/rs6000/rs6000-string.c
+++ b/gcc/config/rs6000/rs6000-string.c
@@ -2811,11 +2811,17 @@ expand_block_move (rtx operands[], bool might_overlap)
 	  gen_func.mov = gen_vsx_movv2di_64bit;
 	}
       else if (TARGET_BLOCK_OPS_UNALIGNED_VSX
-	       && TARGET_POWER10 && bytes < 16
+	       /* Only use lxvl/stxvl on 64bit POWER10.  */
+	       && TARGET_POWER10
+	       && TARGET_64BIT
+	       && bytes < 16
 	       && orig_bytes > 16
-	       && !(bytes == 1 || bytes == 2
-		    || bytes == 4 || bytes == 8)
-	       && (align >= 128 || !STRICT_ALIGNMENT))
+	       && !(bytes == 1
+		    || bytes == 2
+		    || bytes == 4
+		    || bytes == 8)
+	       && (align >= 128
+		   || !STRICT_ALIGNMENT))
 	{
 	  /* Only use lxvl/stxvl if it could replace multiple ordinary
 	     loads+stores.  Also don't use it unless we likely already
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 0421dc7adb3..3e5281c0f05 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -4147,14 +4147,6 @@ rs6000_option_override_internal (bool global_init_p)
 	rs6000_isa_flags &= ~OPTION_MASK_BLOCK_OPS_UNALIGNED_VSX;
     }
 
-  if (!(rs6000_isa_flags_explicit & OPTION_MASK_BLOCK_OPS_VECTOR_PAIR))
-    {
-      if (TARGET_MMA && TARGET_EFFICIENT_UNALIGNED_VSX)
-	rs6000_isa_flags |= OPTION_MASK_BLOCK_OPS_VECTOR_PAIR;
-      else
-	rs6000_isa_flags &= ~OPTION_MASK_BLOCK_OPS_VECTOR_PAIR;
-    }
-
   /* Use long double size to select the appropriate long double.  We use
      TYPE_PRECISION to differentiate the 3 different long double types.  We map
      128 into the precision used for TFmode.  */
@@ -5742,33 +5734,68 @@ const char *rs6000_machine;
 const char *
 rs6000_machine_from_flags (void)
 {
-  /* For some CPUs, the machine cannot be determined by ISA flags.  We have to
-     check them first.  */
-  switch (rs6000_cpu)
-    {
-    case PROCESSOR_PPC8540:
-    case PROCESSOR_PPC8548:
-      return "e500";
+  /* e300 and e500 */
+  if (rs6000_cpu == PROCESSOR_PPCE300C2 || rs6000_cpu == PROCESSOR_PPCE300C3)
+    return "e300";
+  if (rs6000_cpu == PROCESSOR_PPC8540 || rs6000_cpu == PROCESSOR_PPC8548)
+    return "e500";
+  if (rs6000_cpu == PROCESSOR_PPCE500MC)
+    return "e500mc";
+  if (rs6000_cpu == PROCESSOR_PPCE500MC64)
+    return "e500mc64";
+  if (rs6000_cpu == PROCESSOR_PPCE5500)
+    return "e5500";
+  if (rs6000_cpu == PROCESSOR_PPCE6500)
+    return "e6500";
 
-    case PROCESSOR_PPCE300C2:
-    case PROCESSOR_PPCE300C3:
-      return "e300";
+  /* 400 series */
+  if (rs6000_cpu == PROCESSOR_PPC403)
+    return "\"403\"";
+  if (rs6000_cpu == PROCESSOR_PPC405)
+    return "\"405\"";
+  if (rs6000_cpu == PROCESSOR_PPC440)
+    return "\"440\"";
+  if (rs6000_cpu == PROCESSOR_PPC476)
+    return "\"476\"";
 
-    case PROCESSOR_PPCE500MC:
-      return "e500mc";
+  /* A2 */
+  if (rs6000_cpu == PROCESSOR_PPCA2)
+    return "a2";
 
-    case PROCESSOR_PPCE500MC64:
-      return "e500mc64";
+  /* Cell BE */
+  if (rs6000_cpu == PROCESSOR_CELL)
+    return "cell";
 
-    case PROCESSOR_PPCE5500:
-      return "e5500";
+  /* Titan */
+  if (rs6000_cpu == PROCESSOR_TITAN)
+    return "titan";
 
-    case PROCESSOR_PPCE6500:
-      return "e6500";
+  /* 500 series and 800 series */
+  if (rs6000_cpu == PROCESSOR_MPCCORE)
+    return "\"821\"";
 
-    default:
-      break;
-    }
+#if 0
+  /* This (and ppc64 below) are disabled here (for now at least) because
+     PROCESSOR_POWERPC, PROCESSOR_POWERPC64, and PROCESSOR_COMMON
+     are #define'd as some of these.  Untangling that is a job for later.  */
+
+  /* 600 series and 700 series, "classic" */
+  if (rs6000_cpu == PROCESSOR_PPC601 || rs6000_cpu == PROCESSOR_PPC603
+      || rs6000_cpu == PROCESSOR_PPC604 || rs6000_cpu == PROCESSOR_PPC604e
+      || rs6000_cpu == PROCESSOR_PPC750)
+    return "ppc";
+#endif
+
+  /* Classic with AltiVec, "G4" */
+  if (rs6000_cpu == PROCESSOR_PPC7400 || rs6000_cpu == PROCESSOR_PPC7450)
+    return "\"7450\"";
+
+#if 0
+  /* The older 64-bit CPUs */
+  if (rs6000_cpu == PROCESSOR_PPC620 || rs6000_cpu == PROCESSOR_PPC630
+      || rs6000_cpu == PROCESSOR_RS64A)
+    return "ppc64";
+#endif
 
   HOST_WIDE_INT flags = rs6000_isa_flags;
 
@@ -7052,23 +7079,29 @@ rs6000_expand_vector_set_var_p9 (rtx target, rtx val, rtx idx)
   machine_mode idx_mode = GET_MODE (idx);
 
   machine_mode shift_mode;
-  rtx (*gen_ashl)(rtx, rtx, rtx);
-  rtx (*gen_lvsl)(rtx, rtx);
-  rtx (*gen_lvsr)(rtx, rtx);
+  /* Gen function pointers for shifting left and generation of permutation
+     control vectors.  */
+  rtx (*gen_ashl) (rtx, rtx, rtx);
+  rtx (*gen_pcvr1) (rtx, rtx);
+  rtx (*gen_pcvr2) (rtx, rtx);
 
   if (TARGET_POWERPC64)
     {
       shift_mode = DImode;
       gen_ashl = gen_ashldi3;
-      gen_lvsl = gen_altivec_lvsl_reg_di;
-      gen_lvsr = gen_altivec_lvsr_reg_di;
+      gen_pcvr1 = BYTES_BIG_ENDIAN ? gen_altivec_lvsl_reg_di
+				   : gen_altivec_lvsr_reg_di;
+      gen_pcvr2 = BYTES_BIG_ENDIAN ? gen_altivec_lvsr_reg_di
+				   : gen_altivec_lvsl_reg_di;
     }
   else
     {
       shift_mode = SImode;
       gen_ashl = gen_ashlsi3;
-      gen_lvsl = gen_altivec_lvsl_reg_si;
-      gen_lvsr = gen_altivec_lvsr_reg_si;
+      gen_pcvr1 = BYTES_BIG_ENDIAN ? gen_altivec_lvsl_reg_si
+				   : gen_altivec_lvsr_reg_si;
+      gen_pcvr2 = BYTES_BIG_ENDIAN ? gen_altivec_lvsr_reg_si
+				   : gen_altivec_lvsl_reg_si;
     }
   /* Generate the IDX for permute shift, width is the vector element size.
      idx = idx * width.  */
@@ -7077,25 +7110,29 @@ rs6000_expand_vector_set_var_p9 (rtx target, rtx val, rtx idx)
 
   emit_insn (gen_ashl (tmp, idx, GEN_INT (shift)));
 
-  /*  lvsr    v1,0,idx.  */
-  rtx pcvr = gen_reg_rtx (V16QImode);
-  emit_insn (gen_lvsr (pcvr, tmp));
-
-  /*  lvsl    v2,0,idx.  */
-  rtx pcvl = gen_reg_rtx (V16QImode);
-  emit_insn (gen_lvsl (pcvl, tmp));
+  /* Generate one permutation control vector used for rotating the element
+     at to-insert position to element zero in target vector.  lvsl is
+     used for big endianness while lvsr is used for little endianness:
+     lvs[lr]    v1,0,idx.  */
+  rtx pcvr1 = gen_reg_rtx (V16QImode);
+  emit_insn (gen_pcvr1 (pcvr1, tmp));
 
   rtx sub_target = simplify_gen_subreg (V16QImode, target, mode, 0);
+  rtx perm1 = gen_altivec_vperm_v8hiv16qi (sub_target, sub_target, sub_target,
+					   pcvr1);
+  emit_insn (perm1);
 
-  rtx permr
-    = gen_altivec_vperm_v8hiv16qi (sub_target, sub_target, sub_target, pcvr);
-  emit_insn (permr);
-
+  /* Insert val into element 0 of target vector.  */
   rs6000_expand_vector_set (target, val, const0_rtx);
 
-  rtx perml
-    = gen_altivec_vperm_v8hiv16qi (sub_target, sub_target, sub_target, pcvl);
-  emit_insn (perml);
+  /* Rotate back with a reversed permutation control vector generated from:
+     lvs[rl]   v2,0,idx.  */
+  rtx pcvr2 = gen_reg_rtx (V16QImode);
+  emit_insn (gen_pcvr2 (pcvr2, tmp));
+
+  rtx perm2 = gen_altivec_vperm_v8hiv16qi (sub_target, sub_target, sub_target,
+					   pcvr2);
+  emit_insn (perm2);
 }
 
 /* Insert VAL into IDX of TARGET, VAL size is same of the vector element, IDX
@@ -8040,7 +8077,8 @@ darwin_rs6000_special_round_type_align (tree type, unsigned int computed,
       type = TREE_TYPE (type);
   } while (AGGREGATE_TYPE_P (type));
 
-  if (! AGGREGATE_TYPE_P (type) && type != error_mark_node)
+  if (type != error_mark_node && ! AGGREGATE_TYPE_P (type)
+      && ! TYPE_PACKED (type) && maximum_field_alignment == 0)
     align = MAX (align, TYPE_ALIGN (type));
 
   return align;
@@ -10968,26 +11006,6 @@ init_float128_ibm (machine_mode mode)
     }
 }
 
-/* Create a decl for either complex long double multiply or complex long double
-   divide when long double is IEEE 128-bit floating point.  We can't use
-   __multc3 and __divtc3 because the original long double using IBM extended
-   double used those names.  The complex multiply/divide functions are encoded
-   as builtin functions with a complex result and 4 scalar inputs.  */
-
-static void
-create_complex_muldiv (const char *name, built_in_function fncode, tree fntype)
-{
-  tree fndecl = add_builtin_function (name, fntype, fncode, BUILT_IN_NORMAL,
-				      name, NULL_TREE);
-
-  set_builtin_decl (fncode, fndecl, true);
-
-  if (TARGET_DEBUG_BUILTIN)
-    fprintf (stderr, "create complex %s, fncode: %d\n", name, (int) fncode);
-
-  return;
-}
-
 /* Set up IEEE 128-bit floating point routines.  Use different names if the
    arguments can be passed in a vector register.  The historical PowerPC
    implementation of IEEE 128-bit floating point used _q_<op> for the names, so
@@ -10999,32 +11017,6 @@ init_float128_ieee (machine_mode mode)
 {
   if (FLOAT128_VECTOR_P (mode))
     {
-      static bool complex_muldiv_init_p = false;
-
-      /* Set up to call __mulkc3 and __divkc3 under -mabi=ieeelongdouble.  If
-	 we have clone or target attributes, this will be called a second
-	 time.  We want to create the built-in function only once.  */
-     if (mode == TFmode && TARGET_IEEEQUAD && !complex_muldiv_init_p)
-       {
-	 complex_muldiv_init_p = true;
-	 built_in_function fncode_mul =
-	   (built_in_function) (BUILT_IN_COMPLEX_MUL_MIN + TCmode
-				- MIN_MODE_COMPLEX_FLOAT);
-	 built_in_function fncode_div =
-	   (built_in_function) (BUILT_IN_COMPLEX_DIV_MIN + TCmode
-				- MIN_MODE_COMPLEX_FLOAT);
-
-	 tree fntype = build_function_type_list (complex_long_double_type_node,
-						 long_double_type_node,
-						 long_double_type_node,
-						 long_double_type_node,
-						 long_double_type_node,
-						 NULL_TREE);
-
-	 create_complex_muldiv ("__mulkc3", fncode_mul, fntype);
-	 create_complex_muldiv ("__divkc3", fncode_div, fntype);
-       }
-
       set_optab_libfunc (add_optab, mode, "__addkf3");
       set_optab_libfunc (sub_optab, mode, "__subkf3");
       set_optab_libfunc (neg_optab, mode, "__negkf2");
@@ -17050,7 +17042,7 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)
       if (DECIMAL_FLOAT_MODE_P (GET_MODE (x)))
 	REAL_VALUE_TO_TARGET_DECIMAL128 (*CONST_DOUBLE_REAL_VALUE (x), k);
       else
-	REAL_VALUE_TO_TARGET_LONG_DOUBLE (*CONST_DOUBLE_REAL_VALUE (x), k);
+	real_to_target (k, CONST_DOUBLE_REAL_VALUE (x), GET_MODE (x));
 
       if (TARGET_64BIT)
 	{
@@ -21768,7 +21760,9 @@ rs6000_rtx_costs (rtx x, machine_mode mode, int outer_code,
 	    *total = rs6000_cost->divsi;
 	}
       /* Add in shift and subtract for MOD unless we have a mod instruction. */
-      if (!TARGET_MODULO && (code == MOD || code == UMOD))
+      if ((!TARGET_MODULO
+	   || (RS6000_DISABLE_SCALAR_MODULO && SCALAR_INT_MODE_P (mode)))
+	 && (code == MOD || code == UMOD))
 	*total += COSTS_N_INSNS (2);
       return false;
 
@@ -25074,6 +25068,11 @@ rs6000_can_inline_p (tree caller, tree callee)
       else
 	caller_isa = rs6000_isa_flags;
 
+      /* Ignore -mpower8-fusion and -mpower10-fusion options for inlining
+	 purposes.  */
+      callee_isa &= ~(OPTION_MASK_P8_FUSION | OPTION_MASK_P10_FUSION);
+      explicit_isa &= ~(OPTION_MASK_P8_FUSION | OPTION_MASK_P10_FUSION);
+
       /* The callee's options must be a subset of the caller's options, i.e.
 	 a vsx function may inline an altivec function, but a no-vsx function
 	 must not inline a vsx function.  However, for those options that the
@@ -27795,6 +27794,27 @@ rs6000_starting_frame_offset (void)
   return RS6000_STARTING_FRAME_OFFSET;
 }
 
+/* Internal function to return the built-in function id for the complex
+   multiply operation for a given mode.  */
+
+static inline built_in_function
+complex_multiply_builtin_code (machine_mode mode)
+{
+  gcc_assert (IN_RANGE (mode, MIN_MODE_COMPLEX_FLOAT, MAX_MODE_COMPLEX_FLOAT));
+  int func = BUILT_IN_COMPLEX_MUL_MIN + mode - MIN_MODE_COMPLEX_FLOAT;
+  return (built_in_function) func;
+}
+
+/* Internal function to return the built-in function id for the complex divide
+   operation for a given mode.  */
+
+static inline built_in_function
+complex_divide_builtin_code (machine_mode mode)
+{
+  gcc_assert (IN_RANGE (mode, MIN_MODE_COMPLEX_FLOAT, MAX_MODE_COMPLEX_FLOAT));
+  int func = BUILT_IN_COMPLEX_DIV_MIN + mode - MIN_MODE_COMPLEX_FLOAT;
+  return (built_in_function) func;
+}
 
 /* On 64-bit Linux and Freebsd systems, possibly switch the long double library
    function names from <foo>l to <foo>f128 if the default long double type is
@@ -27813,11 +27833,53 @@ rs6000_starting_frame_offset (void)
    only do this transformation if the __float128 type is enabled.  This
    prevents us from doing the transformation on older 32-bit ports that might
    have enabled using IEEE 128-bit floating point as the default long double
-   type.  */
+   type.
+
+   We also use the TARGET_MANGLE_DECL_ASSEMBLER_NAME hook to change the
+   function names used for complex multiply and divide to the appropriate
+   names.  */
 
 static tree
 rs6000_mangle_decl_assembler_name (tree decl, tree id)
 {
+  /* Handle complex multiply/divide.  For IEEE 128-bit, use __mulkc3 or
+     __divkc3 and for IBM 128-bit use __multc3 and __divtc3.  */
+  if (TARGET_FLOAT128_TYPE
+      && TREE_CODE (decl) == FUNCTION_DECL
+      && DECL_IS_UNDECLARED_BUILTIN (decl)
+      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)
+    {
+      built_in_function id = DECL_FUNCTION_CODE (decl);
+      const char *newname = NULL;
+
+      if (id == complex_multiply_builtin_code (KCmode))
+	newname = "__mulkc3";
+
+      else if (id == complex_multiply_builtin_code (ICmode))
+	newname = "__multc3";
+
+      else if (id == complex_multiply_builtin_code (TCmode))
+	newname = (TARGET_IEEEQUAD) ? "__mulkc3" : "__multc3";
+
+      else if (id == complex_divide_builtin_code (KCmode))
+	newname = "__divkc3";
+
+      else if (id == complex_divide_builtin_code (ICmode))
+	newname = "__divtc3";
+
+      else if (id == complex_divide_builtin_code (TCmode))
+	newname = (TARGET_IEEEQUAD) ? "__divkc3" : "__divtc3";
+
+      if (newname)
+	{
+	  if (TARGET_DEBUG_BUILTIN)
+	    fprintf (stderr, "Map complex mul/div => %s\n", newname);
+
+	  return get_identifier (newname);
+	}
+    }
+
+  /* Map long double built-in functions if long double is IEEE 128-bit.  */
   if (TARGET_FLOAT128_TYPE && TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128
       && TREE_CODE (decl) == FUNCTION_DECL
       && DECL_IS_UNDECLARED_BUILTIN (decl)
@@ -28000,28 +28062,6 @@ rs6000_invalid_conversion (const_tree fromtype, const_tree totype)
       if (tomode == OOmode)
 	return N_("invalid conversion to type %<__vector_pair%>");
     }
-  else if (POINTER_TYPE_P (fromtype) && POINTER_TYPE_P (totype))
-    {
-      /* We really care about the modes of the base types.  */
-      frommode = TYPE_MODE (TREE_TYPE (fromtype));
-      tomode = TYPE_MODE (TREE_TYPE (totype));
-
-      /* Do not allow conversions to/from XOmode and OOmode pointer
-	 types, except to/from void pointers.  */
-      if (frommode != tomode
-	  && frommode != VOIDmode
-	  && tomode != VOIDmode)
-	{
-	  if (frommode == XOmode)
-	    return N_("invalid conversion from type %<* __vector_quad%>");
-	  if (tomode == XOmode)
-	    return N_("invalid conversion to type %<* __vector_quad%>");
-	  if (frommode == OOmode)
-	    return N_("invalid conversion from type %<* __vector_pair%>");
-	  if (tomode == OOmode)
-	    return N_("invalid conversion to type %<* __vector_pair%>");
-	}
-    }
 
   /* Conversion allowed.  */
   return NULL;
@@ -28068,6 +28108,87 @@ rs6000_output_addr_vec_elt (FILE *file, int value)
   fprintf (file, "\n");
 }
 
+
+/* Now we have only two opaque types, they are __vector_quad and
+   __vector_pair built-in types.  They are target specific and
+   only available when MMA is supported.  With MMA supported, it
+   simply returns true, otherwise it checks if the given gimple
+   STMT is an assignment, asm or call stmt and uses either of
+   these two opaque types unexpectedly, if yes, it would raise
+   an error message and returns true, otherwise it returns false.  */
+
+bool
+rs6000_opaque_type_invalid_use_p (gimple *stmt)
+{
+  if (TARGET_MMA)
+    return false;
+
+  /* If the given TYPE is one MMA opaque type, emit the corresponding
+     error messages and return true, otherwise return false.  */
+  auto check_and_error_invalid_use = [](tree type)
+  {
+    tree mv = TYPE_MAIN_VARIANT (type);
+    if (mv == vector_quad_type_node)
+      {
+	error ("type %<__vector_quad%> requires the %qs option", "-mmma");
+	return true;
+      }
+    else if (mv == vector_pair_type_node)
+      {
+	error ("type %<__vector_pair%> requires the %qs option", "-mmma");
+	return true;
+      }
+    return false;
+  };
+
+  if (stmt)
+    {
+      /* The usage of MMA opaque types is very limited for now,
+	 to check with gassign, gasm and gcall is enough so far.  */
+      if (gassign *ga = dyn_cast<gassign *> (stmt))
+	{
+	  tree lhs = gimple_assign_lhs (ga);
+	  tree type = TREE_TYPE (lhs);
+	  if (check_and_error_invalid_use (type))
+	    return true;
+	}
+      else if (gasm *gs = dyn_cast<gasm *> (stmt))
+	{
+	  unsigned ninputs = gimple_asm_ninputs (gs);
+	  for (unsigned i = 0; i < ninputs; i++)
+	    {
+	      tree op = gimple_asm_input_op (gs, i);
+	      tree val = TREE_VALUE (op);
+	      tree type = TREE_TYPE (val);
+	      if (check_and_error_invalid_use (type))
+		return true;
+	    }
+	  unsigned noutputs = gimple_asm_noutputs (gs);
+	  for (unsigned i = 0; i < noutputs; i++)
+	    {
+	      tree op = gimple_asm_output_op (gs, i);
+	      tree val = TREE_VALUE (op);
+	      tree type = TREE_TYPE (val);
+	      if (check_and_error_invalid_use (type))
+		return true;
+	    }
+	}
+      else if (gcall *gc = dyn_cast<gcall *> (stmt))
+	{
+	  unsigned nargs = gimple_call_num_args (gc);
+	  for (unsigned i = 0; i < nargs; i++)
+	    {
+	      tree arg = gimple_call_arg (gc, i);
+	      tree type = TREE_TYPE (arg);
+	      if (check_and_error_invalid_use (type))
+		return true;
+	    }
+	}
+    }
+
+  return false;
+}
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-rs6000.h"
diff --git a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
index 4ca6372435d..5a6f9bf4aa2 100644
--- a/gcc/config/rs6000/rs6000.h
+++ b/gcc/config/rs6000/rs6000.h
@@ -81,12 +81,15 @@
 # define SUBTARGET_DRIVER_SELF_SPECS ""
 #endif
 
-/* Only for use in the testsuite: -mdejagnu-cpu= simply overrides -mcpu=.
+/* Only for use in the testsuite: -mdejagnu-cpu=<value> filters out all
+   -mcpu= as well as -mtune= options then simply adds -mcpu=<value>,
+   while -mdejagnu-tune=<value> filters out all -mtune= options then
+   simply adds -mtune=<value>.
    With older versions of Dejagnu the command line arguments you set in
-   RUNTESTFLAGS override those set in the testcases; with this option,
-   the testcase will always win.  Ditto for -mdejagnu-tune=.  */
+   RUNTESTFLAGS override those set in the testcases; with these options,
+   the testcase will always win.  */
 #define DRIVER_SELF_SPECS \
-  "%{mdejagnu-cpu=*: %<mcpu=* -mcpu=%*}", \
+  "%{mdejagnu-cpu=*: %<mcpu=* %<mtune=* -mcpu=%*}", \
   "%{mdejagnu-tune=*: %<mtune=* -mtune=%*}", \
   "%{mdejagnu-*: %<mdejagnu-*}", \
    SUBTARGET_DRIVER_SELF_SPECS
@@ -2607,3 +2610,9 @@ while (0)
        rs6000_asm_output_opcode (STREAM);				\
     }									\
   while (0)
+
+/* Disable generation of scalar modulo instructions due to performance issues
+   with certain input values.  This can be removed in the future when the
+   issues have been resolved.  */
+#define RS6000_DISABLE_SCALAR_MODULO 1
+
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
index a4a7d105f5e..e74222c5f3e 100644
--- a/gcc/config/rs6000/rs6000.md
+++ b/gcc/config/rs6000/rs6000.md
@@ -287,7 +287,7 @@
 ;; Whether this insn has a prefixed form and a non-prefixed form.
 (define_attr "maybe_prefixed" "no,yes"
   (if_then_else (eq_attr "type" "load,fpload,vecload,store,fpstore,vecstore,
-  				 integer,add")
+  				 integer,add,fused_load_cmpi")
 		(const_string "yes")
 		(const_string "no")))
 
@@ -302,7 +302,7 @@
 	      (eq_attr "maybe_prefixed" "no"))
 	 (const_string "no")
 
-	 (eq_attr "type" "load,fpload,vecload")
+	 (eq_attr "type" "load,fpload,vecload,fused_load_cmpi")
 	 (if_then_else (match_test "prefixed_load_p (insn)")
 		       (const_string "yes")
 		       (const_string "no"))
@@ -835,8 +835,8 @@
 ;; complex forms.  Basic data transfer is done later.
 
 (define_insn "zero_extendqi<mode>2"
-  [(set (match_operand:EXTQI 0 "gpc_reg_operand" "=r,r,^wa,^v")
-	(zero_extend:EXTQI (match_operand:QI 1 "reg_or_mem_operand" "m,r,Z,v")))]
+  [(set (match_operand:EXTQI 0 "gpc_reg_operand" "=r,r,wa,^v")
+	(zero_extend:EXTQI (match_operand:QI 1 "reg_or_mem_operand" "m,r,?Z,v")))]
   ""
   "@
    lbz%U1%X1 %0,%1
@@ -889,8 +889,8 @@
 
 
 (define_insn "zero_extendhi<mode>2"
-  [(set (match_operand:EXTHI 0 "gpc_reg_operand" "=r,r,^wa,^v")
-	(zero_extend:EXTHI (match_operand:HI 1 "reg_or_mem_operand" "m,r,Z,v")))]
+  [(set (match_operand:EXTHI 0 "gpc_reg_operand" "=r,r,wa,^v")
+	(zero_extend:EXTHI (match_operand:HI 1 "reg_or_mem_operand" "m,r,?Z,v")))]
   ""
   "@
    lhz%U1%X1 %0,%1
@@ -944,7 +944,7 @@
 
 (define_insn "zero_extendsi<mode>2"
   [(set (match_operand:EXTSI 0 "gpc_reg_operand" "=r,r,d,wa,wa,r,wa")
-	(zero_extend:EXTSI (match_operand:SI 1 "reg_or_mem_operand" "m,r,Z,Z,r,wa,wa")))]
+	(zero_extend:EXTSI (match_operand:SI 1 "reg_or_mem_operand" "m,r,?Z,?Z,r,wa,wa")))]
   ""
   "@
    lwz%U1%X1 %0,%1
@@ -3359,6 +3359,17 @@
 	FAIL;
 
       operands[2] = force_reg (<MODE>mode, operands[2]);
+
+      if (RS6000_DISABLE_SCALAR_MODULO)
+	{
+	  temp1 = gen_reg_rtx (<MODE>mode);
+	  temp2 = gen_reg_rtx (<MODE>mode);
+
+	  emit_insn (gen_div<mode>3 (temp1, operands[1], operands[2]));
+	  emit_insn (gen_mul<mode>3 (temp2, temp1, operands[2]));
+	  emit_insn (gen_sub<mode>3 (operands[0], operands[1], temp2));
+	  DONE;
+	}
     }
   else
     {
@@ -3378,17 +3389,36 @@
   [(set (match_operand:GPR 0 "gpc_reg_operand" "=&r")
         (mod:GPR (match_operand:GPR 1 "gpc_reg_operand" "r")
 		 (match_operand:GPR 2 "gpc_reg_operand" "r")))]
-  "TARGET_MODULO"
+  "TARGET_MODULO && !RS6000_DISABLE_SCALAR_MODULO"
   "mods<wd> %0,%1,%2"
   [(set_attr "type" "div")
    (set_attr "size" "<bits>")])
 
+;; This define_expand can be removed when RS6000_DISABLE_SCALAR_MODULO is
+;; removed.
+(define_expand "umod<mode>3"
+  [(set (match_operand:GPR 0 "gpc_reg_operand")
+	(umod:GPR (match_operand:GPR 1 "gpc_reg_operand")
+		  (match_operand:GPR 2 "gpc_reg_operand")))]
+  "TARGET_MODULO"
+{
+  if (RS6000_DISABLE_SCALAR_MODULO)
+    {
+      rtx temp1 = gen_reg_rtx (<MODE>mode);
+      rtx temp2 = gen_reg_rtx (<MODE>mode);
 
-(define_insn "umod<mode>3"
+      emit_insn (gen_udiv<mode>3 (temp1, operands[1], operands[2]));
+      emit_insn (gen_mul<mode>3 (temp2, temp1, operands[2]));
+      emit_insn (gen_sub<mode>3 (operands[0], operands[1], temp2));
+      DONE;
+    }
+})
+
+(define_insn "*umod<mode>3"
   [(set (match_operand:GPR 0 "gpc_reg_operand" "=&r")
         (umod:GPR (match_operand:GPR 1 "gpc_reg_operand" "r")
 		  (match_operand:GPR 2 "gpc_reg_operand" "r")))]
-  "TARGET_MODULO"
+  "TARGET_MODULO && !RS6000_DISABLE_SCALAR_MODULO"
   "modu<wd> %0,%1,%2"
   [(set_attr "type" "div")
    (set_attr "size" "<bits>")])
@@ -3445,7 +3475,7 @@
   [(set (match_operand:TI 0 "altivec_register_operand" "=v")
 	(umod:TI (match_operand:TI 1 "altivec_register_operand" "v")
 		 (match_operand:TI 2 "altivec_register_operand" "v")))]
-  "TARGET_POWER10 && TARGET_POWERPC64"
+  "TARGET_POWER10 && TARGET_POWERPC64 && !RS6000_DISABLE_SCALAR_MODULO"
   "vmoduq %0,%1,%2"
   [(set_attr "type" "vecdiv")
    (set_attr "size" "128")])
@@ -3454,7 +3484,7 @@
   [(set (match_operand:TI 0 "altivec_register_operand" "=v")
 	(mod:TI (match_operand:TI 1 "altivec_register_operand" "v")
 		(match_operand:TI 2 "altivec_register_operand" "v")))]
-  "TARGET_POWER10 && TARGET_POWERPC64"
+  "TARGET_POWER10 && TARGET_POWERPC64 && !RS6000_DISABLE_SCALAR_MODULO"
   "vmodsq %0,%1,%2"
   [(set_attr "type" "vecdiv")
    (set_attr "size" "128")])
@@ -7312,7 +7342,7 @@
   [(set (match_operand:SI 0 "nonimmediate_operand"
 	  "=r,         r,
 	   r,          d,          v,
-	   m,          Z,          Z,
+	   m,          ?Z,         ?Z,
 	   r,          r,          r,          r,
 	   wa,         wa,         wa,         v,
 	   wa,         v,          v,
@@ -7320,7 +7350,7 @@
 	   r,          *h,         *h")
 	(match_operand:SI 1 "input_operand"
 	  "r,          U,
-	   m,          Z,          Z,
+	   m,          ?Z,         ?Z,
 	   r,          d,          v,
 	   I,          L,          eI,         n,
 	   wa,         O,          wM,         wB,
@@ -7557,7 +7587,7 @@
   rtx op0_v16qi = gen_rtx_REG (V16QImode, r);
 
   emit_insn (gen_xxspltib_v16qi (op0_v16qi, op1));
-  emit_insn (gen_vsx_sign_extend_qi_si (operands[0], op0_v16qi));
+  emit_insn (gen_vsx_sign_extend_v16qi_si (operands[0], op0_v16qi));
   DONE;
 })
 
@@ -7601,11 +7631,11 @@
 ;;		MTVSRWZ     MF%1       MT%1       NOP
 (define_insn "*mov<mode>_internal"
   [(set (match_operand:QHI 0 "nonimmediate_operand"
-		"=r,        r,         wa,        m,         Z,         r,
+		"=r,        r,         wa,        m,         ?Z,        r,
 		 wa,        wa,        wa,        v,         ?v,        r,
 		 wa,        r,         *c*l,      *h")
 	(match_operand:QHI 1 "input_operand"
-		"r,         m,         Z,         r,         wa,        i,
+		"r,         m,         ?Z,        r,         wa,        i,
 		 wa,        O,         wM,        wB,        wS,        wa,
 		 r,         *h,        r,         0"))]
   "gpc_reg_operand (operands[0], <MODE>mode)
@@ -7784,10 +7814,10 @@
 ;;	FMR          MR         MT%0       MF%1       NOP
 (define_insn "movsd_hardfloat"
   [(set (match_operand:SD 0 "nonimmediate_operand"
-	 "=!r,       d,         m,         Z,         ?d,        ?r,
+	 "=!r,       d,         m,         ?Z,        ?d,        ?r,
 	  f,         !r,        *c*l,      !r,        *h")
 	(match_operand:SD 1 "input_operand"
-	 "m,         Z,         r,         wx,        r,         d,
+	 "m,         ?Z,        r,         wx,        r,         d,
 	  f,         r,         r,         *h,        0"))]
   "(register_operand (operands[0], SDmode)
    || register_operand (operands[1], SDmode))
@@ -9452,9 +9482,9 @@
 
   emit_insn (gen_xxspltib_v16qi (op0_v16qi, op1));
   if (<MODE>mode == DImode)
-    emit_insn (gen_vsx_sign_extend_qi_di (operands[0], op0_v16qi));
+    emit_insn (gen_vsx_sign_extend_v16qi_di (operands[0], op0_v16qi));
   else if (<MODE>mode == SImode)
-    emit_insn (gen_vsx_sign_extend_qi_si (operands[0], op0_v16qi));
+    emit_insn (gen_vsx_sign_extend_v16qi_si (operands[0], op0_v16qi));
   else if (<MODE>mode == HImode)
     {
       rtx op0_v8hi = gen_rtx_REG (V8HImode, r);
diff --git a/gcc/config/rs6000/rtems.h b/gcc/config/rs6000/rtems.h
index 872cc2849af..2a064bfad19 100644
--- a/gcc/config/rs6000/rtems.h
+++ b/gcc/config/rs6000/rtems.h
@@ -23,6 +23,9 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
+/* Undef gnu-user.h macro we don't want.  */
+#undef CPLUSPLUS_CPP_SPEC
+
 /* Copy and paste from linux64.h and freebsd64.h */
 #ifdef IN_LIBGCC2
 #undef TARGET_64BIT
@@ -252,7 +255,8 @@
 %{mcpu=821:  %{!Dppc*: %{!Dmpc*: -Dmpc821}  } } \
 %{mcpu=860:  %{!Dppc*: %{!Dmpc*: -Dmpc860}  } } \
 %{mcpu=8540: %{!Dppc*: %{!Dmpc*: -Dppc8540}  } } \
-%{mcpu=e6500: -D__PPC_CPU_E6500__}"
+%{mcpu=e6500: -D__PPC_CPU_E6500__} \
+%{mvrsave: -D__PPC_VRSAVE__}"
 
 #undef	ASM_SPEC
 #define	ASM_SPEC "%{!m64:%(asm_spec32)}%{m64:%(asm_spec64)} %(asm_spec_common)"
diff --git a/gcc/config/rs6000/smmintrin.h b/gcc/config/rs6000/smmintrin.h
index bdf6eb365d8..9d9df7842ba 100644
--- a/gcc/config/rs6000/smmintrin.h
+++ b/gcc/config/rs6000/smmintrin.h
@@ -45,31 +45,31 @@
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi8 (__m128i const __A, int const __D, int const __N)
 {
-  __v16qi result = (__v16qi)__A;
+  __v16qi __result = (__v16qi)__A;
 
-  result [__N & 0xf] = __D;
+  __result [__N & 0xf] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi32 (__m128i const __A, int const __D, int const __N)
 {
-  __v4si result = (__v4si)__A;
+  __v4si __result = (__v4si)__A;
 
-  result [__N & 3] = __D;
+  __result [__N & 3] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_epi64 (__m128i const __A, long long const __D, int const __N)
 {
-  __v2di result = (__v2di)__A;
+  __v2di __result = (__v2di)__A;
 
-  result [__N & 1] = __D;
+  __result [__N & 1] = __D;
 
-  return (__m128i) result;
+  return (__m128i) __result;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/rs6000/t-rtems b/gcc/config/rs6000/t-rtems
index 1ca3f0b1599..041d455ebb8 100644
--- a/gcc/config/rs6000/t-rtems
+++ b/gcc/config/rs6000/t-rtems
@@ -36,6 +36,9 @@ MULTILIB_DIRNAMES += nof
 MULTILIB_OPTIONS += mno-altivec
 MULTILIB_DIRNAMES += noaltivec
 
+MULTILIB_OPTIONS += mvrsave
+MULTILIB_DIRNAMES += vrsave
+
 MULTILIB_MATCHES  	+= ${MULTILIB_MATCHES_ENDIAN}
 MULTILIB_MATCHES	+= ${MULTILIB_MATCHES_SYSV}
 # Map 405 to 403
@@ -70,5 +73,7 @@ MULTILIB_REQUIRED += mcpu=7400/msoft-float
 MULTILIB_REQUIRED += mcpu=8540/msoft-float
 MULTILIB_REQUIRED += mcpu=860
 MULTILIB_REQUIRED += mcpu=e6500/m32
+MULTILIB_REQUIRED += mcpu=e6500/m32/mvrsave
 MULTILIB_REQUIRED += mcpu=e6500/m32/msoft-float/mno-altivec
 MULTILIB_REQUIRED += mcpu=e6500/m64
+MULTILIB_REQUIRED += mcpu=e6500/m64/mvrsave
diff --git a/gcc/config/rs6000/tmmintrin.h b/gcc/config/rs6000/tmmintrin.h
index 971511260b7..63e3f8a8262 100644
--- a/gcc/config/rs6000/tmmintrin.h
+++ b/gcc/config/rs6000/tmmintrin.h
@@ -112,8 +112,8 @@ _mm_alignr_epi8 (__m128i __A, __m128i __B, const unsigned int __count)
     {
       if (__count >= 32)
 	{
-	  const __v16qu zero = { 0 };
-	  return (__m128i) zero;
+	  const __v16qu __zero = { 0 };
+	  return (__m128i) __zero;
 	}
       else
 	{
diff --git a/gcc/config/rs6000/vector.md b/gcc/config/rs6000/vector.md
index 20b8ba1666f..d4f81abce1d 100644
--- a/gcc/config/rs6000/vector.md
+++ b/gcc/config/rs6000/vector.md
@@ -1288,7 +1288,16 @@
 (define_expand "parity<mode>2"
   [(set (match_operand:VEC_IP 0 "register_operand")
 	(parity:VEC_IP (match_operand:VEC_IP 1 "register_operand")))]
-  "TARGET_P9_VECTOR")
+  "TARGET_P9_VECTOR"
+{
+  rtx op1 = gen_lowpart (V16QImode, operands[1]);
+  rtx res = gen_reg_rtx (V16QImode);
+  emit_insn (gen_popcountv16qi2 (res, op1));
+  emit_insn (gen_rs6000_vprtyb<mode>2 (operands[0],
+				       gen_lowpart (<MODE>mode, res)));
+
+  DONE;
+})
 
 
 ;; Same size conversions
diff --git a/gcc/config/rs6000/vsx.md b/gcc/config/rs6000/vsx.md
index f2260badf70..e7d40cb3cf9 100644
--- a/gcc/config/rs6000/vsx.md
+++ b/gcc/config/rs6000/vsx.md
@@ -1145,10 +1145,10 @@
   emit_insn (gen_xxspltib_v16qi (tmp, GEN_INT (value)));
 
   if (<MODE>mode == V2DImode)
-    emit_insn (gen_vsx_sign_extend_qi_v2di (op0, tmp));
+    emit_insn (gen_vsx_sign_extend_v16qi_v2di (op0, tmp));
 
   else if (<MODE>mode == V4SImode)
-    emit_insn (gen_vsx_sign_extend_qi_v4si (op0, tmp));
+    emit_insn (gen_vsx_sign_extend_v16qi_v4si (op0, tmp));
 
   else if (<MODE>mode == V8HImode)
     emit_insn (gen_altivec_vupkhsb  (op0, tmp));
@@ -1972,22 +1972,20 @@
   "x<VSv>tsqrt<sd>p %0,%x1"
   [(set_attr "type" "<VStype_simple>")])
 
-;; Fused vector multiply/add instructions. Support the classical Altivec
-;; versions of fma, which allows the target to be a separate register from the
-;; 3 inputs.  Under VSX, the target must be either the addend or the first
-;; multiply.
-
+;; Fused vector multiply/add instructions. Do not generate the Altivec versions
+;; of fma (vmaddfp and vnmsubfp).  These instructions allows the target to be a
+;; separate register from the 3 inputs, but they have different rounding
+;; behaviors than the VSX instructions.
 (define_insn "*vsx_fmav4sf4"
-  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa,wa,v")
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa,wa")
 	(fma:V4SF
-	  (match_operand:V4SF 1 "vsx_register_operand" "%wa,wa,v")
-	  (match_operand:V4SF 2 "vsx_register_operand" "wa,0,v")
-	  (match_operand:V4SF 3 "vsx_register_operand" "0,wa,v")))]
+	  (match_operand:V4SF 1 "vsx_register_operand" "%wa,wa")
+	  (match_operand:V4SF 2 "vsx_register_operand" "wa,0")
+	  (match_operand:V4SF 3 "vsx_register_operand" "0,wa")))]
   "VECTOR_UNIT_VSX_P (V4SFmode)"
   "@
    xvmaddasp %x0,%x1,%x2
-   xvmaddmsp %x0,%x1,%x3
-   vmaddfp %0,%1,%2,%3"
+   xvmaddmsp %x0,%x1,%x3"
   [(set_attr "type" "vecfloat")])
 
 (define_insn "*vsx_fmav2df4"
@@ -2029,18 +2027,17 @@
   [(set_attr "type" "<VStype_mul>")])
 
 (define_insn "*vsx_nfmsv4sf4"
-  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa,wa,v")
+  [(set (match_operand:V4SF 0 "vsx_register_operand" "=wa,wa")
 	(neg:V4SF
 	 (fma:V4SF
-	   (match_operand:V4SF 1 "vsx_register_operand" "%wa,wa,v")
-	   (match_operand:V4SF 2 "vsx_register_operand" "wa,0,v")
+	   (match_operand:V4SF 1 "vsx_register_operand" "%wa,wa")
+	   (match_operand:V4SF 2 "vsx_register_operand" "wa,0")
 	   (neg:V4SF
-	     (match_operand:V4SF 3 "vsx_register_operand" "0,wa,v")))))]
+	     (match_operand:V4SF 3 "vsx_register_operand" "0,wa")))))]
   "VECTOR_UNIT_VSX_P (V4SFmode)"
   "@
    xvnmsubasp %x0,%x1,%x2
-   xvnmsubmsp %x0,%x1,%x3
-   vnmsubfp %0,%1,%2,%3"
+   xvnmsubmsp %x0,%x1,%x3"
   [(set_attr "type" "vecfloat")])
 
 (define_insn "*vsx_nfmsv2df4"
@@ -4892,27 +4889,9 @@
  "vextsd2q %0,%1"
 [(set_attr "type" "vecexts")])
 
-(define_expand "vsignextend_v2di_v1ti"
-  [(set (match_operand:V1TI 0 "vsx_register_operand" "=v")
-	(unspec:V1TI [(match_operand:V2DI 1 "vsx_register_operand" "v")]
-		     UNSPEC_VSX_SIGN_EXTEND))]
-  "TARGET_POWER10"
-{
-  if (BYTES_BIG_ENDIAN)
-    {
-      rtx tmp = gen_reg_rtx (V2DImode);
-
-      emit_insn (gen_altivec_vrevev2di2(tmp, operands[1]));
-      emit_insn (gen_vsx_sign_extend_v2di_v1ti(operands[0], tmp));
-      DONE;
-     }
-
-  emit_insn (gen_vsx_sign_extend_v2di_v1ti(operands[0], operands[1]));
-})
-
 ;; ISA 3.0 vector extend sign support
 
-(define_insn "vsx_sign_extend_qi_<mode>"
+(define_insn "vsx_sign_extend_v16qi_<mode>"
   [(set (match_operand:VSINT_84 0 "vsx_register_operand" "=v")
 	(unspec:VSINT_84
 	 [(match_operand:V16QI 1 "vsx_register_operand" "v")]
@@ -4921,25 +4900,7 @@
   "vextsb2<wd> %0,%1"
   [(set_attr "type" "vecexts")])
 
-(define_expand "vsignextend_qi_<mode>"
-  [(set (match_operand:VIlong 0 "vsx_register_operand" "=v")
-	(unspec:VIlong
-	 [(match_operand:V16QI 1 "vsx_register_operand" "v")]
-	 UNSPEC_VSX_SIGN_EXTEND))]
-  "TARGET_P9_VECTOR"
-{
-  if (BYTES_BIG_ENDIAN)
-    {
-      rtx tmp = gen_reg_rtx (V16QImode);
-      emit_insn (gen_altivec_vrevev16qi2(tmp, operands[1]));
-      emit_insn (gen_vsx_sign_extend_qi_<mode>(operands[0], tmp));
-    }
-  else
-    emit_insn (gen_vsx_sign_extend_qi_<mode>(operands[0], operands[1]));
-  DONE;
-})
-
-(define_insn "vsx_sign_extend_hi_<mode>"
+(define_insn "vsx_sign_extend_v8hi_<mode>"
   [(set (match_operand:VSINT_84 0 "vsx_register_operand" "=v")
 	(unspec:VSINT_84
 	 [(match_operand:V8HI 1 "vsx_register_operand" "v")]
@@ -4948,25 +4909,7 @@
   "vextsh2<wd> %0,%1"
   [(set_attr "type" "vecexts")])
 
-(define_expand "vsignextend_hi_<mode>"
-  [(set (match_operand:VIlong 0 "vsx_register_operand" "=v")
-	(unspec:VIlong
-	 [(match_operand:V8HI 1 "vsx_register_operand" "v")]
-	 UNSPEC_VSX_SIGN_EXTEND))]
-  "TARGET_P9_VECTOR"
-{
-  if (BYTES_BIG_ENDIAN)
-    {
-      rtx tmp = gen_reg_rtx (V8HImode);
-      emit_insn (gen_altivec_vrevev8hi2(tmp, operands[1]));
-      emit_insn (gen_vsx_sign_extend_hi_<mode>(operands[0], tmp));
-    }
-  else
-     emit_insn (gen_vsx_sign_extend_hi_<mode>(operands[0], operands[1]));
-  DONE;
-})
-
-(define_insn "vsx_sign_extend_si_v2di"
+(define_insn "vsx_sign_extend_v4si_v2di"
   [(set (match_operand:V2DI 0 "vsx_register_operand" "=v")
 	(unspec:V2DI [(match_operand:V4SI 1 "vsx_register_operand" "v")]
 		     UNSPEC_VSX_SIGN_EXTEND))]
@@ -4974,24 +4917,6 @@
   "vextsw2d %0,%1"
   [(set_attr "type" "vecexts")])
 
-(define_expand "vsignextend_si_v2di"
-  [(set (match_operand:V2DI 0 "vsx_register_operand" "=v")
-	(unspec:V2DI [(match_operand:V4SI 1 "vsx_register_operand" "v")]
-		     UNSPEC_VSX_SIGN_EXTEND))]
-  "TARGET_P9_VECTOR"
-{
-  if (BYTES_BIG_ENDIAN)
-    {
-       rtx tmp = gen_reg_rtx (V4SImode);
-
-       emit_insn (gen_altivec_vrevev4si2(tmp, operands[1]));
-       emit_insn (gen_vsx_sign_extend_si_v2di(operands[0], tmp));
-    }
-  else
-     emit_insn (gen_vsx_sign_extend_si_v2di(operands[0], operands[1]));
-  DONE;
-})
-
 ;; ISA 3.1 vector sign extend
 ;; Move DI value from GPR to TI mode in VSX register, word 1.
 (define_insn "mtvsrdd_diti_w1"
diff --git a/gcc/config/rs6000/xmmintrin.h b/gcc/config/rs6000/xmmintrin.h
index ae1a33e8d95..ba311cbf2df 100644
--- a/gcc/config/rs6000/xmmintrin.h
+++ b/gcc/config/rs6000/xmmintrin.h
@@ -127,14 +127,14 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_loadr_ps (float const *__P)
 {
   __v4sf   __tmp;
-  __m128 result;
-  static const __vector unsigned char permute_vector =
+  __m128 __result;
+  static const __vector unsigned char __permute_vector =
     { 0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B, 0x14, 0x15, 0x16,
 	0x17, 0x10, 0x11, 0x12, 0x13 };
 
   __tmp = vec_ld (0, (__v4sf *) __P);
-  result = (__m128) vec_perm (__tmp, __tmp, permute_vector);
-  return result;
+  __result = (__m128) vec_perm (__tmp, __tmp, __permute_vector);
+  return __result;
 }
 
 /* Create a vector with all four elements equal to F.  */
@@ -184,11 +184,11 @@ extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artific
 _mm_storer_ps (float *__P, __m128 __A)
 {
   __v4sf   __tmp;
-  static const __vector unsigned char permute_vector =
+  static const __vector unsigned char __permute_vector =
     { 0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B, 0x14, 0x15, 0x16,
 	0x17, 0x10, 0x11, 0x12, 0x13 };
 
-  __tmp = (__m128) vec_perm (__A, __A, permute_vector);
+  __tmp = (__m128) vec_perm (__A, __A, __permute_vector);
 
   _mm_store_ps (__P, __tmp);
 }
@@ -218,9 +218,9 @@ _mm_set_ss (float __F)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_move_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
 
-  return (vec_sel ((__v4sf)__A, (__v4sf)__B, mask));
+  return (vec_sel ((__v4sf)__A, (__v4sf)__B, __mask));
 }
 
 /* Create a vector with element 0 as *P and the rest zero.  */
@@ -245,18 +245,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_add_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a + b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a + __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] + __B[0];
   return (__A);
@@ -267,18 +267,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_sub_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a - b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a - __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] - __B[0];
   return (__A);
@@ -289,18 +289,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_mul_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a * b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a * __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] * __B[0];
   return (__A);
@@ -311,18 +311,18 @@ extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artif
 _mm_div_ss (__m128 __A, __m128 __B)
 {
 #ifdef _ARCH_PWR7
-  __m128 a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
      results. So to insure we don't generate spurious exceptions
      (from the upper double values) we splat the lower double
      before we to the operation.  */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = a / b;
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = __a / __b;
   /* Then we merge the lower float result with the original upper
      float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 #else
   __A[0] = __A[0] / __B[0];
   return (__A);
@@ -332,17 +332,17 @@ _mm_div_ss (__m128 __A, __m128 __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sqrt_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = vec_sqrt (a);
+  __a = vec_splat (__A, 0);
+  __c = vec_sqrt (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 /* Perform the respective operation on the four SPFP values in A and B.  */
@@ -391,81 +391,81 @@ _mm_rsqrt_ps (__m128 __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_rcp_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = _mm_rcp_ps (a);
+  __a = vec_splat (__A, 0);
+  __c = _mm_rcp_ps (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_rsqrt_ss (__m128 __A)
 {
-  __m128 a, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __m128 __a, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower double)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper double values) we splat the lower double
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  c = vec_rsqrte (a);
+  __a = vec_splat (__A, 0);
+  __c = vec_rsqrte (__a);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel (__A, c, mask));
+  return (vec_sel (__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_ss (__m128 __A, __m128 __B)
 {
-  __v4sf a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __v4sf __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower float)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper float values) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf)__A, 0);
-  b = vec_splat ((__v4sf)__B, 0);
-  c = vec_min (a, b);
+  __a = vec_splat ((__v4sf)__A, 0);
+  __b = vec_splat ((__v4sf)__B, 0);
+  __c = vec_min (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel ((__v4sf)__A, c, mask));
+  return (vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_ss (__m128 __A, __m128 __B)
 {
-  __v4sf a, b, c;
-  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};
+  __v4sf __a, __b, __c;
+  static const __vector unsigned int __mask = {0xffffffff, 0, 0, 0};
   /* PowerISA VSX does not allow partial (for just lower float)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper float values) we splat the lower float
    * before we to the operation. */
-  a = vec_splat (__A, 0);
-  b = vec_splat (__B, 0);
-  c = vec_max (a, b);
+  __a = vec_splat (__A, 0);
+  __b = vec_splat (__B, 0);
+  __c = vec_max (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return (vec_sel ((__v4sf)__A, c, mask));
+  return (vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_min_ps (__m128 __A, __m128 __B)
 {
-  __vector __bool int m = vec_cmpgt ((__v4sf) __B, (__v4sf) __A);
-  return vec_sel (__B, __A, m);
+  __vector __bool int __m = vec_cmpgt ((__v4sf) __B, (__v4sf) __A);
+  return vec_sel (__B, __A, __m);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_max_ps (__m128 __A, __m128 __B)
 {
-  __vector __bool int m = vec_cmpgt ((__v4sf) __A, (__v4sf) __B);
-  return vec_sel (__B, __A, m);
+  __vector __bool int __m = vec_cmpgt ((__v4sf) __A, (__v4sf) __B);
+  return vec_sel (__B, __A, __m);
 }
 
 /* Perform logical bit-wise operations on 128-bit values.  */
@@ -530,8 +530,8 @@ _mm_cmpge_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_ps (__m128  __A, __m128  __B)
 {
-  __v4sf temp = (__v4sf ) vec_cmpeq ((__v4sf) __A, (__v4sf)__B);
-  return ((__m128)vec_nor (temp, temp));
+  __v4sf __temp = (__v4sf ) vec_cmpeq ((__v4sf) __A, (__v4sf)__B);
+  return ((__m128)vec_nor (__temp, __temp));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -561,31 +561,31 @@ _mm_cmpnge_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_ps (__m128  __A, __m128  __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (float_exp_mask, a);
-  d = (__vector unsigned int) vec_cmpgt (float_exp_mask, b);
-  return ((__m128 ) vec_and (c, d));
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __a);
+  __d = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __b);
+  return ((__m128 ) vec_and (__c, __d));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_ps (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (a, float_exp_mask);
-  d = (__vector unsigned int) vec_cmpgt (b, float_exp_mask);
-  return ((__m128 ) vec_or (c, d));
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__a, __float_exp_mask);
+  __d = (__vector unsigned int) vec_cmpgt (__b, __float_exp_mask);
+  return ((__m128 ) vec_or (__c, __d));
 }
 
 /* Perform a comparison on the lower SPFP values of A and B.  If the
@@ -594,222 +594,222 @@ _mm_cmpunord_ps (__m128 __A, __m128 __B)
 extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpeq_ss (__m128  __A, __m128  __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpeq(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpeq (__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmplt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmplt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmplt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmple_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmple(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmple(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpgt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpgt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpgt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpge_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpge(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpge(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpneq_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpeq(a, b);
-  c = vec_nor (c, c);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpeq(__a, __b);
+  __c = vec_nor (__c, __c);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnlt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpge(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpge(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnle_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmpgt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmpgt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpngt_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we to the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmple(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmple(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpnge_ss (__m128 __A, __m128 __B)
 {
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
-  __v4sf a, b, c;
+  __v4sf __a, __b, __c;
   /* PowerISA VMX does not allow partial (for just element 0)
    * results. So to insure we don't generate spurious exceptions
    * (from the upper elements) we splat the lower float
    * before we do the operation. */
-  a = vec_splat ((__v4sf) __A, 0);
-  b = vec_splat ((__v4sf) __B, 0);
-  c = (__v4sf) vec_cmplt(a, b);
+  __a = vec_splat ((__v4sf) __A, 0);
+  __b = vec_splat ((__v4sf) __B, 0);
+  __c = (__v4sf) vec_cmplt(__a, __b);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, __c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpord_ss (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (float_exp_mask, a);
-  d = (__vector unsigned int) vec_cmpgt (float_exp_mask, b);
-  c = vec_and (c, d);
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __a);
+  __d = (__vector unsigned int) vec_cmpgt (__float_exp_mask, __b);
+  __c = vec_and (__c, __d);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)__c, __mask));
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpunord_ss (__m128 __A, __m128 __B)
 {
-  __vector unsigned int a, b;
-  __vector unsigned int c, d;
-  static const __vector unsigned int float_exp_mask =
+  __vector unsigned int __a, __b;
+  __vector unsigned int __c, __d;
+  static const __vector unsigned int __float_exp_mask =
     { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };
-  static const __vector unsigned int mask =
+  static const __vector unsigned int __mask =
     { 0xffffffff, 0, 0, 0 };
 
-  a = (__vector unsigned int) vec_abs ((__v4sf)__A);
-  b = (__vector unsigned int) vec_abs ((__v4sf)__B);
-  c = (__vector unsigned int) vec_cmpgt (a, float_exp_mask);
-  d = (__vector unsigned int) vec_cmpgt (b, float_exp_mask);
-  c = vec_or (c, d);
+  __a = (__vector unsigned int) vec_abs ((__v4sf)__A);
+  __b = (__vector unsigned int) vec_abs ((__v4sf)__B);
+  __c = (__vector unsigned int) vec_cmpgt (__a, __float_exp_mask);
+  __d = (__vector unsigned int) vec_cmpgt (__b, __float_exp_mask);
+  __c = vec_or (__c, __d);
   /* Then we merge the lower float result with the original upper
    * float elements from __A.  */
-  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)c, mask));
+  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)__c, __mask));
 }
 
 /* Compare the lower SPFP values of A and B and return 1 if true
@@ -905,9 +905,9 @@ _mm_cvtss_f32 (__m128 __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtss_si32 (__m128 __A)
 {
-  int res;
+  int __res;
 #ifdef _ARCH_PWR8
-  double dtmp;
+  double __dtmp;
   __asm__(
 #ifdef __LITTLE_ENDIAN__
       "xxsldwi %x0,%x0,%x0,3;\n"
@@ -916,13 +916,13 @@ _mm_cvtss_si32 (__m128 __A)
       "fctiw  %2,%2;\n"
       "mfvsrd  %1,%x2;\n"
       : "+wa" (__A),
-        "=r" (res),
-        "=f" (dtmp)
+        "=r" (__res),
+        "=f" (__dtmp)
       : );
 #else
-  res = __builtin_rint(__A[0]);
+  __res = __builtin_rint(__A[0]);
 #endif
-  return (res);
+  return __res;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -938,9 +938,9 @@ _mm_cvt_ss2si (__m128 __A)
 extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtss_si64 (__m128 __A)
 {
-  long long res;
+  long long __res;
 #if defined (_ARCH_PWR8) && defined (__powerpc64__)
-  double dtmp;
+  double __dtmp;
   __asm__(
 #ifdef __LITTLE_ENDIAN__
       "xxsldwi %x0,%x0,%x0,3;\n"
@@ -949,13 +949,13 @@ _mm_cvtss_si64 (__m128 __A)
       "fctid  %2,%2;\n"
       "mfvsrd  %1,%x2;\n"
       : "+wa" (__A),
-        "=r" (res),
-        "=f" (dtmp)
+        "=r" (__res),
+        "=f" (__dtmp)
       : );
 #else
-  res = __builtin_llrint(__A[0]);
+  __res = __builtin_llrint(__A[0]);
 #endif
-  return (res);
+  return __res;
 }
 
 /* Microsoft intrinsic.  */
@@ -992,15 +992,15 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_cvtps_pi32 (__m128 __A)
 {
   /* Splat two lower SPFP values to both halves.  */
-  __v4sf temp, rounded;
-  __vector unsigned long long result;
+  __v4sf __temp, __rounded;
+  __vector unsigned long long __result;
 
   /* Splat two lower SPFP values to both halves.  */
-  temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
-  rounded = vec_rint(temp);
-  result = (__vector unsigned long long) vec_cts (rounded, 0);
+  __temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
+  __rounded = vec_rint (__temp);
+  __result = (__vector unsigned long long) vec_cts (__rounded, 0);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1014,9 +1014,9 @@ extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artifici
 _mm_cvttss_si32 (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1030,9 +1030,9 @@ extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __ar
 _mm_cvttss_si64 (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 /* Microsoft intrinsic.  */
@@ -1040,9 +1040,9 @@ extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __ar
 _mm_cvttss_si64x (__m128 __A)
 {
   /* Extract the lower float element.  */
-  float temp = __A[0];
+  float __temp = __A[0];
   /* truncate to 32-bit integer and return.  */
-  return temp;
+  return __temp;
 }
 
 /* Truncate the two lower SPFP values to 32-bit integers.  Return the
@@ -1050,14 +1050,14 @@ _mm_cvttss_si64x (__m128 __A)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvttps_pi32 (__m128 __A)
 {
-  __v4sf temp;
-  __vector unsigned long long result;
+  __v4sf __temp;
+  __vector unsigned long long __result;
 
   /* Splat two lower SPFP values to both halves.  */
-  temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
-  result = (__vector unsigned long long) vec_cts (temp, 0);
+  __temp = (__v4sf) vec_splat ((__vector long long)__A, 0);
+  __result = (__vector unsigned long long) vec_cts (__temp, 0);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1070,8 +1070,8 @@ _mm_cvtt_ps2pi (__m128 __A)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi32_ss (__m128 __A, int __B)
 {
-  float temp = __B;
-  __A[0] = temp;
+  float __temp = __B;
+  __A[0] = __temp;
 
   return __A;
 }
@@ -1087,8 +1087,8 @@ _mm_cvt_si2ss (__m128 __A, int __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtsi64_ss (__m128 __A, long long __B)
 {
-  float temp = __B;
-  __A[0] = temp;
+  float __temp = __B;
+  __A[0] = __temp;
 
   return __A;
 }
@@ -1105,14 +1105,14 @@ _mm_cvtsi64x_ss (__m128 __A, long long __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32_ps (__m128        __A, __m64        __B)
 {
-  __vector signed int vm1;
-  __vector float vf1;
+  __vector signed int __vm1;
+  __vector float __vf1;
 
-  vm1 = (__vector signed int) (__vector unsigned long long) {__B, __B};
-  vf1 = (__vector float) vec_ctf (vm1, 0);
+  __vm1 = (__vector signed int) (__vector unsigned long long) {__B, __B};
+  __vf1 = (__vector float) vec_ctf (__vm1, 0);
 
   return ((__m128) (__vector unsigned long long)
-    { ((__vector unsigned long long)vf1) [0],
+    { ((__vector unsigned long long)__vf1) [0],
 	((__vector unsigned long long)__A) [1]});
 }
 
@@ -1126,54 +1126,54 @@ _mm_cvt_pi2ps (__m128 __A, __m64 __B)
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi16_ps (__m64 __A)
 {
-  __vector signed short vs8;
-  __vector signed int vi4;
-  __vector float vf1;
+  __vector signed short __vs8;
+  __vector signed int __vi4;
+  __vector float __vf1;
 
-  vs8 = (__vector signed short) (__vector unsigned long long) { __A, __A };
-  vi4 = vec_vupklsh (vs8);
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vs8 = (__vector signed short) (__vector unsigned long long) { __A, __A };
+  __vi4 = vec_vupklsh (__vs8);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the four unsigned 16-bit values in A to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpu16_ps (__m64 __A)
 {
-  const __vector unsigned short zero =
+  const __vector unsigned short __zero =
     { 0, 0, 0, 0, 0, 0, 0, 0 };
-  __vector unsigned short vs8;
-  __vector unsigned int vi4;
-  __vector float vf1;
+  __vector unsigned short __vs8;
+  __vector unsigned int __vi4;
+  __vector float __vf1;
 
-  vs8 = (__vector unsigned short) (__vector unsigned long long) { __A, __A };
-  vi4 = (__vector unsigned int) vec_mergel
+  __vs8 = (__vector unsigned short) (__vector unsigned long long) { __A, __A };
+  __vi4 = (__vector unsigned int) vec_mergel
 #ifdef __LITTLE_ENDIAN__
-                                           (vs8, zero);
+                                           (__vs8, __zero);
 #else
-                                           (zero, vs8);
+                                           (__zero, __vs8);
 #endif
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the low four signed 8-bit values in A to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi8_ps (__m64 __A)
 {
-  __vector signed char vc16;
-  __vector signed short vs8;
-  __vector signed int vi4;
-  __vector float vf1;
+  __vector signed char __vc16;
+  __vector signed short __vs8;
+  __vector signed int __vi4;
+  __vector float __vf1;
 
-  vc16 = (__vector signed char) (__vector unsigned long long) { __A, __A };
-  vs8 = vec_vupkhsb (vc16);
-  vi4 = vec_vupkhsh (vs8);
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vc16 = (__vector signed char) (__vector unsigned long long) { __A, __A };
+  __vs8 = vec_vupkhsb (__vc16);
+  __vi4 = vec_vupkhsh (__vs8);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the low four unsigned 8-bit values in A to SPFP form.  */
@@ -1181,70 +1181,70 @@ extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __art
 
 _mm_cvtpu8_ps (__m64  __A)
 {
-  const __vector unsigned char zero =
+  const __vector unsigned char __zero =
     { 0, 0, 0, 0, 0, 0, 0, 0 };
-  __vector unsigned char vc16;
-  __vector unsigned short vs8;
-  __vector unsigned int vi4;
-  __vector float vf1;
+  __vector unsigned char __vc16;
+  __vector unsigned short __vs8;
+  __vector unsigned int __vi4;
+  __vector float __vf1;
 
-  vc16 = (__vector unsigned char) (__vector unsigned long long) { __A, __A };
+  __vc16 = (__vector unsigned char) (__vector unsigned long long) { __A, __A };
 #ifdef __LITTLE_ENDIAN__
-  vs8 = (__vector unsigned short) vec_mergel (vc16, zero);
-  vi4 = (__vector unsigned int) vec_mergeh (vs8,
-					    (__vector unsigned short) zero);
+  __vs8 = (__vector unsigned short) vec_mergel (__vc16, __zero);
+  __vi4 = (__vector unsigned int) vec_mergeh (__vs8,
+					    (__vector unsigned short) __zero);
 #else
-  vs8 = (__vector unsigned short) vec_mergel (zero, vc16);
-  vi4 = (__vector unsigned int) vec_mergeh ((__vector unsigned short) zero,
-                                            vs8);
+  __vs8 = (__vector unsigned short) vec_mergel (__zero, __vc16);
+  __vi4 = (__vector unsigned int) vec_mergeh ((__vector unsigned short) __zero,
+                                            __vs8);
 #endif
-  vf1 = (__vector float) vec_ctf (vi4, 0);
+  __vf1 = (__vector float) vec_ctf (__vi4, 0);
 
-  return (__m128) vf1;
+  return (__m128) __vf1;
 }
 
 /* Convert the four signed 32-bit values in A and B to SPFP form.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtpi32x2_ps (__m64 __A, __m64 __B)
 {
-  __vector signed int vi4;
-  __vector float vf4;
+  __vector signed int __vi4;
+  __vector float __vf4;
 
-  vi4 = (__vector signed int) (__vector unsigned long long) { __A, __B };
-  vf4 = (__vector float) vec_ctf (vi4, 0);
-  return (__m128) vf4;
+  __vi4 = (__vector signed int) (__vector unsigned long long) { __A, __B };
+  __vf4 = (__vector float) vec_ctf (__vi4, 0);
+  return (__m128) __vf4;
 }
 
 /* Convert the four SPFP values in A to four signed 16-bit integers.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_pi16 (__m128 __A)
 {
-  __v4sf rounded;
-  __vector signed int temp;
-  __vector unsigned long long result;
+  __v4sf __rounded;
+  __vector signed int __temp;
+  __vector unsigned long long __result;
 
-  rounded = vec_rint(__A);
-  temp = vec_cts (rounded, 0);
-  result = (__vector unsigned long long) vec_pack (temp, temp);
+  __rounded = vec_rint(__A);
+  __temp = vec_cts (__rounded, 0);
+  __result = (__vector unsigned long long) vec_pack (__temp, __temp);
 
-  return (__m64) ((__vector long long) result)[0];
+  return (__m64) ((__vector long long) __result)[0];
 }
 
 /* Convert the four SPFP values in A to four signed 8-bit integers.  */
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cvtps_pi8 (__m128 __A)
 {
-  __v4sf rounded;
-  __vector signed int tmp_i;
-  static const __vector signed int zero = {0, 0, 0, 0};
-  __vector signed short tmp_s;
-  __vector signed char res_v;
+  __v4sf __rounded;
+  __vector signed int __tmp_i;
+  static const __vector signed int __zero = {0, 0, 0, 0};
+  __vector signed short __tmp_s;
+  __vector signed char __res_v;
 
-  rounded = vec_rint(__A);
-  tmp_i = vec_cts (rounded, 0);
-  tmp_s = vec_pack (tmp_i, zero);
-  res_v = vec_pack (tmp_s, tmp_s);
-  return (__m64) ((__vector long long) res_v)[0];
+  __rounded = vec_rint(__A);
+  __tmp_i = vec_cts (__rounded, 0);
+  __tmp_s = vec_pack (__tmp_i, __zero);
+  __res_v = vec_pack (__tmp_s, __tmp_s);
+  return (__m64) ((__vector long long) __res_v)[0];
 }
 
 /* Selects four specific SPFP values from A and B based on MASK.  */
@@ -1252,11 +1252,11 @@ extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __art
 
 _mm_shuffle_ps (__m128  __A, __m128  __B, int const __mask)
 {
-  unsigned long element_selector_10 = __mask & 0x03;
-  unsigned long element_selector_32 = (__mask >> 2) & 0x03;
-  unsigned long element_selector_54 = (__mask >> 4) & 0x03;
-  unsigned long element_selector_76 = (__mask >> 6) & 0x03;
-  static const unsigned int permute_selectors[4] =
+  unsigned long __element_selector_10 = __mask & 0x03;
+  unsigned long __element_selector_32 = (__mask >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__mask >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__mask >> 6) & 0x03;
+  static const unsigned int __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
       0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C
@@ -1264,13 +1264,13 @@ _mm_shuffle_ps (__m128  __A, __m128  __B, int const __mask)
       0x00010203, 0x04050607, 0x08090A0B, 0x0C0D0E0F
 #endif
     };
-  __vector unsigned int t;
+  __vector unsigned int __t;
 
-  t[0] = permute_selectors[element_selector_10];
-  t[1] = permute_selectors[element_selector_32];
-  t[2] = permute_selectors[element_selector_54] + 0x10101010;
-  t[3] = permute_selectors[element_selector_76] + 0x10101010;
-  return vec_perm ((__v4sf) __A, (__v4sf)__B, (__vector unsigned char)t);
+  __t[0] = __permute_selectors[__element_selector_10];
+  __t[1] = __permute_selectors[__element_selector_32];
+  __t[2] = __permute_selectors[__element_selector_54] + 0x10101010;
+  __t[3] = __permute_selectors[__element_selector_76] + 0x10101010;
+  return vec_perm ((__v4sf) __A, (__v4sf)__B, (__vector unsigned char)__t);
 }
 
 /* Selects and interleaves the upper two SPFP values from A and B.  */
@@ -1352,8 +1352,8 @@ _mm_storel_pi (__m64 *__P, __m128 __A)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_movemask_ps (__m128  __A)
 {
-  __vector unsigned long long result;
-  static const __vector unsigned int perm_mask =
+  __vector unsigned long long __result;
+  static const __vector unsigned int __perm_mask =
     {
 #ifdef __LITTLE_ENDIAN__
 	0x00204060, 0x80808080, 0x80808080, 0x80808080
@@ -1362,14 +1362,14 @@ _mm_movemask_ps (__m128  __A)
 #endif
     };
 
-  result = ((__vector unsigned long long)
+  __result = ((__vector unsigned long long)
 	    vec_vbpermq ((__vector unsigned char) __A,
-			 (__vector unsigned char) perm_mask));
+			 (__vector unsigned char) __perm_mask));
 
 #ifdef __LITTLE_ENDIAN__
-  return result[1];
+  return __result[1];
 #else
-  return result[0];
+  return __result[0];
 #endif
 }
 #endif /* _ARCH_PWR8 */
@@ -1391,12 +1391,12 @@ _mm_load_ps1 (float const *__P)
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_extract_pi16 (__m64 const __A, int const __N)
 {
-  unsigned int shiftr = __N & 3;
+  unsigned int __shiftr = __N & 3;
 #ifdef __BIG_ENDIAN__
-  shiftr = 3 - shiftr;
+  __shiftr = 3 - __shiftr;
 #endif
 
-  return ((__A >> (shiftr * 16)) & 0xffff);
+  return ((__A >> (__shiftr * 16)) & 0xffff);
 }
 
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1410,12 +1410,12 @@ _m_pextrw (__m64 const __A, int const __N)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_insert_pi16 (__m64 const __A, int const __D, int const __N)
 {
-  const int shiftl = (__N & 3) * 16;
-  const __m64 shiftD = (const __m64) __D << shiftl;
-  const __m64 mask = 0xffffUL << shiftl;
-  __m64 result = (__A & (~mask)) | (shiftD & mask);
+  const int __shiftl = (__N & 3) * 16;
+  const __m64 __shiftD = (const __m64) __D << __shiftl;
+  const __m64 __mask = 0xffffUL << __shiftl;
+  __m64 __result = (__A & (~__mask)) | (__shiftD & __mask);
 
-  return (result);
+  return __result;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1430,30 +1430,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_max_pi16 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, r;
-  __vector __bool short c;
+  __vector signed short __a, __b, __r;
+  __vector __bool short __c;
 
-  a = (__vector signed short)vec_splats (__A);
-  b = (__vector signed short)vec_splats (__B);
-  c = (__vector __bool short)vec_cmpgt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __a = (__vector signed short)vec_splats (__A);
+  __b = (__vector signed short)vec_splats (__B);
+  __c = (__vector __bool short)vec_cmpgt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __m1, __m2, __res;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
-  res.as_short[0] =
-      (m1.as_short[0] > m2.as_short[0]) ? m1.as_short[0] : m2.as_short[0];
-  res.as_short[1] =
-      (m1.as_short[1] > m2.as_short[1]) ? m1.as_short[1] : m2.as_short[1];
-  res.as_short[2] =
-      (m1.as_short[2] > m2.as_short[2]) ? m1.as_short[2] : m2.as_short[2];
-  res.as_short[3] =
-      (m1.as_short[3] > m2.as_short[3]) ? m1.as_short[3] : m2.as_short[3];
+  __res.as_short[0] =
+      (__m1.as_short[0] > __m2.as_short[0]) ? __m1.as_short[0] : __m2.as_short[0];
+  __res.as_short[1] =
+      (__m1.as_short[1] > __m2.as_short[1]) ? __m1.as_short[1] : __m2.as_short[1];
+  __res.as_short[2] =
+      (__m1.as_short[2] > __m2.as_short[2]) ? __m1.as_short[2] : __m2.as_short[2];
+  __res.as_short[3] =
+      (__m1.as_short[3] > __m2.as_short[3]) ? __m1.as_short[3] : __m2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1468,28 +1468,27 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_max_pu8 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, r;
-  __vector __bool char c;
+  __vector unsigned char __a, __b, __r;
+  __vector __bool char __c;
 
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = (__vector __bool char)vec_cmpgt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = (__vector __bool char)vec_cmpgt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
-  long i;
+  __m64_union __m1, __m2, __res;
+  long __i;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
+  for (__i = 0; __i < 8; __i++)
+    __res.as_char[__i] =
+      ((unsigned char) __m1.as_char[__i] > (unsigned char) __m2.as_char[__i]) ?
+	  __m1.as_char[__i] : __m2.as_char[__i];
 
-  for (i = 0; i < 8; i++)
-  res.as_char[i] =
-      ((unsigned char) m1.as_char[i] > (unsigned char) m2.as_char[i]) ?
-	  m1.as_char[i] : m2.as_char[i];
-
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1504,30 +1503,30 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_min_pi16 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector signed short a, b, r;
-  __vector __bool short c;
+  __vector signed short __a, __b, __r;
+  __vector __bool short __c;
 
-  a = (__vector signed short)vec_splats (__A);
-  b = (__vector signed short)vec_splats (__B);
-  c = (__vector __bool short)vec_cmplt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __a = (__vector signed short)vec_splats (__A);
+  __b = (__vector signed short)vec_splats (__B);
+  __c = (__vector __bool short)vec_cmplt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
+  __m64_union __m1, __m2, __res;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
-  res.as_short[0] =
-      (m1.as_short[0] < m2.as_short[0]) ? m1.as_short[0] : m2.as_short[0];
-  res.as_short[1] =
-      (m1.as_short[1] < m2.as_short[1]) ? m1.as_short[1] : m2.as_short[1];
-  res.as_short[2] =
-      (m1.as_short[2] < m2.as_short[2]) ? m1.as_short[2] : m2.as_short[2];
-  res.as_short[3] =
-      (m1.as_short[3] < m2.as_short[3]) ? m1.as_short[3] : m2.as_short[3];
+  __res.as_short[0] =
+      (__m1.as_short[0] < __m2.as_short[0]) ? __m1.as_short[0] : __m2.as_short[0];
+  __res.as_short[1] =
+      (__m1.as_short[1] < __m2.as_short[1]) ? __m1.as_short[1] : __m2.as_short[1];
+  __res.as_short[2] =
+      (__m1.as_short[2] < __m2.as_short[2]) ? __m1.as_short[2] : __m2.as_short[2];
+  __res.as_short[3] =
+      (__m1.as_short[3] < __m2.as_short[3]) ? __m1.as_short[3] : __m2.as_short[3];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1542,28 +1541,28 @@ extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artifi
 _mm_min_pu8 (__m64 __A, __m64 __B)
 {
 #if _ARCH_PWR8
-  __vector unsigned char a, b, r;
-  __vector __bool char c;
+  __vector unsigned char __a, __b, __r;
+  __vector __bool char __c;
 
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = (__vector __bool char)vec_cmplt (a, b);
-  r = vec_sel (b, a, c);
-  return (__m64) ((__vector long long) r)[0];
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = (__vector __bool char)vec_cmplt (__a, __b);
+  __r = vec_sel (__b, __a, __c);
+  return (__m64) ((__vector long long) __r)[0];
 #else
-  __m64_union m1, m2, res;
-  long i;
+  __m64_union __m1, __m2, __res;
+  long __i;
 
-  m1.as_m64 = __A;
-  m2.as_m64 = __B;
+  __m1.as_m64 = __A;
+  __m2.as_m64 = __B;
 
 
-  for (i = 0; i < 8; i++)
-  res.as_char[i] =
-      ((unsigned char) m1.as_char[i] < (unsigned char) m2.as_char[i]) ?
-	  m1.as_char[i] : m2.as_char[i];
+  for (__i = 0; __i < 8; __i++)
+    __res.as_char[__i] =
+      ((unsigned char) __m1.as_char[__i] < (unsigned char) __m2.as_char[__i]) ?
+	  __m1.as_char[__i] : __m2.as_char[__i];
 
-  return (__m64) res.as_m64;
+  return (__m64) __res.as_m64;
 #endif
 }
 
@@ -1578,24 +1577,24 @@ extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artifici
 _mm_movemask_pi8 (__m64 __A)
 {
 #ifdef __powerpc64__
-  unsigned long long p =
+  unsigned long long __p =
 #ifdef __LITTLE_ENDIAN__
                          0x0008101820283038UL; // permute control for sign bits
 #else
                          0x3830282018100800UL; // permute control for sign bits
 #endif
-  return __builtin_bpermd (p, __A);
+  return __builtin_bpermd (__p, __A);
 #else
 #ifdef __LITTLE_ENDIAN__
-  unsigned int mask = 0x20283038UL;
-  unsigned int r1 = __builtin_bpermd (mask, __A) & 0xf;
-  unsigned int r2 = __builtin_bpermd (mask, __A >> 32) & 0xf;
+  unsigned int __mask = 0x20283038UL;
+  unsigned int __r1 = __builtin_bpermd (__mask, __A) & 0xf;
+  unsigned int __r2 = __builtin_bpermd (__mask, __A >> 32) & 0xf;
 #else
-  unsigned int mask = 0x38302820UL;
-  unsigned int r1 = __builtin_bpermd (mask, __A >> 32) & 0xf;
-  unsigned int r2 = __builtin_bpermd (mask, __A) & 0xf;
+  unsigned int __mask = 0x38302820UL;
+  unsigned int __r1 = __builtin_bpermd (__mask, __A >> 32) & 0xf;
+  unsigned int __r2 = __builtin_bpermd (__mask, __A) & 0xf;
 #endif
-  return (r2 << 4) | r1;
+  return (__r2 << 4) | __r1;
 #endif
 }
 
@@ -1610,10 +1609,10 @@ _m_pmovmskb (__m64 __A)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_mulhi_pu16 (__m64 __A, __m64 __B)
 {
-  __vector unsigned short a, b;
-  __vector unsigned short c;
-  __vector unsigned int w0, w1;
-  __vector unsigned char xform1 = {
+  __vector unsigned short __a, __b;
+  __vector unsigned short __c;
+  __vector unsigned int __w0, __w1;
+  __vector unsigned char __xform1 = {
 #ifdef __LITTLE_ENDIAN__
       0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,
       0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F
@@ -1623,14 +1622,14 @@ _mm_mulhi_pu16 (__m64 __A, __m64 __B)
 #endif
     };
 
-  a = (__vector unsigned short)vec_splats (__A);
-  b = (__vector unsigned short)vec_splats (__B);
+  __a = (__vector unsigned short)vec_splats (__A);
+  __b = (__vector unsigned short)vec_splats (__B);
 
-  w0 = vec_vmuleuh (a, b);
-  w1 = vec_vmulouh (a, b);
-  c = (__vector unsigned short)vec_perm (w0, w1, xform1);
+  __w0 = vec_vmuleuh (__a, __b);
+  __w1 = vec_vmulouh (__a, __b);
+  __c = (__vector unsigned short)vec_perm (__w0, __w1, __xform1);
 
-  return (__m64) ((__vector long long) c)[0];
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1644,11 +1643,11 @@ _m_pmulhuw (__m64 __A, __m64 __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_shuffle_pi16 (__m64 __A, int const __N)
 {
-  unsigned long element_selector_10 = __N & 0x03;
-  unsigned long element_selector_32 = (__N >> 2) & 0x03;
-  unsigned long element_selector_54 = (__N >> 4) & 0x03;
-  unsigned long element_selector_76 = (__N >> 6) & 0x03;
-  static const unsigned short permute_selectors[4] =
+  unsigned long __element_selector_10 = __N & 0x03;
+  unsigned long __element_selector_32 = (__N >> 2) & 0x03;
+  unsigned long __element_selector_54 = (__N >> 4) & 0x03;
+  unsigned long __element_selector_76 = (__N >> 6) & 0x03;
+  static const unsigned short __permute_selectors[4] =
     {
 #ifdef __LITTLE_ENDIAN__
 	      0x0908, 0x0B0A, 0x0D0C, 0x0F0E
@@ -1656,24 +1655,24 @@ _mm_shuffle_pi16 (__m64 __A, int const __N)
 	      0x0607, 0x0405, 0x0203, 0x0001
 #endif
     };
-  __m64_union t;
-  __vector unsigned long long a, p, r;
+  __m64_union __t;
+  __vector unsigned long long __a, __p, __r;
 
 #ifdef __LITTLE_ENDIAN__
-  t.as_short[0] = permute_selectors[element_selector_10];
-  t.as_short[1] = permute_selectors[element_selector_32];
-  t.as_short[2] = permute_selectors[element_selector_54];
-  t.as_short[3] = permute_selectors[element_selector_76];
+  __t.as_short[0] = __permute_selectors[__element_selector_10];
+  __t.as_short[1] = __permute_selectors[__element_selector_32];
+  __t.as_short[2] = __permute_selectors[__element_selector_54];
+  __t.as_short[3] = __permute_selectors[__element_selector_76];
 #else
-  t.as_short[3] = permute_selectors[element_selector_10];
-  t.as_short[2] = permute_selectors[element_selector_32];
-  t.as_short[1] = permute_selectors[element_selector_54];
-  t.as_short[0] = permute_selectors[element_selector_76];
+  __t.as_short[3] = __permute_selectors[__element_selector_10];
+  __t.as_short[2] = __permute_selectors[__element_selector_32];
+  __t.as_short[1] = __permute_selectors[__element_selector_54];
+  __t.as_short[0] = __permute_selectors[__element_selector_76];
 #endif
-  p = vec_splats (t.as_m64);
-  a = vec_splats (__A);
-  r = vec_perm (a, a, (__vector unsigned char)p);
-  return (__m64) ((__vector long long) r)[0];
+  __p = vec_splats (__t.as_m64);
+  __a = vec_splats (__A);
+  __r = vec_perm (__a, __a, (__vector unsigned char)__p);
+  return (__m64) ((__vector long long) __r)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1688,14 +1687,14 @@ _m_pshufw (__m64 __A, int const __N)
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
 {
-  __m64 hibit = 0x8080808080808080UL;
-  __m64 mask, tmp;
-  __m64 *p = (__m64*)__P;
+  __m64 __hibit = 0x8080808080808080UL;
+  __m64 __mask, __tmp;
+  __m64 *__p = (__m64*)__P;
 
-  tmp = *p;
-  mask = _mm_cmpeq_pi8 ((__N & hibit), hibit);
-  tmp = (tmp & (~mask)) | (__A & mask);
-  *p = tmp;
+  __tmp = *__p;
+  __mask = _mm_cmpeq_pi8 ((__N & __hibit), __hibit);
+  __tmp = (__tmp & (~__mask)) | (__A & __mask);
+  *__p = __tmp;
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1708,12 +1707,12 @@ _m_maskmovq (__m64 __A, __m64 __N, char *__P)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_avg_pu8 (__m64 __A, __m64 __B)
 {
-  __vector unsigned char a, b, c;
+  __vector unsigned char __a, __b, __c;
 
-  a = (__vector unsigned char)vec_splats (__A);
-  b = (__vector unsigned char)vec_splats (__B);
-  c = vec_avg (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned char)vec_splats (__A);
+  __b = (__vector unsigned char)vec_splats (__B);
+  __c = vec_avg (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1726,12 +1725,12 @@ _m_pavgb (__m64 __A, __m64 __B)
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_avg_pu16 (__m64 __A, __m64 __B)
 {
-  __vector unsigned short a, b, c;
+  __vector unsigned short __a, __b, __c;
 
-  a = (__vector unsigned short)vec_splats (__A);
-  b = (__vector unsigned short)vec_splats (__B);
-  c = vec_avg (a, b);
-  return (__m64) ((__vector long long) c)[0];
+  __a = (__vector unsigned short)vec_splats (__A);
+  __b = (__vector unsigned short)vec_splats (__B);
+  __c = vec_avg (__a, __b);
+  return (__m64) ((__vector long long) __c)[0];
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -1746,26 +1745,26 @@ _m_pavgw (__m64 __A, __m64 __B)
 extern __inline    __m64    __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sad_pu8 (__m64  __A, __m64  __B)
 {
-  __vector unsigned char a, b;
-  __vector unsigned char vmin, vmax, vabsdiff;
-  __vector signed int vsum;
-  const __vector unsigned int zero =
+  __vector unsigned char __a, __b;
+  __vector unsigned char __vmin, __vmax, __vabsdiff;
+  __vector signed int __vsum;
+  const __vector unsigned int __zero =
     { 0, 0, 0, 0 };
-  __m64_union result = {0};
+  __m64_union __result = {0};
 
-  a = (__vector unsigned char) (__vector unsigned long long) { 0UL, __A };
-  b = (__vector unsigned char) (__vector unsigned long long) { 0UL, __B };
-  vmin = vec_min (a, b);
-  vmax = vec_max (a, b);
-  vabsdiff = vec_sub (vmax, vmin);
+  __a = (__vector unsigned char) (__vector unsigned long long) { 0UL, __A };
+  __b = (__vector unsigned char) (__vector unsigned long long) { 0UL, __B };
+  __vmin = vec_min (__a, __b);
+  __vmax = vec_max (__a, __b);
+  __vabsdiff = vec_sub (__vmax, __vmin);
   /* Sum four groups of bytes into integers.  */
-  vsum = (__vector signed int) vec_sum4s (vabsdiff, zero);
+  __vsum = (__vector signed int) vec_sum4s (__vabsdiff, __zero);
   /* Sum across four integers with integer result.  */
-  vsum = vec_sums (vsum, (__vector signed int) zero);
+  __vsum = vec_sums (__vsum, (__vector signed int) __zero);
   /* The sum is in the right most 32-bits of the vector result.
      Transfer to a GPR and truncate to 16 bits.  */
-  result.as_short[0] = vsum[3];
-  return result.as_m64;
+  __result.as_short[0] = __vsum[3];
+  return __result.as_m64;
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
index 44e48d90beb..5ef92d699c4 100644
--- a/gcc/config/s390/s390.c
+++ b/gcc/config/s390/s390.c
@@ -13679,36 +13679,37 @@ s390_call_saved_register_used (tree call_expr)
       function_arg_info arg (TREE_TYPE (parameter), /*named=*/true);
       apply_pass_by_reference_rules (&cum_v, arg);
 
-       parm_rtx = s390_function_arg (cum, arg);
+      parm_rtx = s390_function_arg (cum, arg);
 
-       s390_function_arg_advance (cum, arg);
+      s390_function_arg_advance (cum, arg);
 
-       if (!parm_rtx)
-	 continue;
+      if (!parm_rtx)
+	continue;
 
-       if (REG_P (parm_rtx))
-	 {
-	   for (reg = 0; reg < REG_NREGS (parm_rtx); reg++)
-	     if (!call_used_or_fixed_reg_p (reg + REGNO (parm_rtx)))
-	       return true;
-	 }
+      if (REG_P (parm_rtx))
+	{
+	  int size = s390_function_arg_size (arg.mode, arg.type);
+	  int nregs = (size + UNITS_PER_LONG - 1) / UNITS_PER_LONG;
 
-       if (GET_CODE (parm_rtx) == PARALLEL)
-	 {
-	   int i;
+	  for (reg = 0; reg < nregs; reg++)
+	    if (!call_used_or_fixed_reg_p (reg + REGNO (parm_rtx)))
+	      return true;
+	}
+      else if (GET_CODE (parm_rtx) == PARALLEL)
+	{
+	  int i;
 
-	   for (i = 0; i < XVECLEN (parm_rtx, 0); i++)
-	     {
-	       rtx r = XEXP (XVECEXP (parm_rtx, 0, i), 0);
+	  for (i = 0; i < XVECLEN (parm_rtx, 0); i++)
+	    {
+	      rtx r = XEXP (XVECEXP (parm_rtx, 0, i), 0);
 
-	       gcc_assert (REG_P (r));
-
-	       for (reg = 0; reg < REG_NREGS (r); reg++)
-		 if (!call_used_or_fixed_reg_p (reg + REGNO (r)))
-		   return true;
-	     }
-	 }
+	      gcc_assert (REG_P (r));
+	      gcc_assert (REG_NREGS (r) == 1);
 
+	      if (!call_used_or_fixed_reg_p (REGNO (r)))
+		return true;
+	    }
+	}
     }
   return false;
 }
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
index e3af9ae21c1..b647c33637c 100644
--- a/gcc/config/sh/sh.md
+++ b/gcc/config/sh/sh.md
@@ -842,7 +842,7 @@
   if (SUBREG_P (reg))
     reg = SUBREG_REG (reg);
   gcc_assert (REG_P (reg));
-  if (find_regno_note (curr_insn, REG_DEAD, REGNO (reg)) != NULL_RTX)
+  if (find_regno_note (curr_insn, REG_DEAD, REGNO (reg)) == NULL_RTX)
     FAIL;
 
   /* FIXME: Maybe also search the predecessor basic blocks to catch
@@ -10680,6 +10680,45 @@
    && peep2_reg_dead_p (2, operands[1]) && peep2_reg_dead_p (3, operands[0])"
   [(const_int 0)]
 {
+  if (MEM_P (operands[3]) && reg_overlap_mentioned_p (operands[0], operands[3]))
+    {
+      // Take care when the eliminated operand[0] register is part of
+      // the destination memory address.
+      rtx addr = XEXP (operands[3], 0);
+
+      if (REG_P (addr))
+	operands[3] = replace_equiv_address (operands[3], operands[1]);
+
+      else if (GET_CODE (addr) == PLUS && REG_P (XEXP (addr, 0))
+	       && CONST_INT_P (XEXP (addr, 1))
+	       && REGNO (operands[0]) == REGNO (XEXP (addr, 0)))
+	operands[3] = replace_equiv_address (operands[3],
+			    gen_rtx_PLUS (SImode, operands[1], XEXP (addr, 1)));
+
+      else if (GET_CODE (addr) == PLUS && REG_P (XEXP (addr, 0))
+	       && REG_P (XEXP (addr, 1)))
+        {
+          // register + register address  @(R0, Rn)
+          // can change only the Rn in the address, not R0.
+          if (REGNO (operands[0]) == REGNO (XEXP (addr, 0))
+	      && REGNO (XEXP (addr, 0)) != 0)
+	    {
+	      operands[3] = replace_equiv_address (operands[3],
+			    gen_rtx_PLUS (SImode, operands[1], XEXP (addr, 1)));
+	    }
+          else if (REGNO (operands[0]) == REGNO (XEXP (addr, 1))
+		   && REGNO (XEXP (addr, 1)) != 0)
+            {
+	      operands[3] = replace_equiv_address (operands[3],
+			    gen_rtx_PLUS (SImode, XEXP (addr, 0), operands[1]));
+            }
+          else
+            FAIL;
+        }
+      else
+        FAIL;
+    }
+
   emit_insn (gen_addsi3 (operands[1], operands[1], operands[2]));
   sh_peephole_emit_move_insn (operands[3], operands[1]);
 })
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 7c8a1f18c39..c42546eb9d1 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -6122,6 +6122,9 @@ sparc_expand_prologue (void)
 	}
 
       RTX_FRAME_RELATED_P (insn) = 1;
+
+      /* Ensure no memory access is done before the frame is established.  */
+      emit_insn (gen_frame_blockage ());
     }
   else
     {
@@ -6136,13 +6139,7 @@ sparc_expand_prologue (void)
 	  /* %sp is not the CFA register anymore.  */
 	  emit_insn (gen_stack_pointer_inc (GEN_INT (4096 - size)));
 
-	  /* Make sure no %fp-based store is issued until after the frame is
-	     established.  The offset between the frame pointer and the stack
-	     pointer is calculated relative to the value of the stack pointer
-	     at the end of the function prologue, and moving instructions that
-	     access the stack via the frame pointer between the instructions
-	     that decrement the stack pointer could result in accessing the
-	     register window save area, which is volatile.  */
+	  /* Likewise.  */
 	  emit_insn (gen_frame_blockage ());
 	}
       else
@@ -6238,8 +6235,8 @@ sparc_flat_expand_prologue (void)
 	}
       RTX_FRAME_RELATED_P (insn) = 1;
 
-      /* Ensure nothing is scheduled until after the frame is established.  */
-      emit_insn (gen_blockage ());
+      /* Ensure no memory access is done before the frame is established.  */
+      emit_insn (gen_frame_blockage ());
 
       if (frame_pointer_needed)
 	{
@@ -6326,6 +6323,9 @@ sparc_expand_epilogue (bool for_eh)
     ; /* do nothing.  */
   else if (sparc_leaf_function_p)
     {
+      /* Ensure no memory access is done after the frame is destroyed.  */
+      emit_insn (gen_frame_blockage ());
+
       if (size <= 4096)
 	emit_insn (gen_stack_pointer_inc (GEN_INT (size)));
       else if (size <= 8192)
@@ -6376,15 +6376,15 @@ sparc_flat_expand_epilogue (bool for_eh)
     ; /* do nothing.  */
   else if (frame_pointer_needed)
     {
-      /* Make sure the frame is destroyed after everything else is done.  */
-      emit_insn (gen_blockage ());
+      /* Ensure no memory access is done after the frame is destroyed.  */
+      emit_insn (gen_frame_blockage ());
 
       emit_move_insn (stack_pointer_rtx, gen_rtx_REG (Pmode, 1));
     }
   else
     {
       /* Likewise.  */
-      emit_insn (gen_blockage ());
+      emit_insn (gen_frame_blockage ());
 
       if (size <= 4096)
 	emit_insn (gen_stack_pointer_inc (GEN_INT (size)));
@@ -8956,8 +8956,20 @@ epilogue_renumber (rtx *where, int test)
       if (REGNO (*where) >= 8 && REGNO (*where) < 24)      /* oX or lX */
 	return 1;
       if (! test && REGNO (*where) >= 24 && REGNO (*where) < 32)
-	*where = gen_rtx_REG (GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));
-      /* fallthrough */
+	{
+	  if (ORIGINAL_REGNO (*where))
+	    {
+	      rtx n = gen_raw_REG (GET_MODE (*where),
+				   OUTGOING_REGNO (REGNO (*where)));
+	      ORIGINAL_REGNO (n) = ORIGINAL_REGNO (*where);
+	      *where = n;
+	    }
+	  else
+	    *where = gen_rtx_REG (GET_MODE (*where),
+				  OUTGOING_REGNO (REGNO (*where)));
+	}
+      return 0;
+
     case SCRATCH:
     case CC0:
     case PC:
@@ -13074,9 +13086,9 @@ sparc_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,
   if (!TARGET_VIS2)
     return false;
 
-  /* All permutes are supported.  */
+  /* All 8-byte permutes are supported.  */
   if (!target)
-    return true;
+    return GET_MODE_SIZE (vmode) == 8;
 
   /* Force target-independent code to convert constant permutations on other
      modes down to V8QI.  Rely on this to avoid the complexity of the byte
@@ -13693,18 +13705,16 @@ sparc_expand_conditional_move (machine_mode mode, rtx *operands)
 void
 sparc_expand_vcond (machine_mode mode, rtx *operands, int ccode, int fcode)
 {
+  enum rtx_code code = signed_condition (GET_CODE (operands[3]));
   rtx mask, cop0, cop1, fcmp, cmask, bshuf, gsr;
-  enum rtx_code code = GET_CODE (operands[3]);
 
   mask = gen_reg_rtx (Pmode);
   cop0 = operands[4];
   cop1 = operands[5];
   if (code == LT || code == GE)
     {
-      rtx t;
-
       code = swap_condition (code);
-      t = cop0; cop0 = cop1; cop1 = t;
+      std::swap (cop0, cop1);
     }
 
   gsr = gen_rtx_REG (DImode, SPARC_GSR_REG);
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 5ea5a8f1b98..e2ff304bc73 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -9033,6 +9033,50 @@ visl")
   DONE;
 })
 
+(define_expand "vcondv8qiv8qi"
+  [(match_operand:V8QI 0 "register_operand" "")
+   (match_operand:V8QI 1 "register_operand" "")
+   (match_operand:V8QI 2 "register_operand" "")
+   (match_operator 3 ""
+     [(match_operand:V8QI 4 "register_operand" "")
+      (match_operand:V8QI 5 "register_operand" "")])]
+  "TARGET_VIS4"
+{
+  sparc_expand_vcond (V8QImode, operands, UNSPEC_CMASK8, UNSPEC_FCMP);
+  DONE;
+})
+
+(define_insn "fucmp<gcond:code>8<P:mode>_vis"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(unspec:P [(gcond:V8QI (match_operand:V8QI 1 "register_operand" "e")
+		               (match_operand:V8QI 2 "register_operand" "e"))]
+	 UNSPEC_FUCMP))]
+  "TARGET_VIS3"
+  "fucmp<gcond:code>8\t%1, %2, %0"
+  [(set_attr "type" "viscmp")])
+
+(define_insn "fpcmpu<gcond:code><GCM:gcm_name><P:mode>_vis"
+  [(set (match_operand:P 0 "register_operand" "=r")
+	(unspec:P [(gcond:GCM (match_operand:GCM 1 "register_operand" "e")
+		              (match_operand:GCM 2 "register_operand" "e"))]
+	 UNSPEC_FUCMP))]
+  "TARGET_VIS4"
+  "fpcmpu<gcond:code><GCM:gcm_name>\t%1, %2, %0"
+  [(set_attr "type" "viscmp")])
+
+(define_expand "vcondu<GCM:mode><GCM:mode>"
+  [(match_operand:GCM 0 "register_operand" "")
+   (match_operand:GCM 1 "register_operand" "")
+   (match_operand:GCM 2 "register_operand" "")
+   (match_operator 3 ""
+     [(match_operand:GCM 4 "register_operand" "")
+      (match_operand:GCM 5 "register_operand" "")])]
+  "TARGET_VIS4"
+{
+  sparc_expand_vcond (<MODE>mode, operands, UNSPEC_CMASK<gcm_name>, UNSPEC_FUCMP);
+  DONE;
+})
+
 (define_expand "vconduv8qiv8qi"
   [(match_operand:V8QI 0 "register_operand" "")
    (match_operand:V8QI 1 "register_operand" "")
@@ -9351,24 +9395,6 @@ visl")
  [(set_attr "type" "fga")
   (set_attr "subtype" "other")])
 
-(define_insn "fucmp<gcond:code>8<P:mode>_vis"
-  [(set (match_operand:P 0 "register_operand" "=r")
-	(unspec:P [(gcond:V8QI (match_operand:V8QI 1 "register_operand" "e")
-		               (match_operand:V8QI 2 "register_operand" "e"))]
-	 UNSPEC_FUCMP))]
-  "TARGET_VIS3"
-  "fucmp<gcond:code>8\t%1, %2, %0"
-  [(set_attr "type" "viscmp")])
-
-(define_insn "fpcmpu<gcond:code><GCM:gcm_name><P:mode>_vis"
-  [(set (match_operand:P 0 "register_operand" "=r")
-	(unspec:P [(gcond:GCM (match_operand:GCM 1 "register_operand" "e")
-		              (match_operand:GCM 2 "register_operand" "e"))]
-	 UNSPEC_FUCMP))]
-  "TARGET_VIS4"
-  "fpcmpu<gcond:code><GCM:gcm_name>\t%1, %2, %0"
-  [(set_attr "type" "viscmp")])
-
 (define_insn "*naddsf3"
   [(set (match_operand:SF 0 "register_operand" "=f")
         (neg:SF (plus:SF (match_operand:SF 1 "register_operand" "f")
diff --git a/gcc/config/tilepro/gen-mul-tables.cc b/gcc/config/tilepro/gen-mul-tables.cc
index 03c0cfd5a8b..227bf086e8c 100644
--- a/gcc/config/tilepro/gen-mul-tables.cc
+++ b/gcc/config/tilepro/gen-mul-tables.cc
@@ -1190,11 +1190,11 @@ tilegx_emit (long long multiplier, int num_ops)
     long long next_pow10;
 
     while (((j * 10) < abs_multiplier)
-	   && (j < (INTMAX_MAX / 10)))
+	   && (j < (j * 10)))
       j = j * 10;
 
     prev_pow10 = j;
-    next_pow10 = (j > (INTMAX_MAX / 10)) ? 0 : j * 10;
+    next_pow10 = j * 10;
 
     if ((abs_multiplier - prev_pow10 <= 100)
 	|| (next_pow10
diff --git a/gcc/config/xtensa/xtensa.md b/gcc/config/xtensa/xtensa.md
index cdf22f14b94..fabc313197a 100644
--- a/gcc/config/xtensa/xtensa.md
+++ b/gcc/config/xtensa/xtensa.md
@@ -754,11 +754,14 @@
 	 because of offering further optimization opportunities.  */
       if (register_operand (operands[0], DImode))
 	{
-	  rtx first, second;
+	  rtx lowpart, highpart;
 
-	  split_double (operands[1], &first, &second);
-	  emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), first));
-	  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), second));
+	  if (TARGET_BIG_ENDIAN)
+	    split_double (operands[1], &highpart, &lowpart);
+	  else
+	    split_double (operands[1], &lowpart, &highpart);
+	  emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]), lowpart));
+	  emit_insn (gen_movsi (gen_highpart (SImode, operands[0]), highpart));
 	  DONE;
 	}
 
diff --git a/gcc/configure b/gcc/configure
index 7218b0c331a..327c59652e8 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -27016,7 +27016,7 @@ $as_echo "$as_me: WARNING: LTO for $target requires binutils >= 2.20.1, but vers
 	;;
     esac
     case $target_os in
-       darwin2[0-9]* | darwin19*)
+       darwin2* | darwin19*)
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for llvm assembler x86-pad-for-align option" >&5
 $as_echo_n "checking assembler for llvm assembler x86-pad-for-align option... " >&6; }
 if ${gcc_cv_as_mllvm_x86_pad_for_align+:} false; then :
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 49f043ed29b..25a05978be9 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -4772,7 +4772,7 @@ foo:	nop
 	;;
     esac
     case $target_os in
-       darwin2[[0-9]]* | darwin19*)
+       darwin2* | darwin19*)
         gcc_GAS_CHECK_FEATURE([llvm assembler x86-pad-for-align option],
           gcc_cv_as_mllvm_x86_pad_for_align,,
           [-mllvm -x86-pad-for-align=false], [.text],,
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 85c8fdd38cd..0668df8fda6 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,570 @@
+2023-09-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106310
+	* parser.c (cp_parser_template_name): Skip non-member
+	lookup after the template keyword.
+	(cp_parser_lookup_name): Pass down template_keyword_p.
+
+2023-09-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106890
+	PR c++/109666
+	* name-lookup.c (maybe_push_to_top_level)
+	(maybe_pop_from_top_level): Split out...
+	* pt.c (instantiate_body): ...from here.
+	* init.c (maybe_instantiate_nsdmi_init): Use them.
+	* name-lookup.h: Declare them..
+
+2023-08-09  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2023-05-09  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/109761
+	* parser.c (cp_parser_class_specifier): Don't pass a class
+	context to noexcept_override_late_checks.
+	(noexcept_override_late_checks): Remove 'type' parameter
+	and use DECL_CONTEXT of 'fndecl' instead.
+
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2023-03-03  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/108998
+	* pt.c (el_data::skipped_trees): New data member.
+	(extract_locals_r): Push to skipped_trees any unevaluated
+	contexts that we skipped over.
+	(extract_local_specs): For the second walk, start from each
+	tree in skipped_trees.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-15  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/100295
+	PR c++/107579
+	* pt.c (el_data::skip_unevaluated_operands): New data member.
+	(extract_locals_r): If skip_unevaluated_operands is true,
+	don't walk into unevaluated contexts.
+	(extract_local_specs): Walk the pattern twice, first with
+	skip_unevaluated_operands true followed by it set to false.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-11-29  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/107864
+	* decl.c (function_requirements_equivalent_p): Don't check
+	DECL_TEMPLATE_SPECIALIZATION.
+	* pt.c (determine_specialization): Propagate constraints when
+	specializing a function template too.  Simplify by using
+	add_outermost_template_args.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-11-03  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/107179
+	* constraint.cc (tsubst_requires_expr): Make sure we're not
+	deferring access checks.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-03-30  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/100474
+	* constraint.cc (diagnose_trait_expr): Handle all remaining
+	traits appropriately.  Remove default case.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-03-12  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/104527
+	* constraint.cc (normalize_atom): Set
+	ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P appropriately.
+	(get_mapped_args):  Make static, adjust parameters.  Always
+	return a vector whose depth corresponds to the template depth of
+	the context of the atomic constraint expression.  Micro-optimize
+	by passing false as exact to safe_grow_cleared and by collapsing
+	a multi-level depth-one argument vector.
+	(satisfy_atom): Adjust call to get_mapped_args and
+	diagnose_atomic_constraint.
+	(diagnose_atomic_constraint): Replace map parameter with an args
+	parameter.
+	* cp-tree.h (ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P): Define.
+	(get_mapped_args): Remove declaration.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-01-28  Patrick Palka  <ppalka@redhat.com>
+		    Jason Merrill  <jason@redhat.com>
+
+	PR c++/92752
+	* typeck.c (build_ptrmemfunc): Cast a nullptr constant to the
+	unqualified pointer type not the qualified one.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2023-04-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* coroutines.cc (coro_rewrite_function_body): Ensure that added
+	bind expressions have scope blocks.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2023-04-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/101118
+	* coroutines.cc (flatten_await_stmt): Use the current count of
+	promoted temporaries to build a unique name for the frame entries.
+
+2023-05-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106740
+	PR c++/105852
+	* decl.c (duplicate_decls): Change non-templated friend
+	check to an assert.
+	* pt.c	(tsubst_function_decl): Don't set DECL_TEMPLATE_INFO
+	on non-templated friends.
+	(tsubst_friend_function): Adjust.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* Make-lang.in (s-cp-module-version): New target.
+	(cp/module.o): Depend on it.
+	(MODULE_VERSION): Remove variable.
+	(CFLAGS-cp/module.o): For -DMODULE_VERSION= argument just
+	cat s-cp-module-version.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/109164
+	* cp-tree.h (var_needs_tls_wrapper): Declare.
+	* decl2.c (var_needs_tls_wrapper): No longer static.
+	* decl.c (cp_finish_decl): Clear TREE_READONLY on TLS variables
+	for which a TLS wrapper will be needed.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/109096
+	* tree.c (record_has_unique_obj_representations): Ignore unnamed
+	bitfields.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/107558
+	* decl.c (cp_finish_decl): Don't clear TREE_READONLY on
+	automatic non-aggregate variables just because of
+	-fmerge-all-constants.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/108716
+	* cp-gimplify.c (cp_genericize_r) <case USING_STMT>: Set
+	DECL_SOURCE_LOCATION on IMPORTED_DECL to expression location
+	of USING_STMT or input_location.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/108474
+	* cp-gimplify.c (cp_fold_r): Handle structured bindings
+	vars like anon union artificial vars.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/108365
+	* typeck.c (cp_build_binary_op): For integral division or modulo,
+	shorten if type0 is unsigned, or op0 is cast from narrower unsigned
+	integral type or stripped_op1 is INTEGER_CST other than -1.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/108607
+	* constexpr.c (cxx_eval_constant_expression): Handle OMP_*
+	and OACC_* constructs as non-constant.
+	(potential_constant_expression_1): Handle OMP_SCAN.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/53932
+	* cp-gimplify.c (cp_fold_r): During cp_fully_fold_init replace
+	DECL_ANON_UNION_VAR_P VAR_DECLs with their corresponding
+	DECL_VALUE_EXPR.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/108180
+	* pt.c (tsubst_expr): Don't call cp_finish_decl on
+	DECL_OMP_PRIVATIZED_MEMBER vars.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/107065
+	* typeck.c (cp_build_unary_op) <case TRUTH_NOT_EXPR>: If
+	invert_truthvalue_loc returns obvalue_p, wrap it into NON_LVALUE_EXPR.
+	* parser.c (cp_parser_binary_expression): Don't call
+	warn_logical_not_parentheses if current.lhs is a NON_LVALUE_EXPR
+	of a decl with boolean type.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105996
+	* typeck.c (build_ptrmemfunc): Drop 0-offset optimization
+	and location wrappers.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/108975
+	* lambda.c (prune_lambda_captures): Don't bother in a template.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/69410
+	* friend.c (do_friend): Handle namespace as scope argument.
+	* decl.c (grokdeclarator): Pass down in_namespace.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101869
+	* semantics.c (finish_qualified_id_expr): Don't try to build a
+	pointer-to-member if the scope is an enumeration.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105406
+	* coroutines.cc (build_co_await): Handle lvalue 'o'.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/103871
+	PR c++/98056
+	* typeck.c (cp_build_modify_expr): Allow array initialization of
+	DECL_ARTIFICIAL variable.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/108468
+	* pt.c (unify_pack_expansion): Check that TPARMS_PRIMARY_TEMPLATE
+	is non-null.
+
+2023-03-13  Arsen Arsenović  <arsen@aarsen.me>
+
+	PR c++/106188
+	PR c++/106713
+	* coroutines.cc (coro_rewrite_function_body): Ensure we have a
+	BIND_EXPR wrapping the function body.
+
+2023-02-15  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2023-02-15  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/106675
+	* call.c (joust_maybe_elide_copy): Return false for ck_ambig.
+
+2022-12-16  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-10-28  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102780
+	PR c++/108138
+	* constexpr.c (potential_constant_expression_1) <case TRUTH_*_EXPR>:
+	When tf_error isn't set, preemptively check potentiality of the
+	second operand before performing trial evaluation of the first
+	operand.
+	(potential_constant_expression_1): When tf_error is set, first check
+	potentiality quietly and return true if successful, otherwise
+	proceed noisily to give errors.
+
+2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/104066
+	* decl.c (grokdeclarator): Check funcdecl_p before complaining
+	about constinit.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/105774
+	* constexpr.c (cxx_eval_increment_expression): For signed types
+	that promote to int, evaluate PLUS_EXPR or MINUS_EXPR in int type.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* typeck.c (cp_build_modify_expr): Implement
+	P2327R1 - De-deprecating volatile compound operations.  Don't warn
+	for |=, &= or ^= with volatile lhs.
+	* expr.c (mark_use) <case MODIFY_EXPR>: Adjust warning wording,
+	leave out simple.
+
+2022-10-24  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-05-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105725
+	* parser.c (class_decl_loc_t::add): Check CLASS_TYPE_P.
+
+2022-07-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106361
+	* decl.c (move_fn_p): Remove assert.
+
+2022-07-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106024
+	* parser.c (cp_parser_lookup_name): Don't look in dependent lambda.
+
+2022-06-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105925
+	* decl.c (reshape_init_array_1): Set
+	CONSTRUCTOR_IS_DESIGNATED_INIT here.
+	(reshape_init_class): And here.
+
+2022-06-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105852
+	PR c++/105761
+	* decl.c (duplicate_decls): Avoid copying template info
+	from non-templated friend even if newdecl isn't a definition.
+	Correct handling of DECL_UNIQUE_FRIEND_P on templates.
+	* pt.c (non_templated_friend_p): New.
+	* cp-tree.h (non_templated_friend_p): Declare it.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105761
+	* decl.c (duplicate_decls): Don't copy DECL_TEMPLATE_INFO
+	from a hidden friend.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105795
+	* constexpr.c (cxx_eval_bare_aggregate): Always call
+	init_subob_ctx.
+
+2022-05-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102307
+	* decl.c (check_initializer): Use build_cplus_new in case of
+	constexpr failure.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101442
+	* decl.c (cp_finish_decl): Don't pass decl to push_cleanup.
+	* init.c (perform_member_init): Likewise.
+	* semantics.c (push_cleanup): Adjust comment.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101698
+	* pt.c (tsubst_baselink): Also check dependent optype.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65211
+	* pt.c (tsubst_decl) [TYPE_DECL]: Copy TYPE_ALIGN.
+
+2022-05-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-09-27  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102479
+	* pt.c (rewrite_template_parm): Handle single-level tsubst_args.
+	Avoid a tree cycle when assigning the DECL_TEMPLATE_PARMS for a
+	rewritten ttp.
+	(alias_ctad_tweaks): Set current_template_parms accordingly.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102300
+	* parser.c (cp_parser_template_name): Use dependent_scope_p.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102629
+	* pt.c (gen_elem_of_pack_expansion_instantiation): Clear
+	TEMPLATE_TYPE_PARAMETER_PACK on auto.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104646
+	* constexpr.c (maybe_save_constexpr_fundef): Don't do extra
+	checks for defaulted ctors.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82980
+	* lambda.c (type_deducible_expression_p): New.
+	(lambda_capture_field_type): Check it.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105265
+	PR c++/100838
+	* call.c (build_user_type_conversion_1): Drop
+	flag_elide_constructors check.
+	(convert_like_internal): Likewise.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105245
+	PR c++/100111
+	* constexpr.c (cxx_eval_store_expression): Build a CONSTRUCTOR
+	as needed in empty base handling.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104669
+	* decl.c (decls_match): Compare versions even if not recording.
+	(duplicate_decls): Propagate attributes to alias.
+	* decl2.c (find_last_decl): Give up if versioned.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102071
+	* init.c (build_new_1): Include cookie in alignment.  Omit
+	constexpr wrapper from alloc_call.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104142
+	* decl.c (check_initializer): Check TREE_SIDE_EFFECTS.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* lambda.c: Include decl.h.
+	(maybe_add_lambda_conv_op): Temporarily override deprecated_state to
+	DEPRECATED_SUPPRESS.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105386
+	* semantics.c (finish_decltype_type): Pass tf_decltype to
+	instantiate_non_dependent_expr_sfinae.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105289
+	PR c++/86193
+	* pt.c (process_partial_specialization): Downgrade "partial
+	specialization isn't more specialized" diagnostic from permerror
+	to an on-by-default pedwarn.
+	(unify) <case TEMPLATE_PARM_INDEX>: When substituting into the
+	NTTP type a second time, use the original type not the
+	substituted type.
+
+2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90107
+	* parser.c (cp_parser_class_specifier_1): Accept :: after a class
+	definition.
+
+2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105398
+	* pt.c (uses_template_parms): Return false for any NAMESPACE_DECL.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105321
+	* constexpr.c (cxx_eval_logical_expression): Always pass false for lval
+	to cxx_eval_constant_expression.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97296
+	* call.c (direct_reference_binding): strip_top_quals when creating
+	a ck_qual.
+
+2022-04-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2021-12-19  Matthias Kretz  <m.kretz@gsi.de>
+
+	* module.cc (trees_out::get_merge_kind): NAMESPACE_DECLs also
+	cannot have a DECL_TEMPLATE_INFO.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index 155be74efdb..4be5cc6a942 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -59,12 +59,21 @@ CFLAGS-cp/module.o += -DHOST_MACHINE=\"$(host)\" \
 
 # In non-release builds, use a date-related module version.
 ifneq ($(DEVPHASE_c),)
-# Some date's don't grok 'r', if so, simply use today's
-# date (don't bootstrap at midnight).
-MODULE_VERSION := $(shell date -r $(srcdir)/cp/module.cc '+%y%m%d-%H%M' \
-  2>/dev/null || date '+%y%m%d-0000' 2>/dev/null || echo 0)
-
-CFLAGS-cp/module.o += -DMODULE_VERSION='($(subst -,,$(MODULE_VERSION))U)'
+# Some date's don't grok 'r', if so, simply use today's date,
+# but use date from previous stage if bootstrapping to avoid breaking
+# bootstraps across midnight.
+s-cp-module-version: $(srcdir)/cp/module.cc
+	MODULE_VERSION=`if date -r $(srcdir)/cp/module.cc '+%y%m%d%H%MU' \
+			  2>/dev/null; then :; \
+			elif test ../prev-gcc/s-cp-module-version -nt \
+			       $(srcdir)/cp/module.cc; then \
+			  cat ../prev-gcc/s-cp-module-version; \
+			else \
+			  date '+%y%m%d0000U' 2>/dev/null; \
+			fi`; \
+	echo $${MODULE_VERSION} > s-cp-module-version
+cp/module.o: s-cp-module-version
+CFLAGS-cp/module.o += -DMODULE_VERSION='$(shell cat s-cp-module-version)'
 endif
 
 # Create the compiler driver for g++.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 55bb9c45f8c..7c3ce1693e1 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -1683,8 +1683,19 @@ direct_reference_binding (tree type, conversion *conv)
        because the types "int *" and "const int *const" are
        reference-related and we were binding both directly and they
        had the same rank.  To break it up, we add a ck_qual under the
-       ck_ref_bind so that conversion sequence ranking chooses #1.  */
-    conv = build_conv (ck_qual, t, conv);
+       ck_ref_bind so that conversion sequence ranking chooses #1.
+
+       We strip_top_quals here which is also what standard_conversion
+       does.  Failure to do so would confuse comp_cv_qual_signature
+       into thinking that in
+
+	 void f(const int * const &); // #1
+	 void f(const int *); // #2
+	 int *x;
+	 f(x);
+
+       #2 is a better match than #1 even though they're ambiguous (97296).  */
+    conv = build_conv (ck_qual, strip_top_quals (t), conv);
 
   return build_conv (ck_ref_bind, type, conv);
 }
@@ -4117,7 +4128,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,
 	     We represent this in the conversion sequence with an
 	     rvalue conversion, which means a constructor call.  */
 	  if (!TYPE_REF_P (totype)
-	      && (flag_elide_constructors || (flags & LOOKUP_ONLYCONVERTING))
+	      && cxx_dialect < cxx17
+	      && (flags & LOOKUP_ONLYCONVERTING)
 	      && !(convflags & LOOKUP_NO_TEMP_BIND))
 	    cand->second_conv
 	      = build_conv (ck_rvalue, totype, cand->second_conv);
@@ -7804,13 +7816,10 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,
       break;
     };
 
-  tsubst_flags_t sub_complain = complain;
-  if (!flag_elide_constructors)
-    sub_complain &= ~tf_no_cleanup;
   expr = convert_like (next_conversion (convs), expr, fn, argnum,
 		       convs->kind == ck_ref_bind
 		       ? issue_conversion_warnings : false,
-		       c_cast_p, sub_complain);
+		       c_cast_p, complain & ~tf_no_cleanup);
   if (expr == error_mark_node)
     return error_mark_node;
 
@@ -11584,6 +11593,8 @@ joust_maybe_elide_copy (z_candidate *&cand)
   if (!DECL_COPY_CONSTRUCTOR_P (fn) && !DECL_MOVE_CONSTRUCTOR_P (fn))
     return false;
   conversion *conv = cand->convs[0];
+  if (conv->kind == ck_ambig)
+    return false;
   gcc_checking_assert (conv->kind == ck_ref_bind);
   conv = next_conversion (conv);
   if (conv->kind == ck_user && !TYPE_REF_P (conv->type))
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index c13c920ade3..38f684144f0 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -890,7 +890,7 @@ maybe_save_constexpr_fundef (tree fun)
   if (!potential && !DECL_GENERATED_P (fun))
     require_potential_rvalue_constant_expression (massaged);
 
-  if (DECL_CONSTRUCTOR_P (fun)
+  if (DECL_CONSTRUCTOR_P (fun) && !DECL_DEFAULTED_FN (fun)
       && cx_check_missing_mem_inits (DECL_CONTEXT (fun),
 				     massaged, !DECL_GENERATED_P (fun)))
     potential = false;
@@ -4280,19 +4280,18 @@ cxx_eval_bit_cast (const constexpr_ctx *ctx, tree t, bool *non_constant_p,
 static tree
 cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,
                              tree bailout_value, tree continue_value,
-			     bool lval,
-			     bool *non_constant_p, bool *overflow_p)
+			     bool, bool *non_constant_p, bool *overflow_p)
 {
   tree r;
   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),
-					   lval,
-					   non_constant_p, overflow_p);
+					   /*lval*/false, non_constant_p,
+					   overflow_p);
   VERIFY_CONSTANT (lhs);
   if (tree_int_cst_equal (lhs, bailout_value))
     return lhs;
   gcc_assert (tree_int_cst_equal (lhs, continue_value));
   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),
-				    lval, non_constant_p,
+				    /*lval*/false, non_constant_p,
 				    overflow_p);
   VERIFY_CONSTANT (r);
   return r;
@@ -4468,12 +4467,9 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,
       tree orig_value = value;
       /* Like in cxx_eval_store_expression, omit entries for empty fields.  */
       bool no_slot = TREE_CODE (type) == RECORD_TYPE && is_empty_field (index);
-      if (no_slot)
-	new_ctx = *ctx;
-      else
-	init_subob_ctx (ctx, new_ctx, index, value);
+      init_subob_ctx (ctx, new_ctx, index, value);
       int pos_hint = -1;
-      if (new_ctx.ctor != ctx->ctor)
+      if (new_ctx.ctor != ctx->ctor && !no_slot)
 	{
 	  /* If we built a new CONSTRUCTOR, attach it now so that other
 	     initializers can refer to it.  */
@@ -5579,6 +5575,12 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,
     {
       /* See above on initialization of empty bases.  */
       gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);
+      if (!*valp)
+	{
+	  /* But do make sure we have something in *valp.  */
+	  *valp = build_constructor (type, nullptr);
+	  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;
+	}
       return init;
     }
   else
@@ -5672,6 +5674,18 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,
 	offset = fold_build1 (NEGATE_EXPR, TREE_TYPE (offset), offset);
       mod = fold_build2 (POINTER_PLUS_EXPR, type, val, offset);
     }
+  else if (c_promoting_integer_type_p (type)
+	   && !TYPE_UNSIGNED (type)
+	   && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))
+    {
+      offset = fold_convert (integer_type_node, offset);
+      mod = fold_convert (integer_type_node, val);
+      tree t = fold_build2 (inc ? PLUS_EXPR : MINUS_EXPR, integer_type_node,
+			    mod, offset);
+      mod = fold_convert (type, t);
+      if (TREE_OVERFLOW_P (mod) && !TREE_OVERFLOW_P (t))
+	TREE_OVERFLOW (mod) = false;
+    }
   else
     mod = fold_build2 (inc ? PLUS_EXPR : MINUS_EXPR, type, val, offset);
   if (!ptr)
@@ -7158,6 +7172,49 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,
       r = cxx_eval_bit_cast (ctx, t, non_constant_p, overflow_p);
       break;
 
+    case OMP_PARALLEL:
+    case OMP_TASK:
+    case OMP_FOR:
+    case OMP_SIMD:
+    case OMP_DISTRIBUTE:
+    case OMP_TASKLOOP:
+    case OMP_LOOP:
+    case OMP_TEAMS:
+    case OMP_TARGET_DATA:
+    case OMP_TARGET:
+    case OMP_SECTIONS:
+    case OMP_ORDERED:
+    case OMP_CRITICAL:
+    case OMP_SINGLE:
+    case OMP_SCAN:
+    case OMP_SECTION:
+    case OMP_MASTER:
+    case OMP_TASKGROUP:
+    case OMP_TARGET_UPDATE:
+    case OMP_TARGET_ENTER_DATA:
+    case OMP_TARGET_EXIT_DATA:
+    case OMP_ATOMIC:
+    case OMP_ATOMIC_READ:
+    case OMP_ATOMIC_CAPTURE_OLD:
+    case OMP_ATOMIC_CAPTURE_NEW:
+    case OMP_DEPOBJ:
+    case OACC_PARALLEL:
+    case OACC_KERNELS:
+    case OACC_SERIAL:
+    case OACC_DATA:
+    case OACC_HOST_DATA:
+    case OACC_LOOP:
+    case OACC_CACHE:
+    case OACC_DECLARE:
+    case OACC_ENTER_DATA:
+    case OACC_EXIT_DATA:
+    case OACC_UPDATE:
+      if (!ctx->quiet)
+	error_at (EXPR_LOCATION (t),
+		  "statement is not a constant expression");
+      *non_constant_p = true;
+      break;
+
     default:
       if (STATEMENT_CODE_P (TREE_CODE (t)))
 	{
@@ -8575,6 +8632,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
     case OMP_ORDERED:
     case OMP_CRITICAL:
     case OMP_SINGLE:
+    case OMP_SCAN:
     case OMP_SECTION:
     case OMP_MASTER:
     case OMP_TASKGROUP:
@@ -8868,13 +8926,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
       tmp = boolean_false_node;
     truth:
       {
-	tree op = TREE_OPERAND (t, 0);
-	if (!RECUR (op, rval))
+	tree op0 = TREE_OPERAND (t, 0);
+	tree op1 = TREE_OPERAND (t, 1);
+	if (!RECUR (op0, rval))
 	  return false;
+	if (!(flags & tf_error) && RECUR (op1, rval))
+	  /* When quiet, try to avoid expensive trial evaluation by first
+	     checking potentiality of the second operand.  */
+	  return true;
 	if (!processing_template_decl)
-	  op = cxx_eval_outermost_constant_expr (op, true);
-	if (tree_int_cst_equal (op, tmp))
-	  return RECUR (TREE_OPERAND (t, 1), rval);
+	  op0 = cxx_eval_outermost_constant_expr (op0, true);
+	if (tree_int_cst_equal (op0, tmp))
+	  return (flags & tf_error) ? RECUR (op1, rval) : false;
 	else
 	  return true;
       }
@@ -9075,6 +9138,17 @@ bool
 potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,
 				 tsubst_flags_t flags)
 {
+  if (flags & tf_error)
+    {
+      /* Check potentiality quietly first, as that could be performed more
+	 efficiently in some cases (currently only for TRUTH_*_EXPR).  If
+	 that fails, replay the check noisily to give errors.  */
+      flags &= ~tf_error;
+      if (potential_constant_expression_1 (t, want_rval, strict, now, flags))
+	return true;
+      flags |= tf_error;
+    }
+
   tree target = NULL_TREE;
   return potential_constant_expression_1 (t, want_rval, strict, now,
 					  flags, &target);
diff --git a/gcc/cp/constraint.cc b/gcc/cp/constraint.cc
index dea94b5fb27..822bc6261d8 100644
--- a/gcc/cp/constraint.cc
+++ b/gcc/cp/constraint.cc
@@ -788,6 +788,15 @@ normalize_atom (tree t, tree args, norm_info info)
   tree ci = build_tree_list (t, info.context);
 
   tree atom = build1 (ATOMIC_CONSTR, ci, map);
+
+  /* Remember whether the expression of this atomic constraint belongs to
+     a concept definition by inspecting in_decl, which should always be set
+     in this case either by norm_info::update_context (when recursing into a
+     concept-id during normalization) or by normalize_concept_definition
+     (when starting out with a concept-id).  */
+  if (info.in_decl && concept_definition_p (info.in_decl))
+    ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P (atom) = true;
+
   if (!info.generate_diagnostics ())
     {
       /* Cache the ATOMIC_CONSTRs that we return, so that sat_hasher::equal
@@ -2292,6 +2301,9 @@ tsubst_requires_expr (tree t, tree args, sat_info info)
 {
   local_specialization_stack stack (lss_copy);
 
+  /* We need to check access during the substitution.  */
+  deferring_access_check_sentinel acs (dk_no_deferred);
+
   /* A requires-expression is an unevaluated context.  */
   cp_unevaluated u;
 
@@ -2870,33 +2882,37 @@ satisfaction_value (tree t)
     return boolean_true_node;
 }
 
-/* Build a new template argument list with template arguments corresponding
-   to the parameters used in an atomic constraint.  */
+/* Build a new template argument vector corresponding to the parameter
+   mapping of the atomic constraint T, using arguments from ARGS.  */
 
-tree
-get_mapped_args (tree map)
+static tree
+get_mapped_args (tree t, tree args)
 {
+  tree map = ATOMIC_CONSTR_MAP (t);
+
   /* No map, no arguments.  */
   if (!map)
     return NULL_TREE;
 
-  /* Find the mapped parameter with the highest level.  */
-  int count = 0;
-  for (tree p = map; p; p = TREE_CHAIN (p))
-    {
-      int level;
-      int index;
-      template_parm_level_and_index (TREE_VALUE (p), &level, &index);
-      if (level > count)
-        count = level;
-    }
+  /* Determine the depth of the resulting argument vector.  */
+  int depth;
+  if (ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P (t))
+    /* The expression of this atomic constraint comes from a concept definition,
+       whose template depth is always one, so the resulting argument vector
+       will also have depth one.  */
+    depth = 1;
+  else
+    /* Otherwise, the expression of this atomic constraint comes from
+       the context of the constrained entity, whose template depth is that
+       of ARGS.  */
+    depth = TMPL_ARGS_DEPTH (args);
 
   /* Place each argument at its corresponding position in the argument
      list. Note that the list will be sparse (not all arguments supplied),
      but instantiation is guaranteed to only use the parameters in the
      mapping, so null arguments would never be used.  */
-  auto_vec< vec<tree> > lists (count);
-  lists.quick_grow_cleared (count);
+  auto_vec< vec<tree> > lists (depth);
+  lists.quick_grow_cleared (depth);
   for (tree p = map; p; p = TREE_CHAIN (p))
     {
       int level;
@@ -2906,12 +2922,12 @@ get_mapped_args (tree map)
       /* Insert the argument into its corresponding position.  */
       vec<tree> &list = lists[level - 1];
       if (index >= (int)list.length ())
-	list.safe_grow_cleared (index + 1, true);
+	list.safe_grow_cleared (index + 1, /*exact=*/false);
       list[index] = TREE_PURPOSE (p);
     }
 
   /* Build the new argument list.  */
-  tree args = make_tree_vec (lists.length ());
+  args = make_tree_vec (lists.length ());
   for (unsigned i = 0; i != lists.length (); ++i)
     {
       vec<tree> &list = lists[i];
@@ -2923,6 +2939,15 @@ get_mapped_args (tree map)
     }
   SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (args, 0);
 
+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args)
+      && TMPL_ARGS_DEPTH (args) == 1)
+    {
+      /* Get rid of the redundant outer TREE_VEC.  */
+      tree level = TMPL_ARGS_LEVEL (args, 1);
+      ggc_free (args);
+      args = level;
+    }
+
   return args;
 }
 
@@ -2977,7 +3002,7 @@ satisfy_atom (tree t, tree args, sat_info info)
     }
 
   /* Rebuild the argument vector from the parameter mapping.  */
-  args = get_mapped_args (map);
+  args = get_mapped_args (t, args);
 
   /* Apply the parameter mapping (i.e., just substitute).  */
   tree expr = ATOMIC_CONSTR_EXPR (t);
@@ -2999,7 +3024,7 @@ satisfy_atom (tree t, tree args, sat_info info)
   if (!same_type_p (TREE_TYPE (result), boolean_type_node))
     {
       if (info.noisy ())
-	diagnose_atomic_constraint (t, map, result, info);
+	diagnose_atomic_constraint (t, args, result, info);
       return cache.save (inst_cache.save (error_mark_node));
     }
 
@@ -3018,7 +3043,7 @@ satisfy_atom (tree t, tree args, sat_info info)
     }
   result = satisfaction_value (result);
   if (result == boolean_false_node && info.diagnose_unsatisfaction_p ())
-    diagnose_atomic_constraint (t, map, result, info);
+    diagnose_atomic_constraint (t, args, result, info);
 
   return cache.save (inst_cache.save (result));
 }
@@ -3717,16 +3742,56 @@ diagnose_trait_expr (tree expr, tree args)
     case CPTK_IS_UNION:
       inform (loc, "  %qT is not a union", t1);
       break;
-    default:
+    case CPTK_IS_AGGREGATE:
+      inform (loc, "  %qT is not an aggregate", t1);
+      break;
+    case CPTK_IS_TRIVIALLY_COPYABLE:
+      inform (loc, "  %qT is not trivially copyable", t1);
+      break;
+    case CPTK_IS_ASSIGNABLE:
+      inform (loc, "  %qT is not assignable from %qT", t1, t2);
+      break;
+    case CPTK_IS_TRIVIALLY_ASSIGNABLE:
+      inform (loc, "  %qT is not trivially assignable from %qT", t1, t2);
+      break;
+    case CPTK_IS_NOTHROW_ASSIGNABLE:
+      inform (loc, "  %qT is not %<nothrow%> assignable from %qT", t1, t2);
+      break;
+    case CPTK_IS_CONSTRUCTIBLE:
+      if (!t2)
+	inform (loc, "  %qT is not default constructible", t1);
+      else
+	inform (loc, "  %qT is not constructible from %qE", t1, t2);
+      break;
+    case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:
+      if (!t2)
+	inform (loc, "  %qT is not trivially default constructible", t1);
+      else
+	inform (loc, "  %qT is not trivially constructible from %qE", t1, t2);
+      break;
+    case CPTK_IS_NOTHROW_CONSTRUCTIBLE:
+      if (!t2)
+	inform (loc, "  %qT is not %<nothrow%> default constructible", t1);
+      else
+	inform (loc, "  %qT is not %<nothrow%> constructible from %qE", t1, t2);
+      break;
+    case CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS:
+      inform (loc, "  %qT does not have unique object representations", t1);
+      break;
+    case CPTK_BASES:
+    case CPTK_DIRECT_BASES:
+    case CPTK_UNDERLYING_TYPE:
+      /* We shouldn't see these non-expression traits.  */
       gcc_unreachable ();
+    /* We deliberately omit the default case so that when adding a new
+       trait we'll get reminded (by way of a warning) to handle it here.  */
     }
 }
 
-/* Diagnose a substitution failure in the atomic constraint T when applied
-   with the instantiated parameter mapping MAP.  */
+/* Diagnose a substitution failure in the atomic constraint T using ARGS.  */
 
 static void
-diagnose_atomic_constraint (tree t, tree map, tree result, sat_info info)
+diagnose_atomic_constraint (tree t, tree args, tree result, sat_info info)
 {
   /* If the constraint is already ill-formed, we've previously diagnosed
      the reason. We should still say why the constraints aren't satisfied.  */
@@ -3747,7 +3812,6 @@ diagnose_atomic_constraint (tree t, tree map, tree result, sat_info info)
   /* Generate better diagnostics for certain kinds of expressions.  */
   tree expr = ATOMIC_CONSTR_EXPR (t);
   STRIP_ANY_LOCATION_WRAPPER (expr);
-  tree args = get_mapped_args (map);
   switch (TREE_CODE (expr))
     {
     case TRAIT_EXPR:
diff --git a/gcc/cp/coroutines.cc b/gcc/cp/coroutines.cc
index e982cdb89a7..34d9d3e7d61 100644
--- a/gcc/cp/coroutines.cc
+++ b/gcc/cp/coroutines.cc
@@ -1016,9 +1016,13 @@ build_co_await (location_t loc, tree a, suspend_point_kind suspend_kind)
     }
   else
     {
-      e_proxy = get_awaitable_var (suspend_kind, o_type);
+      tree p_type = o_type;
+      if (glvalue_p (o))
+	p_type = cp_build_reference_type (p_type, !lvalue_p (o));
+      e_proxy = get_awaitable_var (suspend_kind, p_type);
       o = cp_build_modify_expr (loc, e_proxy, INIT_EXPR, o,
 				tf_warning_or_error);
+      e_proxy = convert_from_reference (e_proxy);
     }
 
   /* I suppose we could check that this is contextually convertible to bool.  */
@@ -1111,6 +1115,9 @@ build_co_await (location_t loc, tree a, suspend_point_kind suspend_kind)
     }
   TREE_VEC_ELT (awaiter_calls, 2) = awrs_call; /* await_resume().  */
 
+  if (REFERENCE_REF_P (e_proxy))
+    e_proxy = TREE_OPERAND (e_proxy, 0);
+
   tree await_expr = build5_loc (loc, CO_AWAIT_EXPR,
 				TREE_TYPE (TREE_TYPE (awrs_func)),
 				a, e_proxy, o, awaiter_calls,
@@ -2867,7 +2874,7 @@ flatten_await_stmt (var_nest_node *n, hash_set<tree> *promoted,
 	  tree init = t;
 	  temps_used->add (init);
 	  tree var_type = TREE_TYPE (init);
-	  char *buf = xasprintf ("D.%d", DECL_UID (TREE_OPERAND (init, 0)));
+	  char *buf = xasprintf ("T%03u", (unsigned) temps_used->elements ());
 	  tree var = build_lang_decl (VAR_DECL, get_identifier (buf), var_type);
 	  DECL_ARTIFICIAL (var) = true;
 	  free (buf);
@@ -4067,6 +4074,19 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,
       BLOCK_SUPERCONTEXT (replace_blk) = top_block;
       BLOCK_SUBBLOCKS (top_block) = replace_blk;
     }
+  else
+    {
+      /* We are missing a top level BIND_EXPR. We need one to ensure that we
+	 don't shuffle around the coroutine frame and corrupt it.  */
+      tree bind_wrap = build3_loc (fn_start, BIND_EXPR, void_type_node,
+				   NULL, NULL, NULL);
+      BIND_EXPR_BODY (bind_wrap) = fnbody;
+      /* Ensure we have a block to connect up the scopes.  */
+      tree new_blk = make_node (BLOCK);
+      BIND_EXPR_BLOCK (bind_wrap) = new_blk;
+      BLOCK_SUBBLOCKS (top_block) = new_blk;
+      fnbody = bind_wrap;
+    }
 
   /* Wrap the function body in a try {} catch (...) {} block, if exceptions
      are enabled.  */
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
index 4eee9ff6eb6..a1e8ec768e1 100644
--- a/gcc/cp/cp-gimplify.c
+++ b/gcc/cp/cp-gimplify.c
@@ -42,6 +42,14 @@ along with GCC; see the file COPYING3.  If not see
 #include "cgraph.h"
 #include "omp-general.h"
 
+struct cp_fold_data
+{
+  hash_set<tree> pset;
+  bool genericize; // called from cp_fold_function?
+
+  cp_fold_data (bool g): genericize (g) {}
+};
+
 /* Forward declarations.  */
 
 static tree cp_genericize_r (tree *, int *, void *);
@@ -468,8 +476,8 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 				  init, VEC_INIT_EXPR_VALUE_INIT (*expr_p),
 				  from_array,
 				  tf_warning_or_error);
-	hash_set<tree> pset;
-	cp_walk_tree (expr_p, cp_fold_r, &pset, NULL);
+	cp_fold_data data (/*genericize*/true);
+	cp_walk_tree (expr_p, cp_fold_r, &data, NULL);
 	cp_genericize_tree (expr_p, false);
 	copy_if_shared (expr_p);
 	ret = GS_OK;
@@ -875,14 +883,35 @@ struct cp_genericize_data
      GIMPLE-form.  */
 
 static tree
-cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)
+cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data_)
 {
-  tree stmt;
-  enum tree_code code;
+  cp_fold_data *data = (cp_fold_data*)data_;
+  tree stmt = *stmt_p;
+  enum tree_code code = TREE_CODE (stmt);
+
+  switch (code)
+    {
+    case VAR_DECL:
+      /* In initializers replace anon union artificial VAR_DECLs
+	 with their DECL_VALUE_EXPRs, as nothing will do it later.
+	 Ditto for structured bindings.  */
+      if (!data->genericize
+	  && DECL_HAS_VALUE_EXPR_P (stmt)
+	  && (DECL_ANON_UNION_VAR_P (stmt)
+	      || (DECL_DECOMPOSITION_P (stmt) && DECL_DECOMP_BASE (stmt))))
+	{
+	  *stmt_p = stmt = unshare_expr (DECL_VALUE_EXPR (stmt));
+	  break;
+	}
+      break;
+
+    default:
+      break;
+    }
 
   *stmt_p = stmt = cp_fold (*stmt_p);
 
-  if (((hash_set<tree> *) data)->add (stmt))
+  if (data->pset.add (stmt))
     {
       /* Don't walk subtrees of stmts we've already walked once, otherwise
 	 we can have exponential complexity with e.g. lots of nested
@@ -949,8 +978,8 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)
 void
 cp_fold_function (tree fndecl)
 {
-  hash_set<tree> pset;
-  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &pset, NULL);
+  cp_fold_data data (/*genericize*/true);
+  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &data, NULL);
 }
 
 /* Turn SPACESHIP_EXPR EXPR into GENERIC.  */
@@ -1273,6 +1302,8 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)
 		tree using_directive = make_node (IMPORTED_DECL);
 		TREE_TYPE (using_directive) = void_type_node;
 		DECL_CONTEXT (using_directive) = current_function_decl;
+		DECL_SOURCE_LOCATION (using_directive)
+		  = cp_expr_loc_or_input_loc (stmt);
 
 		IMPORTED_DECL_ASSOCIATED_DECL (using_directive) = decl;
 		DECL_CHAIN (using_directive) = BLOCK_VARS (block);
@@ -2218,8 +2249,8 @@ cp_fully_fold_init (tree x)
   if (processing_template_decl)
     return x;
   x = cp_fully_fold (x);
-  hash_set<tree> pset;
-  cp_walk_tree (&x, cp_fold_r, &pset, NULL);
+  cp_fold_data data (/*genericize*/false);
+  cp_walk_tree (&x, cp_fold_r, &data, NULL);
   return x;
 }
 
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index a2d8c1c77b3..8887e946d53 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -466,6 +466,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];
       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)
       OVL_USING_P (in OVERLOAD)
       IMPLICIT_CONV_EXPR_NONTYPE_ARG (in IMPLICIT_CONV_EXPR)
+      ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P (in ATOMIC_CONSTR)
    2: IDENTIFIER_KIND_BIT_2 (in IDENTIFIER_NODE)
       ICS_THIS_FLAG (in _CONV)
       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)
@@ -1635,6 +1636,11 @@ check_constraint_info (tree t)
 #define ATOMIC_CONSTR_MAP_INSTANTIATED_P(NODE) \
   TREE_LANG_FLAG_0 (ATOMIC_CONSTR_CHECK (NODE))
 
+/* Whether the expression for this atomic constraint belongs to a
+   concept definition.  */
+#define ATOMIC_CONSTR_EXPR_FROM_CONCEPT_P(NODE) \
+  TREE_LANG_FLAG_1 (ATOMIC_CONSTR_CHECK (NODE))
+
 /* The expression of an atomic constraint. */
 #define ATOMIC_CONSTR_EXPR(NODE) \
   CONSTR_EXPR (ATOMIC_CONSTR_CHECK (NODE))
@@ -6789,6 +6795,7 @@ extern void copy_linkage			(tree, tree);
 extern tree get_guard				(tree);
 extern tree get_guard_cond			(tree, bool);
 extern tree set_guard				(tree);
+extern bool var_needs_tls_wrapper		(tree);
 extern tree maybe_get_tls_wrapper_call		(tree);
 extern void mark_needed				(tree);
 extern bool decl_needed_p			(tree);
@@ -7242,6 +7249,7 @@ extern bool push_tinst_level_loc                (tree, location_t);
 extern bool push_tinst_level_loc                (tree, tree, location_t);
 extern void pop_tinst_level                     (void);
 extern struct tinst_level *outermost_tinst_level(void);
+extern bool non_templated_friend_p		(tree);
 extern void init_template_processing		(void);
 extern void print_template_statistics		(void);
 bool template_template_parameter_p		(const_tree);
@@ -8137,7 +8145,6 @@ extern tree evaluate_requires_expr		(tree);
 extern tree tsubst_constraint                   (tree, tree, tsubst_flags_t, tree);
 extern tree tsubst_constraint_info              (tree, tree, tsubst_flags_t, tree);
 extern tree tsubst_parameter_mapping		(tree, tree, tsubst_flags_t, tree);
-extern tree get_mapped_args			(tree);
 
 struct processing_constraint_expression_sentinel
 {
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index bffbd004167..712e875edd0 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -944,9 +944,7 @@ static bool
 function_requirements_equivalent_p (tree newfn, tree oldfn)
 {
   /* In the concepts TS, the combined constraints are compared.  */
-  if (cxx_dialect < cxx20
-      && (DECL_TEMPLATE_SPECIALIZATION (newfn)
-	  <= DECL_TEMPLATE_SPECIALIZATION (oldfn)))
+  if (cxx_dialect < cxx20)
     {
       tree ci1 = get_constraints (oldfn);
       tree ci2 = get_constraints (newfn);
@@ -1059,11 +1057,14 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)
       if (types_match
 	  && !DECL_EXTERN_C_P (newdecl)
 	  && !DECL_EXTERN_C_P (olddecl)
-	  && record_versions
-	  && maybe_version_functions (newdecl, olddecl,
-				      (!DECL_FUNCTION_VERSIONED (newdecl)
-				       || !DECL_FUNCTION_VERSIONED (olddecl))))
-	return 0;
+	  && targetm.target_option.function_versions (newdecl, olddecl))
+	{
+	  if (record_versions)
+	    maybe_version_functions (newdecl, olddecl,
+				     (!DECL_FUNCTION_VERSIONED (newdecl)
+				      || !DECL_FUNCTION_VERSIONED (olddecl)));
+	  return 0;
+	}
     }
   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)
     {
@@ -2221,8 +2222,8 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
 	      check_no_redeclaration_friend_default_args
 		(old_result, new_result);
 	    }
-	  if (!DECL_UNIQUE_FRIEND_P (old_result))
-	    DECL_UNIQUE_FRIEND_P (new_result) = false;
+	  if (!DECL_UNIQUE_FRIEND_P (new_result))
+	    DECL_UNIQUE_FRIEND_P (old_result) = false;
 
 	  check_default_args (newdecl);
 
@@ -2523,7 +2524,12 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
       else
 	{
 	  retrofit_lang_decl (newdecl);
-	  DECL_LOCAL_DECL_ALIAS (newdecl) = DECL_LOCAL_DECL_ALIAS (olddecl);
+	  tree alias = DECL_LOCAL_DECL_ALIAS (newdecl)
+	    = DECL_LOCAL_DECL_ALIAS (olddecl);
+	  DECL_ATTRIBUTES (alias)
+	    = (*targetm.merge_decl_attributes) (alias, newdecl);
+	  if (TREE_CODE (newdecl) == FUNCTION_DECL)
+	    merge_attribute_bits (newdecl, alias);
 	}
     }
 
@@ -2581,6 +2587,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)
 		TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))
 		  = TINFO_USED_TEMPLATE_ID (new_template_info);
 	    }
+
+	  /* We don't want to copy template info from a non-templated friend
+	     (PR105761), but these shouldn't have DECL_TEMPLATE_INFO now.  */
+	  gcc_checking_assert (!DECL_TEMPLATE_INFO (olddecl)
+			       || !non_templated_friend_p (olddecl));
 	  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);
 	}
 
@@ -6283,6 +6294,8 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,
       tree elt_init;
       constructor_elt *old_cur = d->cur;
 
+      if (d->cur->index)
+	CONSTRUCTOR_IS_DESIGNATED_INIT (new_init) = true;
       check_array_designated_initializer (d->cur, index);
       elt_init = reshape_init_r (elt_type, d,
 				 /*first_initializer_p=*/NULL_TREE,
@@ -6435,6 +6448,7 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,
 	    }
 	  else if (TREE_CODE (d->cur->index) == IDENTIFIER_NODE)
 	    {
+	      CONSTRUCTOR_IS_DESIGNATED_INIT (new_init) = true;
 	      field = get_class_binding (type, d->cur->index);
 	      direct_desig = true;
 	    }
@@ -7167,12 +7181,19 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)
 	      /* Declared constexpr or constinit, but no suitable initializer;
 		 massage init appropriately so we can pass it into
 		 store_init_value for the error.  */
-	      if (CLASS_TYPE_P (type)
-		  && (!init || TREE_CODE (init) == TREE_LIST))
+	      tree new_init = NULL_TREE;
+	      if (!processing_template_decl
+		  && TREE_CODE (init_code) == CALL_EXPR)
+		new_init = build_cplus_new (type, init_code, tf_none);
+	      else if (CLASS_TYPE_P (type)
+		       && (!init || TREE_CODE (init) == TREE_LIST))
+		new_init = build_functional_cast (input_location, type,
+						  init, tf_none);
+	      if (new_init)
 		{
-		  init = build_functional_cast (input_location, type,
-						init, tf_none);
-		  if (TREE_CODE (init) == TARGET_EXPR)
+		  init = new_init;
+		  if (TREE_CODE (init) == TARGET_EXPR
+		      && !(flags & LOOKUP_ONLYCONVERTING))
 		    TARGET_EXPR_DIRECT_INIT_P (init) = true;
 		}
 	      init_code = NULL_TREE;
@@ -7227,6 +7248,10 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)
   if (init && init != error_mark_node)
     init_code = build2 (INIT_EXPR, type, decl, init);
 
+  if (init_code && !TREE_SIDE_EFFECTS (init_code)
+      && init_code != error_mark_node)
+    init_code = NULL_TREE;
+
   if (init_code)
     {
       /* We might have set these in cp_finish_decl.  */
@@ -8221,8 +8246,10 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
 
       if (var_definition_p
 	  /* With -fmerge-all-constants, gimplify_init_constructor
-	     might add TREE_STATIC to the variable.  */
-	  && (TREE_STATIC (decl) || flag_merge_constants >= 2))
+	     might add TREE_STATIC to aggregate variables.  */
+	  && (TREE_STATIC (decl)
+	      || (flag_merge_constants >= 2
+		  && AGGREGATE_TYPE_P (type))))
 	{
 	  /* If a TREE_READONLY variable needs initialization
 	     at runtime, it is no longer readonly and we need to
@@ -8240,6 +8267,18 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
 	  if (!decl_maybe_constant_destruction (decl, type))
 	    TREE_READONLY (decl) = 0;
 	}
+      else if (VAR_P (decl)
+	       && CP_DECL_THREAD_LOCAL_P (decl)
+	       && (!DECL_EXTERNAL (decl) || flag_extern_tls_init)
+	       && (was_readonly || TREE_READONLY (decl))
+	       && var_needs_tls_wrapper (decl))
+	{
+	  /* TLS variables need dynamic initialization by the TLS wrapper
+	     function, we don't want to hoist accesses to it before the
+	     wrapper.  */
+	  was_readonly = 0;
+	  TREE_READONLY (decl) = 0;
+	}
 
       make_rtl_for_nonlocal_decl (decl, init, asmspec);
 
@@ -8300,7 +8339,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
     {
       unsigned i; tree t;
       FOR_EACH_VEC_ELT (*cleanups, i, t)
-	push_cleanup (decl, t, false);
+	push_cleanup (NULL_TREE, t, false);
       release_tree_vector (cleanups);
     }
 
@@ -12656,7 +12695,7 @@ grokdeclarator (const cp_declarator *declarator,
 			  "an array", name);
 		return error_mark_node;
 	      }
-	    if (constinit_p)
+	    if (constinit_p && funcdecl_p)
 	      {
 		error_at (declspecs->locations[ds_constinit],
 			  "%<constinit%> on function return type is not "
@@ -13862,7 +13901,8 @@ grokdeclarator (const cp_declarator *declarator,
 		      return error_mark_node;
 		  }
 
-		decl = do_friend (ctype, unqualified_id, decl,
+		tree scope = ctype ? ctype : in_namespace;
+		decl = do_friend (scope, unqualified_id, decl,
 				  *attrlist, flags,
 				  funcdef_flag);
 		return decl;
@@ -14663,8 +14703,6 @@ copy_fn_p (const_tree d)
 bool
 move_fn_p (const_tree d)
 {
-  gcc_assert (DECL_FUNCTION_MEMBER_P (d));
-
   if (cxx_dialect == cxx98)
     /* There are no move constructors if we are in C++98 mode.  */
     return false;
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 885c4749989..3ea37e0831f 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -1531,8 +1531,16 @@ find_last_decl (tree decl)
 	  if (TREE_CODE (*iter) == OVERLOAD)
 	    continue;
 
-	  if (decls_match (decl, *iter, /*record_decls=*/false))
-	    return *iter;
+	  tree d = *iter;
+
+	  /* We can't compare versions in the middle of processing the
+	     attribute that has the version.  */
+	  if (TREE_CODE (d) == FUNCTION_DECL
+	      && DECL_FUNCTION_VERSIONED (d))
+	    return NULL_TREE;
+
+	  if (decls_match (decl, d, /*record_decls=*/false))
+	    return d;
 	}
       return NULL_TREE;
     }
@@ -3441,7 +3449,7 @@ var_defined_without_dynamic_init (tree var)
 /* Returns true iff VAR is a variable that needs uses to be
    wrapped for possible dynamic initialization.  */
 
-static bool
+bool
 var_needs_tls_wrapper (tree var)
 {
   return (!error_operand_p (var)
diff --git a/gcc/cp/expr.c b/gcc/cp/expr.c
index d16d1896f2d..6b7ead2adc8 100644
--- a/gcc/cp/expr.c
+++ b/gcc/cp/expr.c
@@ -220,7 +220,7 @@ mark_use (tree expr, bool rvalue_p, bool read_p,
     case MODIFY_EXPR:
 	{
 	  tree lhs = TREE_OPERAND (expr, 0);
-	  /* [expr.ass] "A simple assignment whose left operand is of
+	  /* [expr.ass] "An assignment whose left operand is of
 	     a volatile-qualified type is deprecated unless the assignment
 	     is either a discarded-value expression or appears in an
 	     unevaluated context."  */
@@ -230,7 +230,7 @@ mark_use (tree expr, bool rvalue_p, bool read_p,
 	      && !TREE_THIS_VOLATILE (expr))
 	    {
 	      if (warning_at (location_of (expr), OPT_Wvolatile,
-			      "using value of simple assignment with "
+			      "using value of assignment with "
 			      "%<volatile%>-qualified left operand is "
 			      "deprecated"))
 		/* Make sure not to warn about this assignment again.  */
diff --git a/gcc/cp/friend.c b/gcc/cp/friend.c
index ee73adb1677..e41def3a2ea 100644
--- a/gcc/cp/friend.c
+++ b/gcc/cp/friend.c
@@ -467,19 +467,32 @@ make_friend_class (tree type, tree friend_type, bool complain)
 }
 
 /* Record DECL (a FUNCTION_DECL) as a friend of the
-   CURRENT_CLASS_TYPE.  If DECL is a member function, CTYPE is the
+   CURRENT_CLASS_TYPE.  If DECL is a member function, SCOPE is the
    class of which it is a member, as named in the friend declaration.
+   If the friend declaration was explicitly namespace-qualified, SCOPE
+   is that namespace.
    DECLARATOR is the name of the friend.  FUNCDEF_FLAG is true if the
    friend declaration is a definition of the function.  FLAGS is as
    for grokclass fn.  */
 
 tree
-do_friend (tree ctype, tree declarator, tree decl,
+do_friend (tree scope, tree declarator, tree decl,
 	   tree attrlist, enum overload_flags flags,
 	   bool funcdef_flag)
 {
   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);
-  gcc_assert (!ctype || MAYBE_CLASS_TYPE_P (ctype));
+
+  tree ctype = NULL_TREE;
+  tree in_namespace = NULL_TREE;
+  if (!scope)
+    ;
+  else if (MAYBE_CLASS_TYPE_P (scope))
+    ctype = scope;
+  else
+    {
+      gcc_checking_assert (TREE_CODE (scope) == NAMESPACE_DECL);
+      in_namespace = scope;
+    }
 
   /* Friend functions are unique, until proved otherwise.  */
   DECL_UNIQUE_FRIEND_P (decl) = 1;
@@ -606,7 +619,7 @@ do_friend (tree ctype, tree declarator, tree decl,
 	       parameters.  Instead, we call pushdecl when the class
 	       is instantiated.  */
 	    decl = push_template_decl (decl, /*is_friend=*/true);
-	  else if (current_function_decl)
+	  else if (current_function_decl && !in_namespace)
 	    /* pushdecl will check there's a local decl already.  */
 	    decl = pushdecl (decl, /*hiding=*/true);
 	  else
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index bd27c92324b..08b26ba9a17 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -597,15 +597,9 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)
 	  bool pushed = false;
 	  tree ctx = DECL_CONTEXT (member);
 
-	  processing_template_decl_sentinel ptds (/*reset*/false);
+	  bool push_to_top = maybe_push_to_top_level (member);
 	  if (!currently_open_class (ctx))
 	    {
-	      if (!LOCAL_CLASS_P (ctx))
-		push_to_top_level ();
-	      else
-		/* push_to_top_level would lose the necessary function context,
-		   just reset processing_template_decl.  */
-		processing_template_decl = 0;
 	      push_nested_class (ctx);
 	      push_deferring_access_checks (dk_no_deferred);
 	      pushed = true;
@@ -633,9 +627,8 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)
 	    {
 	      pop_deferring_access_checks ();
 	      pop_nested_class ();
-	      if (!LOCAL_CLASS_P (ctx))
-		pop_from_top_level ();
 	    }
+	  maybe_pop_from_top_level (push_to_top);
 
 	  input_location = sloc;
 	}
@@ -911,7 +904,7 @@ perform_member_init (tree member, tree init)
       init = build2 (INIT_EXPR, type, decl, init);
       finish_expr_stmt (init);
       FOR_EACH_VEC_ELT (*cleanups, i, t)
-	push_cleanup (decl, t, false);
+	push_cleanup (NULL_TREE, t, false);
     }
   else if (type_build_ctor_call (type)
 	   || (init && CLASS_TYPE_P (strip_array_types (type))))
@@ -3079,7 +3072,13 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
 
   tree align_arg = NULL_TREE;
   if (type_has_new_extended_alignment (elt_type))
-    align_arg = build_int_cst (align_type_node, TYPE_ALIGN_UNIT (elt_type));
+    {
+      unsigned align = TYPE_ALIGN_UNIT (elt_type);
+      /* Also consider the alignment of the cookie, if any.  */
+      if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))
+	align = MAX (align, TYPE_ALIGN_UNIT (size_type_node));
+      align_arg = build_int_cst (align_type_node, align);
+    }
 
   alloc_fn = NULL_TREE;
 
@@ -3261,18 +3260,19 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,
 	}
     }
 
+  alloc_expr = alloc_call;
   if (cookie_size)
-    alloc_call = maybe_wrap_new_for_constexpr (alloc_call, type,
+    alloc_expr = maybe_wrap_new_for_constexpr (alloc_call, type,
 					       cookie_size);
 
   /* In the simple case, we can stop now.  */
   pointer_type = build_pointer_type (type);
   if (!cookie_size && !is_initialized)
-    return build_nop (pointer_type, alloc_call);
+    return build_nop (pointer_type, alloc_expr);
 
   /* Store the result of the allocation call in a variable so that we can
      use it more than once.  */
-  alloc_expr = get_target_expr (alloc_call);
+  alloc_expr = get_target_expr (alloc_expr);
   alloc_node = TARGET_EXPR_SLOT (alloc_expr);
 
   /* Strip any COMPOUND_EXPRs from ALLOC_CALL.  */
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
index d8efe91d9fe..bc849beef41 100644
--- a/gcc/cp/lambda.c
+++ b/gcc/cp/lambda.c
@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "toplev.h"
 #include "gimplify.h"
 #include "target.h"
+#include "decl.h"
 
 /* Constructor for a lambda expression.  */
 
@@ -202,6 +203,24 @@ lambda_function (tree lambda)
   return lambda;
 }
 
+/* True if EXPR is an expression whose type can be used directly in lambda
+   capture.  Not to be used for 'auto'.  */
+
+static bool
+type_deducible_expression_p (tree expr)
+{
+  if (!type_dependent_expression_p (expr))
+    return true;
+  if (BRACE_ENCLOSED_INITIALIZER_P (expr)
+      || TREE_CODE (expr) == EXPR_PACK_EXPANSION)
+    return false;
+  tree t = non_reference (TREE_TYPE (expr));
+  if (!t) return false;
+  while (TREE_CODE (t) == POINTER_TYPE)
+    t = TREE_TYPE (t);
+  return currently_open_class (t);
+}
+
 /* Returns the type to use for the FIELD_DECL corresponding to the
    capture of EXPR.  EXPLICIT_INIT_P indicates whether this is a
    C++14 init capture, and BY_REFERENCE_P indicates whether we're
@@ -228,7 +247,7 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,
       else
 	type = do_auto_deduction (type, expr, auto_node);
     }
-  else if (!is_this && type_dependent_expression_p (expr))
+  else if (!is_this && !type_deducible_expression_p (expr))
     {
       type = cxx_make_type (DECLTYPE_TYPE);
       DECLTYPE_TYPE_EXPR (type) = expr;
@@ -1177,9 +1196,13 @@ maybe_add_lambda_conv_op (tree type)
 	}
     }
   else
-    call = build_call_a (callop,
-			 direct_argvec->length (),
-			 direct_argvec->address ());
+    {
+      /* Don't warn on deprecated lambda declarations, unless
+	 the lambda is actually called.  */
+      auto du = make_temp_override (deprecated_state, DEPRECATED_SUPPRESS);
+      call = build_call_a (callop, direct_argvec->length (),
+			   direct_argvec->address ());
+    }
 
   CALL_FROM_THUNK_P (call) = 1;
   SET_EXPR_LOCATION (call, UNKNOWN_LOCATION);
@@ -1536,6 +1559,9 @@ prune_lambda_captures (tree body)
   if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lam) == CPLD_NONE)
     /* No default captures, and we don't prune explicit captures.  */
     return;
+  /* Don't bother pruning in a template, we'll prune at instantiation time.  */
+  if (dependent_type_p (TREE_TYPE (lam)))
+    return;
 
   hash_map<tree,tree*> const_vars;
 
diff --git a/gcc/cp/module.cc b/gcc/cp/module.cc
index b97b1bcb2f8..6cb926c044a 100644
--- a/gcc/cp/module.cc
+++ b/gcc/cp/module.cc
@@ -10059,9 +10059,10 @@ trees_out::get_merge_kind (tree decl, depset *dep)
       tree ctx = CP_DECL_CONTEXT (decl);
       if (TREE_CODE (ctx) == FUNCTION_DECL)
 	{
-	  /* USING_DECLs cannot have DECL_TEMPLATE_INFO -- this isn't
-	     permitting them to have one.   */
+	  /* USING_DECLs and NAMESPACE_DECLs cannot have DECL_TEMPLATE_INFO --
+	     this isn't permitting them to have one.   */
 	  gcc_checking_assert (TREE_CODE (decl) == USING_DECL
+			       || TREE_CODE (decl) == NAMESPACE_DECL
 			       || !DECL_LANG_SPECIFIC (decl)
 			       || !DECL_TEMPLATE_INFO (decl));
 
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index 2901e048b8d..98b1993e127 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -8520,6 +8520,43 @@ do_pop_from_top_level (void)
   free_saved_scope = s;
 }
 
+/* Like push_to_top_level, but not if D is function-local.  Returns whether we
+   did push to top.  */
+
+bool
+maybe_push_to_top_level (tree d)
+{
+  /* Push if D isn't function-local, or is a lambda function, for which name
+     resolution is already done.  */
+  bool push_to_top
+    = !(current_function_decl
+	&& !LAMBDA_FUNCTION_P (d)
+	&& decl_function_context (d) == current_function_decl);
+
+  if (push_to_top)
+    push_to_top_level ();
+  else
+    {
+      gcc_assert (!processing_template_decl);
+      push_function_context ();
+      cp_unevaluated_operand = 0;
+      c_inhibit_evaluation_warnings = 0;
+    }
+
+  return push_to_top;
+}
+
+/* Return from whatever maybe_push_to_top_level did.  */
+
+void
+maybe_pop_from_top_level (bool push_to_top)
+{
+  if (push_to_top)
+    pop_from_top_level ();
+  else
+    pop_function_context ();
+}
+
 /* Push into the scope of the namespace NS, even if it is deeply
    nested within another namespace.  */
 
diff --git a/gcc/cp/name-lookup.h b/gcc/cp/name-lookup.h
index c6d0aa96b55..350a9c05cfe 100644
--- a/gcc/cp/name-lookup.h
+++ b/gcc/cp/name-lookup.h
@@ -470,6 +470,8 @@ extern void push_to_top_level (void);
 extern void pop_from_top_level (void);
 extern void maybe_save_operator_binding (tree);
 extern void push_operator_bindings (void);
+extern bool maybe_push_to_top_level (tree);
+extern void maybe_pop_from_top_level (bool);
 extern void push_using_decl_bindings (tree, tree);
 extern void discard_operator_bindings (tree);
 
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 90d119eaa28..8df715596eb 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -249,7 +249,7 @@ static cp_token_cache *cp_token_cache_new
 static tree cp_parser_late_noexcept_specifier
   (cp_parser *, tree);
 static void noexcept_override_late_checks
-  (tree, tree);
+  (tree);
 
 static void cp_parser_initial_pragma
   (cp_token *);
@@ -2610,7 +2610,7 @@ static tree cp_parser_objc_struct_declaration
 /* Utility Routines */
 
 static cp_expr cp_parser_lookup_name
-  (cp_parser *, tree, enum tag_types, bool, bool, bool, tree *, location_t);
+  (cp_parser *, tree, enum tag_types, int, bool, bool, tree *, location_t);
 static tree cp_parser_lookup_name_simple
   (cp_parser *, tree, location_t);
 static tree cp_parser_maybe_treat_template_as_class
@@ -9968,7 +9968,10 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,
 		      || (TREE_CODE (TREE_TYPE (TREE_OPERAND (current.lhs, 0)))
 			  != BOOLEAN_TYPE))))
 	  /* Avoid warning for !!b == y where b is boolean.  */
-	  && (!DECL_P (tree_strip_any_location_wrapper (current.lhs))
+	  && (!(DECL_P (tree_strip_any_location_wrapper (current.lhs))
+		|| (TREE_CODE (current.lhs) == NON_LVALUE_EXPR
+		    && DECL_P (tree_strip_any_location_wrapper
+					    (TREE_OPERAND (current.lhs, 0)))))
 	      || TREE_TYPE (current.lhs) == NULL_TREE
 	      || TREE_CODE (TREE_TYPE (current.lhs)) != BOOLEAN_TYPE))
 	warn_logical_not_parentheses (current.loc, current.tree_type,
@@ -17728,7 +17731,7 @@ cp_parser_template_name (cp_parser* parser,
 			: parser->context->object_type);
 	  if (scope && TYPE_P (scope)
 	      && (!CLASS_TYPE_P (scope)
-		  || (check_dependency_p && dependent_type_p (scope))))
+		  || (check_dependency_p && dependent_scope_p (scope))))
 	    {
 	      /* We're optimizing away the call to cp_parser_lookup_name, but
 		 we still need to do this.  */
@@ -17739,13 +17742,13 @@ cp_parser_template_name (cp_parser* parser,
     }
 
   /* cp_parser_lookup_name clears OBJECT_TYPE.  */
-  const bool scoped_p = ((parser->scope ? parser->scope
-			  : parser->context->object_type) != NULL_TREE);
+  tree scope = (parser->scope ? parser->scope
+		: parser->context->object_type);
 
   /* Look up the name.  */
   decl = cp_parser_lookup_name (parser, identifier,
 				tag_type,
-				/*is_template=*/true,
+				/*is_template=*/1 + template_keyword_p,
 				/*is_namespace=*/false,
 				check_dependency_p,
 				/*ambiguous_decls=*/NULL,
@@ -17753,6 +17756,19 @@ cp_parser_template_name (cp_parser* parser,
 
   decl = strip_using_decl (decl);
 
+  /* 13.3 [temp.names] A < is interpreted as the delimiter of a
+    template-argument-list if it follows a name that is not a
+    conversion-function-id and
+    - that follows the keyword template or a ~ after a nested-name-specifier or
+    in a class member access expression, or
+    - for which name lookup finds the injected-class-name of a class template
+    or finds any declaration of a template, or
+    - that is an unqualified name for which name lookup either finds one or
+    more functions or finds nothing, or
+    - that is a terminal name in a using-declarator (9.9), in a declarator-id
+    (9.3.4), or in a type-only context other than a nested-name-specifier
+    (13.8).  */
+
   /* If DECL is a template, then the name was a template-name.  */
   if (TREE_CODE (decl) == TEMPLATE_DECL)
     {
@@ -17772,11 +17788,7 @@ cp_parser_template_name (cp_parser* parser,
     }
   else
     {
-      /* The standard does not explicitly indicate whether a name that
-	 names a set of overloaded declarations, some of which are
-	 templates, is a template-name.  However, such a name should
-	 be a template-name; otherwise, there is no way to form a
-	 template-id for the overloaded templates.  */
+      /* Look through an overload set for any templates.  */
       bool found = false;
 
       for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (decl));
@@ -17784,16 +17796,14 @@ cp_parser_template_name (cp_parser* parser,
 	if (TREE_CODE (*iter) == TEMPLATE_DECL)
 	  found = true;
 
+      /* "an unqualified name for which name lookup either finds one or more
+	 functions or finds nothing".  */
       if (!found
 	  && (cxx_dialect > cxx17)
-	  && !scoped_p
+	  && !scope
 	  && cp_lexer_next_token_is (parser->lexer, CPP_LESS)
 	  && tag_type == none_type)
 	{
-	  /* [temp.names] says "A name is also considered to refer to a template
-	     if it is an unqualified-id followed by a < and name lookup finds
-	     either one or more functions or finds nothing."  */
-
 	  /* The "more functions" case.  Just use the OVERLOAD as normally.
 	     We don't use is_overloaded_fn here to avoid considering
 	     BASELINKs.  */
@@ -17806,6 +17816,13 @@ cp_parser_template_name (cp_parser* parser,
 	    return identifier;
 	}
 
+      /* "that follows the keyword template"..."in a type-only context" */
+      if (!found && scope
+	  && (template_keyword_p || tag_type != none_type)
+	  && TYPE_P (scope) && dependent_type_p (scope)
+	  && cp_parser_nth_token_starts_template_argument_list_p (parser, 1))
+	return identifier;
+
       if (!found)
 	{
 	  /* The name does not name a template.  */
@@ -24967,6 +24984,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)
       case CPP_OPEN_PAREN:
       case CPP_CLOSE_PAREN:
       case CPP_COMMA:
+      case CPP_SCOPE:
         want_semicolon = false;
         break;
 
@@ -25175,7 +25193,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)
 	  /* The finish_struct call above performed various override checking,
 	     but it skipped unparsed noexcept-specifier operands.  Now that we
 	     have resolved them, check again.  */
-	  noexcept_override_late_checks (type, decl);
+	  noexcept_override_late_checks (decl);
 
 	  /* Remove any member-function parameters from the symbol table.  */
 	  pop_injected_parms ();
@@ -26859,14 +26877,13 @@ cp_parser_late_noexcept_specifier (cp_parser *parser, tree default_arg)
 }
 
 /* Perform late checking of overriding function with respect to their
-   noexcept-specifiers.  TYPE is the class and FNDECL is the function
-   that potentially overrides some virtual function with the same
-   signature.  */
+   noexcept-specifiers.  FNDECL is the member function that potentially
+   overrides some virtual function with the same signature.  */
 
 static void
-noexcept_override_late_checks (tree type, tree fndecl)
+noexcept_override_late_checks (tree fndecl)
 {
-  tree binfo = TYPE_BINFO (type);
+  tree binfo = TYPE_BINFO (DECL_CONTEXT (fndecl));
   tree base_binfo;
 
   if (DECL_STATIC_FUNCTION_P (fndecl))
@@ -29237,7 +29254,7 @@ prefer_type_arg (tag_types tag_type)
    refer to types are ignored.
 
    If IS_TEMPLATE is TRUE, bindings that do not refer to templates are
-   ignored.
+   ignored.  If IS_TEMPLATE IS 2, the 'template' keyword was specified.
 
    If IS_NAMESPACE is TRUE, bindings that do not refer to namespaces
    are ignored.
@@ -29252,7 +29269,7 @@ prefer_type_arg (tag_types tag_type)
 static cp_expr
 cp_parser_lookup_name (cp_parser *parser, tree name,
 		       enum tag_types tag_type,
-		       bool is_template,
+		       int is_template,
 		       bool is_namespace,
 		       bool check_dependency,
 		       tree *ambiguous_decls,
@@ -29419,9 +29436,12 @@ cp_parser_lookup_name (cp_parser *parser, tree name,
     }
   else if (object_type)
     {
+      bool dep = dependent_scope_p (object_type);
+
       /* Look up the name in the scope of the OBJECT_TYPE, unless the
 	 OBJECT_TYPE is not a class.  */
-      if (CLASS_TYPE_P (object_type))
+      if (CLASS_TYPE_P (object_type)
+	  && !(dep && LAMBDA_TYPE_P (object_type)))
 	/* If the OBJECT_TYPE is a template specialization, it may
 	   be instantiated during name lookup.  In that case, errors
 	   may be issued.  Even if we rollback the current tentative
@@ -29434,7 +29454,14 @@ cp_parser_lookup_name (cp_parser *parser, tree name,
       else
 	decl = NULL_TREE;
 
-      if (!decl)
+      /* If we didn't find a member and have dependent bases, the member lookup
+	 is now dependent.  */
+      if (!dep && !decl && any_dependent_bases_p (object_type))
+	dep = true;
+
+      if (dep && is_template == 2)
+	/* The template keyword specifies a dependent template.  */;
+      else if (!decl)
 	/* Look it up in the enclosing context.  DR 141: When looking for a
 	   template-name after -> or ., only consider class templates.  */
 	decl = lookup_name (name, is_namespace ? LOOK_want::NAMESPACE
@@ -32308,7 +32335,8 @@ class_decl_loc_t::add (cp_parser *parser, location_t key_loc,
   bool key_redundant = (!def_p && !decl_p
 			&& (decl == type_decl
 			    || TREE_CODE (decl) == TEMPLATE_DECL
-			    || TYPE_BEING_DEFINED (type)));
+			    || (CLASS_TYPE_P (type)
+				&& TYPE_BEING_DEFINED (type))));
 
   if (key_redundant
       && class_key != class_type
@@ -32346,7 +32374,7 @@ class_decl_loc_t::add (cp_parser *parser, location_t key_loc,
 	}
       else
 	{
-	  /* TYPE was previously defined in some unknown precompiled hdeader.
+	  /* TYPE was previously defined in some unknown precompiled header.
 	     Simply add a record of its definition at an unknown location and
 	     proceed below to add a reference to it at the current location.
 	     (Declarations in precompiled headers that are not definitions
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 318d42d800d..0304eb759e8 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -2524,17 +2524,14 @@ determine_specialization (tree template_id,
     }
 
   /* It was a specialization of a template.  */
-  targs = DECL_TI_ARGS (DECL_TEMPLATE_RESULT (TREE_VALUE (templates)));
-  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (targs))
-    {
-      *targs_out = copy_node (targs);
-      SET_TMPL_ARGS_LEVEL (*targs_out,
-			   TMPL_ARGS_DEPTH (*targs_out),
-			   TREE_PURPOSE (templates));
-    }
-  else
-    *targs_out = TREE_PURPOSE (templates);
-  return TREE_VALUE (templates);
+  tree tmpl = TREE_VALUE (templates);
+  *targs_out = add_outermost_template_args (tmpl, TREE_PURPOSE (templates));
+
+  /* Propagate the template's constraints to the declaration.  */
+  if (tsk != tsk_template)
+    set_constraints (decl, get_constraints (tmpl));
+
+  return tmpl;
 }
 
 /* Returns a chain of parameter types, exactly like the SPEC_TYPES,
@@ -5200,8 +5197,9 @@ process_partial_specialization (tree decl)
 	   && !get_partial_spec_bindings (maintmpl, maintmpl, specargs))
     {
       auto_diagnostic_group d;
-      if (permerror (input_location, "partial specialization %qD is not "
-		     "more specialized than", decl))
+      if (pedwarn (input_location, 0,
+		   "partial specialization %qD is not more specialized than",
+		   decl))
 	inform (DECL_SOURCE_LOCATION (maintmpl), "primary template %qD",
 		maintmpl);
     }
@@ -10889,7 +10887,7 @@ uses_template_parms (tree t)
 		   || uses_template_parms (TREE_CHAIN (t)));
   else if (TREE_CODE (t) == TYPE_DECL)
     dependent_p = dependent_type_p (TREE_TYPE (t));
-  else if (t == error_mark_node)
+  else if (t == error_mark_node || TREE_CODE (t) == NAMESPACE_DECL)
     dependent_p = false;
   else
     dependent_p = instantiation_dependent_expression_p (t);
@@ -11136,6 +11134,33 @@ outermost_tinst_level (void)
   return level;
 }
 
+/* True iff T is a friend function declaration that is not itself a template
+   and is not defined in a class template.  */
+
+bool
+non_templated_friend_p (tree t)
+{
+  if (t && TREE_CODE (t) == FUNCTION_DECL
+      && DECL_UNIQUE_FRIEND_P (t))
+    {
+      tree ti = DECL_TEMPLATE_INFO (t);
+      if (!ti)
+	return true;
+      /* DECL_FRIEND_CONTEXT is set for a friend defined in class.  */
+      if (DECL_FRIEND_CONTEXT (t))
+	return false;
+      /* Non-templated friends in a class template are still represented with a
+	 TEMPLATE_DECL; check that its primary template is the befriending
+	 class.  Note that DECL_PRIMARY_TEMPLATE is null for
+	 template <class T> friend A<T>::f(); */
+      tree tmpl = TI_TEMPLATE (ti);
+      tree primary = DECL_PRIMARY_TEMPLATE (tmpl);
+      return (primary && primary != tmpl);
+    }
+  else
+    return false;
+}
+
 /* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the
    vector of template arguments, as for tsubst.
 
@@ -11236,9 +11261,10 @@ tsubst_friend_function (tree decl, tree args)
       tree new_friend_template_info = DECL_TEMPLATE_INFO (new_friend);
       tree new_friend_result_template_info = NULL_TREE;
       bool new_friend_is_defn =
-	(DECL_INITIAL (DECL_TEMPLATE_RESULT
-		       (template_for_substitution (new_friend)))
-	 != NULL_TREE);
+	(new_friend_template_info
+	 && (DECL_INITIAL (DECL_TEMPLATE_RESULT
+			   (template_for_substitution (new_friend)))
+	     != NULL_TREE));
       tree not_tmpl = new_friend;
 
       if (TREE_CODE (new_friend) == TEMPLATE_DECL)
@@ -12641,7 +12667,13 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,
     t = tsubst_expr (pattern, args, complain, in_decl,
 		     /*integral_constant_expression_p=*/false);
   else
-    t = tsubst (pattern, args, complain, in_decl);
+    {
+      t = tsubst (pattern, args, complain, in_decl);
+      if (is_auto (t) && !ith_elem_is_expansion)
+	/* When expanding the fake auto... pack expansion from add_capture, we
+	   need to mark that the expansion is no longer a pack.  */
+	TEMPLATE_TYPE_PARAMETER_PACK (t) = false;
+    }
 
   /*  If the Ith argument pack element is a pack expansion, then
       the Ith element resulting from the substituting is going to
@@ -12893,17 +12925,29 @@ public:
   /* List of local_specializations used within the pattern.  */
   tree extra;
   tsubst_flags_t complain;
+  /* True iff we don't want to walk into unevaluated contexts.  */
+  bool skip_unevaluated_operands = false;
+  /* The unevaluated contexts that we avoided walking.  */
+  auto_vec<tree> skipped_trees;
 
   el_data (tsubst_flags_t c)
     : extra (NULL_TREE), complain (c) {}
 };
 static tree
-extract_locals_r (tree *tp, int */*walk_subtrees*/, void *data_)
+extract_locals_r (tree *tp, int *walk_subtrees, void *data_)
 {
   el_data &data = *reinterpret_cast<el_data*>(data_);
   tree *extra = &data.extra;
   tsubst_flags_t complain = data.complain;
 
+  if (data.skip_unevaluated_operands
+      && unevaluated_p (TREE_CODE (*tp)))
+    {
+      data.skipped_trees.safe_push (*tp);
+      *walk_subtrees = 0;
+      return NULL_TREE;
+    }
+
   if (TYPE_P (*tp) && typedef_variant_p (*tp))
     /* Remember local typedefs (85214).  */
     tp = &TYPE_NAME (*tp);
@@ -12995,7 +13039,20 @@ static tree
 extract_local_specs (tree pattern, tsubst_flags_t complain)
 {
   el_data data (complain);
+  /* Walk the pattern twice, ignoring unevaluated operands the first time
+     around, so that if a local specialization appears in both an evaluated
+     and unevaluated context we prefer to process it in the evaluated context
+     (since e.g. process_outer_var_ref is a no-op inside an unevaluated
+     context).  */
+  data.skip_unevaluated_operands = true;
   cp_walk_tree (&pattern, extract_locals_r, &data, &data.visited);
+  /* Now walk the unevaluated contexts we skipped the first time around.  */
+  data.skip_unevaluated_operands = false;
+  for (tree t : data.skipped_trees)
+    {
+      data.visited.remove (t);
+      cp_walk_tree (&t, extract_locals_r, &data, &data.visited);
+    }
   return data.extra;
 }
 
@@ -14037,6 +14094,10 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
 	  && !LAMBDA_FUNCTION_P (t))
 	return t;
 
+      /* A non-templated friend doesn't get DECL_TEMPLATE_INFO.  */
+      if (non_templated_friend_p (t))
+	goto friend_case;
+
       /* Calculate the most general template of which R is a
 	 specialization.  */
       gen_tmpl = most_general_template (DECL_TI_TEMPLATE (t));
@@ -14072,7 +14133,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
       /* This special case arises when we have something like this:
 
 	 template <class T> struct S {
-	 friend void f<int>(int, double);
+	   friend void f<int>(int, double);
 	 };
 
 	 Here, the DECL_TI_TEMPLATE for the friend declaration
@@ -14080,6 +14141,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
 	 tsubst_friend_function, and we want only to create a
 	 new decl (R) with appropriate types so that we can call
 	 determine_specialization.  */
+    friend_case:
       gen_tmpl = NULL_TREE;
       argvec = NULL_TREE;
     }
@@ -14269,7 +14331,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,
       /* If this is an instantiation of a member template, clone it.
 	 If it isn't, that'll be handled by
 	 clone_constructors_and_destructors.  */
-      if (PRIMARY_TEMPLATE_P (gen_tmpl))
+      if (gen_tmpl && PRIMARY_TEMPLATE_P (gen_tmpl))
 	clone_cdtor (r, /*update_methods=*/false);
     }
   else if ((complain & tf_error) != 0
@@ -15110,6 +15172,12 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	  {
 	    DECL_ORIGINAL_TYPE (r) = NULL_TREE;
 	    set_underlying_type (r);
+
+	    /* common_handle_aligned_attribute doesn't apply the alignment
+	       to DECL_ORIGINAL_TYPE.  */
+	    if (TYPE_USER_ALIGN (TREE_TYPE (t)))
+	      TREE_TYPE (r) = build_aligned_type (TREE_TYPE (r),
+						  TYPE_ALIGN (TREE_TYPE (t)));
 	  }
 
 	layout_decl (r, 0);
@@ -16404,7 +16472,8 @@ tsubst_baselink (tree baselink, tree object_type,
 
   tree binfo_type = BINFO_TYPE (BASELINK_BINFO (baselink));
   binfo_type = tsubst (binfo_type, args, complain, in_decl);
-  bool dependent_p = binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink));
+  bool dependent_p = (binfo_type != BINFO_TYPE (BASELINK_BINFO (baselink))
+		      || optype != BASELINK_OPTYPE (baselink));
 
   if (dependent_p)
     {
@@ -18507,6 +18576,11 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,
 		    tree asmspec_tree = NULL_TREE;
 		    maybe_push_decl (decl);
 
+		    if (VAR_P (decl)
+			&& DECL_LANG_SPECIFIC (decl)
+			&& DECL_OMP_PRIVATIZED_MEMBER (decl))
+		      break;
+
 		    if (VAR_P (decl)
 			&& DECL_DECOMPOSITION_P (decl)
 			&& TREE_TYPE (pattern_decl) != error_mark_node)
@@ -23410,6 +23484,8 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,
 	     arguments if it is not otherwise deduced.  */
 	  if (cxx_dialect >= cxx20
 	      && TREE_VEC_LENGTH (new_args) < TREE_VEC_LENGTH (old_args)
+	      /* FIXME This isn't set properly for partial instantiations.  */
+	      && TPARMS_PRIMARY_TEMPLATE (tparms)
 	      && builtin_guide_p (TPARMS_PRIMARY_TEMPLATE (tparms)))
 	    TREE_VEC_LENGTH (old_args) = TREE_VEC_LENGTH (new_args);
 	  if (!comp_template_args (old_args, new_args,
@@ -23928,7 +24004,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,
 	      /* Now check whether the type of this parameter is still
 		 dependent, and give up if so.  */
 	      ++processing_template_decl;
-	      tparm = tsubst (tparm, targs, tf_none, NULL_TREE);
+	      tparm = tsubst (TREE_TYPE (parm), targs, tf_none, NULL_TREE);
 	      --processing_template_decl;
 	      if (uses_template_parms (tparm))
 		return unify_success (explain_p);
@@ -25930,20 +26006,7 @@ instantiate_body (tree pattern, tree args, tree d, bool nested_p)
   if (current_function_decl)
     save_omp_privatization_clauses (omp_privatization_save);
 
-  bool push_to_top
-    = !(current_function_decl
-	&& !LAMBDA_FUNCTION_P (d)
-	&& decl_function_context (d) == current_function_decl);
-
-  if (push_to_top)
-    push_to_top_level ();
-  else
-    {
-      gcc_assert (!processing_template_decl);
-      push_function_context ();
-      cp_unevaluated_operand = 0;
-      c_inhibit_evaluation_warnings = 0;
-    }
+  bool push_to_top = maybe_push_to_top_level (d);
 
   if (VAR_P (d))
     {
@@ -26056,10 +26119,7 @@ instantiate_body (tree pattern, tree args, tree d, bool nested_p)
   if (!nested_p)
     TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (d)) = 0;
 
-  if (push_to_top)
-    pop_from_top_level ();
-  else
-    pop_function_context ();
+  maybe_pop_from_top_level (push_to_top);
 
   if (current_function_decl)
     restore_omp_privatization_clauses (omp_privatization_save);
@@ -28726,7 +28786,7 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,
 	  const int depth = TMPL_ARGS_DEPTH (tsubst_args);
 	  tree ttargs = make_tree_vec (depth + 1);
 	  for (int i = 0; i < depth; ++i)
-	    TREE_VEC_ELT (ttargs, i) = TREE_VEC_ELT (tsubst_args, i);
+	    TREE_VEC_ELT (ttargs, i) = TMPL_ARGS_LEVEL (tsubst_args, i + 1);
 	  TREE_VEC_ELT (ttargs, depth)
 	    = template_parms_level_to_args (ttparms);
 	  // Substitute ttargs into ttparms to fix references to
@@ -28739,8 +28799,17 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,
 	  ttparms = tsubst_template_parms_level (ttparms, ttargs,
 						 complain);
 	  // Finally, tack the adjusted parms onto tparms.
-	  ttparms = tree_cons (size_int (depth), ttparms,
-			       current_template_parms);
+	  ttparms = tree_cons (size_int (level + 1), ttparms,
+			       copy_node (current_template_parms));
+	  // As with all template template parms, the parameter list captured
+	  // by this template template parm that corresponds to its own level
+	  // should be empty.  This avoids infinite recursion when structurally
+	  // comparing two such rewritten template template parms (PR102479).
+	  gcc_assert (!TREE_VEC_LENGTH
+		      (TREE_VALUE (TREE_CHAIN (DECL_TEMPLATE_PARMS (olddecl)))));
+	  gcc_assert (TMPL_PARMS_DEPTH (TREE_CHAIN (ttparms)) == level);
+	  TREE_VALUE (TREE_CHAIN (ttparms)) = make_tree_vec (0);
+	  // All done.
 	  DECL_TEMPLATE_PARMS (newdecl) = ttparms;
 	}
     }
@@ -29238,6 +29307,11 @@ alias_ctad_tweaks (tree tmpl, tree uguides)
 	      ++ndlen;
 	  tree gtparms = make_tree_vec (natparms + ndlen);
 
+	  /* Set current_template_parms as in build_deduction_guide.  */
+	  auto ctp = make_temp_override (current_template_parms);
+	  current_template_parms = copy_node (DECL_TEMPLATE_PARMS (tmpl));
+	  TREE_VALUE (current_template_parms) = gtparms;
+
 	  /* First copy over the parms of A.  */
 	  for (j = 0; j < natparms; ++j)
 	    TREE_VEC_ELT (gtparms, j) = TREE_VEC_ELT (atparms, j);
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index d447ce80174..385e108a1c8 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -655,7 +655,8 @@ do_pushlevel (scope_kind sk)
 
 /* Queue a cleanup.  CLEANUP is an expression/statement to be executed
    when the current scope is exited.  EH_ONLY is true when this is not
-   meant to apply to normal control flow transfer.  */
+   meant to apply to normal control flow transfer.  DECL is the VAR_DECL
+   being cleaned up, if any, or null for temporaries or subobjects.  */
 
 void
 push_cleanup (tree decl, tree cleanup, bool eh_only)
@@ -2301,7 +2302,8 @@ finish_qualified_id_expr (tree qualifying_class,
 
   /* If EXPR occurs as the operand of '&', use special handling that
      permits a pointer-to-member.  */
-  if (address_p && done)
+  if (address_p && done
+      && TREE_CODE (qualifying_class) != ENUMERAL_TYPE)
     {
       if (TREE_CODE (expr) == SCOPE_REF)
 	expr = TREE_OPERAND (expr, 1);
@@ -10220,7 +10222,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,
     }
   else if (processing_template_decl)
     {
-      expr = instantiate_non_dependent_expr_sfinae (expr, complain);
+      expr = instantiate_non_dependent_expr_sfinae (expr, complain|tf_decltype);
       if (expr == error_mark_node)
 	return error_mark_node;
     }
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index b499f38be15..e414d8cfd18 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -4641,7 +4641,7 @@ record_has_unique_obj_representations (const_tree t, const_tree sz)
 						    DECL_SIZE (field)))
 	  return false;
       }
-    else if (DECL_C_BIT_FIELD (field))
+    else if (DECL_C_BIT_FIELD (field) && !DECL_UNNAMED_BIT_FIELD (field))
       {
 	tree btype = DECL_BIT_FIELD_TYPE (field);
 	if (!type_has_unique_obj_representations (btype))
@@ -4652,7 +4652,7 @@ record_has_unique_obj_representations (const_tree t, const_tree sz)
 
   offset_int cur = 0;
   for (tree field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))
-    if (TREE_CODE (field) == FIELD_DECL)
+    if (TREE_CODE (field) == FIELD_DECL && !DECL_UNNAMED_BIT_FIELD (field))
       {
 	offset_int fld = wi::to_offset (DECL_FIELD_OFFSET (field));
 	offset_int bitpos = wi::to_offset (DECL_FIELD_BIT_OFFSET (field));
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 93ad497d531..6e5a35202c7 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -4926,7 +4926,12 @@ cp_build_binary_op (const op_location_t &location,
 		 it was unsigned.  */
 	      tree stripped_op1 = tree_strip_any_location_wrapper (op1);
 	      shorten = ((TREE_CODE (op0) == NOP_EXPR
-			  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))
+			  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0,
+								       0)))
+			  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0)))
+			  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0,
+								       0)))
+			      < TYPE_PRECISION (type0)))
 			 || (TREE_CODE (stripped_op1) == INTEGER_CST
 			     && ! integer_all_onesp (stripped_op1)));
 	    }
@@ -4962,7 +4967,10 @@ cp_build_binary_op (const op_location_t &location,
 	     only if unsigned or if dividing by something we know != -1.  */
 	  tree stripped_op1 = tree_strip_any_location_wrapper (op1);
 	  shorten = ((TREE_CODE (op0) == NOP_EXPR
-		      && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))
+		      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))
+		      && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0)))
+		      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))
+			  < TYPE_PRECISION (type0)))
 		     || (TREE_CODE (stripped_op1) == INTEGER_CST
 			 && ! integer_all_onesp (stripped_op1)));
 	  common = 1;
@@ -6741,9 +6749,13 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,
 				   build_zero_cst (TREE_TYPE (arg)), complain);
       arg = perform_implicit_conversion (boolean_type_node, arg,
 					 complain);
-      val = invert_truthvalue_loc (location, arg);
       if (arg != error_mark_node)
-	return val;
+	{
+	  val = invert_truthvalue_loc (location, arg);
+	  if (obvalue_p (val))
+	    val = non_lvalue_loc (location, val);
+	  return val;
+	}
       errstring = _("in argument to unary !");
       break;
 
@@ -8769,10 +8781,14 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,
 
 	  /* An expression of the form E1 op= E2.  [expr.ass] says:
 	     "Such expressions are deprecated if E1 has volatile-qualified
-	     type."  We warn here rather than in cp_genericize_r because
+	     type and op is not one of the bitwise operators |, &, ^."
+	     We warn here rather than in cp_genericize_r because
 	     for compound assignments we are supposed to warn even if the
 	     assignment is a discarded-value expression.  */
-	  if (TREE_THIS_VOLATILE (lhs) || CP_TYPE_VOLATILE_P (lhstype))
+	  if (modifycode != BIT_AND_EXPR
+	      && modifycode != BIT_IOR_EXPR
+	      && modifycode != BIT_XOR_EXPR
+	      && (TREE_THIS_VOLATILE (lhs) || CP_TYPE_VOLATILE_P (lhstype)))
 	    warning_at (loc, OPT_Wvolatile,
 			"compound assignment with %<volatile%>-qualified left "
 			"operand is deprecated");
@@ -8887,6 +8903,8 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,
 	}
 
       /* Allow array assignment in compiler-generated code.  */
+      else if (DECL_P (lhs) && DECL_ARTIFICIAL (lhs))
+	/* OK, used by coroutines (co-await-initlist1.C).  */;
       else if (!current_function_decl
 	       || !DECL_DEFAULTED_FN (current_function_decl))
 	{
@@ -9208,18 +9226,15 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p,
       if (n == error_mark_node)
 	return error_mark_node;
 
+      STRIP_ANY_LOCATION_WRAPPER (pfn);
+
       /* We don't have to do any conversion to convert a
 	 pointer-to-member to its own type.  But, we don't want to
 	 just return a PTRMEM_CST if there's an explicit cast; that
 	 cast should make the expression an invalid template argument.  */
-      if (TREE_CODE (pfn) != PTRMEM_CST)
-	{
-	  if (same_type_p (to_type, pfn_type))
-	    return pfn;
-	  else if (integer_zerop (n) && TREE_CODE (pfn) != CONSTRUCTOR)
-	    return build_reinterpret_cast (input_location, to_type, pfn, 
-                                           complain);
-	}
+      if (TREE_CODE (pfn) != PTRMEM_CST
+	  && same_type_p (to_type, pfn_type))
+	return pfn;
 
       if (TREE_SIDE_EFFECTS (pfn))
 	pfn = save_expr (pfn);
@@ -9251,7 +9266,9 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p,
   /* Handle null pointer to member function conversions.  */
   if (null_ptr_cst_p (pfn))
     {
-      pfn = cp_build_c_cast (input_location, type, pfn, complain);
+      pfn = cp_build_c_cast (input_location,
+			     TYPE_PTRMEMFUNC_FN_TYPE_RAW (to_type),
+			     pfn, complain);
       return build_ptrmemfunc1 (to_type,
 				integer_zero_node,
 				pfn);
diff --git a/gcc/cse.c b/gcc/cse.c
index df191d5aa3f..2b8292ebd7f 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -1190,14 +1190,14 @@ compute_const_anchors (rtx cst,
 		       HOST_WIDE_INT *lower_base, HOST_WIDE_INT *lower_offs,
 		       HOST_WIDE_INT *upper_base, HOST_WIDE_INT *upper_offs)
 {
-  HOST_WIDE_INT n = INTVAL (cst);
+  unsigned HOST_WIDE_INT n = UINTVAL (cst);
 
   *lower_base = n & ~(targetm.const_anchor - 1);
-  if (*lower_base == n)
+  if ((unsigned HOST_WIDE_INT) *lower_base == n)
     return false;
 
-  *upper_base =
-    (n + (targetm.const_anchor - 1)) & ~(targetm.const_anchor - 1);
+  *upper_base = ((n + (targetm.const_anchor - 1))
+		 & ~(targetm.const_anchor - 1));
   *upper_offs = n - *upper_base;
   *lower_offs = n - *lower_base;
   return true;
@@ -1214,7 +1214,7 @@ insert_const_anchor (HOST_WIDE_INT anchor, rtx reg, HOST_WIDE_INT offs,
   rtx anchor_exp;
   rtx exp;
 
-  anchor_exp = GEN_INT (anchor);
+  anchor_exp = gen_int_mode (anchor, mode);
   hash = HASH (anchor_exp, mode);
   elt = lookup (anchor_exp, hash, mode);
   if (!elt)
diff --git a/gcc/cselib.c b/gcc/cselib.c
index 779874eeb2d..342c3cfdda8 100644
--- a/gcc/cselib.c
+++ b/gcc/cselib.c
@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dumpfile.h"
 #include "cselib.h"
 #include "function-abi.h"
+#include "alias.h"
 
 /* A list of cselib_val structures.  */
 struct elt_list
@@ -1157,6 +1158,75 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)
   return 1;
 }
 
+/* Wrapper for rtx_equal_for_cselib_p to determine whether a SET is
+   truly redundant, taking into account aliasing information.  */
+bool
+cselib_redundant_set_p (rtx set)
+{
+  gcc_assert (GET_CODE (set) == SET);
+  rtx dest = SET_DEST (set);
+  if (cselib_reg_set_mode (dest) != GET_MODE (dest))
+    return false;
+
+  if (!rtx_equal_for_cselib_p (dest, SET_SRC (set)))
+    return false;
+
+  while (GET_CODE (dest) == SUBREG
+	 || GET_CODE (dest) == ZERO_EXTRACT
+	 || GET_CODE (dest) == STRICT_LOW_PART)
+    dest = XEXP (dest, 0);
+
+  if (!flag_strict_aliasing || !MEM_P (dest))
+    return true;
+
+  /* For a store we need to check that suppressing it will not change
+     the effective alias set.  */
+  rtx dest_addr = XEXP (dest, 0);
+
+  /* Lookup the equivalents to the original dest (rather than just the
+     MEM).  */
+  cselib_val *src_val = cselib_lookup (SET_DEST (set),
+				       GET_MODE (SET_DEST (set)),
+				       0, VOIDmode);
+
+  if (src_val)
+    {
+      /* Walk the list of source equivalents to find the MEM accessing
+	 the same location.  */
+      for (elt_loc_list *l = src_val->locs; l; l = l->next)
+	{
+	  rtx src_equiv = l->loc;
+	  while (GET_CODE (src_equiv) == SUBREG
+		 || GET_CODE (src_equiv) == ZERO_EXTRACT
+		 || GET_CODE (src_equiv) == STRICT_LOW_PART)
+	    src_equiv = XEXP (src_equiv, 0);
+
+	  if (MEM_P (src_equiv))
+	    {
+	      /* Match the MEMs by comparing the addresses.  We can
+		 only remove the later store if the earlier aliases at
+		 least all the accesses of the later one.  */
+	      if (rtx_equal_for_cselib_1 (dest_addr, XEXP (src_equiv, 0),
+					  GET_MODE (dest), 0))
+		return mems_same_for_tbaa_p (src_equiv, dest);
+	    }
+	}
+    }
+
+  /* We failed to find a recorded value in the cselib history, so try
+     the source of this set; this catches cases such as *p = *q when p
+     and q have the same value.  */
+  rtx src = SET_SRC (set);
+  while (GET_CODE (src) == SUBREG)
+    src = XEXP (src, 0);
+
+  if (MEM_P (src)
+      && rtx_equal_for_cselib_1 (dest_addr, XEXP (src, 0), GET_MODE (dest), 0))
+    return mems_same_for_tbaa_p (src, dest);
+
+  return false;
+}
+
 /* Helper function for cselib_hash_rtx.  Arguments like for cselib_hash_rtx,
    except that it hashes (plus:P x c).  */
 
diff --git a/gcc/cselib.h b/gcc/cselib.h
index af112fd0985..14478eec238 100644
--- a/gcc/cselib.h
+++ b/gcc/cselib.h
@@ -83,6 +83,7 @@ extern void cselib_process_insn (rtx_insn *);
 extern bool fp_setter_insn (rtx_insn *);
 extern machine_mode cselib_reg_set_mode (const_rtx);
 extern int rtx_equal_for_cselib_1 (rtx, rtx, machine_mode, int);
+extern bool cselib_redundant_set_p (rtx);
 extern int references_value_p (const_rtx, int);
 extern rtx cselib_expand_value_rtx (rtx, bitmap, int);
 typedef rtx (*cselib_expand_callback)(rtx, bitmap, int, void *);
diff --git a/gcc/d/ChangeLog b/gcc/d/ChangeLog
index 6021ffdbf78..091a7fafaf0 100644
--- a/gcc/d/ChangeLog
+++ b/gcc/d/ChangeLog
@@ -1,3 +1,152 @@
+2023-07-07  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-07-07  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108842
+	* decl.cc (DeclVisitor::visit (VarDeclaration *)): Only emit scalar
+	manifest constants.
+	(get_symbol_decl): Don't generate CONST_DECL for non-scalar manifest
+	constants.
+	* imports.cc (ImportVisitor::visit (VarDeclaration *)): New method.
+
+2023-07-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-07-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/110516
+	* intrinsics.cc (expand_volatile_load): Set TREE_SIDE_EFFECTS on the
+	expanded expression.
+	(expand_volatile_store): Likewise.
+
+2023-07-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/110511
+	* dmd/dinterpret.c (Interpreter::visit (CastExp *)): Handle casting
+	null to int or float.
+
+2023-06-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-06-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/110359
+	* d-convert.cc (convert_for_rvalue): Only apply the @safe boolean
+	conversion to boolean fields of a union.
+	(convert_for_condition): Call convert_for_rvalue in the default case.
+
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-03-14  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-03-14  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/109108
+	* decl.cc (get_symbol_decl): Set DECL_LAMBDA_FUNCTION_P on function
+	literals.
+	(start_function): Unconditionally unset DECL_EXTERNAL.
+	(set_linkage_for_decl): Give lambda functions one-only linkage.
+
+2023-03-13  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-03-13  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* decl.cc (finish_thunk): Unset DECL_EXTERNAL on thunk.
+	(make_thunk): Set DECL_EXTERNAL on thunk, don't call build_decl_tree.
+	(finish_function): Call finish_thunk on forward referenced thunks.
+
+2023-03-13  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-03-13  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* decl.cc (get_fndecl_result): New function.
+	(get_fndecl_arguments): New function.
+	(DeclVisitor::visit (FuncDeclaration *)): Adjust to call
+	get_fndecl_arguments.
+	(make_thunk): Adjust to call get_fndecl_arguments and
+	get_fndecl_result.
+	(start_function): Adjust to call get_fndecl_result.
+
+2023-03-03  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-03-03  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108877
+	* imports.cc (ImportVisitor::visit (EnumDeclaration *)): Call
+	make_import on TYPE_MAIN_VARIANT.
+	(ImportVisitor::visit (AggregateDeclaration *)): Likewise.
+	(ImportVisitor::visit (ClassDeclaration *)): Likewise.
+
+2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108050
+	* decl.cc (DeclVisitor::visit (Import *)): Handle build_import_decl
+	returning a TREE_LIST.
+	* imports.cc (ImportVisitor::visit (OverloadSet *)): New override.
+
+2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/107592
+	* toir.cc (IRVisitor::push_unrolled_continue_label): New method.
+	(IRVisitor::pop_unrolled_continue_label): New method.
+	(IRVisitor::visit (UnrolledLoopStatement *)): Use them instead of
+	push_continue_label and pop_continue_label.
+
+2022-08-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-08-16  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106638
+	* gdc.texi: Update DIP links to point at upstream dlang/DIPs
+	repository.
+
+2022-07-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106139
+	* d-convert.cc (convert_expr): Handle casting from array to vector.
+	(convert_for_rvalue): Rewrite vector to array casts of the same
+	element type into a constructor.
+	(convert_for_assignment): Return calling convert_for_rvalue.
+	* dmd/expressionsem.c (ExpressionSemanticVisitor::visit): Run semantic
+	on vector expression after lowering.
+	* expr.cc (ExprVisitor::visit (VectorExp *)): Handle generating a
+	vector expression from a static array.
+	* toir.cc (IRVisitor::visit (ReturnStatement *)): Call
+	convert_for_rvalue on return value.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* typeinfo.cc (make_internal_typeinfo): Set TYPE_ARTIFICIAL.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* d-spec.cc (lang_specific_driver): Set SKIPOPT on -static-libstdc++
+	and -static-libphobos only when target supports LD_STATIC_DYNAMIC.
+	Remove generate_option to re-add -static-libstdc++.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/d/d-convert.cc b/gcc/d/d-convert.cc
index d43485dca77..135aaf7e049 100644
--- a/gcc/d/d-convert.cc
+++ b/gcc/d/d-convert.cc
@@ -502,6 +502,15 @@ convert_expr (tree exp, Type *etype, Type *totype)
 	  gcc_assert (totype->size () == etype->size ());
 	  result = build_vconvert (build_ctype (totype), exp);
 	}
+      else if (tbtype->ty == Tvector && tbtype->size () == ebtype->size ())
+	{
+	  /* Allow casting from array to vector as if its an unaligned load.  */
+	  tree type = build_ctype (totype);
+	  tree unaligned_type = build_variant_type_copy (type);
+	  SET_TYPE_ALIGN (unaligned_type, 1 * BITS_PER_UNIT);
+	  TYPE_USER_ALIGN (unaligned_type) = 1;
+	  result = convert (type, build_vconvert (unaligned_type, exp));
+	}
       else
 	{
 	  error ("cannot cast expression of type %qs to type %qs",
@@ -602,7 +611,7 @@ convert_expr (tree exp, Type *etype, Type *totype)
   return result ? result : convert (build_ctype (totype), exp);
 }
 
-/* Return a TREE represenwation of EXPR, whose type has been converted from
+/* Return a TREE representation of EXPR, whose type has been converted from
  * ETYPE to TOTYPE, and is being used in an rvalue context.  */
 
 tree
@@ -618,24 +627,64 @@ convert_for_rvalue (tree expr, Type *etype, Type *totype)
     case Tbool:
       /* If casting from bool, the result is either 0 or 1, any other value
 	 violates @safe code, so enforce that it is never invalid.  */
-      if (CONSTANT_CLASS_P (expr))
-	result = d_truthvalue_conversion (expr);
-      else
+      for (tree ref = expr; TREE_CODE (ref) == COMPONENT_REF;
+	   ref = TREE_OPERAND (ref, 0))
 	{
-	  /* Reinterpret the boolean as an integer and test the first bit.
-	     The generated code should end up being equivalent to:
+	  /* If the expression is a field that's part of a union, reinterpret
+	     the boolean as an integer and test the first bit.  The generated
+	     code should end up being equivalent to:
 		*cast(ubyte *)&expr & 1;  */
-	  machine_mode bool_mode = TYPE_MODE (TREE_TYPE (expr));
-	  tree mtype = lang_hooks.types.type_for_mode (bool_mode, 1);
-	  result = fold_build2 (BIT_AND_EXPR, mtype,
-				build_vconvert (mtype, expr),
-				build_one_cst (mtype));
+	  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 0))) == UNION_TYPE)
+	    {
+	      machine_mode bool_mode = TYPE_MODE (TREE_TYPE (expr));
+	      tree mtype = lang_hooks.types.type_for_mode (bool_mode, 1);
+	      result = fold_build2 (BIT_AND_EXPR, mtype,
+				    build_vconvert (mtype, expr),
+				    build_one_cst (mtype));
+	      break;
+	    }
 	}
 
+      if (result == NULL_TREE)
+	result = d_truthvalue_conversion (expr);
+
       result = convert (build_ctype (tbtype), result);
       break;
     }
 
+  if (tbtype->ty == Tsarray
+      && ebtype->ty == Tsarray
+      && tbtype->nextOf ()->ty == ebtype->nextOf ()->ty
+      && INDIRECT_REF_P (expr)
+      && CONVERT_EXPR_CODE_P (TREE_CODE (TREE_OPERAND (expr, 0)))
+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (expr, 0), 0)) == ADDR_EXPR)
+    {
+      /* If expression is a vector that was casted to an array either by
+	 explicit type cast or by taking the vector's `.array' value, strip the
+	 reinterpret cast and build a constructor instead.  */
+      tree ptr = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);
+
+      if (VECTOR_TYPE_P (TREE_TYPE (TREE_TYPE (ptr))))
+	{
+	  /* Rewrite: `*(Array *)&vector'
+		into: `{ vector[0], vector[1], ... }'  */
+	  tree array = d_save_expr (TREE_OPERAND (ptr, 0));
+	  array = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (expr), array);
+
+	  uinteger_t dim = tbtype->isTypeSArray ()->dim->toUInteger ();
+	  vec <constructor_elt, va_gc> *elms = NULL;
+	  for (uinteger_t i = 0; i < dim; i++)
+	    {
+	      tree index = size_int (i);
+	      tree value = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (array)),
+				   array, index, NULL_TREE, NULL_TREE);
+	      CONSTRUCTOR_APPEND_ELT (elms, index, value);
+	    }
+
+	  return build_constructor (build_ctype (totype), elms);
+	}
+    }
+
   return result ? result : convert_expr (expr, etype, totype);
 }
 
@@ -696,7 +745,7 @@ convert_for_assignment (tree expr, Type *etype, Type *totype)
       return expr;
     }
 
-  return convert_expr (expr, etype, totype);
+  return convert_for_rvalue (expr, etype, totype);
 }
 
 /* Return a TREE representation of EXPR converted to represent
@@ -796,7 +845,7 @@ convert_for_condition (tree expr, Type *type)
       break;
 
     default:
-      result = expr;
+      result = convert_for_rvalue (expr, type, type);
       break;
     }
 
diff --git a/gcc/d/d-spec.cc b/gcc/d/d-spec.cc
index b12d28f1047..1304126a675 100644
--- a/gcc/d/d-spec.cc
+++ b/gcc/d/d-spec.cc
@@ -253,13 +253,23 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 
 	case OPT_static_libstdc__:
 	  saw_static_libcxx = true;
+#ifdef HAVE_LD_STATIC_DYNAMIC
+	  /* Remove -static-libstdc++ from the command only if target supports
+	     LD_STATIC_DYNAMIC.  When not supported, it is left in so that a
+	     back-end target can use outfile substitution.  */
 	  args[i] |= SKIPOPT;
+#endif
 	  break;
 
 	case OPT_static_libphobos:
 	  if (phobos_library != PHOBOS_NOLINK)
 	    phobos_library = PHOBOS_STATIC;
+#ifdef HAVE_LD_STATIC_DYNAMIC
+	  /* Remove -static-libphobos from the command only if target supports
+	     LD_STATIC_DYNAMIC.  When not supported, it is left in so that a
+	     back-end target can use outfile substitution.  */
 	  args[i] |= SKIPOPT;
+#endif
 	  break;
 
 	case OPT_shared_libphobos:
@@ -460,7 +470,7 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 #endif
     }
 
-  if (saw_libcxx || need_stdcxx)
+  if (saw_libcxx || saw_static_libcxx || need_stdcxx)
     {
 #ifdef HAVE_LD_STATIC_DYNAMIC
       if (saw_static_libcxx && !static_link)
@@ -468,12 +478,6 @@ lang_specific_driver (cl_decoded_option **in_decoded_options,
 	  generate_option (OPT_Wl_, LD_STATIC_OPTION, 1, CL_DRIVER,
 			   &new_decoded_options[j++]);
 	}
-#else
-      /* Push the -static-libstdc++ option back onto the command so that
-	 a target without LD_STATIC_DYNAMIC can use outfile substitution.  */
-      if (saw_static_libcxx && !static_link)
-	generate_option (OPT_static_libstdc__, NULL, 1, CL_DRIVER,
-			 &new_decoded_options[j++]);
 #endif
       if (saw_libcxx)
 	new_decoded_options[j++] = *saw_libcxx;
diff --git a/gcc/d/decl.cc b/gcc/d/decl.cc
index a30549ce8e0..477e8d880d9 100644
--- a/gcc/d/decl.cc
+++ b/gcc/d/decl.cc
@@ -116,6 +116,107 @@ gcc_attribute_p (Dsymbol *decl)
   return false;
 }
 
+/* Return the DECL_RESULT for the function declaration DECL, create it if it
+   doesn't already exist.  */
+
+static tree
+get_fndecl_result (FuncDeclaration *decl)
+{
+  tree fndecl = get_symbol_decl (decl);
+  tree resdecl = DECL_RESULT (fndecl);
+
+  if (resdecl != NULL_TREE)
+    return resdecl;
+
+  resdecl = build_decl (make_location_t (decl->loc), RESULT_DECL,
+			NULL_TREE, TREE_TYPE (TREE_TYPE (fndecl)));
+
+  DECL_ARTIFICIAL (resdecl) = 1;
+  DECL_IGNORED_P (resdecl) = 1;
+  DECL_CONTEXT (resdecl) = fndecl;
+  DECL_RESULT (fndecl) = resdecl;
+  return resdecl;
+}
+
+/* Return the list of PARAM_DECLs for the function declaration DECL, create it
+   if it doesn't already exist.  */
+
+static tree
+get_fndecl_arguments (FuncDeclaration *decl)
+{
+  tree fndecl = get_symbol_decl (decl);
+  tree param_list = DECL_ARGUMENTS (fndecl);
+
+  if (param_list != NULL_TREE)
+    return param_list;
+
+  if (decl->fbody)
+    {
+      /* Handle special arguments first.  */
+
+      /* `this' parameter:
+	 For nested functions, D still generates a vthis, but it
+	 should not be referenced in any expression.  */
+      if (decl->vthis)
+	{
+	  tree parm_decl = get_symbol_decl (decl->vthis);
+	  DECL_ARTIFICIAL (parm_decl) = 1;
+	  TREE_READONLY (parm_decl) = 1;
+
+	  if (decl->vthis->type == Type::tvoidptr)
+	    {
+	      /* Replace generic pointer with back-end closure type
+		 (this wins for gdb).  */
+	      tree frame_type = FRAMEINFO_TYPE (get_frameinfo (decl));
+	      gcc_assert (frame_type != NULL_TREE);
+	      TREE_TYPE (parm_decl) = build_pointer_type (frame_type);
+	    }
+
+	  param_list = chainon (param_list, parm_decl);
+	}
+
+      /* `_arguments' parameter.  */
+      if (decl->v_arguments)
+	{
+	  tree parm_decl = get_symbol_decl (decl->v_arguments);
+	  param_list = chainon (param_list, parm_decl);
+	}
+
+      /* Now add on formal function parameters.  */
+      size_t n_parameters = decl->parameters ? decl->parameters->length : 0;
+
+      for (size_t i = 0; i < n_parameters; i++)
+	{
+	  VarDeclaration *param = (*decl->parameters)[i];
+	  tree parm_decl = get_symbol_decl (param);
+	  /* Chain them in the correct order.  */
+	  param_list = chainon (param_list, parm_decl);
+	}
+    }
+  else
+    {
+      /* Build parameters from the function type.  */
+      tree fntype = TREE_TYPE (fndecl);
+
+      for (tree t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))
+	{
+	  if (t == void_list_node)
+	    break;
+
+	  tree param = build_decl (DECL_SOURCE_LOCATION (fndecl),
+				   PARM_DECL, NULL_TREE, TREE_VALUE (t));
+	  DECL_ARG_TYPE (param) = TREE_TYPE (param);
+	  DECL_ARTIFICIAL (param) = 1;
+	  DECL_IGNORED_P (param) = 1;
+	  DECL_CONTEXT (param) = fndecl;
+	  param_list = chainon (param_list, param);
+	}
+    }
+
+  DECL_ARGUMENTS (fndecl) = param_list;
+  return param_list;
+}
+
 /* Implements the visitor interface to lower all Declaration AST classes
    emitted from the D Front-end to GCC trees.
    All visit methods accept one parameter D, which holds the frontend AST
@@ -197,8 +298,16 @@ public:
 	    tree name = (alias != NULL)
 	      ? get_identifier (alias->toChars ()) : NULL_TREE;
 
-	    debug_hooks->imported_module_or_decl (decl, name, context,
-						  false, false);
+	    if (TREE_CODE (decl) != TREE_LIST)
+	      debug_hooks->imported_module_or_decl (decl, name, context,
+						    false, false);
+	    else
+	      {
+		/* Overload sets return a list of imported decls.  */
+		for (; decl != NULL_TREE; decl = TREE_CHAIN (decl))
+		  debug_hooks->imported_module_or_decl (TREE_VALUE (decl), name,
+							context, false, false);
+	      }
 	  }
       }
     else
@@ -646,7 +755,7 @@ public:
       {
 	/* Do not store variables we cannot take the address of,
 	   but keep the values for purposes of debugging.  */
-	if (!d->type->isscalar ())
+	if (d->type->isscalar () && !d->type->hasPointers ())
 	  {
 	    tree decl = get_symbol_decl (d);
 	    d_pushdecl (decl);
@@ -824,59 +933,17 @@ public:
     d->semanticRun = PASSobj;
 
     tree old_context = start_function (d);
+    tree param_list = get_fndecl_arguments (d);
 
-    tree parm_decl = NULL_TREE;
-    tree param_list = NULL_TREE;
-
-    /* Special arguments...  */
-
-    /* `this' parameter:
-       For nested functions, D still generates a vthis, but it
-       should not be referenced in any expression.  */
-    if (d->vthis)
-      {
-	parm_decl = get_symbol_decl (d->vthis);
-	DECL_ARTIFICIAL (parm_decl) = 1;
-	TREE_READONLY (parm_decl) = 1;
-
-	if (d->vthis->type == Type::tvoidptr)
-	  {
-	    /* Replace generic pointer with back-end closure type
-	       (this wins for gdb).  */
-	    tree frame_type = FRAMEINFO_TYPE (get_frameinfo (d));
-	    gcc_assert (frame_type != NULL_TREE);
-	    TREE_TYPE (parm_decl) = build_pointer_type (frame_type);
-	  }
-
-	param_list = chainon (param_list, parm_decl);
-	d_function_chain->static_chain = parm_decl;
-      }
-
-    /* _arguments parameter.  */
-    if (d->v_arguments)
-      {
-	parm_decl = get_symbol_decl (d->v_arguments);
-	param_list = chainon (param_list, parm_decl);
-      }
-
-    /* formal function parameters.  */
-    size_t n_parameters = d->parameters ? d->parameters->length : 0;
-
-    for (size_t i = 0; i < n_parameters; i++)
-      {
-	VarDeclaration *param = (*d->parameters)[i];
-	parm_decl = get_symbol_decl (param);
-	/* Chain them in the correct order.  */
-	param_list = chainon (param_list, parm_decl);
-      }
-
-    DECL_ARGUMENTS (fndecl) = param_list;
     DECL_IN_UNITTEST_CONDITION_P (fndecl) = this->in_version_unittest_;
     rest_of_decl_compilation (fndecl, 1, 0);
 
     /* If this is a member function that nested (possibly indirectly) in another
        function, construct an expession for this member function's static chain
        by going through parent link of nested classes.  */
+    if (d->vthis)
+      d_function_chain->static_chain = get_symbol_decl (d->vthis);
+
     if (d->isThis ())
       {
 	AggregateDeclaration *ad = d->isThis ();
@@ -891,7 +958,7 @@ public:
 	    ad = pd->isAggregateDeclaration ();
 	    if (ad == NULL)
 	      {
-		cfun->language->static_chain = this_tree;
+		d_function_chain->static_chain = this_tree;
 		break;
 	      }
 	  }
@@ -952,7 +1019,7 @@ public:
 	var = build_address (var);
 
 	tree init = build_call_expr (builtin_decl_explicit (BUILT_IN_VA_START),
-				     2, var, parm_decl);
+				     2, var, tree_last (param_list));
 	declare_local_var (d->v_argptr);
 	add_stmt (init);
 
@@ -1031,6 +1098,20 @@ get_symbol_decl (Declaration *decl)
       return decl->csym;
     }
 
+  if (VarDeclaration *vd = decl->isVarDeclaration ())
+    {
+      /* CONST_DECL was initially intended for enumerals and may be used for
+	 scalars in general, but not for aggregates.  Here a non-constant
+	 value is generated anyway so as its value can be used.  */
+      if (!vd->canTakeAddressOf () && !vd->type->isscalar ())
+	{
+	  gcc_assert (vd->_init && !vd->_init->isVoidInitializer ());
+	  Expression *ie = initializerToExpression (vd->_init);
+	  decl->csym = build_expr (ie, false);
+	  return decl->csym;
+	}
+    }
+
   /* Build the tree for the symbol.  */
   FuncDeclaration *fd = decl->isFuncDeclaration ();
   if (fd)
@@ -1078,23 +1159,15 @@ get_symbol_decl (Declaration *decl)
       if (vd->storage_class & STCextern)
 	DECL_EXTERNAL (decl->csym) = 1;
 
-      /* CONST_DECL was initially intended for enumerals and may be used for
-	 scalars in general, but not for aggregates.  Here a non-constant
-	 value is generated anyway so as the CONST_DECL only serves as a
-	 placeholder for the value, however the DECL itself should never be
-	 referenced in any generated code, or passed to the back-end.  */
-      if (vd->storage_class & STCmanifest)
+      if (!vd->canTakeAddressOf ())
 	{
 	  /* Cannot make an expression out of a void initializer.  */
-	  if (vd->_init && !vd->_init->isVoidInitializer ())
-	    {
-	      Expression *ie = initializerToExpression (vd->_init);
+	  gcc_assert (vd->_init && !vd->_init->isVoidInitializer ());
+	  /* Non-scalar manifest constants have already been dealt with.  */
+	  gcc_assert (vd->type->isscalar ());
 
-	      if (!vd->type->isscalar ())
-		DECL_INITIAL (decl->csym) = build_expr (ie, false);
-	      else
-		DECL_INITIAL (decl->csym) = build_expr (ie, true);
-	    }
+	  Expression *ie = initializerToExpression (vd->_init);
+	  DECL_INITIAL (decl->csym) = build_expr (ie, true);
 	}
     }
 
@@ -1253,6 +1326,12 @@ get_symbol_decl (Declaration *decl)
 	  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl->csym) = 1;
 	}
 
+      /* In [expression/function_literals], function literals (aka lambdas)
+	 enable embedding anonymous functions and anonymous delegates directly
+	 into expressions.  They are defined in each referencing module.  */
+      if (fd->isFuncLiteralDeclaration ())
+	DECL_SET_LAMBDA_FUNCTION (decl->csym, true);
+
       /* Mark compiler generated functions as artificial.  */
       if (fd->generated)
 	DECL_ARTIFICIAL (decl->csym) = 1;
@@ -1640,6 +1719,7 @@ finish_thunk (tree thunk, tree function)
 
   TREE_ADDRESSABLE (function) = 1;
   TREE_USED (function) = 1;
+  DECL_EXTERNAL (thunk) = 0;
 
   if (flag_syntax_only)
     {
@@ -1711,43 +1791,14 @@ make_thunk (FuncDeclaration *decl, int offset)
 
   if (!DECL_ARGUMENTS (function) || !DECL_RESULT (function))
     {
-      /* Compile the function body before generating the thunk, this is done
-	 even if the decl is external to the current module.  */
-      if (decl->fbody)
-	build_decl_tree (decl);
-      else
-	{
-	  /* Build parameters for functions that are not being compiled,
-	     so that they can be correctly cloned in finish_thunk.  */
-	  tree fntype = TREE_TYPE (function);
-	  tree params = NULL_TREE;
-
-	  for (tree t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))
-	    {
-	      if (t == void_list_node)
-		break;
-
-	      tree param = build_decl (DECL_SOURCE_LOCATION (function),
-				       PARM_DECL, NULL_TREE, TREE_VALUE (t));
-	      DECL_ARG_TYPE (param) = TREE_TYPE (param);
-	      DECL_ARTIFICIAL (param) = 1;
-	      DECL_IGNORED_P (param) = 1;
-	      DECL_CONTEXT (param) = function;
-	      params = chainon (params, param);
-	    }
-
-	  DECL_ARGUMENTS (function) = params;
-
-	  /* Also build the result decl, which is needed when force creating
-	     the thunk in gimple inside cgraph_node::expand_thunk.  */
-	  tree resdecl = build_decl (DECL_SOURCE_LOCATION (function),
-				     RESULT_DECL, NULL_TREE,
-				     TREE_TYPE (fntype));
-	  DECL_ARTIFICIAL (resdecl) = 1;
-	  DECL_IGNORED_P (resdecl) = 1;
-	  DECL_CONTEXT (resdecl) = function;
-	  DECL_RESULT (function) = resdecl;
-	}
+      /* Build parameters for functions that are not being compiled,
+	 so that they can be correctly cloned in finish_thunk.  */
+      tree function = get_symbol_decl (decl);
+      DECL_ARGUMENTS (function) = get_fndecl_arguments (decl);
+
+      /* Also build the result decl, which is needed when force creating
+	 the thunk in gimple inside cgraph_node::expand_thunk.  */
+      DECL_RESULT (function) = get_fndecl_result (decl);
     }
 
   /* Don't build the thunk if the compilation step failed.  */
@@ -1773,11 +1824,10 @@ make_thunk (FuncDeclaration *decl, int offset)
 
   DECL_CONTEXT (thunk) = d_decl_context (decl);
 
-  /* Thunks inherit the public access of the function they are targeting.
-     Thunks are connected to the definitions of the functions, so thunks are
-     not produced for external functions.  */
+  /* Thunks inherit the public access of the function they are targeting.  */
   TREE_PUBLIC (thunk) = TREE_PUBLIC (function);
-  DECL_EXTERNAL (thunk) = DECL_EXTERNAL (function);
+  /* The thunk has not been defined -- yet.  */
+  DECL_EXTERNAL (thunk) = 1;
 
   /* Thunks are always addressable.  */
   TREE_ADDRESSABLE (thunk) = 1;
@@ -1812,6 +1862,8 @@ make_thunk (FuncDeclaration *decl, int offset)
   d_keep (thunk);
   free (CONST_CAST (char *, ident));
 
+  /* Thunks are connected to the definitions of the functions, so thunks are
+     not produced for external functions.  */
   if (!DECL_EXTERNAL (function))
     finish_thunk (thunk, function);
 
@@ -1833,9 +1885,10 @@ start_function (FuncDeclaration *fd)
 {
   tree fndecl = get_symbol_decl (fd);
 
-  /* Function has been defined, check now whether we intend to send it to
-     object file, or it really is extern.  Such as inlinable functions from
-     modules not in this compilation, or thunk aliases.  */
+  /* Function has been defined. Whether we intend to send it to object file, or
+     discard it has already been determined by set_linkage_for_decl.  */
+  DECL_EXTERNAL (fndecl) = 0;
+
   TemplateInstance *ti = fd->isInstantiated ();
   if (ti && ti->needsCodegen ())
     {
@@ -1845,14 +1898,6 @@ start_function (FuncDeclaration *fd)
 	  warning (OPT_Wtemplates, "%s %qs instantiated",
 		   ti->kind (), ti->toPrettyChars (false));
 	}
-
-      DECL_EXTERNAL (fndecl) = 0;
-    }
-  else
-    {
-      Module *md = fd->getModule ();
-      if (md && md->isRoot ())
-	DECL_EXTERNAL (fndecl) = 0;
     }
 
   DECL_INITIAL (fndecl) = error_mark_node;
@@ -1869,14 +1914,8 @@ start_function (FuncDeclaration *fd)
   /* Let GCC know the current scope is this function.  */
   current_function_decl = fndecl;
 
-  tree restype = TREE_TYPE (TREE_TYPE (fndecl));
-  tree resdecl = build_decl (make_location_t (fd->loc), RESULT_DECL,
-			     NULL_TREE, restype);
-
-  DECL_RESULT (fndecl) = resdecl;
-  DECL_CONTEXT (resdecl) = fndecl;
-  DECL_ARTIFICIAL (resdecl) = 1;
-  DECL_IGNORED_P (resdecl) = 1;
+  /* Build the result decl before calling allocate_struct_function.  */
+  DECL_RESULT (fndecl) = get_fndecl_result (fd);
 
   /* Initialize the RTL code for the function.  */
   allocate_struct_function (fndecl, false);
@@ -1943,6 +1982,10 @@ finish_function (tree old_context)
 
   DECL_SAVED_TREE (fndecl) = bind;
 
+  /* Finish any forward referenced thunks for the function.  */
+  for (tree t = DECL_LANG_THUNKS (fndecl); t; t = DECL_CHAIN (t))
+    finish_thunk (t, fndecl);
+
   if (!errorcount && !global.errors)
     {
       /* Dump the D-specific tree IR.  */
@@ -2375,16 +2418,17 @@ set_linkage_for_decl (tree decl)
   if (!TREE_PUBLIC (decl))
     return;
 
+  /* Function literals and functions declared as `pragma(inline, true)' can
+     appear in multiple translation units.  */
+  if (TREE_CODE (decl) == FUNCTION_DECL
+      && (DECL_DECLARED_INLINE_P (decl) || DECL_LAMBDA_FUNCTION_P (decl)))
+    return d_comdat_linkage (decl);
+
   /* Don't need to give private or protected symbols a special linkage.  */
   if ((TREE_PRIVATE (decl) || TREE_PROTECTED (decl))
       && !DECL_INSTANTIATED (decl))
     return;
 
-  /* Functions declared as `pragma(inline, true)' can appear in multiple
-     translation units.  */
-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl))
-    return d_comdat_linkage (decl);
-
   /* If all instantiations must go in COMDAT, give them that linkage.
      This also applies to other extern declarations, so that it is possible
      for them to override template declarations.  */
diff --git a/gcc/d/dmd/dinterpret.c b/gcc/d/dmd/dinterpret.c
index ab9d88c660c..d4cfb0caacb 100644
--- a/gcc/d/dmd/dinterpret.c
+++ b/gcc/d/dmd/dinterpret.c
@@ -5792,12 +5792,22 @@ public:
         }
         if (e->to->ty == Tsarray)
             e1 = resolveSlice(e1);
-        if (e->to->toBasetype()->ty == Tbool && e1->type->ty == Tpointer)
+        Type *tobt = e->to->toBasetype();
+        if (tobt->ty == Tbool && e1->type->ty == Tpointer)
         {
             new(pue) IntegerExp(e->loc, e1->op != TOKnull, e->to);
             result = pue->exp();
             return;
         }
+        else if (tobt->isTypeBasic() && e1->op == TOKnull)
+        {
+            if (tobt->isintegral())
+                new(pue) IntegerExp(e->loc, 0, e->to);
+            else if (tobt->isreal())
+                new(pue) RealExp(e->loc, CTFloat::zero, e->to);
+            result = pue->exp();
+            return;
+        }
         result = ctfeCast(pue, e->loc, e->type, e->to, e1);
     }
 
diff --git a/gcc/d/dmd/expressionsem.c b/gcc/d/dmd/expressionsem.c
index 5ae5fe6a717..fe90039d6f0 100644
--- a/gcc/d/dmd/expressionsem.c
+++ b/gcc/d/dmd/expressionsem.c
@@ -6330,6 +6330,7 @@ public:
         if (tob->ty == Tvector && t1b->ty != Tvector)
         {
             result = new VectorExp(exp->loc, exp->e1, exp->to);
+            result = expressionSemantic(result, sc);
             return;
         }
 
diff --git a/gcc/d/expr.cc b/gcc/d/expr.cc
index 85269c6b2be..eb5feffef6a 100644
--- a/gcc/d/expr.cc
+++ b/gcc/d/expr.cc
@@ -3034,14 +3034,13 @@ public:
 
   void visit (VectorExp *e)
   {
-    tree type = build_ctype (e->type);
-
     /* First handle array literal expressions.  */
     if (e->e1->op == TOKarrayliteral)
       {
 	ArrayLiteralExp *ale = e->e1->isArrayLiteralExp ();
 	vec <constructor_elt, va_gc> *elms = NULL;
 	bool constant_p = true;
+	tree type = build_ctype (e->type);
 
 	vec_safe_reserve (elms, ale->elements->length);
 	for (size_t i = 0; i < ale->elements->length; i++)
@@ -3061,9 +3060,16 @@ public:
 	else
 	  this->result_ = build_constructor (type, elms);
       }
+    else if (e->e1->type->toBasetype ()->ty == Tsarray)
+      {
+	/* Build a vector representation from a static array.  */
+	this->result_ = convert_expr (build_expr (e->e1, this->constp_),
+				      e->e1->type, e->type);
+      }
     else
       {
 	/* Build constructor from single value.  */
+	tree type = build_ctype (e->type);
 	tree value = d_convert (TREE_TYPE (type),
 				build_expr (e->e1, this->constp_, true));
 	this->result_ = build_vector_from_val (type, value);
diff --git a/gcc/d/gdc.texi b/gcc/d/gdc.texi
index 095f7ecca41..0976aebd7d4 100644
--- a/gcc/d/gdc.texi
+++ b/gcc/d/gdc.texi
@@ -637,9 +637,11 @@ List information on all language changes.
 @item complex
 List all usages of complex or imaginary types.
 @item dip1000
-Implements @uref{http://wiki.dlang.org/DIP1000} (experimental).
+Implements @uref{https://github.com/dlang/DIPs/blob/master/DIPs/other/DIP1000.md}
+(Scoped pointers).
 @item dip25
-Implements @uref{http://wiki.dlang.org/DIP25} (experimental).
+Implements @uref{https://github.com/dlang/DIPs/blob/master/DIPs/archive/DIP25.md}
+(Sealed references).
 @item field
 List all non-mutable fields which occupy an object instance.
 @item nogc
diff --git a/gcc/d/imports.cc b/gcc/d/imports.cc
index 2288843c61a..51ed5e0260a 100644
--- a/gcc/d/imports.cc
+++ b/gcc/d/imports.cc
@@ -97,12 +97,17 @@ public:
     tree type = build_ctype (d->type);
     /* Not all kinds of D enums create a TYPE_DECL.  */
     if (TREE_CODE (type) == ENUMERAL_TYPE)
-      d->isym = this->make_import (TYPE_STUB_DECL (type));
+      {
+	type = TYPE_MAIN_VARIANT (type);
+	d->isym = this->make_import (TYPE_STUB_DECL (type));
+      }
+
   }
 
   void visit (AggregateDeclaration *d)
   {
     tree type = build_ctype (d->type);
+    type = TYPE_MAIN_VARIANT (type);
     d->isym = this->make_import (TYPE_STUB_DECL (type));
   }
 
@@ -110,9 +115,19 @@ public:
   {
     /* Want the RECORD_TYPE, not POINTER_TYPE.  */
     tree type = TREE_TYPE (build_ctype (d->type));
+    type = TYPE_MAIN_VARIANT (type);
     d->isym = this->make_import (TYPE_STUB_DECL (type));
   }
 
+  void visit (VarDeclaration *d)
+  {
+    /* Not all kinds of manifest constants create a CONST_DECL.  */
+    if (!d->canTakeAddressOf () && !d->type->isscalar ())
+      return;
+
+    visit ((Declaration *) d);
+  }
+
   /* For now, ignore importing other kinds of dsymbols.  */
   void visit (ScopeDsymbol *)
   {
@@ -157,6 +172,20 @@ public:
       }
   }
 
+  /* Build IMPORTED_DECLs for all overloads in a set.  */
+  void visit (OverloadSet *d)
+  {
+    vec<tree, va_gc> *tset = NULL;
+
+    vec_alloc (tset, d->a.length);
+
+    for (size_t i = 0; i < d->a.length; i++)
+      vec_safe_push (tset, build_import_decl (d->a[i]));
+
+    d->isym = build_tree_list_vec (tset);
+    tset->truncate (0);
+  }
+
   /* Function aliases are the same as alias symbols.  */
   void visit (FuncAliasDeclaration *d)
   {
diff --git a/gcc/d/intrinsics.cc b/gcc/d/intrinsics.cc
index 539dc0c1f37..5788f5cb4ad 100644
--- a/gcc/d/intrinsics.cc
+++ b/gcc/d/intrinsics.cc
@@ -721,6 +721,7 @@ expand_volatile_load (tree callexp)
   tree type = build_qualified_type (TREE_TYPE (ptrtype), TYPE_QUAL_VOLATILE);
   tree result = indirect_ref (type, ptr);
   TREE_THIS_VOLATILE (result) = 1;
+  TREE_SIDE_EFFECTS (result) = 1;
 
   return result;
 }
@@ -748,6 +749,7 @@ expand_volatile_store (tree callexp)
   tree type = build_qualified_type (TREE_TYPE (ptrtype), TYPE_QUAL_VOLATILE);
   tree result = indirect_ref (type, ptr);
   TREE_THIS_VOLATILE (result) = 1;
+  TREE_SIDE_EFFECTS (result) = 1;
 
   /* (*(volatile T *) ptr) = value;  */
   tree value = CALL_EXPR_ARG (callexp, 1);
diff --git a/gcc/d/toir.cc b/gcc/d/toir.cc
index eaee6f7e803..1db50b8cfbe 100644
--- a/gcc/d/toir.cc
+++ b/gcc/d/toir.cc
@@ -541,6 +541,28 @@ public:
     this->do_label (label);
   }
 
+  /* Generate and set a new continue label for the current unrolled loop.  */
+
+  void push_unrolled_continue_label (UnrolledLoopStatement *s)
+  {
+    this->push_continue_label (s);
+  }
+
+  /* Finish with the continue label for the unrolled loop.  */
+
+  void pop_unrolled_continue_label (UnrolledLoopStatement *s)
+  {
+    Statement *stmt = s->getRelatedLabeled ();
+    d_label_entry *ent = d_function_chain->labels->get (stmt);
+    gcc_assert (ent != NULL && ent->bc_label == true);
+
+    this->pop_continue_label (TREE_VEC_ELT (ent->label, bc_continue));
+
+    /* Remove the continue label from the label htab, as a new one must be
+       inserted at the end of every unrolled loop.  */
+    ent->label = TREE_VEC_ELT (ent->label, bc_break);
+  }
+
   /* Visitor interfaces.  */
 
 
@@ -1090,6 +1112,7 @@ public:
 	    /* Generate: (<retval> = expr, return <retval>);  */
 	    tree expr = build_expr_dtor (s->exp);
 	    tree init = stabilize_expr (&expr);
+	    expr = convert_for_rvalue (expr, s->exp->type, type);
 	    expr = build_assign (INIT_EXPR, this->func_->shidden, expr);
 	    add_stmt (compound_expr (init, expr));
 	  }
@@ -1156,9 +1179,9 @@ public:
 
 	if (statement != NULL)
 	  {
-	    tree lcontinue = this->push_continue_label (statement);
+	    this->push_unrolled_continue_label (s);
 	    this->build_stmt (statement);
-	    this->pop_continue_label (lcontinue);
+	    this->pop_unrolled_continue_label (s);
 	  }
       }
 
diff --git a/gcc/d/typeinfo.cc b/gcc/d/typeinfo.cc
index 9d6464deb07..a10d21e355e 100644
--- a/gcc/d/typeinfo.cc
+++ b/gcc/d/typeinfo.cc
@@ -179,6 +179,7 @@ make_internal_typeinfo (tinfo_kind tk, Identifier *ident, ...)
 
   /* Create the TypeInfo type.  */
   tree type = make_node (RECORD_TYPE);
+  TYPE_ARTIFICIAL (type) = 1;
   finish_builtin_struct (type, ident->toChars (), fields, NULL_TREE);
 
   tinfo_types[tk] = type;
diff --git a/gcc/doc/cppopts.texi b/gcc/doc/cppopts.texi
index b941de6df1b..03fd8084619 100644
--- a/gcc/doc/cppopts.texi
+++ b/gcc/doc/cppopts.texi
@@ -318,9 +318,10 @@ supported by the system's @code{iconv} library routine.
 @opindex fwide-exec-charset
 @cindex character set, wide execution
 Set the wide execution character set, used for wide string and
-character constants.  The default is UTF-32 or UTF-16, whichever
-corresponds to the width of @code{wchar_t}.  As with
-@option{-fexec-charset}, @var{charset} can be any encoding supported
+character constants.  The default is one of UTF-32BE, UTF-32LE, UTF-16BE,
+or UTF-16LE, whichever corresponds to the width of @code{wchar_t} and the
+big-endian or little-endian byte order being used for code generation.  As
+with @option{-fexec-charset}, @var{charset} can be any encoding supported
 by the system's @code{iconv} library routine; however, you will have
 problems with encodings that do not fit exactly in @code{wchar_t}.
 
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 689ec7de4d3..64bd4c1cb6c 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -688,7 +688,7 @@ myprintf (FILE *f, const char *format, ...)
 @end smallexample
 @end deftypefn
 
-@deftypefn {Built-in Function} {size_t} __builtin_va_arg_pack_len ()
+@deftypefn {Built-in Function} {int} __builtin_va_arg_pack_len ()
 This built-in function returns the number of anonymous arguments of
 an inline function.  It can be used only in inline functions that
 are always inlined, never compiled as a separate function, such
@@ -2487,7 +2487,7 @@ The following attributes are supported on most targets.
 @table @code
 @c Keep this table alphabetized by attribute name.  Treat _ as space.
 
-@itemx access (@var{access-mode}, @var{ref-index})
+@item access (@var{access-mode}, @var{ref-index})
 @itemx access (@var{access-mode}, @var{ref-index}, @var{size-index})
 
 The @code{access} attribute enables the detection of invalid or unsafe
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 4b05ccfaffb..68a0f2b04e9 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -363,6 +363,9 @@ tables.
 
 Used by @command{automake}.
 
+If available, enables parallel testing of @samp{libgomp} in case that
+@command{flock} is not available.
+
 @end table
 
 Several support libraries are necessary to build GCC, some are required,
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 35508efb4ef..fffa899585e 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -1396,7 +1396,7 @@ See RS/6000 and PowerPC Options.
 -m96bit-long-double  -mlong-double-64  -mlong-double-80  -mlong-double-128 @gol
 -mregparm=@var{num}  -msseregparm @gol
 -mveclibabi=@var{type}  -mvect8-ret-in-mem @gol
--mpc32  -mpc64  -mpc80  -mstackrealign @gol
+-mpc32  -mpc64  -mpc80 -mdaz-ftz -mstackrealign @gol
 -momit-leaf-frame-pointer  -mno-red-zone  -mno-tls-direct-seg-refs @gol
 -mcmodel=@var{code-model}  -mabi=@var{name}  -maddress-mode=@var{mode} @gol
 -m32  -m64  -mx32  -m16  -miamcu  -mlarge-data-threshold=@var{num} @gol
@@ -18231,7 +18231,7 @@ performance of the code.  Permissible values for this option are:
 @samp{cortex-a78}, @samp{cortex-a78ae}, @samp{cortex-a78c},
 @samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},
 @samp{neoverse-512tvb}, @samp{neoverse-e1}, @samp{neoverse-n1},
-@samp{neoverse-n2}, @samp{neoverse-v1}, @samp{qdf24xx},
+@samp{neoverse-n2}, @samp{neoverse-v1},@samp{neoverse-v2}, @samp{qdf24xx},
 @samp{saphira}, @samp{phecda}, @samp{xgene1}, @samp{vulcan},
 @samp{octeontx}, @samp{octeontx81},  @samp{octeontx83},
 @samp{octeontx2}, @samp{octeontx2t98}, @samp{octeontx2t96}
@@ -18244,7 +18244,8 @@ performance of the code.  Permissible values for this option are:
 @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
 @samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
 @samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55},
-@samp{cortex-r82}, @samp{cortex-x1}, @samp{ampere1}, @samp{native}.
+@samp{cortex-r82}, @samp{cortex-x1}, @samp{ampere1},
+@samp{ampere1a}, @samp{native}.
 
 The values @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},
 @samp{cortex-a73.cortex-a35}, @samp{cortex-a73.cortex-a53},
@@ -30755,6 +30756,15 @@ are enabled by default; routines in such libraries could suffer significant
 loss of accuracy, typically through so-called ``catastrophic cancellation'',
 when this option is used to set the precision to less than extended precision.
 
+@item -mdaz-ftz
+@opindex mdaz-ftz
+
+The flush-to-zero (FTZ) and denormals-are-zero (DAZ) flags in the MXCSR register
+are used to control floating-point calculations.SSE and AVX instructions
+including scalar and vector instructions could benefit from enabling the FTZ
+and DAZ flags when @option{-mdaz-ftz} is specified. Don't set FTZ/DAZ flags
+when @option{-mno-daz-ftz} is specified.
+
 @item -mstackrealign
 @opindex mstackrealign
 Realign the stack at entry.  On the x86, the @option{-mstackrealign}
@@ -31747,7 +31757,7 @@ on x86-64 processors in 64-bit environments.
 Generate code for a 16-bit, 32-bit or 64-bit environment.
 The @option{-m32} option sets @code{int}, @code{long}, and pointer types
 to 32 bits, and
-generates code that runs on any i386 system.
+generates code that runs in 32-bit mode.
 
 The @option{-m64} option sets @code{int} to 32 bits and @code{long} and pointer
 types to 64 bits, and generates code for the x86-64 architecture.
diff --git a/gcc/doc/match-and-simplify.texi b/gcc/doc/match-and-simplify.texi
index e7e5a4f7299..b76aeac4121 100644
--- a/gcc/doc/match-and-simplify.texi
+++ b/gcc/doc/match-and-simplify.texi
@@ -374,8 +374,10 @@ for example
 
 which moves the outer @code{plus} operation to the inner arms
 of the @code{vec_cond} expression but only if the actual plus
-operations both simplify.  Note this is currently only supported
-for code generation targeting @code{GIMPLE}.
+operations both simplify.  Note that on @code{GENERIC} a simple
+operand means that the result satisfies @code{!EXPR_P} which
+can be limiting if the operation itself simplifies but the
+remaining operand is an (unrelated) expression.
 
 As intermediate conversions are often optional there is a way to
 avoid the need to repeat patterns both with and without such
diff --git a/gcc/dse.c b/gcc/dse.c
index b634429449c..dd99756d151 100644
--- a/gcc/dse.c
+++ b/gcc/dse.c
@@ -1562,12 +1562,7 @@ record_store (rtx body, bb_info_t bb_info)
 					 width)
 	      /* We can only remove the later store if the earlier aliases
 		 at least all accesses the later one.  */
-	      && ((MEM_ALIAS_SET (mem) == MEM_ALIAS_SET (s_info->mem)
-		   || alias_set_subset_of (MEM_ALIAS_SET (mem),
-					   MEM_ALIAS_SET (s_info->mem)))
-		  && (!MEM_EXPR (s_info->mem)
-		      || refs_same_for_tbaa_p (MEM_EXPR (s_info->mem),
-					       MEM_EXPR (mem)))))
+	      && mems_same_for_tbaa_p (s_info->mem, mem))
 	    {
 	      if (GET_MODE (mem) == BLKmode)
 		{
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index e5d3ce4966d..c3dab15026d 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -5791,6 +5791,7 @@ lookup_type_die (tree type)
   if (die && die->removed)
     {
       TYPE_SYMTAB_DIE (type) = NULL;
+      TREE_ASM_WRITTEN (type) = 0;
       return NULL;
     }
   return die;
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 07e908624a0..0dc51220682 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -6465,7 +6465,8 @@ emit_copy_of_insn_after (rtx_insn *insn, rtx_insn *after)
     }
 
   /* Update LABEL_NUSES.  */
-  mark_jump_label (PATTERN (new_rtx), new_rtx, 0);
+  if (NONDEBUG_INSN_P (insn))
+    mark_jump_label (PATTERN (new_rtx), new_rtx, 0);
 
   INSN_LOCATION (new_rtx) = INSN_LOCATION (insn);
 
diff --git a/gcc/expr.c b/gcc/expr.c
index 14a25c25450..eae9c023cb7 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -5793,6 +5793,9 @@ store_expr (tree exp, rtx target, int call_param_p,
 	  temp = convert_modes (inner_mode, outer_mode, temp,
 				SUBREG_PROMOTED_SIGN (target));
 	}
+      else if (!SCALAR_INT_MODE_P (GET_MODE (temp)))
+	temp = convert_modes (outer_mode, TYPE_MODE (TREE_TYPE (exp)),
+			      temp, SUBREG_PROMOTED_SIGN (target));
 
       convert_move (SUBREG_REG (target), temp,
 		    SUBREG_PROMOTED_SIGN (target));
@@ -6192,13 +6195,13 @@ count_type_elements (const_tree type, bool for_ctor_p)
     case OFFSET_TYPE:
     case REFERENCE_TYPE:
     case NULLPTR_TYPE:
+    case OPAQUE_TYPE:
       return 1;
 
     case ERROR_MARK:
       return 0;
 
     case VOID_TYPE:
-    case OPAQUE_TYPE:
     case METHOD_TYPE:
     case FUNCTION_TYPE:
     case LANG_TYPE:
@@ -7436,8 +7439,7 @@ get_inner_reference (tree exp, poly_int64_pod *pbitsize,
 	  /* For vector fields re-check the target flags, as DECL_MODE
 	     could have been set with different target flags than
 	     the current function has.  */
-	  if (mode == BLKmode
-	      && VECTOR_TYPE_P (TREE_TYPE (field))
+	  if (VECTOR_TYPE_P (TREE_TYPE (field))
 	      && VECTOR_MODE_P (TYPE_MODE_RAW (TREE_TYPE (field))))
 	    mode = TYPE_MODE (TREE_TYPE (field));
 	}
@@ -8566,7 +8568,8 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,
   expanding_cond_expr_using_cmove = true;
   start_sequence ();
   expand_operands (treeop1, treeop2,
-		   temp, &op1, &op2, EXPAND_NORMAL);
+		   mode == orig_mode ? temp : NULL_RTX, &op1, &op2,
+		   EXPAND_NORMAL);
 
   if (TREE_CODE (treeop0) == SSA_NAME
       && (srcstmt = get_def_for_expr_class (treeop0, tcc_comparison)))
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 70c5b3886ef..5b4053df520 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -2355,7 +2355,7 @@ build_zero_vector (tree type)
 bool
 fold_convertible_p (const_tree type, const_tree arg)
 {
-  tree orig = TREE_TYPE (arg);
+  const_tree orig = TREE_TYPE (arg);
 
   if (type == orig)
     return true;
@@ -2387,7 +2387,7 @@ fold_convertible_p (const_tree type, const_tree arg)
       return (VECTOR_TYPE_P (orig)
 	      && known_eq (TYPE_VECTOR_SUBPARTS (type),
 			   TYPE_VECTOR_SUBPARTS (orig))
-	      && fold_convertible_p (TREE_TYPE (type), TREE_TYPE (orig)));
+	      && tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (orig)));
 
     default:
       return false;
@@ -3331,9 +3331,6 @@ operand_compare::operand_equal_p (const_tree arg0, const_tree arg1,
 		if (compare_address
 		    && (flags & OEP_ADDRESS_OF_SAME_FIELD) == 0)
 		  {
-		    if (TREE_OPERAND (arg0, 2)
-			|| TREE_OPERAND (arg1, 2))
-		      return OP_SAME_WITH_NULL (2);
 		    tree field0 = TREE_OPERAND (arg0, 1);
 		    tree field1 = TREE_OPERAND (arg1, 1);
 
@@ -3844,17 +3841,10 @@ operand_compare::hash_operand (const_tree t, inchash::hash &hstate,
 	      if (sflags & OEP_ADDRESS_OF)
 		{
 		  hash_operand (TREE_OPERAND (t, 0), hstate, flags);
-		  if (TREE_OPERAND (t, 2))
-		    hash_operand (TREE_OPERAND (t, 2), hstate,
-				  flags & ~OEP_ADDRESS_OF);
-		  else
-		    {
-		      tree field = TREE_OPERAND (t, 1);
-		      hash_operand (DECL_FIELD_OFFSET (field),
-				    hstate, flags & ~OEP_ADDRESS_OF);
-		      hash_operand (DECL_FIELD_BIT_OFFSET (field),
-				    hstate, flags & ~OEP_ADDRESS_OF);
-		    }
+		  hash_operand (DECL_FIELD_OFFSET (TREE_OPERAND (t, 1)),
+				hstate, flags & ~OEP_ADDRESS_OF);
+		  hash_operand (DECL_FIELD_BIT_OFFSET (TREE_OPERAND (t, 1)),
+				hstate, flags & ~OEP_ADDRESS_OF);
 		  return;
 		}
 	      break;
@@ -7508,7 +7498,7 @@ tree_swap_operands_p (const_tree arg0, const_tree arg1)
 static tree
 fold_to_nonsharp_ineq_using_bound (location_t loc, tree ineq, tree bound)
 {
-  tree a, typea, type = TREE_TYPE (ineq), a1, diff, y;
+  tree a, typea, type = TREE_TYPE (bound), a1, diff, y;
 
   if (TREE_CODE (bound) == LT_EXPR)
     a = TREE_OPERAND (bound, 0);
@@ -9488,6 +9478,16 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)
 		  > min_align_of_type (TREE_TYPE (TREE_TYPE (arg00)))))
 	    return NULL_TREE;
 
+	  /* Similarly, avoid this optimization in GENERIC for -fsanitize=null
+	     when type is a reference type and arg00's type is not,
+	     because arg00 could be validly nullptr and if arg01 doesn't return,
+	     we don't want false positive binding of reference to nullptr.  */
+	  if (TREE_CODE (type) == REFERENCE_TYPE
+	      && !in_gimple_form
+	      && sanitize_flags_p (SANITIZE_NULL)
+	      && TREE_CODE (TREE_TYPE (arg00)) != REFERENCE_TYPE)
+	    return NULL_TREE;
+
 	  arg00 = fold_convert_loc (loc, type, arg00);
 	  return fold_build_pointer_plus_loc (loc, arg00, arg01);
 	}
@@ -11987,11 +11987,15 @@ fold_binary_loc (location_t loc, enum tree_code code, tree type,
 	{
 	  tem = fold_to_nonsharp_ineq_using_bound (loc, arg0, arg1);
 	  if (tem && !operand_equal_p (tem, arg0, 0))
-	    return fold_build2_loc (loc, code, type, tem, arg1);
+	    return fold_convert (type,
+				 fold_build2_loc (loc, code, TREE_TYPE (arg1),
+						  tem, arg1));
 
 	  tem = fold_to_nonsharp_ineq_using_bound (loc, arg1, arg0);
 	  if (tem && !operand_equal_p (tem, arg1, 0))
-	    return fold_build2_loc (loc, code, type, arg0, tem);
+	    return fold_convert (type,
+				 fold_build2_loc (loc, code, TREE_TYPE (arg0),
+						  arg0, tem));
 	}
 
       if ((tem = fold_truth_andor (loc, code, type, arg0, arg1, op0, op1))
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index ee1c7bb4b31..fb812e0740c 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,607 @@
+2023-10-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-10-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/111837
+	* frontend-passes.c (traverse_io_block): Dependency check of loop
+	nest shall be triangular, not banded.
+
+2023-08-06  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2022-12-18  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/107397
+	* decl.c (add_init_expr_to_sym): Add check with new error message.
+
+2023-08-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backported from master:
+	2023-01-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/103506
+	* parse.c (parse_module): Remove use of a bool error value
+	that prevented proper setting of the namespace pointer.
+
+2023-07-20  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-07-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95947
+	PR fortran/110658
+	* trans-expr.c (gfc_conv_procedure_call): For intrinsic procedures
+	whose result characteristics depends on the first argument and which
+	can be of type character, the character length will not be deferred.
+
+2023-07-14  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-07-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/110288
+	* symbol.c (gfc_copy_formal_args_intr): When deriving the formal
+	argument attributes from the actual ones for intrinsic procedure
+	calls, take special care of CHARACTER arguments that we do not
+	wrongly treat them formally as deferred-length.
+
+2023-07-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-07-08  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/110585
+	* arith.c (gfc_compare_expr): Handle equality comparison of constant
+	complex gfc_expr arguments.
+
+2023-06-09  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-06-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/96024
+	* primary.c (gfc_convert_to_structure_constructor): Only do
+	constant string ctor length verification and truncation/padding
+	if constant length has INTEGER type.
+
+2023-06-04  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2023-06-02  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/100607
+	* resolve.c (resolve_select_rank): Remove duplicate error.
+	(resolve_fl_var_and_proc): Prevent NULL pointer dereference and
+	suppress error message for temporary.
+
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-20  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-05-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/109846
+	* expr.c (gfc_check_vardef_context): Check appropriate pointer
+	attribute for CLASS vs. non-CLASS function result in variable
+	definition context.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/108451
+	* trans-decl.c (gfc_trans_use_stmts): Call clear_slot before
+	doing continue.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/108349
+	* f95-lang.c (gfc_init_builtin_function): Fix up function types
+	for BUILT_IN_REALLOC and BUILT_IN_SINCOS{F,,L}.  Formatting fixes.
+
+2023-04-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-04-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/109511
+	* simplify.c (gfc_simplify_set_exponent): Fix implementation of
+	compile-time simplification of intrinsic SET_EXPONENT for argument
+	X < 1 and for I < 0.
+
+2023-04-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	* dump-parse-tree.c (get_c_type_name): Fix "long_long"
+	type name to be "long long".
+
+2023-04-02  Andrew Pinski  <apinski@marvell.com>
+
+	* dump-parse-tree.c (get_c_type_name): Fix "long_long"
+	type name to be "long long". Add a comment on why adding
+	2 to the name too.
+
+2023-03-24  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99036
+	* decl.c (gfc_match_modproc): Reject MODULE PROCEDURE if not in a
+	generic module interface.
+
+2023-03-24  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/109186
+	* simplify.c (gfc_simplify_nearest): Fix off-by-one error in setting
+	up real kind-specific maximum exponent for mpfr.
+
+2023-03-24  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-19  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/85877
+	* resolve.c (resolve_fl_procedure): Check for an explicit interface
+	of procedures with the BIND(C) attribute (F2018:15.4.2.2).
+
+2023-03-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106945
+	* trans-expr.c (gfc_copy_class_to_class): Convert element counts in
+	bounds check to common type for comparison.
+
+2023-03-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-10  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104332
+	* resolve.c (resolve_symbol): Avoid NULL pointer dereference while
+	checking a symbol with the BIND(C) attribute.
+
+2023-03-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2023-03-01  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/108546
+	* trans-openmp.c (gfc_trans_omp_clauses): Fix mapping of
+	type(C_ptr) variables.
+
+2023-03-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108937
+	* trans-intrinsic.c (gfc_conv_intrinsic_ibits): Handle corner case
+	LEN argument of IBITS equal to BITSIZE(I).
+
+2023-03-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/96024
+	* resolve.c (resolve_component): The type of a CHARACTER length
+	expression must be INTEGER.
+
+2023-03-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/96025
+	* parse.c (check_function_result_typed): Improve type check of
+	specification expression for character length and return status.
+	(parse_spec): Use status from above.
+	* resolve.c (resolve_fntype): Prevent use of invalid specification
+	expression for character length.
+
+2023-02-10  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2023-02-08  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103259
+	* resolve.c (resolve_common_vars): Avoid NULL pointer dereference
+	when a symbol's location is not set.
+
+2023-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95107
+	* trans-decl.c (gfc_finish_var_decl): With -fno-automatic, do not
+	make ASSOCIATE variables TREE_STATIC.
+
+2023-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-01  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108609
+	* expr.c (find_array_section): Add check to prevent interpreting an
+	mpz non-integer constant as an integer.
+
+2023-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-28  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/108527
+	* resolve.c (compare_bound_int): Expression to compare must be of
+	type INTEGER.
+	(compare_bound_mpz_t): Likewise.
+	(check_dimension): Fix comment on checks applied to array section
+	and clean up associated logic.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108529
+	* simplify.c (simplify_transformation): Do not try to simplify
+	transformational intrinsic when the ARRAY argument has a NULL shape.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-07-14  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/106209
+	* decl.c (add_init_expr_to_sym): Handle bad initializers for
+	implied-shape arrays.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108501
+	* interface.c (get_expr_storage_size): Check array subscript triplets
+	that we actually have integer values before trying to extract with
+	mpz_get_si.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108502
+	* dependency.c (gfc_check_dependency): Prevent NULL pointer
+	dereference while recursively checking expressions.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108421
+	* interface.c (get_expr_storage_size): Check that we actually have
+	an integer value before trying to extract it with mpz_get_si.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108420
+	* iresolve.c (check_charlen_present): Preserve character length if
+	there is no array constructor.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-28  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108453
+	* match.c (gfc_match_common): A USE associated name shall not appear
+	in a COMMON block (F2018:C8121).
+
+2023-01-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-12-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108131
+	* array.c (match_array_element_spec): Avoid too early simplification
+	of matched array element specs that can lead to a misinterpretation
+	when used as array bounds in array declarations.
+
+2022-12-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2022-12-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/107872
+	* resolve.c (derived_inaccessible): Skip over allocatable components
+	to prevent an infinite loop.
+
+2022-11-25  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-11-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107576
+	* interface.c (gfc_procedure_use): Reject NULL as actual argument
+	when there is no explicit procedure interface.
+
+2022-10-29  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-21  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100097
+	PR fortran/100098
+	* trans-array.c (gfc_trans_class_array): New function to
+	initialize class descriptor's TKR information.
+	* trans-array.h (gfc_trans_class_array): Add function prototype.
+	* trans-decl.c (gfc_trans_deferred_vars): Add calls to the new
+	function for both pointers and allocatables.
+
+2022-10-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103413
+	* symbol.c (gfc_type_compatible): A boz-literal-constant has no type
+	and thus is not considered compatible to any type.
+
+2022-10-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-20  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105633
+	* expr.c (find_array_section): Move check for NULL pointers so
+	that both subscript triplets and vector subscripts are covered.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/106817
+	* trans-expr.c (gfc_conv_procedure_call): Collect all clobbers
+	to their own separate block.  Append the block of clobbers to
+	the procedure preliminary block after the argument evaluation
+	codes for all the arguments.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/105012
+	* trans-expr.c (gfc_conv_procedure_call): Retrieve variable
+	from the just calculated variable reference.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	* trans.h (gfc_conv_expr_reference): Remove add_clobber
+	argument.
+	* trans-expr.c (gfc_conv_expr_reference): Ditto. Inline code
+	depending on add_clobber and conditions controlling it ...
+	(gfc_conv_procedure_call): ... to here.
+
+2022-10-08  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100040
+	PR fortran/100029
+	* trans-expr.c (gfc_conv_class_to_class): Add code to have
+	assumed-rank arrays recognized as full arrays and fix the type
+	of the array assignment.
+	(gfc_conv_procedure_call): Change order of code blocks such that
+	the free of ALLOCATABLE dummy arguments with INTENT(OUT) occurs
+	first.
+
+2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-20  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100132
+	* trans-types.c (create_fn_spec): Fix function attributes when
+	passing polymorphic pointers.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107054
+	* simplify.c (gfc_simplify_unpack): Replace assert by condition
+	that terminates simplification when there are not enough elements
+	in the constructor of argument VECTOR.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82868
+	* trans-decl.c (generate_coarray_sym_init): Skip symbol
+	if attr.associate_var.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106985
+	* expr.c (gfc_simplify_expr): Avoid NULL pointer dereference.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103694
+	* simplify.c (simplify_size): The size expression of an array cannot
+	be simplified if an error occurs while resolving the array spec.
+
+2022-09-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106986
+	* simplify.c (gfc_simplify_findloc): Do not try to simplify
+	intrinsic FINDLOC when the ARRAY argument has a NULL shape.
+
+2022-09-24  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-03  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100245
+	* trans-expr.c (trans_class_assignment): Add if clause to handle
+	derived type in the LHS.
+
+2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106857
+	* simplify.c (gfc_simplify_pack): Check for NULL pointer dereferences
+	while walking through constructors (error recovery).
+
+2022-09-05  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-04  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100136
+	* trans-expr.c (gfc_conv_procedure_call): Add handling of pointer
+	expressions.
+
+2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103504
+	* interface.c (get_sym_storage_size): Array bounds and character
+	length can only be of integer type.
+
+2022-07-16  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2022-07-15  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/104313
+	* trans-decl.c (gfc_generate_return): Do not generate conflicting
+	fake results for functions with no result variable under -ff2c.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-30  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103137
+	PR fortran/103138
+	PR fortran/103693
+	PR fortran/105243
+	* decl.c (gfc_match_data_decl): Reject CLASS entity declaration
+	when it is given the PARAMETER attribute.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-29  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/106121
+	* simplify.c (gfc_simplify_extends_type_of): Do not attempt to
+	simplify when one of the arguments is a CLASS variable that was
+	not properly declared.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105954
+	* decl.c (variable_decl): Adjust upper bounds for explicit-shape
+	specs with constant bound expressions to ensure non-negative
+	extents.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105691
+	* simplify.c (gfc_simplify_index): Replace old simplification
+	code by the equivalent of the runtime library implementation.  Use
+	HOST_WIDE_INT instead of int for string index, length variables.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105813
+	* check.c (gfc_check_unpack): Try to simplify MASK argument to
+	UNPACK so that checking of the VECTOR argument can work when MASK
+	is a variable.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-05-11  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105230
+	* expr.c (find_array_section): Correct logic to avoid NULL
+	pointer dereference on invalid array section.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-03-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104849
+	* expr.c (find_array_section): Avoid NULL pointer dereference on
+	invalid array section.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* trans-expr.c (gfc_conv_union_initializer): Pass vec* by reference.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/fortran/arith.c b/gcc/fortran/arith.c
index 8a0d70d23ba..aed449ede89 100644
--- a/gcc/fortran/arith.c
+++ b/gcc/fortran/arith.c
@@ -1080,6 +1080,11 @@ gfc_compare_expr (gfc_expr *op1, gfc_expr *op2, gfc_intrinsic_op op)
 	    || (op1->value.logical && !op2->value.logical));
       break;
 
+    case BT_COMPLEX:
+      gcc_assert (op == INTRINSIC_EQ);
+      rc = mpc_cmp (op1->value.complex, op2->value.complex);
+      break;
+
     default:
       gfc_internal_error ("gfc_compare_expr(): Bad basic type");
     }
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
index b406f6d1f6e..bb6f2bb9045 100644
--- a/gcc/fortran/array.c
+++ b/gcc/fortran/array.c
@@ -492,8 +492,6 @@ match_array_element_spec (gfc_array_spec *as)
   if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))
     return AS_UNKNOWN;
 
-  gfc_try_simplify_expr (*upper, 0);
-
   if (((*upper)->expr_type == EXPR_CONSTANT
 	&& (*upper)->ts.type != BT_INTEGER) ||
       ((*upper)->expr_type == EXPR_FUNCTION
@@ -526,8 +524,6 @@ match_array_element_spec (gfc_array_spec *as)
   if (!gfc_expr_check_typed (*upper, gfc_current_ns, false))
     return AS_UNKNOWN;
 
-  gfc_try_simplify_expr (*upper, 0);
-
   if (((*upper)->expr_type == EXPR_CONSTANT
 	&& (*upper)->ts.type != BT_INTEGER) ||
       ((*upper)->expr_type == EXPR_FUNCTION
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
index 1add9436dce..4e2736fef1e 100644
--- a/gcc/fortran/check.c
+++ b/gcc/fortran/check.c
@@ -6342,6 +6342,8 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)
   if (!same_type_check (vector, 0, field, 2))
     return false;
 
+  gfc_simplify_expr (mask, 0);
+
   if (mask->expr_type == EXPR_ARRAY
       && gfc_array_size (vector, &vector_size))
     {
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index 602ad3e59bd..f21504b939b 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -2050,10 +2050,21 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	  /* The shape may be NULL for EXPR_ARRAY, set it.  */
 	  if (init->shape == NULL)
 	    {
-	      gcc_assert (init->expr_type == EXPR_ARRAY);
+	      if (init->expr_type != EXPR_ARRAY)
+		{
+		  gfc_error ("Bad shape of initializer at %L", &init->where);
+		  return false;
+		}
+
 	      init->shape = gfc_get_shape (1);
 	      if (!gfc_array_size (init, &init->shape[0]))
-		  gfc_internal_error ("gfc_array_size failed");
+		{
+		  gfc_error ("Cannot determine shape of initializer at %L",
+			     &init->where);
+		  free (init->shape);
+		  init->shape = NULL;
+		  return false;
+		}
 	    }
 
 	  for (dim = 0; dim < sym->as->rank; ++dim)
@@ -2130,6 +2141,14 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)
 	    sym->ts.f90_type = init->ts.f90_type;
 	}
 
+      /* Catch the case:  type(t), parameter :: x = z'1'.  */
+      if (sym->ts.type == BT_DERIVED && init->ts.type == BT_BOZ)
+	{
+	  gfc_error ("Entity %qs at %L is incompatible with a BOZ "
+		     "literal constant", name, &sym->declared_at);
+	  return false;
+	}
+
       /* Add initializer.  Make sure we keep the ranks sane.  */
       if (sym->attr.dimension && init->rank == 0)
 	{
@@ -2696,6 +2715,18 @@ variable_decl (int elem)
 		  else
 		    gfc_free_expr (n);
 		}
+	      /* For an explicit-shape spec with constant bounds, ensure
+		 that the effective upper bound is not lower than the
+		 respective lower bound minus one.  Otherwise adjust it so
+		 that the extent is trivially derived to be zero.  */
+	      if (as->lower[i]->expr_type == EXPR_CONSTANT
+		  && as->upper[i]->expr_type == EXPR_CONSTANT
+		  && as->lower[i]->ts.type == BT_INTEGER
+		  && as->upper[i]->ts.type == BT_INTEGER
+		  && mpz_cmp (as->upper[i]->value.integer,
+			      as->lower[i]->value.integer) < 0)
+		mpz_sub_ui (as->upper[i]->value.integer,
+			    as->lower[i]->value.integer, 1);
 	    }
 	}
     }
@@ -6169,6 +6200,14 @@ gfc_match_data_decl (void)
       goto cleanup;
     }
 
+  /* F2018:C708.  */
+  if (current_ts.type == BT_CLASS && current_attr.flavor == FL_PARAMETER)
+    {
+      gfc_error ("CLASS entity at %C cannot have the PARAMETER attribute");
+      m = MATCH_ERROR;
+      goto cleanup;
+    }
+
   if (current_ts.type == BT_CLASS
 	&& current_ts.u.derived->attr.unlimited_polymorphic)
     goto ok;
@@ -9871,9 +9910,10 @@ gfc_match_modproc (void)
   gfc_namespace *module_ns;
   gfc_interface *old_interface_head, *interface;
 
-  if ((gfc_state_stack->state != COMP_INTERFACE
-       && gfc_state_stack->state != COMP_CONTAINS)
-      || gfc_state_stack->previous == NULL
+  if (gfc_state_stack->previous == NULL
+      || (gfc_state_stack->state != COMP_INTERFACE
+	  && (gfc_state_stack->state != COMP_CONTAINS
+	      || gfc_state_stack->previous->state != COMP_INTERFACE))
       || current_interface.type == INTERFACE_NAMELESS
       || current_interface.type == INTERFACE_ABSTRACT)
     {
diff --git a/gcc/fortran/dependency.c b/gcc/fortran/dependency.c
index e1336e1c654..7a3cc82a5b2 100644
--- a/gcc/fortran/dependency.c
+++ b/gcc/fortran/dependency.c
@@ -1292,6 +1292,11 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)
   if (expr1->expr_type != EXPR_VARIABLE)
     gfc_internal_error ("gfc_check_dependency: expecting an EXPR_VARIABLE");
 
+  /* Prevent NULL pointer dereference while recursively analyzing invalid
+     expressions.  */
+  if (expr2 == NULL)
+    return 0;
+
   switch (expr2->expr_type)
     {
     case EXPR_OP:
diff --git a/gcc/fortran/dump-parse-tree.c b/gcc/fortran/dump-parse-tree.c
index 059d8421bb5..4e210a0e87f 100644
--- a/gcc/fortran/dump-parse-tree.c
+++ b/gcc/fortran/dump-parse-tree.c
@@ -3349,7 +3349,12 @@ get_c_type_name (gfc_typespec *ts, gfc_array_spec *as, const char **pre,
 	  if (c_interop_kinds_table[i].f90_type == ts->type
 	      && c_interop_kinds_table[i].value == ts->kind)
 	    {
+	      /* Skip over 'c_'. */
 	      *type_name = c_interop_kinds_table[i].name + 2;
+	      if (strcmp (*type_name, "long_long") == 0)
+		*type_name = "long long";
+	      if (strcmp (*type_name, "long_double") == 0)
+		*type_name = "long double";
 	      if (strcmp (*type_name, "signed_char") == 0)
 		*type_name = "signed char";
 	      else if (strcmp (*type_name, "size_t") == 0)
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index edacd974a21..0b9458f82ac 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -1549,6 +1549,16 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)
       lower = ref->u.ar.as->lower[d];
       upper = ref->u.ar.as->upper[d];
 
+      if (!lower || !upper
+	  || lower->expr_type != EXPR_CONSTANT
+	  || upper->expr_type != EXPR_CONSTANT
+	  || lower->ts.type != BT_INTEGER
+	  || upper->ts.type != BT_INTEGER)
+	{
+	  t = false;
+	  goto cleanup;
+	}
+
       if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR)  /* Vector subscript.  */
 	{
 	  gfc_constructor *ci;
@@ -2281,7 +2291,8 @@ gfc_simplify_expr (gfc_expr *p, int type)
 	 initialization expression, or we want a subsection.  */
       if (p->symtree->n.sym->attr.flavor == FL_PARAMETER
 	  && (gfc_init_expr_flag || p->ref
-	      || p->symtree->n.sym->value->expr_type != EXPR_ARRAY))
+	      || (p->symtree->n.sym->value
+		  && p->symtree->n.sym->value->expr_type != EXPR_ARRAY)))
 	{
 	  if (!simplify_parameter_variable (p, type))
 	    return false;
@@ -6224,7 +6235,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,
       && !(sym->attr.flavor == FL_PROCEDURE && sym == sym->result)
       && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.proc_pointer)
       && !(sym->attr.flavor == FL_PROCEDURE
-	   && sym->attr.function && sym->attr.pointer))
+	   && sym->attr.function && attr.pointer))
     {
       if (context)
 	gfc_error ("%qs in variable definition context (%s) at %L is not"
diff --git a/gcc/fortran/f95-lang.c b/gcc/fortran/f95-lang.c
index a346457b5e0..b11cff6559b 100644
--- a/gcc/fortran/f95-lang.c
+++ b/gcc/fortran/f95-lang.c
@@ -696,31 +696,34 @@ gfc_init_builtin_functions (void)
                                                 float_type_node, NULL_TREE);
 
   func_cdouble_double = build_function_type_list (double_type_node,
-                                                  complex_double_type_node,
-                                                  NULL_TREE);
+						  complex_double_type_node,
+						  NULL_TREE);
 
   func_double_cdouble = build_function_type_list (complex_double_type_node,
-                                                  double_type_node, NULL_TREE);
+						  double_type_node, NULL_TREE);
 
-  func_clongdouble_longdouble =
-    build_function_type_list (long_double_type_node,
-                              complex_long_double_type_node, NULL_TREE);
+  func_clongdouble_longdouble
+    = build_function_type_list (long_double_type_node,
+				complex_long_double_type_node, NULL_TREE);
 
-  func_longdouble_clongdouble =
-    build_function_type_list (complex_long_double_type_node,
-                              long_double_type_node, NULL_TREE);
+  func_longdouble_clongdouble
+    = build_function_type_list (complex_long_double_type_node,
+				long_double_type_node, NULL_TREE);
 
   ptype = build_pointer_type (float_type_node);
-  func_float_floatp_floatp =
-    build_function_type_list (void_type_node, ptype, ptype, NULL_TREE);
+  func_float_floatp_floatp
+    = build_function_type_list (void_type_node, float_type_node, ptype, ptype,
+				NULL_TREE);
 
   ptype = build_pointer_type (double_type_node);
-  func_double_doublep_doublep =
-    build_function_type_list (void_type_node, ptype, ptype, NULL_TREE);
+  func_double_doublep_doublep
+    = build_function_type_list (void_type_node, double_type_node, ptype,
+				ptype, NULL_TREE);
 
   ptype = build_pointer_type (long_double_type_node);
-  func_longdouble_longdoublep_longdoublep =
-    build_function_type_list (void_type_node, ptype, ptype, NULL_TREE);
+  func_longdouble_longdoublep_longdoublep
+    = build_function_type_list (void_type_node, long_double_type_node, ptype,
+				ptype, NULL_TREE);
 
 /* Non-math builtins are defined manually, so they're not included here.  */
 #define OTHER_BUILTIN(ID,NAME,TYPE,CONST)
@@ -974,9 +977,8 @@ gfc_init_builtin_functions (void)
 		      "calloc", ATTR_NOTHROW_LEAF_MALLOC_LIST);
   DECL_IS_MALLOC (builtin_decl_explicit (BUILT_IN_CALLOC)) = 1;
 
-  ftype = build_function_type_list (pvoid_type_node,
-                                    size_type_node, pvoid_type_node,
-                                    NULL_TREE);
+  ftype = build_function_type_list (pvoid_type_node, pvoid_type_node,
+				    size_type_node, NULL_TREE);
   gfc_define_builtin ("__builtin_realloc", ftype, BUILT_IN_REALLOC,
 		      "realloc", ATTR_NOTHROW_LEAF_LIST);
 
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index ad1ba397803..ebc5a7f3699 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -1326,7 +1326,7 @@ traverse_io_block (gfc_code *code, bool *has_reached, gfc_code *prev)
       if (iters[i])
 	{
 	  gfc_expr *var = iters[i]->var;
-	  for (int j = i - 1; j < i; j++)
+	  for (int j = 0; j < i; j++)
 	    {
 	      if (iters[j]
 		  && (var_in_expr (var, iters[j]->start)
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
index 9e3e8aa9da9..150f3def319 100644
--- a/gcc/fortran/interface.c
+++ b/gcc/fortran/interface.c
@@ -2760,7 +2760,8 @@ get_sym_storage_size (gfc_symbol *sym)
   if (sym->ts.type == BT_CHARACTER)
     {
       if (sym->ts.u.cl && sym->ts.u.cl->length
-          && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
+	  && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	  && sym->ts.u.cl->length->ts.type == BT_INTEGER)
 	strlen = mpz_get_ui (sym->ts.u.cl->length->value.integer);
       else
 	return 0;
@@ -2777,7 +2778,9 @@ get_sym_storage_size (gfc_symbol *sym)
   for (i = 0; i < sym->as->rank; i++)
     {
       if (sym->as->upper[i]->expr_type != EXPR_CONSTANT
-	  || sym->as->lower[i]->expr_type != EXPR_CONSTANT)
+	  || sym->as->lower[i]->expr_type != EXPR_CONSTANT
+	  || sym->as->upper[i]->ts.type != BT_INTEGER
+	  || sym->as->lower[i]->ts.type != BT_INTEGER)
 	return 0;
 
       elements *= mpz_get_si (sym->as->upper[i]->value.integer)
@@ -2808,7 +2811,8 @@ get_expr_storage_size (gfc_expr *e)
   if (e->ts.type == BT_CHARACTER)
     {
       if (e->ts.u.cl && e->ts.u.cl->length
-          && e->ts.u.cl->length->expr_type == EXPR_CONSTANT)
+	  && e->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	  && e->ts.u.cl->length->ts.type == BT_INTEGER)
 	strlen = mpz_get_si (e->ts.u.cl->length->value.integer);
       else if (e->expr_type == EXPR_CONSTANT
 	       && (e->ts.u.cl == NULL || e->ts.u.cl->length == NULL))
@@ -2859,7 +2863,8 @@ get_expr_storage_size (gfc_expr *e)
 
 	    if (ref->u.ar.stride[i])
 	      {
-		if (ref->u.ar.stride[i]->expr_type == EXPR_CONSTANT)
+		if (ref->u.ar.stride[i]->expr_type == EXPR_CONSTANT
+		    && ref->u.ar.stride[i]->ts.type == BT_INTEGER)
 		  stride = mpz_get_si (ref->u.ar.stride[i]->value.integer);
 		else
 		  return 0;
@@ -2867,26 +2872,30 @@ get_expr_storage_size (gfc_expr *e)
 
 	    if (ref->u.ar.start[i])
 	      {
-		if (ref->u.ar.start[i]->expr_type == EXPR_CONSTANT)
+		if (ref->u.ar.start[i]->expr_type == EXPR_CONSTANT
+		    && ref->u.ar.start[i]->ts.type == BT_INTEGER)
 		  start = mpz_get_si (ref->u.ar.start[i]->value.integer);
 		else
 		  return 0;
 	      }
 	    else if (ref->u.ar.as->lower[i]
-		     && ref->u.ar.as->lower[i]->expr_type == EXPR_CONSTANT)
+		     && ref->u.ar.as->lower[i]->expr_type == EXPR_CONSTANT
+		     && ref->u.ar.as->lower[i]->ts.type == BT_INTEGER)
 	      start = mpz_get_si (ref->u.ar.as->lower[i]->value.integer);
 	    else
 	      return 0;
 
 	    if (ref->u.ar.end[i])
 	      {
-		if (ref->u.ar.end[i]->expr_type == EXPR_CONSTANT)
+		if (ref->u.ar.end[i]->expr_type == EXPR_CONSTANT
+		    && ref->u.ar.end[i]->ts.type == BT_INTEGER)
 		  end = mpz_get_si (ref->u.ar.end[i]->value.integer);
 		else
 		  return 0;
 	      }
 	    else if (ref->u.ar.as->upper[i]
-		     && ref->u.ar.as->upper[i]->expr_type == EXPR_CONSTANT)
+		     && ref->u.ar.as->upper[i]->expr_type == EXPR_CONSTANT
+		     && ref->u.ar.as->upper[i]->ts.type == BT_INTEGER)
 	      end = mpz_get_si (ref->u.ar.as->upper[i]->value.integer);
 	    else
 	      return 0;
@@ -2927,7 +2936,9 @@ get_expr_storage_size (gfc_expr *e)
 		  || ref->u.ar.as->upper[i] == NULL
 		  || ref->u.ar.as->lower[i] == NULL
 		  || ref->u.ar.as->upper[i]->expr_type != EXPR_CONSTANT
-		  || ref->u.ar.as->lower[i]->expr_type != EXPR_CONSTANT)
+		  || ref->u.ar.as->lower[i]->expr_type != EXPR_CONSTANT
+		  || ref->u.ar.as->upper[i]->ts.type != BT_INTEGER
+		  || ref->u.ar.as->lower[i]->ts.type != BT_INTEGER)
 		return 0;
 
 	      elements
@@ -2949,7 +2960,9 @@ get_expr_storage_size (gfc_expr *e)
 	    {
 	      if (!as->upper[i] || !as->lower[i]
 		  || as->upper[i]->expr_type != EXPR_CONSTANT
-		  || as->lower[i]->expr_type != EXPR_CONSTANT)
+		  || as->lower[i]->expr_type != EXPR_CONSTANT
+		  || as->upper[i]->ts.type != BT_INTEGER
+		  || as->lower[i]->ts.type != BT_INTEGER)
 		return 0;
 
 	      elements = elements
@@ -3973,6 +3986,14 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 	      return false;
 	    }
 
+	  if (a->expr && a->expr->expr_type == EXPR_NULL)
+	    {
+	      gfc_error ("Passing intrinsic NULL as actual argument at %L "
+			 "requires an explicit interface", &a->expr->where);
+	      a->expr->error = 1;
+	      return false;
+	    }
+
 	  /* TS 29113, C407b.  */
 	  if (a->expr && a->expr->expr_type == EXPR_VARIABLE
 	      && symbol_rank (a->expr->symtree->n.sym) == -1)
diff --git a/gcc/fortran/iresolve.c b/gcc/fortran/iresolve.c
index 598c0409b66..03db23b5b45 100644
--- a/gcc/fortran/iresolve.c
+++ b/gcc/fortran/iresolve.c
@@ -94,9 +94,12 @@ check_charlen_present (gfc_expr *source)
   else if (source->expr_type == EXPR_ARRAY)
     {
       gfc_constructor *c = gfc_constructor_first (source->value.constructor);
-      source->ts.u.cl->length
-		= gfc_get_int_expr (gfc_charlen_int_kind, NULL,
-				    c->expr->value.character.length);
+      if (c)
+	source->ts.u.cl->length
+	  = gfc_get_int_expr (gfc_charlen_int_kind, NULL,
+			      c->expr->value.character.length);
+      if (source->ts.u.cl->length == NULL)
+	gfc_internal_error ("check_charlen_present(): length not set");
     }
 }
 
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index 860b6567d2a..91b31e06e56 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -5299,6 +5299,16 @@ gfc_match_common (void)
 		goto cleanup;
 	    }
 
+	  /* F2018:R874:  common-block-object is variable-name [ (array-spec) ]
+	     F2018:C8121: A variable-name shall not be a name made accessible
+	     by use association.  */
+	  if (sym->attr.use_assoc)
+	    {
+	      gfc_error ("Symbol %qs at %C is USE associated from module %qs "
+			 "and cannot occur in COMMON", sym->name, sym->module);
+	      goto cleanup;
+	    }
+
 	  /* Deal with an optional array specification after the
 	     symbol name.  */
 	  m = gfc_match_array_spec (&as, true, true);
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 04501f44ef8..6893557733b 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -3747,21 +3747,30 @@ match_deferred_characteristics (gfc_typespec * ts)
    For return types specified in a FUNCTION prefix, the IMPLICIT rules of the
    scope are not yet parsed so this has to be delayed up to parse_spec.  */
 
-static void
+static bool
 check_function_result_typed (void)
 {
   gfc_typespec ts;
 
   gcc_assert (gfc_current_state () == COMP_FUNCTION);
 
-  if (!gfc_current_ns->proc_name->result) return;
+  if (!gfc_current_ns->proc_name->result)
+    return true;
 
   ts = gfc_current_ns->proc_name->result->ts;
 
   /* Check type-parameters, at the moment only CHARACTER lengths possible.  */
   /* TODO:  Extend when KIND type parameters are implemented.  */
   if (ts.type == BT_CHARACTER && ts.u.cl && ts.u.cl->length)
-    gfc_expr_check_typed (ts.u.cl->length, gfc_current_ns, true);
+    {
+      /* Reject invalid type of specification expression for length.  */
+      if (ts.u.cl->length->ts.type != BT_INTEGER)
+	  return false;
+
+      gfc_expr_check_typed (ts.u.cl->length, gfc_current_ns, true);
+    }
+
+  return true;
 }
 
 
@@ -3869,10 +3878,7 @@ loop:
 	}
 
       if (verify_now)
-	{
-	  check_function_result_typed ();
-	  function_result_typed = true;
-	}
+	function_result_typed = check_function_result_typed ();
     }
 
   switch (st)
@@ -3883,10 +3889,7 @@ loop:
     case ST_IMPLICIT_NONE:
     case ST_IMPLICIT:
       if (!function_result_typed)
-	{
-	  check_function_result_typed ();
-	  function_result_typed = true;
-	}
+	function_result_typed = check_function_result_typed ();
       goto declSt;
 
     case ST_FORMAT:
@@ -6157,7 +6160,6 @@ parse_module (void)
 {
   gfc_statement st;
   gfc_gsymbol *s;
-  bool error;
 
   s = gfc_get_gsymbol (gfc_new_block->name, false);
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_MODULE))
@@ -6180,7 +6182,6 @@ parse_module (void)
 
   st = parse_spec (ST_NONE);
 
-  error = false;
 loop:
   switch (st)
     {
@@ -6199,16 +6200,11 @@ loop:
     default:
       gfc_error ("Unexpected %s statement in MODULE at %C",
 		 gfc_ascii_statement (st));
-
-      error = true;
       reject_statement ();
       st = next_statement ();
       goto loop;
     }
-
-  /* Make sure not to free the namespace twice on error.  */
-  if (!error)
-    s->ns = gfc_current_ns;
+  s->ns = gfc_current_ns;
 }
 
 
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
index 1b93f96367f..5cad2d2682b 100644
--- a/gcc/fortran/primary.c
+++ b/gcc/fortran/primary.c
@@ -3188,10 +3188,11 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c
 	goto cleanup;
 
       /* For a constant string constructor, make sure the length is
-	 correct; truncate of fill with blanks if needed.  */
+	 correct; truncate or fill with blanks if needed.  */
       if (this_comp->ts.type == BT_CHARACTER && !this_comp->attr.allocatable
 	  && this_comp->ts.u.cl && this_comp->ts.u.cl->length
 	  && this_comp->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	  && this_comp->ts.u.cl->length->ts.type == BT_INTEGER
 	  && actual->expr->ts.type == BT_CHARACTER
 	  && actual->expr->expr_type == EXPR_CONSTANT)
 	{
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index a26a90993a7..bc38444ea75 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -953,9 +953,15 @@ resolve_common_vars (gfc_common_head *common_block, bool named_common)
     {
       gsym = gfc_find_gsymbol (gfc_gsym_root, csym->name);
       if (gsym && (gsym->type == GSYM_MODULE || gsym->type == GSYM_PROGRAM))
-	gfc_error_now ("Global entity %qs at %L cannot appear in a "
-			"COMMON block at %L", gsym->name,
-			&gsym->where, &csym->common_block->where);
+	{
+	  if (csym->common_block)
+	    gfc_error_now ("Global entity %qs at %L cannot appear in a "
+			   "COMMON block at %L", gsym->name,
+			   &gsym->where, &csym->common_block->where);
+	  else
+	    gfc_error_now ("Global entity %qs at %L cannot appear in a "
+			   "COMMON block", gsym->name, &gsym->where);
+	}
 
       /* gfc_add_in_common may have been called before, but the reported errors
 	 have been ignored to continue parsing.
@@ -4543,12 +4549,11 @@ compare_bound_int (gfc_expr *a, int b)
 {
   int i;
 
-  if (a == NULL || a->expr_type != EXPR_CONSTANT)
+  if (a == NULL
+      || a->expr_type != EXPR_CONSTANT
+      || a->ts.type != BT_INTEGER)
     return CMP_UNKNOWN;
 
-  if (a->ts.type != BT_INTEGER)
-    gfc_internal_error ("compare_bound_int(): Bad expression");
-
   i = mpz_cmp_si (a->value.integer, b);
 
   if (i < 0)
@@ -4566,12 +4571,11 @@ compare_bound_mpz_t (gfc_expr *a, mpz_t b)
 {
   int i;
 
-  if (a == NULL || a->expr_type != EXPR_CONSTANT)
+  if (a == NULL
+      || a->expr_type != EXPR_CONSTANT
+      || a->ts.type != BT_INTEGER)
     return CMP_UNKNOWN;
 
-  if (a->ts.type != BT_INTEGER)
-    gfc_internal_error ("compare_bound_int(): Bad expression");
-
   i = mpz_cmp (a->value.integer, b);
 
   if (i < 0)
@@ -4701,23 +4705,24 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)
 #define AR_END (ar->end[i] ? ar->end[i] : as->upper[i])
 
 	compare_result comp_start_end = compare_bound (AR_START, AR_END);
+	compare_result comp_stride_zero = compare_bound_int (ar->stride[i], 0);
 
 	/* Check for zero stride, which is not allowed.  */
-	if (compare_bound_int (ar->stride[i], 0) == CMP_EQ)
+	if (comp_stride_zero == CMP_EQ)
 	  {
 	    gfc_error ("Illegal stride of zero at %L", &ar->c_where[i]);
 	    return false;
 	  }
 
-	/* if start == len || (stride > 0 && start < len)
-			   || (stride < 0 && start > len),
+	/* if start == end || (stride > 0 && start < end)
+			   || (stride < 0 && start > end),
 	   then the array section contains at least one element.  In this
 	   case, there is an out-of-bounds access if
 	   (start < lower || start > upper).  */
-	if (compare_bound (AR_START, AR_END) == CMP_EQ
-	    || ((compare_bound_int (ar->stride[i], 0) == CMP_GT
-		 || ar->stride[i] == NULL) && comp_start_end == CMP_LT)
-	    || (compare_bound_int (ar->stride[i], 0) == CMP_LT
+	if (comp_start_end == CMP_EQ
+	    || ((comp_stride_zero == CMP_GT || ar->stride[i] == NULL)
+		&& comp_start_end == CMP_LT)
+	    || (comp_stride_zero == CMP_LT
 	        && comp_start_end == CMP_GT))
 	  {
 	    if (compare_bound (AR_START, as->lower[i]) == CMP_LT)
@@ -7497,7 +7502,8 @@ derived_inaccessible (gfc_symbol *sym)
   for (c = sym->components; c; c = c->next)
     {
 	/* Prevent an infinite loop through this function.  */
-	if (c->ts.type == BT_DERIVED && c->attr.pointer
+	if (c->ts.type == BT_DERIVED
+	    && (c->attr.pointer || c->attr.allocatable)
 	    && sym == c->ts.u.derived)
 	  continue;
 
@@ -9858,11 +9864,6 @@ resolve_select_rank (gfc_code *code, gfc_namespace *old_ns)
 			       || gfc_expr_attr (code->expr1).pointer))
 	gfc_error ("RANK (*) at %L cannot be used with the pointer or "
 		   "allocatable selector at %L", &c->where, &code->expr1->where);
-
-      if (case_value == -1 && (gfc_expr_attr (code->expr1).allocatable
-			       || gfc_expr_attr (code->expr1).pointer))
-	gfc_error ("RANK (*) at %L cannot be used with the pointer or "
-		   "allocatable selector at %L", &c->where, &code->expr1->where);
     }
 
   /* Add EXEC_SELECT to switch on rank.  */
@@ -12800,7 +12801,10 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)
 
       if (allocatable)
 	{
-	  if (dimension && as->type != AS_ASSUMED_RANK)
+	  if (dimension
+	      && as
+	      && as->type != AS_ASSUMED_RANK
+	      && !sym->attr.select_rank_temporary)
 	    {
 	      gfc_error ("Allocatable array %qs at %L must have a deferred "
 			 "shape or assumed rank", sym->name, &sym->declared_at);
@@ -13510,6 +13514,16 @@ check_formal:
 	    }
 	}
     }
+
+  /* F2018:15.4.2.2 requires an explicit interface for procedures with the
+     BIND(C) attribute.  */
+  if (sym->attr.is_bind_c && sym->attr.if_source == IFSRC_UNKNOWN)
+    {
+      gfc_error ("Interface of %qs at %L must be explicit",
+		 sym->name, &sym->declared_at);
+      return false;
+    }
+
   return true;
 }
 
@@ -14741,6 +14755,19 @@ resolve_component (gfc_component *c, gfc_symbol *sym)
                     c->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);
          return false;
        }
+
+     if (c->ts.u.cl->length && c->ts.u.cl->length->ts.type != BT_INTEGER)
+       {
+	 if (!c->ts.u.cl->length->error)
+	   {
+	     gfc_error ("Character length expression of component %qs at %L "
+			"must be of INTEGER type, found %s",
+			c->name, &c->ts.u.cl->length->where,
+			gfc_basic_typename (c->ts.u.cl->length->ts.type));
+	     c->ts.u.cl->length->error = 1;
+	   }
+	 return false;
+       }
     }
 
   if (c->ts.type == BT_CHARACTER && c->ts.deferred
@@ -15759,8 +15786,8 @@ resolve_symbol (gfc_symbol *sym)
 
       /* First, make sure the variable is declared at the
 	 module-level scope (J3/04-007, Section 15.3).	*/
-      if (sym->ns->proc_name->attr.flavor != FL_MODULE &&
-          sym->attr.in_common == 0)
+      if (!(sym->ns->proc_name && sym->ns->proc_name->attr.flavor == FL_MODULE)
+	  && !sym->attr.in_common)
 	{
 	  gfc_error ("Variable %qs at %L cannot be BIND(C) because it "
 		     "is neither a COMMON block nor declared at the "
@@ -17254,7 +17281,9 @@ resolve_fntype (gfc_namespace *ns)
 	  }
       }
 
-  if (sym->ts.type == BT_CHARACTER)
+  if (sym->ts.type == BT_CHARACTER
+      && sym->ts.u.cl->length
+      && sym->ts.u.cl->length->ts.type == BT_INTEGER)
     gfc_traverse_expr (sym->ts.u.cl->length, sym, flag_fn_result_spec, 0);
 }
 
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index 3599e1b3194..885f672e389 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -708,6 +708,7 @@ simplify_transformation (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,
   size_zero = gfc_is_size_zero_array (array);
 
   if (!(is_constant_array_expr (array) || size_zero)
+      || array->shape == NULL
       || !gfc_is_constant_expr (dim))
     return NULL;
 
@@ -3092,6 +3093,10 @@ gfc_simplify_extends_type_of (gfc_expr *a, gfc_expr *mold)
   if (UNLIMITED_POLY (a) || UNLIMITED_POLY (mold))
     return NULL;
 
+  if ((a->ts.type == BT_CLASS && !gfc_expr_attr (a).class_ok)
+      || (mold->ts.type == BT_CLASS && !gfc_expr_attr (mold).class_ok))
+    return NULL;
+
   /* Return .false. if the dynamic type can never be an extension.  */
   if ((a->ts.type == BT_CLASS && mold->ts.type == BT_CLASS
        && !gfc_type_is_extension_of
@@ -3502,17 +3507,15 @@ gfc_expr *
 gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)
 {
   gfc_expr *result;
-  int back, len, lensub;
-  int i, j, k, count, index = 0, start;
+  bool back;
+  HOST_WIDE_INT len, lensub, start, last, i, index = 0;
+  int k, delta;
 
   if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT
       || ( b != NULL && b->expr_type !=  EXPR_CONSTANT))
     return NULL;
 
-  if (b != NULL && b->value.logical != 0)
-    back = 1;
-  else
-    back = 0;
+  back = (b != NULL && b->value.logical != 0);
 
   k = get_kind (BT_INTEGER, kind, "INDEX", gfc_default_integer_kind);
   if (k == -1)
@@ -3529,111 +3532,40 @@ gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)
       return result;
     }
 
-  if (back == 0)
+  if (lensub == 0)
     {
-      if (lensub == 0)
-	{
-	  mpz_set_si (result->value.integer, 1);
-	  return result;
-	}
-      else if (lensub == 1)
-	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[i])
-		    {
-		      index = i + 1;
-		      goto done;
-		    }
-		}
-	    }
-	}
+      if (back)
+	index = len + 1;
       else
-	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[i])
-		    {
-		      start = i;
-		      count = 0;
-
-		      for (k = 0; k < lensub; k++)
-			{
-			  if (y->value.character.string[k]
-			      == x->value.character.string[k + start])
-			    count++;
-			}
-
-		      if (count == lensub)
-			{
-			  index = start + 1;
-			  goto done;
-			}
-		    }
-		}
-	    }
-	}
+	index = 1;
+      goto done;
+    }
 
+  if (!back)
+    {
+      last = len + 1 - lensub;
+      start = 0;
+      delta = 1;
     }
   else
     {
-      if (lensub == 0)
-	{
-	  mpz_set_si (result->value.integer, len + 1);
-	  return result;
-	}
-      else if (lensub == 1)
-	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[len - i])
-		    {
-		      index = len - i + 1;
-		      goto done;
-		    }
-		}
-	    }
-	}
-      else
-	{
-	  for (i = 0; i < len; i++)
-	    {
-	      for (j = 0; j < lensub; j++)
-		{
-		  if (y->value.character.string[j]
-		      == x->value.character.string[len - i])
-		    {
-		      start = len - i;
-		      if (start <= len - lensub)
-			{
-			  count = 0;
-			  for (k = 0; k < lensub; k++)
-			    if (y->value.character.string[k]
-			        == x->value.character.string[k + start])
-			      count++;
+      last = -1;
+      start = len - lensub;
+      delta = -1;
+    }
 
-			  if (count == lensub)
-			    {
-			      index = start + 1;
-			      goto done;
-			    }
-			}
-		      else
-			{
-			  continue;
-			}
-		    }
-		}
-	    }
+  for (; start != last; start += delta)
+    {
+      for (i = 0; i < lensub; i++)
+	{
+	  if (x->value.character.string[start + i]
+	      != y->value.character.string[i])
+	    break;
+	}
+      if (i == lensub)
+	{
+	  index = start + 1;
+	  goto done;
 	}
     }
 
@@ -5915,6 +5847,7 @@ gfc_simplify_findloc (gfc_expr *array, gfc_expr *value, gfc_expr *dim,
   bool back_val = false;
 
   if (!is_constant_array_expr (array)
+      || array->shape == NULL
       || !gfc_is_constant_expr (dim))
     return NULL;
 
@@ -6114,7 +6047,7 @@ gfc_simplify_nearest (gfc_expr *x, gfc_expr *s)
   kind = gfc_validate_kind (BT_REAL, x->ts.kind, 0);
   mpfr_set_emin ((mpfr_exp_t) gfc_real_kinds[kind].min_exponent -
 		mpfr_get_prec(result->value.real) + 1);
-  mpfr_set_emax ((mpfr_exp_t) gfc_real_kinds[kind].max_exponent - 1);
+  mpfr_set_emax ((mpfr_exp_t) gfc_real_kinds[kind].max_exponent);
   mpfr_check_range (result->value.real, 0, MPFR_RNDU);
 
   if (mpfr_sgn (s->value.real) > 0)
@@ -6451,7 +6384,7 @@ gfc_simplify_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)
       /* Copy only those elements of ARRAY to RESULT whose
 	 MASK equals .TRUE..  */
       mask_ctor = gfc_constructor_first (mask->value.constructor);
-      while (mask_ctor)
+      while (mask_ctor && array_ctor)
 	{
 	  if (mask_ctor->expr->value.logical)
 	    {
@@ -7364,7 +7297,7 @@ gfc_simplify_set_exponent (gfc_expr *x, gfc_expr *i)
 {
   gfc_expr *result;
   mpfr_t exp, absv, log2, pow2, frac;
-  unsigned long exp2;
+  long exp2;
 
   if (x->expr_type != EXPR_CONSTANT || i->expr_type != EXPR_CONSTANT)
     return NULL;
@@ -7396,19 +7329,19 @@ gfc_simplify_set_exponent (gfc_expr *x, gfc_expr *i)
   mpfr_abs (absv, x->value.real, GFC_RND_MODE);
   mpfr_log2 (log2, absv, GFC_RND_MODE);
 
-  mpfr_trunc (log2, log2);
+  mpfr_floor (log2, log2);
   mpfr_add_ui (exp, log2, 1, GFC_RND_MODE);
 
   /* Old exponent value, and fraction.  */
   mpfr_ui_pow (pow2, 2, exp, GFC_RND_MODE);
 
-  mpfr_div (frac, absv, pow2, GFC_RND_MODE);
+  mpfr_div (frac, x->value.real, pow2, GFC_RND_MODE);
 
   /* New exponent.  */
-  exp2 = (unsigned long) mpz_get_d (i->value.integer);
-  mpfr_mul_2exp (result->value.real, frac, exp2, GFC_RND_MODE);
+  exp2 = mpz_get_si (i->value.integer);
+  mpfr_mul_2si (result->value.real, frac, exp2, GFC_RND_MODE);
 
-  mpfr_clears (absv, log2, pow2, frac, NULL);
+  mpfr_clears (absv, log2, exp, pow2, frac, NULL);
 
   return range_check (result, "SET_EXPONENT");
 }
@@ -7556,8 +7489,9 @@ simplify_size (gfc_expr *array, gfc_expr *dim, int k)
     }
 
   for (ref = array->ref; ref; ref = ref->next)
-    if (ref->type == REF_ARRAY && ref->u.ar.as)
-      gfc_resolve_array_spec (ref->u.ar.as, 0);
+    if (ref->type == REF_ARRAY && ref->u.ar.as
+	&& !gfc_resolve_array_spec (ref->u.ar.as, 0))
+      return NULL;
 
   if (dim == NULL)
     {
@@ -8476,9 +8410,16 @@ gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)
     {
       if (mask_ctor->expr->value.logical)
 	{
-	  gcc_assert (vector_ctor);
-	  e = gfc_copy_expr (vector_ctor->expr);
-	  vector_ctor = gfc_constructor_next (vector_ctor);
+	  if (vector_ctor)
+	    {
+	      e = gfc_copy_expr (vector_ctor->expr);
+	      vector_ctor = gfc_constructor_next (vector_ctor);
+	    }
+	  else
+	    {
+	      gfc_free_expr (result);
+	      return NULL;
+	    }
 	}
       else if (field->expr_type == EXPR_ARRAY)
 	e = gfc_copy_expr (field_ctor->expr);
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index c2dad08d878..56ad114d84f 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -4705,6 +4705,13 @@ gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src,
       formal_arg->sym->attr.flavor = FL_VARIABLE;
       formal_arg->sym->attr.dummy = 1;
 
+      /* Do not treat an actual deferred-length character argument wrongly
+	 as template for the formal argument.  */
+      if (formal_arg->sym->ts.type == BT_CHARACTER
+	  && !(formal_arg->sym->attr.allocatable
+	       || formal_arg->sym->attr.pointer))
+	formal_arg->sym->ts.deferred = false;
+
       if (formal_arg->sym->ts.type == BT_CHARACTER)
 	formal_arg->sym->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);
 
@@ -5146,6 +5153,10 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)
   bool is_union1 = (ts1->type == BT_UNION);
   bool is_union2 = (ts2->type == BT_UNION);
 
+  /* A boz-literal-constant has no type.  */
+  if (ts1->type == BT_BOZ || ts2->type == BT_BOZ)
+    return false;
+
   if (is_class1
       && ts1->u.derived->components
       && ((ts1->u.derived->attr.is_class
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
index ad6a30a47ca..abdecc7df7a 100644
--- a/gcc/fortran/trans-array.c
+++ b/gcc/fortran/trans-array.c
@@ -10795,6 +10795,52 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,
 }
 
 
+/* Initialize class descriptor's TKR infomation.  */
+
+void
+gfc_trans_class_array (gfc_symbol * sym, gfc_wrapped_block * block)
+{
+  tree type, etype;
+  tree tmp;
+  tree descriptor;
+  stmtblock_t init;
+  locus loc;
+  int rank;
+
+  /* Make sure the frontend gets these right.  */
+  gcc_assert (sym->ts.type == BT_CLASS && CLASS_DATA (sym)
+	      && (CLASS_DATA (sym)->attr.class_pointer
+		  || CLASS_DATA (sym)->attr.allocatable));
+
+  gcc_assert (VAR_P (sym->backend_decl)
+	      || TREE_CODE (sym->backend_decl) == PARM_DECL);
+
+  if (sym->attr.dummy)
+    return;
+
+  descriptor = gfc_class_data_get (sym->backend_decl);
+  type = TREE_TYPE (descriptor);
+
+  if (type == NULL || !GFC_DESCRIPTOR_TYPE_P (type))
+    return;
+
+  gfc_save_backend_locus (&loc);
+  gfc_set_backend_locus (&sym->declared_at);
+  gfc_init_block (&init);
+
+  rank = CLASS_DATA (sym)->as ? (CLASS_DATA (sym)->as->rank) : (0);
+  gcc_assert (rank>=0);
+  tmp = gfc_conv_descriptor_dtype (descriptor);
+  etype = gfc_get_element_type (type);
+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, TREE_TYPE (tmp), tmp,
+			 gfc_get_dtype_rank_type (rank, etype));
+  gfc_add_expr_to_block (&init, tmp);
+
+  gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);
+  gfc_restore_backend_locus (&loc);
+}
+
+
 /* NULLIFY an allocatable/pointer array on function entry, free it on exit.
    Do likewise, recursively if necessary, with the allocatable components of
    derived types.  This function is also called for assumed-rank arrays, which
diff --git a/gcc/fortran/trans-array.h b/gcc/fortran/trans-array.h
index def6f8a43a0..0ec77cf27e1 100644
--- a/gcc/fortran/trans-array.h
+++ b/gcc/fortran/trans-array.h
@@ -67,6 +67,8 @@ tree gfc_check_pdt_dummy (gfc_symbol *, tree, int, gfc_actual_arglist *);
 
 tree gfc_alloc_allocatable_for_assignment (gfc_loopinfo*, gfc_expr*, gfc_expr*);
 
+/* Add initialization for class descriptors  */
+void gfc_trans_class_array (gfc_symbol *, gfc_wrapped_block *);
 /* Add initialization for deferred arrays.  */
 void gfc_trans_deferred_array (gfc_symbol *, gfc_wrapped_block *);
 /* Generate an initializer for a static pointer or allocatable array.  */
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 95af7d93162..b4fc4afdda3 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -738,6 +738,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
   /* Keep variables larger than max-stack-var-size off stack.  */
   if (!(sym->ns->proc_name && sym->ns->proc_name->attr.recursive)
       && !sym->attr.automatic
+      && !sym->attr.associate_var
       && sym->attr.save != SAVE_EXPLICIT
       && sym->attr.save != SAVE_IMPLICIT
       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))
@@ -4923,7 +4924,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
       else if ((!sym->attr.dummy || sym->ts.deferred)
 		&& (sym->ts.type == BT_CLASS
 		&& CLASS_DATA (sym)->attr.class_pointer))
-	continue;
+	gfc_trans_class_array (sym, block);
       else if ((!sym->attr.dummy || sym->ts.deferred)
 		&& (sym->attr.allocatable
 		    || (sym->attr.pointer && sym->attr.result)
@@ -5007,6 +5008,10 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)
 		  tmp = NULL_TREE;
 		}
 
+	      /* Initialize descriptor's TKR information.  */
+	      if (sym->ts.type == BT_CLASS)
+		gfc_trans_class_array (sym, block);
+
 	      /* Deallocate when leaving the scope. Nullifying is not
 		 needed.  */
 	      if (!sym->attr.result && !sym->attr.dummy && !sym->attr.pointer
@@ -5426,7 +5431,11 @@ gfc_trans_use_stmts (gfc_namespace * ns)
 	      /* Sometimes, generic interfaces wind up being over-ruled by a
 		 local symbol (see PR41062).  */
 	      if (!st->n.sym->attr.use_assoc)
-		continue;
+		{
+		  *slot = error_mark_node;
+		  entry->decls->clear_slot (slot);
+		  continue;
+		}
 
 	      if (st->n.sym->backend_decl
 		  && DECL_P (st->n.sym->backend_decl)
@@ -5624,6 +5633,7 @@ generate_coarray_sym_init (gfc_symbol *sym)
 
   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension
       || sym->attr.use_assoc || !sym->attr.referenced
+      || sym->attr.associate_var
       || sym->attr.select_type_temporary)
     return;
 
@@ -6564,7 +6574,7 @@ gfc_generate_return (void)
 	     NULL_TREE, and a 'return' is generated without a variable.
 	     The following generates a 'return __result_XXX' where XXX is
 	     the function name.  */
-	  if (sym == sym->result && sym->attr.function)
+	  if (sym == sym->result && sym->attr.function && !flag_f2c)
 	    {
 	      result = gfc_get_fake_result_decl (sym, 0);
 	      result = fold_build2_loc (input_location, MODIFY_EXPR,
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index a5c391d077e..5adee114157 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -1136,8 +1136,10 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
     return;
 
   /* Test for FULL_ARRAY.  */
-  if (e->rank == 0 && gfc_expr_attr (e).codimension
-      && gfc_expr_attr (e).dimension)
+  if (e->rank == 0
+      && ((gfc_expr_attr (e).codimension && gfc_expr_attr (e).dimension)
+	  || (class_ts.u.derived->components->as
+	      && class_ts.u.derived->components->as->type == AS_ASSUMED_RANK)))
     full_array = true;
   else
     gfc_is_class_array_ref (e, &full_array);
@@ -1185,8 +1187,12 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,
 	  && e->rank != class_ts.u.derived->components->as->rank)
 	{
 	  if (e->rank == 0)
-	    gfc_add_modify (&parmse->post, gfc_class_data_get (parmse->expr),
-			    gfc_conv_descriptor_data_get (ctree));
+	    {
+	      tmp = gfc_class_data_get (parmse->expr);
+	      gfc_add_modify (&parmse->post, tmp,
+			      fold_convert (TREE_TYPE (tmp),
+					 gfc_conv_descriptor_data_get (ctree)));
+	    }
 	  else
 	    class_array_data_assign (&parmse->post, parmse->expr, ctree, true);
 	}
@@ -1483,6 +1489,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)
 	    name = (const char *)(DECL_NAME (to)->identifier.id.str);
 
 	  from_len = gfc_conv_descriptor_size (from_data, 1);
+	  from_len = fold_convert (TREE_TYPE (orig_nelems), from_len);
 	  tmp = fold_build2_loc (input_location, NE_EXPR,
 				  logical_type_node, from_len, orig_nelems);
 	  msg = xasprintf ("Array bound mismatch for dimension %d "
@@ -5642,7 +5649,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
   gfc_charlen cl;
   gfc_expr *e;
   gfc_symbol *fsym;
-  stmtblock_t post;
   enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};
   gfc_component *comp = NULL;
   int arglen;
@@ -5686,7 +5692,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
   else
     info = NULL;
 
+  stmtblock_t post, clobbers;
   gfc_init_block (&post);
+  gfc_init_block (&clobbers);
   gfc_init_interface_mapping (&mapping);
   if (!comp)
     {
@@ -6023,7 +6031,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 				&& e->symtree->n.sym->attr.pointer))
 			&& fsym && fsym->attr.target)
 		/* Make sure the function only gets called once.  */
-		gfc_conv_expr_reference (&parmse, e, false);
+		gfc_conv_expr_reference (&parmse, e);
 	      else if (e->expr_type == EXPR_FUNCTION
 		       && e->symtree->n.sym->result
 		       && e->symtree->n.sym->result != e->symtree->n.sym
@@ -6130,22 +6138,37 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    }
 		  else
 		    {
-		      bool add_clobber;
-		      add_clobber = fsym && fsym->attr.intent == INTENT_OUT
-			&& !fsym->attr.allocatable && !fsym->attr.pointer
-			&& e->symtree && e->symtree->n.sym
-			&& !e->symtree->n.sym->attr.dimension
-			&& !e->symtree->n.sym->attr.pointer
-			&& !e->symtree->n.sym->attr.allocatable
-			/* See PR 41453.  */
-			&& !e->symtree->n.sym->attr.dummy
-			/* FIXME - PR 87395 and PR 41453  */
-			&& e->symtree->n.sym->attr.save == SAVE_NONE
-			&& !e->symtree->n.sym->attr.associate_var
-			&& e->ts.type != BT_CHARACTER && e->ts.type != BT_DERIVED
-			&& e->ts.type != BT_CLASS && !sym->attr.elemental;
+		      gfc_conv_expr_reference (&parmse, e);
 
-		      gfc_conv_expr_reference (&parmse, e, add_clobber);
+		      if (fsym
+			  && fsym->attr.intent == INTENT_OUT
+			  && !fsym->attr.allocatable
+			  && !fsym->attr.pointer
+			  && e->expr_type == EXPR_VARIABLE
+			  && e->ref == NULL
+			  && e->symtree
+			  && e->symtree->n.sym
+			  && !e->symtree->n.sym->attr.dimension
+			  && !e->symtree->n.sym->attr.pointer
+			  && !e->symtree->n.sym->attr.allocatable
+			  /* See PR 41453.  */
+			  && !e->symtree->n.sym->attr.dummy
+			  /* FIXME - PR 87395 and PR 41453  */
+			  && e->symtree->n.sym->attr.save == SAVE_NONE
+			  && !e->symtree->n.sym->attr.associate_var
+			  && e->ts.type != BT_CHARACTER
+			  && e->ts.type != BT_DERIVED
+			  && e->ts.type != BT_CLASS
+			  && !sym->attr.elemental)
+			{
+			  tree var;
+			  /* FIXME: This fails if var is passed by reference, see PR
+			     41453.  */
+			  var = build_fold_indirect_ref_loc (input_location,
+							     parmse.expr);
+			  tree clobber = build_clobber (TREE_TYPE (var));
+			  gfc_add_modify (&clobbers, var, clobber);
+			}
 		    }
 		  /* Catch base objects that are not variables.  */
 		  if (e->ts.type == BT_CLASS
@@ -6154,23 +6177,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		    base_object = build_fold_indirect_ref_loc (input_location,
 							       parmse.expr);
 
-		  /* A class array element needs converting back to be a
-		     class object, if the formal argument is a class object.  */
-		  if (fsym && fsym->ts.type == BT_CLASS
-			&& e->ts.type == BT_CLASS
-			&& ((CLASS_DATA (fsym)->as
-			     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)
-			    || CLASS_DATA (e)->attr.dimension))
-		    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,
-				     fsym->attr.intent != INTENT_IN
-				     && (CLASS_DATA (fsym)->attr.class_pointer
-					 || CLASS_DATA (fsym)->attr.allocatable),
-				     fsym->attr.optional
-				     && e->expr_type == EXPR_VARIABLE
-				     && e->symtree->n.sym->attr.optional,
-				     CLASS_DATA (fsym)->attr.class_pointer
-				     || CLASS_DATA (fsym)->attr.allocatable);
-
 		  /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is
 		     allocated on entry, it must be deallocated.  */
 		  if (fsym && fsym->attr.intent == INTENT_OUT
@@ -6230,6 +6236,23 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 		      gfc_add_expr_to_block (&se->pre, tmp);
 		    }
 
+		  /* A class array element needs converting back to be a
+		     class object, if the formal argument is a class object.  */
+		  if (fsym && fsym->ts.type == BT_CLASS
+			&& e->ts.type == BT_CLASS
+			&& ((CLASS_DATA (fsym)->as
+			     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)
+			    || CLASS_DATA (e)->attr.dimension))
+		    gfc_conv_class_to_class (&parmse, e, fsym->ts, false,
+				     fsym->attr.intent != INTENT_IN
+				     && (CLASS_DATA (fsym)->attr.class_pointer
+					 || CLASS_DATA (fsym)->attr.allocatable),
+				     fsym->attr.optional
+				     && e->expr_type == EXPR_VARIABLE
+				     && e->symtree->n.sym->attr.optional,
+				     CLASS_DATA (fsym)->attr.class_pointer
+				     || CLASS_DATA (fsym)->attr.allocatable);
+
 		  if (fsym && (fsym->ts.type == BT_DERIVED
 			       || fsym->ts.type == BT_ASSUMED)
 		      && e->ts.type == BT_CLASS
@@ -6808,16 +6831,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	      else
 		goto end_pointer_check;
 
+	      tmp = parmse.expr;
 	      if (fsym && fsym->ts.type == BT_CLASS)
 		{
-		  tmp = build_fold_indirect_ref_loc (input_location,
-						      parmse.expr);
+		  if (POINTER_TYPE_P (TREE_TYPE (tmp)))
+		    tmp = build_fold_indirect_ref_loc (input_location, tmp);
 		  tmp = gfc_class_data_get (tmp);
 		  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))
 		    tmp = gfc_conv_descriptor_data_get (tmp);
 		}
-	      else
-		tmp = parmse.expr;
 
 	      /* If the argument is passed by value, we need to strip the
 		 INDIRECT_REF.  */
@@ -6973,6 +6995,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 
       vec_safe_push (arglist, parmse.expr);
     }
+  gfc_add_block_to_block (&se->pre, &clobbers);
   gfc_finish_interface_mapping (&mapping, &se->pre, &se->post);
 
   if (comp)
@@ -6993,7 +7016,12 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,
 	     (and other intrinsics?) and dummy functions.  In the case of SPREAD,
 	     we take the character length of the first argument for the result.
 	     For dummies, we have to look through the formal argument list for
-	     this function and use the character length found there.*/
+	     this function and use the character length found there.
+	     Likewise, we handle the case of deferred-length character dummy
+	     arguments to intrinsics that determine the characteristics of
+	     the result, which cannot be deferred-length.  */
+	  if (expr->value.function.isym)
+	    ts.deferred = false;
 	  if (ts.deferred)
 	    cl.backend_decl = gfc_create_var (gfc_charlen_type_node, "slen");
 	  else if (!sym->attr.dummy)
@@ -8782,8 +8810,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init, bool coarray)
   return gfc_finish_block (&block);
 }
 
-void
-gfc_conv_union_initializer (vec<constructor_elt, va_gc> *v,
+static void
+gfc_conv_union_initializer (vec<constructor_elt, va_gc> *&v,
                             gfc_component *un, gfc_expr *init)
 {
   gfc_constructor *ctor;
@@ -9066,7 +9094,7 @@ gfc_conv_expr_type (gfc_se * se, gfc_expr * expr, tree type)
    values only.  */
 
 void
-gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
+gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)
 {
   gfc_ss *ss;
   tree var;
@@ -9106,16 +9134,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr, bool add_clobber)
 	  gfc_add_block_to_block (&se->pre, &se->post);
 	  se->expr = var;
 	}
-      else if (add_clobber && expr->ref == NULL)
-	{
-	  tree clobber;
-	  tree var;
-	  /* FIXME: This fails if var is passed by reference, see PR
-	     41453.  */
-	  var = expr->symtree->n.sym->backend_decl;
-	  clobber = build_clobber (TREE_TYPE (var));
-	  gfc_add_modify (&se->pre, var, clobber);
-	}
       return;
     }
 
@@ -11021,6 +11039,9 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,
       class_han = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))
 	  ? gfc_class_data_get (lse->expr) : lse->expr;
 
+      if (!POINTER_TYPE_P (TREE_TYPE (class_han)))
+	class_han = gfc_build_addr_expr (NULL_TREE, class_han);
+
       /* Allocate block.  */
       gfc_init_block (&alloc);
       gfc_allocate_using_malloc (&alloc, class_han, size, NULL_TREE);
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
index 313440d7022..05dc2c7c9a6 100644
--- a/gcc/fortran/trans-intrinsic.c
+++ b/gcc/fortran/trans-intrinsic.c
@@ -6645,6 +6645,7 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)
   tree type;
   tree tmp;
   tree mask;
+  tree num_bits, cond;
 
   gfc_conv_intrinsic_function_args (se, expr, args, 3);
   type = TREE_TYPE (args[0]);
@@ -6685,8 +6686,17 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)
 			       "in intrinsic IBITS", tmp1, tmp2, nbits);
     }
 
+  /* The Fortran standard allows (shift width) LEN <= BIT_SIZE(I), whereas
+     gcc requires a shift width < BIT_SIZE(I), so we have to catch this
+     special case.  See also gfc_conv_intrinsic_ishft ().  */
+  num_bits = build_int_cst (TREE_TYPE (args[2]), TYPE_PRECISION (type));
+
   mask = build_int_cst (type, -1);
   mask = fold_build2_loc (input_location, LSHIFT_EXPR, type, mask, args[2]);
+  cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node, args[2],
+			  num_bits);
+  mask = fold_build3_loc (input_location, COND_EXPR, type, cond,
+			  build_int_cst (type, 0), mask);
   mask = fold_build1_loc (input_location, BIT_NOT_EXPR, type, mask);
 
   tmp = fold_build2_loc (input_location, RSHIFT_EXPR, type, args[0], args[1]);
diff --git a/gcc/fortran/trans-openmp.c b/gcc/fortran/trans-openmp.c
index 973d916b4a2..b24059a4eb3 100644
--- a/gcc/fortran/trans-openmp.c
+++ b/gcc/fortran/trans-openmp.c
@@ -2747,7 +2747,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,
 			       || GFC_DECL_CRAY_POINTEE (decl)
 			       || GFC_DESCRIPTOR_TYPE_P
 					     (TREE_TYPE (TREE_TYPE (decl)))
-			       || n->sym->ts.type == BT_DERIVED))
+			       || (n->sym->ts.type == BT_DERIVED
+				   && (n->sym->ts.u.derived->ts.f90_type
+				       != BT_VOID))))
 		    {
 		      tree orig_decl = decl;
 
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
index d6520eee5c0..96b8b512749 100644
--- a/gcc/fortran/trans-types.c
+++ b/gcc/fortran/trans-types.c
@@ -2981,12 +2981,23 @@ create_fn_spec (gfc_symbol *sym, tree fntype)
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
     if (spec_len < sizeof (spec))
       {
-	if (!f->sym || f->sym->attr.pointer || f->sym->attr.target
+	bool is_class = false;
+	bool is_pointer = false;
+
+	if (f->sym)
+	  {
+	    is_class = f->sym->ts.type == BT_CLASS && CLASS_DATA (f->sym)
+	      && f->sym->attr.class_ok;
+	    is_pointer = is_class ? CLASS_DATA (f->sym)->attr.class_pointer
+				  : f->sym->attr.pointer;
+	  }
+
+	if (f->sym == NULL || is_pointer || f->sym->attr.target
 	    || f->sym->attr.external || f->sym->attr.cray_pointer
 	    || (f->sym->ts.type == BT_DERIVED
 		&& (f->sym->ts.u.derived->attr.proc_pointer_comp
 		    || f->sym->ts.u.derived->attr.pointer_comp))
-	    || (f->sym->ts.type == BT_CLASS
+	    || (is_class
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
 		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
index 69d3fdcfdac..bc032231d3a 100644
--- a/gcc/fortran/trans.h
+++ b/gcc/fortran/trans.h
@@ -500,8 +500,7 @@ tree gfc_build_compare_string (tree, tree, tree, tree, int, enum tree_code);
 void gfc_conv_expr (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_val (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_lhs (gfc_se * se, gfc_expr * expr);
-void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr,
-			      bool add_clobber = false);
+void gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr);
 void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);
 
 
diff --git a/gcc/function.c b/gcc/function.c
index 0495e9f1b81..1352863acbc 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -4862,7 +4862,7 @@ allocate_struct_function (tree fndecl, bool abstract_p)
    instead of just setting it.  */
 
 void
-push_struct_function (tree fndecl)
+push_struct_function (tree fndecl, bool abstract_p)
 {
   /* When in_dummy_function we might be in the middle of a pop_cfun and
      current_function_decl and cfun may not match.  */
@@ -4871,7 +4871,7 @@ push_struct_function (tree fndecl)
 	      || (cfun && current_function_decl == cfun->decl));
   cfun_stack.safe_push (cfun);
   current_function_decl = fndecl;
-  allocate_struct_function (fndecl, false);
+  allocate_struct_function (fndecl, abstract_p);
 }
 
 /* Reset crtl and other non-struct-function variables to defaults as
@@ -5032,9 +5032,12 @@ stack_protect_epilogue (void)
    PARMS_HAVE_CLEANUPS is nonzero if there are cleanups associated with
    the function's parameters, which must be run at any return statement.  */
 
+bool currently_expanding_function_start;
 void
 expand_function_start (tree subr)
 {
+  currently_expanding_function_start = true;
+
   /* Make sure volatile mem refs aren't considered
      valid operands of arithmetic insns.  */
   init_recog_no_volatile ();
@@ -5227,6 +5230,8 @@ expand_function_start (tree subr)
   /* If we are doing generic stack checking, the probe should go here.  */
   if (flag_stack_check == GENERIC_STACK_CHECK)
     stack_check_probe_note = emit_note (NOTE_INSN_DELETED);
+
+  currently_expanding_function_start = false;
 }
 
 void
diff --git a/gcc/function.h b/gcc/function.h
index 66cfa973808..a41514acafc 100644
--- a/gcc/function.h
+++ b/gcc/function.h
@@ -676,7 +676,7 @@ extern void pop_cfun (void);
 extern int get_next_funcdef_no (void);
 extern int get_last_funcdef_no (void);
 extern void allocate_struct_function (tree, bool);
-extern void push_struct_function (tree fndecl);
+extern void push_struct_function (tree fndecl, bool = false);
 extern void push_dummy_function (bool);
 extern void pop_dummy_function (void);
 extern void init_dummy_function_start (void);
@@ -712,4 +712,6 @@ extern const char *current_function_name (void);
 
 extern void used_types_insert (tree);
 
+extern bool currently_expanding_function_start;
+
 #endif  /* GCC_FUNCTION_H */
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 0af888c7d78..20a649ea08e 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -27,6 +27,7 @@ CC recognizes how to compile each input file by suffixes in the file names.
 Once it knows which kind of compilation to perform, the procedure for
 compilation is specified by a string called a "spec".  */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -43,6 +44,7 @@ compilation is specified by a string called a "spec".  */
 #include "opts.h"
 #include "filenames.h"
 #include "spellcheck.h"
+#include "opts-jobserver.h"
 
 
 
@@ -4487,10 +4489,12 @@ driver_handle_option (struct gcc_options *opts,
     case OPT_static_libgcc:
     case OPT_shared_libgcc:
     case OPT_static_libgfortran:
+    case OPT_static_libphobos:
     case OPT_static_libstdc__:
       /* These are always valid, since gcc.c itself understands the
-	 first two, gfortranspec.c understands -static-libgfortran and
-	 g++spec.c understands -static-libstdc++ */
+	 first two, gfortranspec.c understands -static-libgfortran,
+	 d-spec.cc understands -static-libphobos, and g++spec.c
+	 understands -static-libstdc++ */
       validated = true;
       break;
 
@@ -9071,38 +9075,9 @@ driver::final_actions () const
 void
 driver::detect_jobserver () const
 {
-  /* Detect jobserver and drop it if it's not working.  */
-  const char *makeflags = env.get ("MAKEFLAGS");
-  if (makeflags != NULL)
-    {
-      const char *needle = "--jobserver-auth=";
-      const char *n = strstr (makeflags, needle);
-      if (n != NULL)
-	{
-	  int rfd = -1;
-	  int wfd = -1;
-
-	  bool jobserver
-	    = (sscanf (n + strlen (needle), "%d,%d", &rfd, &wfd) == 2
-	       && rfd > 0
-	       && wfd > 0
-	       && is_valid_fd (rfd)
-	       && is_valid_fd (wfd));
-
-	  /* Drop the jobserver if it's not working now.  */
-	  if (!jobserver)
-	    {
-	      unsigned offset = n - makeflags;
-	      char *dup = xstrdup (makeflags);
-	      dup[offset] = '\0';
-
-	      const char *space = strchr (makeflags + offset, ' ');
-	      if (space != NULL)
-		strcpy (dup + offset, space);
-	      xputenv (concat ("MAKEFLAGS=", dup, NULL));
-	    }
-	}
-    }
+  jobserver_info jinfo;
+  if (!jinfo.is_active && !jinfo.skipped_makeflags.empty ())
+    xputenv (xstrdup (jinfo.skipped_makeflags.c_str ()));
 }
 
 /* Determine what the exit code of the driver should be.  */
diff --git a/gcc/generic-match-head.c b/gcc/generic-match-head.c
index a063512f68e..4347efb53e1 100644
--- a/gcc/generic-match-head.c
+++ b/gcc/generic-match-head.c
@@ -37,6 +37,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "gimplify.h"
 #include "optabs-tree.h"
 #include "dbgcnt.h"
+#include "tm.h"
+#include "tree-pass.h"
 
 /* Routine to determine if the types T1 and T2 are effectively
    the same for GENERIC.  If T1 or T2 is not a type, the test
@@ -68,7 +70,7 @@ single_use (tree t ATTRIBUTE_UNUSED)
 static inline bool
 canonicalize_math_p ()
 {
-  return true;
+  return !cfun || (cfun->curr_properties & PROP_gimple_opt_math) == 0;
 }
 
 /* Return true if math operations that are beneficial only after
@@ -87,7 +89,7 @@ canonicalize_math_after_vectorization_p ()
 static inline bool
 optimize_vectors_before_lowering_p ()
 {
-  return true;
+  return !cfun || (cfun->curr_properties & PROP_gimple_lvec) == 0;
 }
 
 /* Return true if successive divisions can be optimized.
diff --git a/gcc/genmatch.c b/gcc/genmatch.c
index 8311f5d768a..c04ab9cff5e 100644
--- a/gcc/genmatch.c
+++ b/gcc/genmatch.c
@@ -2526,7 +2526,8 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,
       for (unsigned i = 0; i < ops.length (); ++i)
 	fprintf (f, ", _o%d[%u]", depth, i);
       fprintf (f, ");\n");
-      fprintf_indent (f, indent, "tem_op.resimplify (lseq, valueize);\n");
+      fprintf_indent (f, indent, "tem_op.resimplify (%s, valueize);\n",
+		      !force_leaf ? "lseq" : "NULL");
       fprintf_indent (f, indent,
 		      "_r%d = maybe_push_res_to_seq (&tem_op, %s);\n", depth,
 		      !force_leaf ? "lseq" : "NULL");
@@ -2547,29 +2548,32 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,
 	{
 	  fprintf_indent (f, indent, "if (TREE_TYPE (_o%d[0]) != %s)\n",
 			  depth, type);
-	  indent += 2;
+	  fprintf_indent (f, indent + 2, "{\n");
+	  indent += 4;
 	}
       if (opr->kind == id_base::CODE)
 	fprintf_indent (f, indent, "_r%d = fold_build%d_loc (loc, %s, %s",
 			depth, ops.length(), opr_name, type);
       else
-	{
-	  fprintf_indent (f, indent, "{\n");
-	  fprintf_indent (f, indent, "  _r%d = maybe_build_call_expr_loc (loc, "
-			  "%s, %s, %d", depth, opr_name, type, ops.length());
-	}
+	fprintf_indent (f, indent, "_r%d = maybe_build_call_expr_loc (loc, "
+			"%s, %s, %d", depth, opr_name, type, ops.length());
       for (unsigned i = 0; i < ops.length (); ++i)
 	fprintf (f, ", _o%d[%u]", depth, i);
       fprintf (f, ");\n");
       if (opr->kind != id_base::CODE)
 	{
-	  fprintf_indent (f, indent, "  if (!_r%d)\n", depth);
-	  fprintf_indent (f, indent, "    goto %s;\n", fail_label);
-	  fprintf_indent (f, indent, "}\n");
+	  fprintf_indent (f, indent, "if (!_r%d)\n", depth);
+	  fprintf_indent (f, indent, "  goto %s;\n", fail_label);
+	}
+      if (force_leaf)
+	{
+	  fprintf_indent (f, indent, "if (EXPR_P (_r%d))\n", depth);
+	  fprintf_indent (f, indent, "  goto %s;\n", fail_label);
 	}
       if (*opr == CONVERT_EXPR)
 	{
-	  indent -= 2;
+	  fprintf_indent (f, indent - 2, "}\n");
+	  indent -= 4;
 	  fprintf_indent (f, indent, "else\n");
 	  fprintf_indent (f, indent, "  _r%d = _o%d[0];\n", depth, depth);
 	}
@@ -3428,7 +3432,8 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)
 	  if (!is_predicate)
 	    {
 	      fprintf_indent (f, indent,
-			      "res_op->resimplify (lseq, valueize);\n");
+			      "res_op->resimplify (%s, valueize);\n",
+			      !e->force_leaf ? "lseq" : "NULL");
 	      if (e->force_leaf)
 		fprintf_indent (f, indent,
 				"if (!maybe_push_res_to_seq (res_op, NULL)) "
@@ -4298,9 +4303,6 @@ parser::parse_expr ()
       && token->type == CPP_NOT
       && !(token->flags & PREV_WHITE))
     {
-      if (!gimple)
-	fatal_at (token, "forcing simplification to a leaf is not supported "
-		  "for GENERIC");
       eat_token (CPP_NOT);
       e->force_leaf = true;
     }
diff --git a/gcc/gimple-array-bounds.cc b/gcc/gimple-array-bounds.cc
index b1179518651..8bcc0077b8c 100644
--- a/gcc/gimple-array-bounds.cc
+++ b/gcc/gimple-array-bounds.cc
@@ -783,7 +783,7 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,
   int i = 0;
   if (extrema[i] < -arrbounds[1] || extrema[i = 1] > ubound)
     {
-      HOST_WIDE_INT tmpidx = extrema[i].to_shwi () / eltsize.to_shwi ();
+      HOST_WIDE_INT tmpidx = (extrema[i] / eltsize).to_shwi ();
 
       if (warning_at (location, OPT_Warray_bounds,
 		      "intermediate array offset %wi is outside array bounds "
diff --git a/gcc/gimple-isel.cc b/gcc/gimple-isel.cc
index 2c78a08d3f1..a055cbecd0c 100644
--- a/gcc/gimple-isel.cc
+++ b/gcc/gimple-isel.cc
@@ -43,28 +43,29 @@ along with GCC; see the file COPYING3.  If not see
 /* Expand all ARRAY_REF(VIEW_CONVERT_EXPR) gimple assignments into calls to
    internal function based on vector type of selected expansion.
    i.e.:
-     VIEW_CONVERT_EXPR<int[4]>(u)[_1] =  = i_4(D);
+     VIEW_CONVERT_EXPR<int[4]>(u)[_1] = i_4(D);
    =>
      _7 = u;
      _8 = .VEC_SET (_7, i_4(D), _1);
      u = _8;  */
 
-static gimple *
-gimple_expand_vec_set_expr (gimple_stmt_iterator *gsi)
+static bool
+gimple_expand_vec_set_expr (struct function *fun, gimple_stmt_iterator *gsi)
 {
   enum tree_code code;
   gcall *new_stmt = NULL;
   gassign *ass_stmt = NULL;
+  bool cfg_changed = false;
 
   /* Only consider code == GIMPLE_ASSIGN.  */
   gassign *stmt = dyn_cast<gassign *> (gsi_stmt (*gsi));
   if (!stmt)
-    return NULL;
+    return false;
 
   tree lhs = gimple_assign_lhs (stmt);
   code = TREE_CODE (lhs);
   if (code != ARRAY_REF)
-    return NULL;
+    return false;
 
   tree val = gimple_assign_rhs1 (stmt);
   tree op0 = TREE_OPERAND (lhs, 0);
@@ -76,7 +77,7 @@ gimple_expand_vec_set_expr (gimple_stmt_iterator *gsi)
       tree pos = TREE_OPERAND (lhs, 1);
       tree view_op0 = TREE_OPERAND (op0, 0);
       machine_mode outermode = TYPE_MODE (TREE_TYPE (view_op0));
-      if (auto_var_in_fn_p (view_op0, cfun->decl)
+      if (auto_var_in_fn_p (view_op0, fun->decl)
 	  && !TREE_ADDRESSABLE (view_op0) && can_vec_set_var_idx_p (outermode))
 	{
 	  location_t loc = gimple_location (stmt);
@@ -98,19 +99,23 @@ gimple_expand_vec_set_expr (gimple_stmt_iterator *gsi)
 	  gimple_set_location (ass_stmt, loc);
 	  gsi_insert_before (gsi, ass_stmt, GSI_SAME_STMT);
 
+	  basic_block bb = gimple_bb (stmt);
 	  gimple_move_vops (ass_stmt, stmt);
-	  gsi_remove (gsi, true);
+	  if (gsi_remove (gsi, true)
+	      && gimple_purge_dead_eh_edges (bb))
+	    cfg_changed = true;
+	  *gsi = gsi_for_stmt (ass_stmt);
 	}
     }
 
-  return ass_stmt;
+  return cfg_changed;
 }
 
 /* Expand all VEC_COND_EXPR gimple assignments into calls to internal
    function based on type of selected expansion.  */
 
 static gimple *
-gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,
+gimple_expand_vec_cond_expr (struct function *fun, gimple_stmt_iterator *gsi,
 			     hash_map<tree, unsigned int> *vec_cond_ssa_name_uses)
 {
   tree lhs, op0a = NULL_TREE, op0b = NULL_TREE;
@@ -191,7 +196,6 @@ gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,
 						     tcode);
 
 	  /* Try to fold x CMP y ? -1 : 0 to x CMP y.  */
-
 	  if (can_compute_op0
 	      && integer_minus_onep (op1)
 	      && integer_zerop (op2)
@@ -203,14 +207,19 @@ gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,
 	      return new_stmt;
 	    }
 
-	  if (can_compute_op0
-	      && used_vec_cond_exprs >= 2
-	      && (get_vcond_mask_icode (mode, TYPE_MODE (op0_type))
-		  != CODE_FOR_nothing))
-	    {
-	      /* Keep the SSA name and use vcond_mask.  */
-	      tcode = TREE_CODE (op0);
-	    }
+	  /* When the compare has EH we do not want to forward it when
+	     it has multiple uses and in general because of the complication
+	     with EH redirection.  */
+	  if (stmt_can_throw_internal (fun, def_stmt))
+	    tcode = TREE_CODE (op0);
+
+	  /* If we can compute op0 and have multiple uses, keep the SSA
+	     name and use vcond_mask.  */
+	  else if (can_compute_op0
+		   && used_vec_cond_exprs >= 2
+		   && (get_vcond_mask_icode (mode, TYPE_MODE (op0_type))
+		       != CODE_FOR_nothing))
+	    tcode = TREE_CODE (op0);
 	}
       else
 	tcode = TREE_CODE (op0);
@@ -241,6 +250,14 @@ gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,
 			GET_MODE_NUNITS (cmp_op_mode)));
 
   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);
+  /* Some targets do not have vcondeq and only vcond with NE/EQ
+     but not vcondu, so make sure to also try vcond here as
+     vcond_icode_p would canonicalize the optab query to.  */
+  if (icode == CODE_FOR_nothing
+      && (tcode == NE_EXPR || tcode == EQ_EXPR)
+      && ((icode = get_vcond_icode (mode, cmp_op_mode, !unsignedp))
+	  != CODE_FOR_nothing))
+    unsignedp = !unsignedp;
   if (icode == CODE_FOR_nothing)
     {
       if (tcode == LT_EXPR
@@ -282,18 +299,19 @@ gimple_expand_vec_cond_expr (gimple_stmt_iterator *gsi,
    VEC_COND_EXPR assignments.  */
 
 static unsigned int
-gimple_expand_vec_exprs (void)
+gimple_expand_vec_exprs (struct function *fun)
 {
   gimple_stmt_iterator gsi;
   basic_block bb;
   hash_map<tree, unsigned int> vec_cond_ssa_name_uses;
   auto_bitmap dce_ssa_names;
+  bool cfg_changed = false;
 
-  FOR_EACH_BB_FN (bb, cfun)
+  FOR_EACH_BB_FN (bb, fun)
     {
       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
 	{
-	  gimple *g = gimple_expand_vec_cond_expr (&gsi,
+	  gimple *g = gimple_expand_vec_cond_expr (fun, &gsi,
 						   &vec_cond_ssa_name_uses);
 	  if (g != NULL)
 	    {
@@ -302,7 +320,7 @@ gimple_expand_vec_exprs (void)
 	      gsi_replace (&gsi, g, false);
 	    }
 
-	  gimple_expand_vec_set_expr (&gsi);
+	  cfg_changed |= gimple_expand_vec_set_expr (fun, &gsi);
 	  if (gsi_end_p (gsi))
 	    break;
 	}
@@ -314,7 +332,7 @@ gimple_expand_vec_exprs (void)
 
   simple_dce_from_worklist (dce_ssa_names);
 
-  return 0;
+  return cfg_changed ? TODO_cleanup_cfg : 0;
 }
 
 namespace {
@@ -345,9 +363,9 @@ public:
       return true;
     }
 
-  virtual unsigned int execute (function *)
+  virtual unsigned int execute (function *fun)
     {
-      return gimple_expand_vec_exprs ();
+      return gimple_expand_vec_exprs (fun);
     }
 
 }; // class pass_gimple_isel
diff --git a/gcc/gimple-ssa-store-merging.c b/gcc/gimple-ssa-store-merging.c
index 0a74b025d00..288a73d68a6 100644
--- a/gcc/gimple-ssa-store-merging.c
+++ b/gcc/gimple-ssa-store-merging.c
@@ -263,7 +263,7 @@ do_shift_rotate (enum tree_code code,
 		 int count)
 {
   int i, size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;
-  unsigned head_marker;
+  uint64_t head_marker;
 
   if (count < 0
       || count >= TYPE_PRECISION (n->type)
@@ -1520,7 +1520,7 @@ namespace {
    then VAL represents the constant and all the other fields are zero, or
    a memory load, then VAL represents the reference, BASE_ADDR is non-NULL
    and the other fields also reflect the memory load, or an SSA name, then
-   VAL represents the SSA name and all the other fields are zero,  */
+   VAL represents the SSA name and all the other fields are zero.  */
 
 class store_operand_info
 {
@@ -2223,6 +2223,10 @@ merged_store_group::apply_stores ()
   if (buf_size <= MOVE_MAX)
     string_concatenation = false;
 
+  /* String concatenation only works for byte aligned start and end.  */
+  if (start % BITS_PER_UNIT != 0 || width % BITS_PER_UNIT != 0)
+    string_concatenation = false;
+
   /* Create a power-of-2-sized buffer for native_encode_expr.  */
   if (!string_concatenation)
     buf_size = 1 << ceil_log2 (buf_size);
@@ -3548,7 +3552,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,
 
   /* For bswap framework using sets of stores, all the checking has been done
      earlier in try_coalesce_bswap and the result always needs to be emitted
-     as a single store.  Likewise for string concatenation,  */
+     as a single store.  Likewise for string concatenation.  */
   if (group->stores[0]->rhs_code == LROTATE_EXPR
       || group->stores[0]->rhs_code == NOP_EXPR
       || group->string_concatenation)
@@ -4515,12 +4519,13 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)
 		    }
 		  else if ((BYTES_BIG_ENDIAN ? start_gap : end_gap) > 0)
 		    {
-		      const unsigned HOST_WIDE_INT imask
-			= (HOST_WIDE_INT_1U << info->bitsize) - 1;
+		      wide_int imask
+			= wi::mask (info->bitsize, false,
+				    TYPE_PRECISION (TREE_TYPE (tem)));
 		      tem = gimple_build (&seq, loc,
 					  BIT_AND_EXPR, TREE_TYPE (tem), tem,
-					  build_int_cst (TREE_TYPE (tem),
-							 imask));
+					  wide_int_to_tree (TREE_TYPE (tem),
+							    imask));
 		    }
 		  const HOST_WIDE_INT shift
 		    = (BYTES_BIG_ENDIAN ? end_gap : start_gap);
diff --git a/gcc/gimple-ssa-warn-alloca.c b/gcc/gimple-ssa-warn-alloca.c
index 42c0ba1d87b..69c2583f090 100644
--- a/gcc/gimple-ssa-warn-alloca.c
+++ b/gcc/gimple-ssa-warn-alloca.c
@@ -218,6 +218,7 @@ alloca_call_type (range_query &query, gimple *stmt, bool is_vla)
   int_range_max r;
   if (warn_limit_specified_p (is_vla)
       && TREE_CODE (len) == SSA_NAME
+      && types_compatible_p (TREE_TYPE (len), size_type_node)
       && query.range_of_expr (r, len, stmt)
       && !r.varying_p ())
     {
diff --git a/gcc/gimple-ssa-warn-restrict.c b/gcc/gimple-ssa-warn-restrict.c
index ad37f20afaa..cfaa2179bb6 100644
--- a/gcc/gimple-ssa-warn-restrict.c
+++ b/gcc/gimple-ssa-warn-restrict.c
@@ -514,7 +514,6 @@ builtin_memref::set_base_and_offset (tree expr)
     {
       tree memrefoff = fold_convert (ptrdiff_type_node, TREE_OPERAND (base, 1));
       extend_offset_range (memrefoff);
-      base = TREE_OPERAND (base, 0);
 
       if (refoff != HOST_WIDE_INT_MIN
       	  && TREE_CODE (expr) == COMPONENT_REF)
@@ -527,14 +526,19 @@ builtin_memref::set_base_and_offset (tree expr)
 	     REFOFF is set to s[1].b - (char*)s.  */
 	  offset_int off = tree_to_shwi (memrefoff);
 	  refoff += off;
-      	}
 
-      if (!integer_zerop (memrefoff))
-	/* A non-zero offset into an array of struct with flexible array
-	   members implies that the array is empty because there is no
-	   way to initialize such a member when it belongs to an array.
-	   This must be some sort of a bug.  */
-	refsize = 0;
+	  if (!integer_zerop (memrefoff)
+	      && !COMPLETE_TYPE_P (TREE_TYPE (expr))
+	      && multiple_of_p (sizetype, memrefoff,
+				TYPE_SIZE_UNIT (TREE_TYPE (base))))
+	    /* A non-zero offset into an array of struct with flexible array
+	       members implies that the array is empty because there is no
+	       way to initialize such a member when it belongs to an array.
+	       This must be some sort of a bug.  */
+	    refsize = 0;
+	}
+
+      base = TREE_OPERAND (base, 0);
     }
 
   if (TREE_CODE (ref) == COMPONENT_REF)
diff --git a/gcc/go/ChangeLog b/gcc/go/ChangeLog
index aa786cc1ef0..323b9dae832 100644
--- a/gcc/go/ChangeLog
+++ b/gcc/go/ChangeLog
@@ -1,3 +1,15 @@
+2023-06-29  Paul E. Murphy  <murphyp@linux.ibm.com>
+
+	Backported from master:
+	2023-06-22  Paul E. Murphy  <murphyp@linux.ibm.com>
+
+	* go-backend.c [TARGET_AIX]: Rename and update usage to TARGET_AIX_OS.
+	* go-lang.c: Likewise.
+
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/go/go-backend.c b/gcc/go/go-backend.c
index 7a223e51b00..4655fee6ece 100644
--- a/gcc/go/go-backend.c
+++ b/gcc/go/go-backend.c
@@ -45,8 +45,8 @@ along with GCC; see the file COPYING3.  If not see
 #define GO_EXPORT_SECTION_NAME ".go_export"
 #endif
 
-#ifndef TARGET_AIX
-#define TARGET_AIX 0
+#ifndef TARGET_AIX_OS
+#define TARGET_AIX_OS 0
 #endif
 
 /* This file holds all the cases where the Go frontend needs
@@ -107,7 +107,7 @@ go_write_export_data (const char *bytes, unsigned int size)
     {
       gcc_assert (targetm_common.have_named_sections);
       sec = get_section (GO_EXPORT_SECTION_NAME,
-			 TARGET_AIX ? SECTION_EXCLUDE : SECTION_DEBUG,
+			 TARGET_AIX_OS ? SECTION_EXCLUDE : SECTION_DEBUG,
 			 NULL);
     }
 
diff --git a/gcc/go/go-lang.c b/gcc/go/go-lang.c
index a01db8dbdcd..249ecf2503f 100644
--- a/gcc/go/go-lang.c
+++ b/gcc/go/go-lang.c
@@ -39,8 +39,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "go-c.h"
 #include "go-gcc.h"
 
-#ifndef TARGET_AIX
-#define TARGET_AIX 0
+#ifndef TARGET_AIX_OS
+#define TARGET_AIX_OS 0
 #endif
 
 /* Language-dependent contents of a type.  */
@@ -119,9 +119,9 @@ go_langhook_init (void)
   args.compiling_runtime = go_compiling_runtime;
   args.debug_escape_level = go_debug_escape_level;
   args.debug_escape_hash = go_debug_escape_hash;
-  args.nil_check_size_threshold = TARGET_AIX ? -1 : 4096;
+  args.nil_check_size_threshold = TARGET_AIX_OS ? -1 : 4096;
   args.debug_optimization = go_debug_optimization;
-  args.need_eqtype = TARGET_AIX ? true : false;
+  args.need_eqtype = TARGET_AIX_OS ? true : false;
   args.linemap = go_get_linemap();
   args.backend = go_get_backend();
   go_create_gogo (&args);
diff --git a/gcc/ifcvt.c b/gcc/ifcvt.c
index 0439a8aacff..367d5c25c56 100644
--- a/gcc/ifcvt.c
+++ b/gcc/ifcvt.c
@@ -2814,18 +2814,19 @@ noce_try_sign_mask (struct noce_if_info *if_info)
     return FALSE;
 
   /* This is only profitable if T is unconditionally executed/evaluated in the
-     original insn sequence or T is cheap.  The former happens if B is the
-     non-zero (T) value and if INSN_B was taken from TEST_BB, or there was no
-     INSN_B which can happen for e.g. conditional stores to memory.  For the
-     cost computation use the block TEST_BB where the evaluation will end up
-     after the transformation.  */
+     original insn sequence or T is cheap and can't trap or fault.  The former
+     happens if B is the non-zero (T) value and if INSN_B was taken from
+     TEST_BB, or there was no INSN_B which can happen for e.g. conditional
+     stores to memory.  For the cost computation use the block TEST_BB where
+     the evaluation will end up after the transformation.  */
   t_unconditional
     = (t == if_info->b
        && (if_info->insn_b == NULL_RTX
 	   || BLOCK_FOR_INSN (if_info->insn_b) == if_info->test_bb));
   if (!(t_unconditional
-	|| (set_src_cost (t, mode, if_info->speed_p)
-	    < COSTS_N_INSNS (2))))
+	|| ((set_src_cost (t, mode, if_info->speed_p)
+	     < COSTS_N_INSNS (2))
+	    && !may_trap_or_fault_p (t))))
     return FALSE;
 
   if (!noce_can_force_operand (t))
diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
index 5dd33a75c3a..44407e1b5cd 100644
--- a/gcc/ipa-icf.c
+++ b/gcc/ipa-icf.c
@@ -2411,10 +2411,11 @@ sem_item_optimizer::filter_removed_items (void)
 	    {
 	      /* Filter out non-readonly variables.  */
 	      tree decl = item->decl;
-	      if (TREE_READONLY (decl))
-		filtered.safe_push (item);
-	      else
+	      varpool_node *vnode = static_cast <sem_variable *>(item)->get_node ();
+	      if (!TREE_READONLY (decl) || vnode->body_removed)
 		remove_item (item);
+	      else
+		filtered.safe_push (item);
 	    }
         }
     }
diff --git a/gcc/ipa-modref-tree.h b/gcc/ipa-modref-tree.h
index d36c28c0470..9927fc0982b 100644
--- a/gcc/ipa-modref-tree.h
+++ b/gcc/ipa-modref-tree.h
@@ -560,7 +560,7 @@ struct GTY((user)) modref_tree
 	    size_t k;
 	    modref_access_node *access_node;
 	    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)
-	      if (access_node->parm_index > 0)
+	      if (access_node->parm_index >= 0)
 		{
 		  if (access_node->parm_index < (int)map->length ())
 		    access_node->parm_index = (*map)[access_node->parm_index];
diff --git a/gcc/ipa-prop.c b/gcc/ipa-prop.c
index b6c6b51612d..c1ddf8ba11e 100644
--- a/gcc/ipa-prop.c
+++ b/gcc/ipa-prop.c
@@ -1109,6 +1109,10 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,
   if (!base)
     return false;
 
+  /* We can not propagate across volatile loads.  */
+  if (TREE_THIS_VOLATILE (op))
+    return false;
+
   if (DECL_P (base))
     {
       int index = ipa_get_param_decl_index_1 (descriptors, base);
diff --git a/gcc/ira-color.c b/gcc/ira-color.c
index d9f66e1e2bc..9f44157456d 100644
--- a/gcc/ira-color.c
+++ b/gcc/ira-color.c
@@ -1967,8 +1967,8 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)
     restore_costs_from_copies (a);
   ALLOCNO_HARD_REGNO (a) = best_hard_regno;
   ALLOCNO_ASSIGNED_P (a) = true;
-  if (best_hard_regno >= 0)
-    update_costs_from_copies (a, true, ! retry_p);
+  if (best_hard_regno >= 0 && !retry_p)
+    update_costs_from_copies (a, true, true);
   ira_assert (ALLOCNO_CLASS (a) == aclass);
   /* We don't need updated costs anymore.  */
   ira_free_allocno_updated_costs (a);
diff --git a/gcc/ira.c b/gcc/ira.c
index b93588d8a9f..ad40506d2a9 100644
--- a/gcc/ira.c
+++ b/gcc/ira.c
@@ -5613,6 +5613,7 @@ ira (FILE *f)
     regstat_free_ri ();
     regstat_init_n_sets_and_refs ();
     regstat_compute_ri ();
+    resize_reg_info ();
   };
 
   int max_regno_before_rm = max_reg_num ();
diff --git a/gcc/jit/ChangeLog b/gcc/jit/ChangeLog
index a6488d7c1db..8255ddde21f 100644
--- a/gcc/jit/ChangeLog
+++ b/gcc/jit/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/loop-invariant.c b/gcc/loop-invariant.c
index 633d35b1205..a3f2c0e8c93 100644
--- a/gcc/loop-invariant.c
+++ b/gcc/loop-invariant.c
@@ -1831,6 +1831,8 @@ move_invariant_reg (class loop *loop, unsigned invno)
       else if (dump_file)
 	fprintf (dump_file, "Invariant %d moved without introducing a new "
 			    "temporary register\n", invno);
+      if (JUMP_P (BB_END (preheader)))
+	preheader = split_edge (loop_preheader_edge (loop));
       reorder_insns (inv->insn, inv->insn, BB_END (preheader));
       df_recompute_luids (preheader);
 
diff --git a/gcc/lra-assigns.c b/gcc/lra-assigns.c
index b406096a39c..0ec0a79080a 100644
--- a/gcc/lra-assigns.c
+++ b/gcc/lra-assigns.c
@@ -1775,8 +1775,8 @@ lra_split_hard_reg_for (void)
      iterations.  Either it's an asm and something is wrong with the
      constraints, or we have run out of spill registers; error out in
      either case.  */
-  bool asm_p = false;
-  bitmap_head failed_reload_insns, failed_reload_pseudos;
+  bool asm_p = false, spill_p = false;
+  bitmap_head failed_reload_insns, failed_reload_pseudos, over_split_insns;
   
   if (lra_dump_file != NULL)
     fprintf (lra_dump_file,
@@ -1787,6 +1787,7 @@ lra_split_hard_reg_for (void)
   bitmap_ior (&non_reload_pseudos, &lra_inheritance_pseudos, &lra_split_regs);
   bitmap_ior_into (&non_reload_pseudos, &lra_subreg_reload_pseudos);
   bitmap_ior_into (&non_reload_pseudos, &lra_optional_reload_pseudos);
+  bitmap_initialize (&over_split_insns, &reg_obstack);
   for (i = lra_constraint_new_regno_start; i < max_regno; i++)
     if (reg_renumber[i] < 0 && lra_reg_info[i].nrefs != 0
 	&& (rclass = lra_get_allocno_class (i)) != NO_REGS
@@ -1794,14 +1795,41 @@ lra_split_hard_reg_for (void)
       {
 	if (! find_reload_regno_insns (i, first, last))
 	  continue;
-	if (BLOCK_FOR_INSN (first) == BLOCK_FOR_INSN (last)
-	    && spill_hard_reg_in_range (i, rclass, first, last))
+	if (BLOCK_FOR_INSN (first) == BLOCK_FOR_INSN (last))
 	  {
-	    bitmap_clear (&failed_reload_pseudos);
-	    return true;
+	    /* Check that we are not trying to split over the same insn
+	       requiring reloads to avoid splitting the same hard reg twice or
+	       more.  If we need several hard regs splitting over the same insn
+	       it can be finished on the next iterations.
+
+	       The following loop iteration number is small as we split hard
+	       reg in a very small range.  */
+	    for (insn = first;
+		 insn != NEXT_INSN (last);
+		 insn = NEXT_INSN (insn))
+	      if (bitmap_bit_p (&over_split_insns, INSN_UID (insn)))
+		break;
+	    if (insn != NEXT_INSN (last)
+		|| !spill_hard_reg_in_range (i, rclass, first, last))
+	      {
+		bitmap_set_bit (&failed_reload_pseudos, i);
+	      }
+	    else
+	      {
+		for (insn = first;
+		     insn != NEXT_INSN (last);
+		     insn = NEXT_INSN (insn))
+		  bitmap_set_bit (&over_split_insns, INSN_UID (insn));
+		spill_p = true;
+	      }
 	  }
-	bitmap_set_bit (&failed_reload_pseudos, i);
       }
+  bitmap_clear (&over_split_insns);
+  if (spill_p)
+    {
+      bitmap_clear (&failed_reload_pseudos);
+      return true;
+    }
   bitmap_clear (&non_reload_pseudos);
   bitmap_initialize (&failed_reload_insns, &reg_obstack);
   EXECUTE_IF_SET_IN_BITMAP (&failed_reload_pseudos, 0, u, bi)
diff --git a/gcc/lto-streamer-in.c b/gcc/lto-streamer-in.c
index eb8a7dc57b0..0c5af5cecef 100644
--- a/gcc/lto-streamer-in.c
+++ b/gcc/lto-streamer-in.c
@@ -1699,11 +1699,14 @@ lto_read_tree_1 (class lto_input_block *ib, class data_in *data_in, tree expr)
   /* Read all the pointer fields in EXPR.  */
   streamer_read_tree_body (ib, data_in, expr);
 
-  /* Read any LTO-specific data not read by the tree streamer.  */
+  /* Read any LTO-specific data not read by the tree streamer.  Do not use
+     stream_read_tree here since that flushes the dref_queue in mids of
+     SCC reading.  */
   if (DECL_P (expr)
       && TREE_CODE (expr) != FUNCTION_DECL
       && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)
-    DECL_INITIAL (expr) = stream_read_tree (ib, data_in);
+    DECL_INITIAL (expr)
+      = lto_input_tree_1 (ib, data_in, streamer_read_record_start (ib), 0);
 
   /* Stream references to early generated DIEs.  Keep in sync with the
      trees handled in dwarf2out_register_external_die.  */
diff --git a/gcc/lto-wrapper.c b/gcc/lto-wrapper.c
index 03a5922f8ea..038784ca2dc 100644
--- a/gcc/lto-wrapper.c
+++ b/gcc/lto-wrapper.c
@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see
    ./ccCJuXGv.lto.ltrans.o
 */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -48,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "simple-object.h"
 #include "lto-section-names.h"
 #include "collect-utils.h"
+#include "opts-jobserver.h"
 
 /* Environment variable, used for passing the names of offload targets from GCC
    driver to lto-wrapper.  */
@@ -1304,37 +1306,6 @@ init_num_threads (void)
 #endif
 }
 
-/* FIXME: once using -std=c++11, we can use std::thread::hardware_concurrency.  */
-
-/* Test and return reason why a jobserver cannot be detected.  */
-
-static const char *
-jobserver_active_p (void)
-{
-  #define JS_PREFIX "jobserver is not available: "
-  #define JS_NEEDLE "--jobserver-auth="
-
-  const char *makeflags = getenv ("MAKEFLAGS");
-  if (makeflags == NULL)
-    return JS_PREFIX "%<MAKEFLAGS%> environment variable is unset";
-
-  const char *n = strstr (makeflags, JS_NEEDLE);
-  if (n == NULL)
-    return JS_PREFIX "%<" JS_NEEDLE "%> is not present in %<MAKEFLAGS%>";
-
-  int rfd = -1;
-  int wfd = -1;
-
-  if (sscanf (n + strlen (JS_NEEDLE), "%d,%d", &rfd, &wfd) == 2
-      && rfd > 0
-      && wfd > 0
-      && is_valid_fd (rfd)
-      && is_valid_fd (wfd))
-    return NULL;
-  else
-    return JS_PREFIX "cannot access %<" JS_NEEDLE "%> file descriptors";
-}
-
 /* Test that a make command is present and working, return true if so.  */
 
 static bool
@@ -1549,6 +1520,14 @@ run_gcc (unsigned argc, char *argv[])
 	  skip_debug = option->arg && !strcmp (option->arg, "0");
 	  break;
 
+	case OPT_gdwarf:
+	case OPT_gdwarf_:
+	case OPT_ggdb:
+	case OPT_gvms:
+	  /* Negative forms, if allowed, enable debug info as well.  */
+	  skip_debug = false;
+	  break;
+
 	case OPT_dumpdir:
 	  incoming_dumppfx = dumppfx = option->arg;
 	  break;
@@ -1581,14 +1560,14 @@ run_gcc (unsigned argc, char *argv[])
     }
   else
     {
-      const char *jobserver_error = jobserver_active_p ();
-      if (jobserver && jobserver_error != NULL)
+      jobserver_info jinfo;
+      if (jobserver && !jinfo.is_active)
 	{
-	  warning (0, jobserver_error);
+	  warning (0, jinfo.error_msg.c_str ());
 	  parallel = 0;
 	  jobserver = 0;
 	}
-      else if (!jobserver && jobserver_error == NULL)
+      else if (!jobserver && jinfo.is_active)
 	{
 	  parallel = 1;
 	  jobserver = 1;
@@ -1903,6 +1882,15 @@ cont:
       maybe_unlink (ltrans_output_file);
       ltrans_output_file = NULL;
 
+      if (nr > 1)
+	{
+	  jobserver_info jinfo;
+	  if (jobserver && !jinfo.is_active)
+	    warning (0, jinfo.error_msg.c_str ());
+	  else if (parallel == 0)
+	    warning (0, "using serial compilation of %d LTRANS jobs", nr);
+	}
+
       if (parallel)
 	{
 	  makefile = make_temp_file (".mk");
diff --git a/gcc/lto/ChangeLog b/gcc/lto/ChangeLog
index 0a1fa489549..fe5c2a2123e 100644
--- a/gcc/lto/ChangeLog
+++ b/gcc/lto/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/match.pd b/gcc/match.pd
index e89601c0c14..ba09a901b5b 100644
--- a/gcc/match.pd
+++ b/gcc/match.pd
@@ -1543,7 +1543,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 /* (x | CST1) & CST2 -> (x & CST2) | (CST1 & CST2) */
 (simplify
   (bit_and (bit_ior @0 CONSTANT_CLASS_P@1) CONSTANT_CLASS_P@2)
-  (bit_ior (bit_and @0 @2) (bit_and @1 @2)))
+  (bit_ior (bit_and @0 @2) (bit_and! @1 @2)))
 
 /* Combine successive equal operations with constants.  */
 (for bitop (bit_and bit_ior bit_xor)
@@ -1552,7 +1552,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
   (if (!CONSTANT_CLASS_P (@0))
    /* This is the canonical form regardless of whether (bitop @1 @2) can be
       folded to a constant.  */
-   (bitop @0 (bitop @1 @2))
+   (bitop @0 (bitop! @1 @2))
    /* In this case we have three constants and (bitop @0 @1) doesn't fold
       to a constant.  This can happen if @0 or @1 is a POLY_INT_CST and if
       the values involved are such that the operation can't be decided at
@@ -2432,13 +2432,13 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 	 forever if something doesn't simplify into a constant.  */
       (if (!CONSTANT_CLASS_P (@0))
        (if (outer_op == PLUS_EXPR)
-	(plus (view_convert @0) (inner_op @2 (view_convert @1)))
-	(minus (view_convert @0) (neg_inner_op @2 (view_convert @1)))))
+	(plus (view_convert @0) (inner_op! @2 (view_convert @1)))
+	(minus (view_convert @0) (neg_inner_op! @2 (view_convert @1)))))
       (if (!ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))
 	   || TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))
        (if (outer_op == PLUS_EXPR)
-	(view_convert (plus @0 (inner_op (view_convert @2) @1)))
-	(view_convert (minus @0 (neg_inner_op (view_convert @2) @1))))
+	(view_convert (plus @0 (inner_op! (view_convert @2) @1)))
+	(view_convert (minus @0 (neg_inner_op! (view_convert @2) @1))))
        /* If the constant operation overflows we cannot do the transform
 	  directly as we would introduce undefined overflow, for example
 	  with (a - 1) + INT_MIN.  */
@@ -2469,10 +2469,10 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
      /* If all 3 captures are CONSTANT_CLASS_P, punt, as we might recurse
 	forever if something doesn't simplify into a constant.  */
      (if (!CONSTANT_CLASS_P (@0))
-      (minus (outer_op (view_convert @1) @2) (view_convert @0)))
+      (minus (outer_op! (view_convert @1) @2) (view_convert @0)))
      (if (!ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))
 	  || TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))
-      (view_convert (minus (outer_op @1 (view_convert @2)) @0))
+      (view_convert (minus (outer_op! @1 (view_convert @2)) @0))
       (if (types_match (type, @0))
        (with { tree cst = const_binop (outer_op, type, @1, @2); }
 	(if (cst && !TREE_OVERFLOW (cst))
@@ -2488,10 +2488,10 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
     /* If all 3 captures are CONSTANT_CLASS_P, punt, as we might recurse
       forever if something doesn't simplify into a constant.  */
     (if (!CONSTANT_CLASS_P (@0))
-     (plus (view_convert @0) (minus @1 (view_convert @2))))
+     (plus (view_convert @0) (minus! @1 (view_convert @2))))
     (if (!ANY_INTEGRAL_TYPE_P (TREE_TYPE (@0))
 	 || TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))
-     (view_convert (plus @0 (minus (view_convert @1) @2)))
+     (view_convert (plus @0 (minus! (view_convert @1) @2)))
      (if (types_match (type, @0))
       (with { tree cst = const_binop (MINUS_EXPR, type, @1, @2); }
        (if (cst && !TREE_OVERFLOW (cst))
@@ -3675,6 +3675,10 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
 /* (v ? w : 0) ? a : b is just (v & w) ? a : b
    Currently disabled after pass lvec because ARM understands
    VEC_COND_EXPR<v==w,-1,0> but not a plain v==w fed to BIT_IOR_EXPR.  */
+#if GIMPLE
+/* These can only be done in gimple as fold likes to convert:
+   (CMP) & N into (CMP) ? N : 0
+   and we try to match the same pattern again and again. */
 (simplify
  (vec_cond (vec_cond:s @0 @3 integer_zerop) @1 @2)
  (if (optimize_vectors_before_lowering_p () && types_match (@0, @3))
@@ -3709,6 +3713,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
  (vec_cond @0 @3 (vec_cond:s @1 @2 @3))
  (if (optimize_vectors_before_lowering_p () && types_match (@0, @1))
   (vec_cond (bit_and (bit_not @0) @1) @2 @3)))
+#endif
 
 /* Canonicalize mask ? { 0, ... } : { -1, ...} to ~mask if the mask
    types are compatible.  */
@@ -4114,7 +4119,10 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
   (if (! FLOAT_TYPE_P (TREE_TYPE (@0))
        || ! HONOR_NANS (@0))
    { constant_boolean_node (true, type); }
-   (if (cmp != EQ_EXPR)
+   (if (cmp != EQ_EXPR
+	/* With -ftrapping-math conversion to EQ loses an exception.  */
+	&& (! FLOAT_TYPE_P (TREE_TYPE (@0))
+	    || ! flag_trapping_math))
     (eq @0 @0)))))
 (for cmp (ne gt lt)
  (simplify
@@ -6261,7 +6269,9 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)
       isize = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (@1)));
   }
   (switch
-   (if (wi::leu_p (wi::to_wide (@ipos), wi::to_wide (@rpos))
+   (if ((!INTEGRAL_TYPE_P (TREE_TYPE (@1))
+         || type_has_mode_precision_p (TREE_TYPE (@1)))
+        && wi::leu_p (wi::to_wide (@ipos), wi::to_wide (@rpos))
 	&& wi::leu_p (wi::to_wide (@rpos) + wi::to_wide (@rsize),
 		      wi::to_wide (@ipos) + isize))
     (BIT_FIELD_REF @1 @rsize { wide_int_to_tree (bitsizetype,
diff --git a/gcc/objc/ChangeLog b/gcc/objc/ChangeLog
index b3758fad724..789ae00d665 100644
--- a/gcc/objc/ChangeLog
+++ b/gcc/objc/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/objcp/ChangeLog b/gcc/objcp/ChangeLog
index 5654106fb88..66c468bd675 100644
--- a/gcc/objcp/ChangeLog
+++ b/gcc/objcp/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/omp-expand.c b/gcc/omp-expand.c
index dc797f95154..72b0551b312 100644
--- a/gcc/omp-expand.c
+++ b/gcc/omp-expand.c
@@ -1982,8 +1982,8 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,
 	    t = fold_build2 (MINUS_EXPR, itype, unshare_expr (fd->loops[i].m2),
 			     unshare_expr (fd->loops[i].m1));
 	  else if (fd->loops[i].m1)
-	    t = fold_unary (NEGATE_EXPR, itype,
-			    unshare_expr (fd->loops[i].m1));
+	    t = fold_build1 (NEGATE_EXPR, itype,
+			     unshare_expr (fd->loops[i].m1));
 	  else
 	    t = unshare_expr (fd->loops[i].m2);
 	  tree m2minusm1
@@ -3501,7 +3501,7 @@ expand_omp_ordered_source_sink (struct omp_region *region,
 static basic_block
 expand_omp_for_ordered_loops (struct omp_for_data *fd, tree *counts,
 			      basic_block cont_bb, basic_block body_bb,
-			      bool ordered_lastprivate)
+			      basic_block l0_bb, bool ordered_lastprivate)
 {
   if (fd->ordered == fd->collapse)
     return cont_bb;
@@ -3606,7 +3606,7 @@ expand_omp_for_ordered_loops (struct omp_for_data *fd, tree *counts,
 	  class loop *loop = alloc_loop ();
 	  loop->header = new_header;
 	  loop->latch = e2->src;
-	  add_loop (loop, body_bb->loop_father);
+	  add_loop (loop, l0_bb->loop_father);
 	}
     }
 
@@ -4294,9 +4294,15 @@ expand_omp_for_generic (struct omp_region *region,
 	    }
 	  if (i < fd->ordered)
 	    {
+	      if (entry_bb->loop_father != l0_bb->loop_father)
+		{
+		  remove_bb_from_loops (l0_bb);
+		  add_bb_to_loop (l0_bb, entry_bb->loop_father);
+		  gcc_assert (single_succ (l0_bb) == l1_bb);
+		}
 	      cont_bb
 		= create_empty_bb (EXIT_BLOCK_PTR_FOR_FN (cfun)->prev_bb);
-	      add_bb_to_loop (cont_bb, l1_bb->loop_father);
+	      add_bb_to_loop (cont_bb, l0_bb->loop_father);
 	      gimple_stmt_iterator gsi = gsi_after_labels (cont_bb);
 	      gimple *g = gimple_build_omp_continue (fd->loop.v, fd->loop.v);
 	      gsi_insert_before (&gsi, g, GSI_SAME_STMT);
@@ -4308,7 +4314,7 @@ expand_omp_for_generic (struct omp_region *region,
 	}
       expand_omp_ordered_source_sink (region, fd, counts, cont_bb);
       cont_bb = expand_omp_for_ordered_loops (fd, counts, cont_bb, l1_bb,
-					      ordered_lastprivate);
+					      l0_bb, ordered_lastprivate);
       if (counts[fd->collapse - 1])
 	{
 	  gcc_assert (fd->collapse == 1);
@@ -10043,7 +10049,10 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,
 		case GF_OMP_TARGET_KIND_OACC_UPDATE:
 		case GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:
 		case GF_OMP_TARGET_KIND_OACC_DECLARE:
-		  /* ..., other than for those stand-alone directives...  */
+		  /* ..., other than for those stand-alone directives...
+		     To be precise, target data isn't stand-alone, but
+		     gimplifier put the end API call into try finally block
+		     for it, so omp expansion can treat it as such.  */
 		  region = NULL;
 		  break;
 		default:
@@ -10061,6 +10070,11 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,
 		   && gimple_omp_task_taskwait_p (stmt))
 	    /* #pragma omp taskwait depend(...) is a stand-alone directive.  */
 	    region = NULL;
+	  else if (code == GIMPLE_OMP_TASKGROUP)
+	    /* #pragma omp taskgroup isn't a stand-alone directive, but
+	       gimplifier put the end API call into try finall block
+	       for it, so omp expansion can treat it as such.  */
+	    region = NULL;
 	  /* ..., this directive becomes the parent for a new region.  */
 	  if (region)
 	    parent = region;
@@ -10255,13 +10269,18 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,
     case GIMPLE_OMP_SINGLE:
     case GIMPLE_OMP_TEAMS:
     case GIMPLE_OMP_MASTER:
-    case GIMPLE_OMP_TASKGROUP:
     case GIMPLE_OMP_CRITICAL:
     case GIMPLE_OMP_SECTION:
       cur_region = new_omp_region (bb, code, cur_region);
       fallthru = true;
       break;
 
+    case GIMPLE_OMP_TASKGROUP:
+      cur_region = new_omp_region (bb, code, cur_region);
+      fallthru = true;
+      cur_region = cur_region->outer;
+      break;
+
     case GIMPLE_OMP_TASK:
       cur_region = new_omp_region (bb, code, cur_region);
       fallthru = true;
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index 962cf886710..8d76127934b 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -5903,10 +5903,10 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 			}
 
 		      if (POINTER_TYPE_P (TREE_TYPE (x)))
-			x = fold_build2 (POINTER_PLUS_EXPR,
-					 TREE_TYPE (x), x, t);
+			x = fold_build_pointer_plus (x, t);
 		      else
-			x = fold_build2 (PLUS_EXPR, TREE_TYPE (x), x, t);
+			x = fold_build2 (PLUS_EXPR, TREE_TYPE (x), x,
+					 fold_convert (TREE_TYPE (x), t));
 		    }
 
 		  if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LINEAR
@@ -9217,7 +9217,6 @@ lower_omp_taskgroup (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   gimple_bind_add_seq (bind, gimple_omp_body (stmt));
   gimple_omp_set_body (stmt, NULL);
 
-  gimple_bind_add_stmt (bind, gimple_build_omp_return (true));
   gimple_bind_add_seq (bind, dseq);
 
   pop_gimplify_context (bind);
@@ -12911,7 +12910,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)
 				     gimple_build_assign (new_var, x));
 	      }
 	    tree present;
-	    present = (do_optional_check
+	    present = ((do_optional_check
+			&& OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR)
 		       ? omp_check_optional_argument (OMP_CLAUSE_DECL (c), true)
 		       : NULL_TREE);
 	    if (present)
diff --git a/gcc/optc-save-gen.awk b/gcc/optc-save-gen.awk
index 19afa895930..a1864689eb6 100644
--- a/gcc/optc-save-gen.awk
+++ b/gcc/optc-save-gen.awk
@@ -1013,7 +1013,7 @@ for (i = 0; i < n_target_string; i++) {
 	print "             indent, \"\",";
 	print "             \"" name "\",";
 	print "             ptr1->x_" name " ? ptr1->x_" name " : \"(null)\",";
-	print "             ptr2->x_" name " ? ptr1->x_" name " : \"(null)\");";
+	print "             ptr2->x_" name " ? ptr2->x_" name " : \"(null)\");";
 	print "";
 }
 
diff --git a/gcc/opts-common.c b/gcc/opts-common.c
index 5e10edeb4cf..e41d21d8ddc 100644
--- a/gcc/opts-common.c
+++ b/gcc/opts-common.c
@@ -17,6 +17,7 @@ You should have received a copy of the GNU General Public License
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#define INCLUDE_STRING
 #include "config.h"
 #include "system.h"
 #include "intl.h"
@@ -25,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "options.h"
 #include "diagnostic.h"
 #include "spellcheck.h"
+#include "opts-jobserver.h"
 
 static void prune_options (struct cl_decoded_option **, unsigned int *);
 
@@ -1848,3 +1850,55 @@ void prepend_xassembler_to_collect_as_options (const char *collect_as_options,
       obstack_1grow (o, '\'');
     }
 }
+
+jobserver_info::jobserver_info ()
+{
+  /* Traditionally, GNU make uses opened pipes for jobserver-auth,
+    e.g. --jobserver-auth=3,4.
+    Starting with GNU make 4.4, one can use --jobserver-style=fifo
+    and then named pipe is used: --jobserver-auth=fifo:/tmp/hcsparta.  */
+
+  /* Detect jobserver and drop it if it's not working.  */
+  string js_needle = "--jobserver-auth=";
+  string fifo_prefix = "fifo:";
+
+  const char *envval = getenv ("MAKEFLAGS");
+  if (envval != NULL)
+    {
+      string makeflags = envval;
+      size_t n = makeflags.rfind (js_needle);
+      if (n != string::npos)
+	{
+	  string ending = makeflags.substr (n + js_needle.size ());
+	  if (ending.find (fifo_prefix) == 0)
+	    {
+	      ending = ending.substr (fifo_prefix.size ());
+	      pipe_path = ending.substr (0, ending.find (' '));
+	      is_active = true;
+	    }
+	  else if (sscanf (makeflags.c_str () + n + js_needle.size (),
+			   "%d,%d", &rfd, &wfd) == 2
+	      && rfd > 0
+	      && wfd > 0
+	      && is_valid_fd (rfd)
+	      && is_valid_fd (wfd))
+	    is_active = true;
+	  else
+	    {
+	      string dup = makeflags.substr (0, n);
+	      size_t pos = makeflags.find (' ', n);
+	      if (pos != string::npos)
+		dup += makeflags.substr (pos);
+	      skipped_makeflags = "MAKEFLAGS=" + dup;
+	      error_msg
+		= "cannot access %<" + js_needle + "%> file descriptors";
+	    }
+	}
+      error_msg = "%<" + js_needle + "%> is not present in %<MAKEFLAGS%>";
+    }
+  else
+    error_msg = "%<MAKEFLAGS%> environment variable is unset";
+
+  if (!error_msg.empty ())
+    error_msg = "jobserver is not available: " + error_msg;
+}
diff --git a/gcc/opts-jobserver.h b/gcc/opts-jobserver.h
new file mode 100644
index 00000000000..98ea2579962
--- /dev/null
+++ b/gcc/opts-jobserver.h
@@ -0,0 +1,46 @@
+/* GNU make's jobserver related functionality.
+   Copyright (C) 2022 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.
+
+See dbgcnt.def for usage information.  */
+
+#ifndef GCC_JOBSERVER_H
+#define GCC_JOBSERVER_H
+
+using namespace std;
+
+struct jobserver_info
+{
+  /* Default constructor.  */
+  jobserver_info ();
+
+  /* Error message if there is a problem.  */
+  string error_msg = "";
+  /* Skipped MAKEFLAGS where --jobserver-auth is skipped.  */
+  string skipped_makeflags = "";
+  /* File descriptor for reading used for jobserver communication.  */
+  int rfd = -1;
+  /* File descriptor for writing used for jobserver communication.  */
+  int wfd = -1;
+  /* Named pipe path.  */
+  string pipe_path = "";
+  /* Return true if jobserver is active.  */
+  bool is_active = false;
+};
+
+#endif /* GCC_JOBSERVER_H */
diff --git a/gcc/po/ChangeLog b/gcc/po/ChangeLog
index a1e2b6802c2..d052046ac4b 100644
--- a/gcc/po/ChangeLog
+++ b/gcc/po/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/postreload.c b/gcc/postreload.c
index 60a622dbaf3..ed5f54aaeb0 100644
--- a/gcc/postreload.c
+++ b/gcc/postreload.c
@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see
 #include "function-abi.h"
 #include "rtl-iter.h"
 
-static int reload_cse_noop_set_p (rtx);
 static bool reload_cse_simplify (rtx_insn *, rtx);
 static void reload_cse_regs_1 (void);
 static int reload_cse_simplify_set (rtx, rtx_insn *);
@@ -74,16 +73,6 @@ reload_cse_regs (rtx_insn *first ATTRIBUTE_UNUSED)
     }
 }
 
-/* See whether a single set SET is a noop.  */
-static int
-reload_cse_noop_set_p (rtx set)
-{
-  if (cselib_reg_set_mode (SET_DEST (set)) != GET_MODE (SET_DEST (set)))
-    return 0;
-
-  return rtx_equal_for_cselib_p (SET_DEST (set), SET_SRC (set));
-}
-
 /* Try to simplify INSN.  Return true if the CFG may have changed.  */
 static bool
 reload_cse_simplify (rtx_insn *insn, rtx testreg)
@@ -118,7 +107,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)
          this out, so it's safer to simplify before we delete.  */
       count += reload_cse_simplify_set (body, insn);
 
-      if (!count && reload_cse_noop_set_p (body))
+      if (!count && cselib_redundant_set_p (body))
 	{
 	  if (check_for_inc_dec (insn))
 	    delete_insn_and_edges (insn);
@@ -157,7 +146,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)
 	  rtx part = XVECEXP (body, 0, i);
 	  if (GET_CODE (part) == SET)
 	    {
-	      if (! reload_cse_noop_set_p (part))
+	      if (! cselib_redundant_set_p (part))
 		break;
 	      if (REG_P (SET_DEST (part))
 		  && REG_FUNCTION_VALUE_P (SET_DEST (part)))
diff --git a/gcc/predict.c b/gcc/predict.c
index d0a8e5f8e04..75b09fa9e1b 100644
--- a/gcc/predict.c
+++ b/gcc/predict.c
@@ -4023,7 +4023,9 @@ compute_function_frequency (void)
     }
 
   node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;
-  warn_function_cold (current_function_decl);
+  if (lookup_attribute ("cold", DECL_ATTRIBUTES (current_function_decl))
+      == NULL)
+    warn_function_cold (current_function_decl);
   if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.ipa() == profile_count::zero ())
     return;
   FOR_EACH_BB_FN (bb, cfun)
diff --git a/gcc/range-op.cc b/gcc/range-op.cc
index c33f4edc2c1..e58821a1ceb 100644
--- a/gcc/range-op.cc
+++ b/gcc/range-op.cc
@@ -2649,6 +2649,9 @@ operator_bitwise_xor::op1_range (irange &r, tree type,
 	    r.set_varying (type);
 	  else if (op2.zero_p ())
 	    r = range_true (type);
+	  // See get_bool_state for the rationale
+	  else if (op2.contains_p (build_zero_cst (op2.type ())))
+	    r = range_true_and_false (type);
 	  else
 	    r = range_false (type);
 	  break;
diff --git a/gcc/ree.c b/gcc/ree.c
index 65457c582c6..e2b793272f6 100644
--- a/gcc/ree.c
+++ b/gcc/ree.c
@@ -876,7 +876,8 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)
 
 	  for (df_link *use = uses; use; use = use->next)
 	    if (paradoxical_subreg_p (GET_MODE (*DF_REF_LOC (use->ref)),
-				      GET_MODE (SET_DEST (*dest_sub_rtx))))
+				      GET_MODE (SET_DEST (*dest_sub_rtx)))
+		&& !DEBUG_INSN_P (DF_REF_INSN (use->ref)))
 	      return false;
 	}
 
@@ -965,7 +966,8 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)
 	      rtx dest2 = SET_DEST (*dest_sub_rtx2);
 	      for (use = uses; use; use = use->next)
 		if (paradoxical_subreg_p (GET_MODE (*DF_REF_LOC (use->ref)),
-					  GET_MODE (dest2)))
+					  GET_MODE (dest2))
+		    && !DEBUG_INSN_P (DF_REF_INSN (use->ref)))
 		  break;
 	      if (use)
 		break;
diff --git a/gcc/reg-stack.c b/gcc/reg-stack.c
index bace44e6468..fa3365f4c81 100644
--- a/gcc/reg-stack.c
+++ b/gcc/reg-stack.c
@@ -262,14 +262,14 @@ static void swap_to_top (rtx_insn *, stack_ptr, rtx, rtx);
 static bool move_for_stack_reg (rtx_insn *, stack_ptr, rtx);
 static bool move_nan_for_stack_reg (rtx_insn *, stack_ptr, rtx);
 static int swap_rtx_condition_1 (rtx);
-static int swap_rtx_condition (rtx_insn *);
+static int swap_rtx_condition (rtx_insn *, int &);
 static void compare_for_stack_reg (rtx_insn *, stack_ptr, rtx, bool);
 static bool subst_stack_regs_pat (rtx_insn *, stack_ptr, rtx);
 static void subst_asm_stack_regs (rtx_insn *, stack_ptr);
 static bool subst_stack_regs (rtx_insn *, stack_ptr);
 static void change_stack (rtx_insn *, stack_ptr, stack_ptr, enum emit_where);
 static void print_stack (FILE *, stack_ptr);
-static rtx_insn *next_flags_user (rtx_insn *);
+static rtx_insn *next_flags_user (rtx_insn *, int &);
 
 /* Return nonzero if any stack register is mentioned somewhere within PAT.  */
 
@@ -335,7 +335,7 @@ stack_regs_mentioned (const_rtx insn)
 static rtx ix86_flags_rtx;
 
 static rtx_insn *
-next_flags_user (rtx_insn *insn)
+next_flags_user (rtx_insn *insn, int &debug_seen)
 {
   /* Search forward looking for the first use of this value.
      Stop at block boundaries.  */
@@ -345,7 +345,14 @@ next_flags_user (rtx_insn *insn)
       insn = NEXT_INSN (insn);
 
       if (INSN_P (insn) && reg_mentioned_p (ix86_flags_rtx, PATTERN (insn)))
-	return insn;
+	{
+	  if (DEBUG_INSN_P (insn) && debug_seen >= 0)
+	    {
+	      debug_seen = 1;
+	      continue;
+	    }
+	  return insn;
+	}
 
       if (CALL_P (insn))
 	return NULL;
@@ -1246,8 +1253,22 @@ swap_rtx_condition_1 (rtx pat)
   return r;
 }
 
+/* This function swaps condition in cc users and returns true
+   if successful.  It is invoked in 2 different modes, one with
+   DEBUG_SEEN set initially to 0.  In this mode, next_flags_user
+   will skip DEBUG_INSNs that it would otherwise return and just
+   sets DEBUG_SEEN to 1 in that case.  If DEBUG_SEEN is 0 at
+   the end of toplevel swap_rtx_condition which returns true,
+   it means no problematic DEBUG_INSNs were seen and all changes
+   have been applied.  If it returns true but DEBUG_SEEN is 1,
+   it means some problematic DEBUG_INSNs were seen and no changes
+   have been applied so far.  In that case one needs to call
+   swap_rtx_condition again with DEBUG_SEEN set to -1, in which
+   case it doesn't skip DEBUG_INSNs, but instead adjusts the
+   flags related condition in them or resets them as needed.  */
+
 static int
-swap_rtx_condition (rtx_insn *insn)
+swap_rtx_condition (rtx_insn *insn, int &debug_seen)
 {
   rtx pat = PATTERN (insn);
 
@@ -1257,7 +1278,7 @@ swap_rtx_condition (rtx_insn *insn)
       && REG_P (SET_DEST (pat))
       && REGNO (SET_DEST (pat)) == FLAGS_REG)
     {
-      insn = next_flags_user (insn);
+      insn = next_flags_user (insn, debug_seen);
       if (insn == NULL_RTX)
 	return 0;
       pat = PATTERN (insn);
@@ -1279,7 +1300,18 @@ swap_rtx_condition (rtx_insn *insn)
 	{
 	  insn = NEXT_INSN (insn);
 	  if (INSN_P (insn) && reg_mentioned_p (dest, insn))
-	    break;
+	    {
+	      if (DEBUG_INSN_P (insn))
+		{
+		  if (debug_seen >= 0)
+		    debug_seen = 1;
+		  else
+		    /* Reset the DEBUG insn otherwise.  */
+		    INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();
+		  continue;
+		}
+	      break;
+	    }
 	  if (CALL_P (insn))
 	    return 0;
 	}
@@ -1299,7 +1331,7 @@ swap_rtx_condition (rtx_insn *insn)
 	return 0;
 
       /* Now we are prepared to handle this as a normal cc0 setter.  */
-      insn = next_flags_user (insn);
+      insn = next_flags_user (insn, debug_seen);
       if (insn == NULL_RTX)
 	return 0;
       pat = PATTERN (insn);
@@ -1308,23 +1340,25 @@ swap_rtx_condition (rtx_insn *insn)
   if (swap_rtx_condition_1 (pat))
     {
       int fail = 0;
-      INSN_CODE (insn) = -1;
-      if (recog_memoized (insn) == -1)
-	fail = 1;
+      if (DEBUG_INSN_P (insn))
+	gcc_assert (debug_seen < 0);
+      else
+	{
+	  INSN_CODE (insn) = -1;
+	  if (recog_memoized (insn) == -1)
+	    fail = 1;
+	}
       /* In case the flags don't die here, recurse to try fix
-         following user too.  */
-      else if (! dead_or_set_p (insn, ix86_flags_rtx))
+	 following user too.  */
+      if (!fail && !dead_or_set_p (insn, ix86_flags_rtx))
 	{
-	  insn = next_flags_user (insn);
-	  if (!insn || !swap_rtx_condition (insn))
+	  insn = next_flags_user (insn, debug_seen);
+	  if (!insn || !swap_rtx_condition (insn, debug_seen))
 	    fail = 1;
 	}
-      if (fail)
-	{
-	  swap_rtx_condition_1 (pat);
-	  return 0;
-	}
-      return 1;
+      if (fail || debug_seen == 1)
+	swap_rtx_condition_1 (pat);
+      return !fail;
     }
   return 0;
 }
@@ -1343,6 +1377,7 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack,
 {
   rtx *src1, *src2;
   rtx src1_note, src2_note;
+  int debug_seen = 0;
 
   src1 = get_true_reg (&XEXP (pat_src, 0));
   src2 = get_true_reg (&XEXP (pat_src, 1));
@@ -1352,8 +1387,17 @@ compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack,
   if ((! STACK_REG_P (*src1)
        || (STACK_REG_P (*src2)
 	   && get_hard_regnum (regstack, *src2) == FIRST_STACK_REG))
-      && swap_rtx_condition (insn))
+      && swap_rtx_condition (insn, debug_seen))
     {
+      /* If swap_rtx_condition succeeded but some debug insns
+	 were seen along the way, it has actually reverted all the
+	 changes.  Rerun swap_rtx_condition in a mode where DEBUG_ISNSs
+	 will be adjusted as well.  */
+      if (debug_seen)
+	{
+	  debug_seen = -1;
+	  swap_rtx_condition (insn, debug_seen);
+	}
       std::swap (XEXP (pat_src, 0), XEXP (pat_src, 1));
 
       src1 = get_true_reg (&XEXP (pat_src, 0));
diff --git a/gcc/regrename.c b/gcc/regrename.c
index c0d4643f802..0cf93d323d9 100644
--- a/gcc/regrename.c
+++ b/gcc/regrename.c
@@ -324,8 +324,7 @@ static bool
 check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,
 		 class du_head *this_head, HARD_REG_SET this_unavailable)
 {
-  machine_mode mode = GET_MODE (*this_head->first->loc);
-  int nregs = hard_regno_nregs (new_reg, mode);
+  int nregs = this_head->nregs;
   int i;
   struct du_chain *tmp;
 
diff --git a/gcc/rtl-ssa/accesses.cc b/gcc/rtl-ssa/accesses.cc
index de3a29edbeb..af7b568fa98 100644
--- a/gcc/rtl-ssa/accesses.cc
+++ b/gcc/rtl-ssa/accesses.cc
@@ -393,6 +393,28 @@ set_node::print (pretty_printer *pp) const
   pp_access (pp, first_def ());
 }
 
+// See the comment above the declaration.
+clobber_info *
+clobber_group::prev_clobber (insn_info *insn) const
+{
+  auto &tree = const_cast<clobber_tree &> (m_clobber_tree);
+  int comparison = lookup_clobber (tree, insn);
+  if (comparison <= 0)
+    return dyn_cast<clobber_info *> (tree.root ()->prev_def ());
+  return tree.root ();
+}
+
+// See the comment above the declaration.
+clobber_info *
+clobber_group::next_clobber (insn_info *insn) const
+{
+  auto &tree = const_cast<clobber_tree &> (m_clobber_tree);
+  int comparison = lookup_clobber (tree, insn);
+  if (comparison >= 0)
+    return dyn_cast<clobber_info *> (tree.root ()->next_def ());
+  return tree.root ();
+}
+
 // See the comment above the declaration.
 void
 clobber_group::print (pretty_printer *pp) const
@@ -415,6 +437,32 @@ clobber_group::print (pretty_printer *pp) const
   pp_indentation (pp) -= 4;
 }
 
+// See the comment above the declaration.
+def_info *
+def_lookup::prev_def (insn_info *insn) const
+{
+  if (mux && comparison == 0)
+    if (auto *node = mux.dyn_cast<def_node *> ())
+      if (auto *group = dyn_cast<clobber_group *> (node))
+	if (clobber_info *clobber = group->prev_clobber (insn))
+	  return clobber;
+
+  return last_def_of_prev_group ();
+}
+
+// See the comment above the declaration.
+def_info *
+def_lookup::next_def (insn_info *insn) const
+{
+  if (mux && comparison == 0)
+    if (auto *node = mux.dyn_cast<def_node *> ())
+      if (auto *group = dyn_cast<clobber_group *> (node))
+	if (clobber_info *clobber = group->next_clobber (insn))
+	  return clobber;
+
+  return first_def_of_next_group ();
+}
+
 // Return a clobber_group for CLOBBER, creating one if CLOBBER doesn't
 // already belong to a group.
 clobber_group *
@@ -1295,9 +1343,9 @@ function_info::make_use_available (use_info *use, bb_info *bb)
 	  input->m_is_temp = true;
 	  phi->m_is_temp = true;
 	  phi->make_degenerate (input);
-	  if (def_info *prev = dl.prev_def ())
+	  if (def_info *prev = dl.prev_def (phi_insn))
 	    phi->set_prev_def (prev);
-	  if (def_info *next = dl.next_def ())
+	  if (def_info *next = dl.next_def (phi_insn))
 	    phi->set_next_def (next);
 	}
 
diff --git a/gcc/rtl-ssa/accesses.h b/gcc/rtl-ssa/accesses.h
index 91e64f3321f..ed72a3f61f0 100644
--- a/gcc/rtl-ssa/accesses.h
+++ b/gcc/rtl-ssa/accesses.h
@@ -909,6 +909,12 @@ public:
   clobber_info *first_clobber () const;
   clobber_info *last_clobber () const { return m_last_clobber; }
 
+  // Return the last clobber before INSN in the group, or null if none.
+  clobber_info *prev_clobber (insn_info *insn) const;
+
+  // Return the next clobber after INSN in the group, or null if none.
+  clobber_info *next_clobber (insn_info *insn) const;
+
   // Return true if this group has been replaced by new clobber_groups.
   bool has_been_superceded () const { return !m_last_clobber; }
 
@@ -993,25 +999,33 @@ public:
   //
   // Otherwise, return the last definition that occurs before P,
   // or null if none.
-  def_info *prev_def () const;
+  def_info *last_def_of_prev_group () const;
 
   // If we found a clobber_group that spans P, return the definition
   // that follows the end of the group, or null if none.
   //
   // Otherwise, return the first definition that occurs after P,
   // or null if none.
-  def_info *next_def () const;
+  def_info *first_def_of_next_group () const;
 
   // If we found a set_info at P, return that set_info, otherwise return null.
   set_info *matching_set () const;
 
   // If we found a set_info at P, return that set_info, otherwise return
   // prev_def ().
-  def_info *matching_or_prev_def () const;
+  def_info *matching_set_or_last_def_of_prev_group () const;
 
   // If we found a set_info at P, return that set_info, otherwise return
   // next_def ().
-  def_info *matching_or_next_def () const;
+  def_info *matching_set_or_first_def_of_next_group () const;
+
+  // P is the location of INSN.  Return the last definition (of any kind)
+  // that occurs before INSN, or null if none.
+  def_info *prev_def (insn_info *insn) const;
+
+  // P is the location of INSN.  Return the next definition (of any kind)
+  // that occurs after INSN, or null if none.
+  def_info *next_def (insn_info *insn) const;
 
   def_mux mux;
   int comparison;
diff --git a/gcc/rtl-ssa/member-fns.inl b/gcc/rtl-ssa/member-fns.inl
index 0b821ae1a77..2aae89e5a94 100644
--- a/gcc/rtl-ssa/member-fns.inl
+++ b/gcc/rtl-ssa/member-fns.inl
@@ -401,7 +401,7 @@ def_mux::set () const
 }
 
 inline def_info *
-def_lookup::prev_def () const
+def_lookup::last_def_of_prev_group () const
 {
   if (!mux)
     return nullptr;
@@ -413,7 +413,7 @@ def_lookup::prev_def () const
 }
 
 inline def_info *
-def_lookup::next_def () const
+def_lookup::first_def_of_next_group () const
 {
   if (!mux)
     return nullptr;
@@ -433,19 +433,19 @@ def_lookup::matching_set () const
 }
 
 inline def_info *
-def_lookup::matching_or_prev_def () const
+def_lookup::matching_set_or_last_def_of_prev_group () const
 {
   if (set_info *set = matching_set ())
     return set;
-  return prev_def ();
+  return last_def_of_prev_group ();
 }
 
 inline def_info *
-def_lookup::matching_or_next_def () const
+def_lookup::matching_set_or_first_def_of_next_group () const
 {
   if (set_info *set = matching_set ())
     return set;
-  return next_def ();
+  return first_def_of_next_group ();
 }
 
 inline insn_note::insn_note (insn_note_kind kind)
diff --git a/gcc/rtl-ssa/movement.h b/gcc/rtl-ssa/movement.h
index 5e749235840..03e10e52193 100644
--- a/gcc/rtl-ssa/movement.h
+++ b/gcc/rtl-ssa/movement.h
@@ -103,7 +103,7 @@ restrict_movement_for_dead_range (insn_range_info &move_range,
   resource_info resource = full_register (regno);
   def_lookup dl = crtl->ssa->find_def (resource, insn);
 
-  def_info *prev = dl.prev_def ();
+  def_info *prev = dl.last_def_of_prev_group ();
   ebb_info *ebb = insn->ebb ();
   if (!prev || prev->ebb () != ebb)
     {
@@ -143,8 +143,8 @@ restrict_movement_for_dead_range (insn_range_info &move_range,
     }
 
   // Stop the instruction moving beyond the next relevant definition of REGNO.
-  def_info *next = first_def_ignoring (dl.matching_or_next_def (),
-				       ignore_clobbers::YES, ignore);
+  def_info *next = dl.matching_set_or_first_def_of_next_group ();
+  next = first_def_ignoring (next, ignore_clobbers::YES, ignore);
   if (next)
     move_range = move_earlier_than (move_range, next->insn ());
 
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
index 67a49e65fd8..88b37584f74 100644
--- a/gcc/rtlanal.c
+++ b/gcc/rtlanal.c
@@ -3405,7 +3405,7 @@ replace_rtx (rtx x, rtx from, rtx to, bool all_regs)
     {
       rtx new_rtx = replace_rtx (SUBREG_REG (x), from, to, all_regs);
 
-      if (CONST_INT_P (new_rtx))
+      if (CONST_SCALAR_INT_P (new_rtx))
 	{
 	  x = simplify_subreg (GET_MODE (x), new_rtx,
 			       GET_MODE (SUBREG_REG (x)),
@@ -3421,7 +3421,7 @@ replace_rtx (rtx x, rtx from, rtx to, bool all_regs)
     {
       rtx new_rtx = replace_rtx (XEXP (x, 0), from, to, all_regs);
 
-      if (CONST_INT_P (new_rtx))
+      if (CONST_SCALAR_INT_P (new_rtx))
 	{
 	  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
 					new_rtx, GET_MODE (XEXP (x, 0)));
diff --git a/gcc/sanopt.c b/gcc/sanopt.c
index 2910e33c1cc..f29f07c79f1 100644
--- a/gcc/sanopt.c
+++ b/gcc/sanopt.c
@@ -1275,6 +1275,7 @@ pass_sanopt::execute (function *fun)
   basic_block bb;
   int asan_num_accesses = 0;
   bool contains_asan_mark = false;
+  int ret = 0;
 
   /* Try to remove redundant checks.  */
   if (optimize
@@ -1327,6 +1328,7 @@ pass_sanopt::execute (function *fun)
 	  if (gimple_call_internal_p (stmt))
 	    {
 	      enum internal_fn ifn = gimple_call_internal_fn (stmt);
+	      int this_ret = TODO_cleanup_cfg;
 	      switch (ifn)
 		{
 		case IFN_UBSAN_NULL:
@@ -1362,8 +1364,10 @@ pass_sanopt::execute (function *fun)
 		  no_next = hwasan_expand_mark_ifn (&gsi);
 		  break;
 		default:
+		  this_ret = 0;
 		  break;
 		}
+	      ret |= this_ret;
 	    }
 	  else if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))
 	    {
@@ -1393,7 +1397,7 @@ pass_sanopt::execute (function *fun)
   if (need_commit_edge_insert)
     gsi_commit_edge_inserts ();
 
-  return 0;
+  return ret;
 }
 
 } // anon namespace
diff --git a/gcc/selftest-diagnostic.c b/gcc/selftest-diagnostic.c
index 27976f161b3..45f1446fb3c 100644
--- a/gcc/selftest-diagnostic.c
+++ b/gcc/selftest-diagnostic.c
@@ -41,6 +41,7 @@ test_diagnostic_context::test_diagnostic_context ()
   show_column = true;
   start_span = start_span_cb;
   min_margin_width = 6;
+  caret_max_width = 80;
 }
 
 test_diagnostic_context::~test_diagnostic_context ()
diff --git a/gcc/symbol-summary.h b/gcc/symbol-summary.h
index 6c0fbdd1c4a..aa8a7725bc4 100644
--- a/gcc/symbol-summary.h
+++ b/gcc/symbol-summary.h
@@ -191,7 +191,7 @@ public:
   template<typename Arg, bool (*f)(const T &, Arg)>
   void traverse (Arg a) const
   {
-    m_map.traverse <f> (a);
+    m_map.template traverse <f> (a);
   }
 
   /* Getter for summary callgraph node pointer.  If a summary for a node
@@ -690,7 +690,7 @@ public:
   template<typename Arg, bool (*f)(const T &, Arg)>
   void traverse (Arg a) const
   {
-    m_map.traverse <f> (a);
+    m_map.template traverse <f> (a);
   }
 
   /* Getter for summary callgraph edge pointer.
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 5fc23605244..3d7e72a7189 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,2579 @@
+2023-10-21  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-10-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/111837
+	* gfortran.dg/implied_do_io_8.f90: New test.
+
+2023-10-17  liuhongt  <hongtao.liu@intel.com>
+
+	Backported from master:
+	2023-07-06  liuhongt  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/pr110170-3.c: New test.
+
+2023-10-07  Andrew Pinski  <pinskia@gmail.com>
+
+	Backported from master:
+	2023-10-06  Andrew Pinski  <pinskia@gmail.com>
+
+	PR middle-end/111699
+	* gcc.c-torture/compile/pr111699-1.c: New test.
+
+2023-10-02  Pat Haugen  <pthaugen@linux.ibm.com>
+
+	Backported from master:
+	2023-09-19  Pat Haugen  <pthaugen@linux.ibm.com>
+
+	* gcc.target/powerpc/clone1.c: Add xfails.
+	* gcc.target/powerpc/clone3.c: Likewise.
+	* gcc.target/powerpc/mod-1.c: Update scan strings and add xfails.
+	* gcc.target/powerpc/mod-2.c: Likewise.
+	* gcc.target/powerpc/p10-vdivq-vmodq.c: Add xfails.
+
+2023-09-12  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2023-09-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/111340
+	* gcc.target/i386/pr111340.c: New test.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/stack-protector-8.c: New test.
+	* gcc.target/aarch64/stack-protector-9.c: Likewise.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/pcs/stack_clash_3.c: Avoid redundant probes.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/stack-check-prologue-17.c: Expect the probe
+	to be at offset 1024 rather than offset 0.
+	* gcc.target/aarch64/stack-check-prologue-18.c: Likewise.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/stack-check-prologue-18.c: New test.
+
+2023-09-12  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/stack-check-prologue-17.c: New test.
+
+2023-09-12  Haochen Gui  <guihaoc@gcc.gnu.org>
+
+	Backported from master:
+	2023-08-31  Haochen Gui  <guihaoc@gcc.gnu.org>
+
+	PR target/96762
+	* gcc.target/powerpc/pr96762.c: New.
+
+2023-09-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106310
+	* g++.dg/template/template-keyword4.C: New test.
+
+2023-09-11  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106890
+	PR c++/109666
+	* g++.dg/cpp0x/nsdmi-array2.C: New test.
+	* g++.dg/cpp0x/nsdmi-template25.C: New test.
+
+2023-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/110914
+	* gcc.c-torture/execute/pr110914.c: New test.
+
+2023-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-08-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/111015
+	* gcc.dg/pr111015.c: New test.
+
+2023-08-16  liuhongt  <hongtao.liu@intel.com>
+
+	Backported from master:
+	2023-08-16  liuhongt  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/avx2-gather-2.c: Adjust options to keep
+	gather vectorization.
+	* gcc.target/i386/avx2-gather-6.c: Ditto.
+	* gcc.target/i386/avx512f-pr88464-1.c: Ditto.
+	* gcc.target/i386/avx512f-pr88464-5.c: Ditto.
+	* gcc.target/i386/avx512vl-pr88464-1.c: Ditto.
+	* gcc.target/i386/avx512vl-pr88464-11.c: Ditto.
+	* gcc.target/i386/avx512vl-pr88464-3.c: Ditto.
+	* gcc.target/i386/avx512vl-pr88464-9.c: Ditto.
+
+2023-08-09  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2023-05-09  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/109761
+	* g++.dg/cpp0x/noexcept78.C: New test.
+
+2023-08-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/107397
+	* gfortran.dg/pr107397.f90: Adjust expected diagnostic wording and
+	add space between dg-error string and closing }.
+
+2023-08-06  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2022-12-18  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/107397
+	* gfortran.dg/pr107397.f90: New test.
+
+2023-08-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backported from master:
+	2023-01-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR fortran/103506
+	* gfortran.dg/pr103506_1.f90: New test.
+
+2023-08-01  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-07-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/110741
+	* g++.target/powerpc/pr110741.C: New test.
+
+2023-07-20  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-07-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95947
+	PR fortran/110658
+	* gfortran.dg/deferred_character_37.f90: New test.
+
+2023-07-19  Maciej W. Rozycki  <macro@embecosm.com>
+
+	Backported from master:
+	2023-07-11  Maciej W. Rozycki  <macro@embecosm.com>
+
+	* gcc.dg/vect/pr97428.c: Limit to `vect_double' targets.
+
+2023-07-14  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-07-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/110288
+	* gfortran.dg/findloc_10.f90: New test.
+
+2023-07-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-07-08  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/110585
+	* gfortran.dg/findloc_9.f90: New test.
+
+2023-07-07  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-07-07  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108842
+	* gdc.dg/pr98277.d: Add more tests.
+	* gdc.dg/pr108842.d: New test.
+
+2023-07-05  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2023-06-23   Michael Meissner  <meissner@linux.ibm.com>
+		    Aaron Sawdey   <acsawdey@linux.ibm.com>
+
+	PR target/105325
+	* g++.target/powerpc/pr105325.C: New test.
+	* gcc.target/powerpc/fusion-p10-ldcmpi.c: Update insn counts.
+
+2023-07-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-07-02  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/110516
+	* gdc.dg/torture/pr110516a.d: New test.
+	* gdc.dg/torture/pr110516b.d: New test.
+
+2023-07-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/110511
+	* gdc.test/compilable/test21794.d: New test.
+
+2023-06-28  liuhongt  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/avx-vzeroupper-29.c: New testcase.
+
+2023-06-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-06-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/110359
+	* gdc.dg/pr110359.d: New test.
+
+2023-06-20  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/109932
+	* gcc.target/powerpc/pr109932-1.c: New test.
+	* gcc.target/powerpc/pr109932-2.c: New test.
+
+2023-06-20  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-06-12  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/110011
+	* gcc.target/powerpc/pr110011.c: New test.
+
+2023-06-09  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2023-05-25  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/109800
+	* gcc.target/arm/pure-code/pr109800.c: New test.
+
+2023-06-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2023-06-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/110044
+	* gcc.target/powerpc/darwin-abi-13-0.c: New test.
+	* gcc.target/powerpc/darwin-abi-13-1.c: New test.
+	* gcc.target/powerpc/darwin-abi-13-2.c: New test.
+	* gcc.target/powerpc/darwin-structs-0.h: New test.
+
+2023-06-04  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2023-06-02  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/100607
+	* gfortran.dg/select_rank_6.f90: New test.
+
+2023-06-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-05-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109505
+	* gcc.target/aarch64/sve/pr109505.c: New test.
+
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-22   Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/70243
+	* gcc.target/powerpc/pr70243.c: New test.  Back port from master
+	04/10/2023.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2023-03-03  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/108998
+	* g++.dg/cpp2a/lambda-generic11.C: New test.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-12-15  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/100295
+	PR c++/107579
+	* g++.dg/cpp1z/constexpr-if-lambda5.C: New test.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-11-29  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/107864
+	* g++.dg/concepts/explicit-spec1a.C: New test.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-11-03  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/107179
+	* g++.dg/cpp2a/concepts-requires31.C: New test.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-03-30  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/100474
+	* g++.dg/cpp2a/concepts-traits3.C: New test.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-03-12  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/104527
+	* g++.dg/cpp2a/concepts-return-req4.C: New test.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-01-28  Patrick Palka  <ppalka@redhat.com>
+		    Jason Merrill  <jason@redhat.com>
+
+	PR c++/92752
+	* g++.dg/warn/Wignored-qualifiers2.C: New test.
+
+2023-05-20  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-05-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/109846
+	* gfortran.dg/ptr-func-5.f90: New test.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2021-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/darwin-aligned-globals.c: New test.
+	* gcc.dg/darwin-comm-1.c: New test.
+	* gcc.dg/attr-aligned.c: Amend for new alignment values on
+	Darwin.
+	* gcc.target/i386/pr89261.c: Likewise.
+
+2023-05-16  François-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	Backported from master:
+	2021-12-18  François-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	* gcc.dg/darwin-minversion-link.c: Test darwin21.
+	* obj-c++.dg/cxx-ivars-3.mm: Homogeneize darwin versions.
+	* obj-c++.dg/objc-gc-3.mm: Homogeneize darwin versions.
+	* objc.dg/objc-gc-4.m: Homogeneize darwin versions.
+
+2023-05-10  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-03-02  Richard Biener  <rguenther@suse.de>
+
+	PR testsuite/108985
+	* gcc.dg/vect/pr108950.c: Require vect_simd_clones.
+
+2023-05-09  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-05-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109778
+	* gcc.dg/lto/pr109778_0.c: New test.
+	* gcc.dg/lto/pr109778_1.c: New file.
+
+2023-05-09  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-05-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109778
+	* gcc.c-torture/execute/pr109778.c: New test.
+
+2023-05-09  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-03-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/108950
+	* gcc.dg/vect/pr108950.c: New testcase.
+
+2023-05-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106740
+	PR c++/105852
+	* g++.dg/template/friend78.C: New test.
+
+2023-05-04  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109724
+	* g++.dg/torture/pr109724.C: New testcase.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109410
+	* gcc.dg/pr109410.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/106190
+	* gcc.dg/asan/pr106190.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/109276
+	* gcc.target/i386/pr109276.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/105685
+	* c-c++-common/cold-2.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/109176
+	* gcc.target/aarch64/sve/pr109176.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/109164
+	* g++.dg/tls/thread_local13.C: New test.
+	* g++.dg/tls/thread_local13-aux.cc: New file.
+	* g++.dg/tls/thread_local14.C: New test.
+	* g++.dg/tls/thread_local14-aux.cc: New file.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105554
+	* gcc.target/i386/pr105554.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/109151
+	* c-c++-common/ubsan/div-by-zero-8.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108685
+	* c-c++-common/gomp/doacross-8.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/109096
+	* g++.dg/cpp1z/has-unique-obj-representations3.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/107558
+	* g++.dg/gomp/pr107558.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107465
+	* c-c++-common/Wsign-compare-2.c (f18): New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107465
+	* c-c++-common/Wsign-compare-2.c: New test.
+	* c-c++-common/pr107465.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/108716
+	* g++.dg/debug/dwarf2/pr108716.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/108967
+	* g++.dg/debug/pr108967.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108854
+	* g++.dg/opt/pr108854.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/108881
+	* gcc.target/i386/avx512bf16-pr108881.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/108474
+	* g++.dg/cpp1z/decomp57.C: New test.
+	* g++.dg/cpp1z/decomp58.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/108365
+	* g++.dg/opt/pr108365.C: New test.
+	* g++.dg/warn/pr108365.C: New test.
+
+2023-05-02  Andrew Pinski  <apinski@marvell.com>
+
+	Backported from master:
+	2023-02-09  Andrew Pinski  <apinski@marvell.com>
+
+	PR tree-optimization/108688
+	* gcc.c-torture/compile/pr108688-1.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/108692
+	* gcc.dg/pr108692.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108435
+	* gcc.dg/gomp/pr108435.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/108573
+	* gcc.dg/pr108573.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/108607
+	* g++.dg/gomp/pr108607.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/108596
+	* gcc.c-torture/compile/pr108596.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/108498
+	* gcc.c-torture/execute/pr108498-1.c: New test.
+	* gcc.c-torture/execute/pr108498-2.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/53932
+	* g++.dg/init/pr53932.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108237
+	* gcc.c-torture/compile/pr108237.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108264
+	* gcc.dg/pr108264.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/108068
+	* gcc.dg/dfp/pr108068.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/108193
+	* gfortran.dg/pr108193.f90: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR testsuite/108151
+	* gcc.dg/pr64536.c (bar): Cast long to __INTPTR_TYPE__
+	before casting to long *.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR testsuite/108151
+	* gcc.dg/pr64536.c (bar): Use casts to __INTPTR_TYPE__ rather than
+	long when casting pointer to integral type.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/106751
+	* gcc.c-torture/compile/pr106751.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/107065
+	* g++.dg/cpp0x/pr107065.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/108095
+	* gcc.dg/pr108095.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/107997
+	* gcc.c-torture/compile/pr107997.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/106719
+	* gcc.dg/pr106719.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/106875
+	* g++.target/i386/pr106875.C: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/107317
+	* gcc.dg/asan/pr107317.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107127
+	* gcc.dg/pr107127.c (foo): Add missing closing }.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-23  Andrew Pinski  <apinski@marvell.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107127
+	* gcc.dg/pr107127.c: New test.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-02-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/108821
+	* gcc.dg/tree-ssa/ssa-lim-24.c: New testcase.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109573
+	* g++.dg/vect/pr109573.cc: New testcase.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR rtl-optimization/109585
+	* gcc.dg/torture/pr109585.c: New testcase.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109502
+	* gcc.dg/vect/pr109502.c: New testcase.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-04-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/109473
+	* gcc.dg/vect/pr109473.c: New testcase.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-02-02  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/108625
+	* gcc.dg/pr108625.c: New testcase.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/108076
+	* gcc.dg/torture/pr108076.c: New testcase.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-12-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107451
+	* gcc.dg/torture/pr107451.c: New testcase.
+
+2023-05-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2023-03-29  Richard Biener  <rguenther@suse.de>
+
+	PR ipa/106124
+	* g++.dg/gomp/pr106124.C: New testcase.
+
+2023-04-24  Haochen Gui  <guihaoc@gcc.gnu.org>
+
+	PR target/108812
+	* gcc.target/powerpc/p9-sign_extend-runnable.c: Set corresponding
+	expected vectors for Big Endian.
+	* gcc.target/powerpc/int_128bit-runnable.c: Likewise.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/107163
+	* g++.dg/warn/Wsequence-point-5.C: New test.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105996
+	* g++.dg/cpp0x/constexpr-pmf3.C: New test.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/108975
+	* g++.dg/cpp0x/lambda/lambda-const11.C: New test.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/69410
+	* g++.dg/lookup/friend24.C: New test.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101869
+	* g++.dg/cpp0x/enum43.C: New test.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105406
+	* g++.dg/coroutines/co-await-moveonly1.C: New test.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/103871
+	PR c++/98056
+	* g++.dg/coroutines/co-await-initlist1.C: New test.
+
+2023-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/108468
+	* g++.dg/cpp1y/var-templ78.C: New test.
+
+2023-04-18  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2023-01-31  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	PR target/108589
+	* gcc.target/aarch64/pr108589.c: New test.
+
+2023-04-17  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2023-04-17  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+		    Di Zhao  <di.zhao@amperecomputing.com>
+
+	* gcc.target/aarch64/ampere1-no_ldp_combine.c: New test.
+
+2023-04-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105484
+	* gcc.dg/torture/pr105484.c: New testcase.
+
+2023-04-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/104464
+	* gcc.dg/pr104464.c: New testcase.
+
+2023-04-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-02-09  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/104450
+	* g++.dg/torture/pr104450.C: New testcase.
+
+2023-04-17  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-04-04  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/108699
+	* gcc.target/powerpc/p9-vparity.c: Add scan-assembler-not for vpopcntb
+	to distinguish parity byte from parity.
+	* gcc.target/powerpc/pr108699.c: New test.
+
+2023-04-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-04-14  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/109511
+	* gfortran.dg/set_exponent_1.f90: New test.
+
+2023-04-11  Michael Meissner  <meissner@linux.ibm.com>
+
+	PR target/109067
+	* gcc.target/powerpc/divic3-1.c: New test.  Backport from master,
+	3/20/2023.
+	* gcc.target/powerpc/divic3-2.c: Likewise.
+	* gcc.target/powerpc/mulic3-1.c: Likewise.
+	* gcc.target/powerpc/mulic3-2.c: Likewise.
+
+2023-03-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20230328-1.c: New test.
+	* gcc.target/sparc/20230328-2.c: Likewise.
+	* gcc.target/sparc/20230328-3.c: Likewise.
+	* gcc.target/sparc/20230328-4.c: Likewise.
+
+2023-03-24  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/99036
+	* gfortran.dg/pr99036.f90: New test.
+
+2023-03-24  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/109186
+	* gfortran.dg/nearest_6.f90: New test.
+
+2023-03-24  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-19  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/85877
+	* gfortran.dg/pr85877.f90: New test.
+
+2023-03-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-11  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106945
+	* gfortran.dg/pr106945.f90: New test.
+
+2023-03-17  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-03-10  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104332
+	* gfortran.dg/bind_c_usage_34.f90: New test.
+
+2023-03-14  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-03-14  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/109108
+	* gdc.dg/torture/torture.exp (srcdir): New proc.
+	* gdc.dg/torture/imports/pr109108.d: New test.
+	* gdc.dg/torture/pr109108.d: New test.
+
+2023-03-13  Arsen Arsenović  <arsen@aarsen.me>
+
+	PR c++/106188
+	PR c++/106713
+	* g++.dg/coroutines/pr106188.C: New test.
+
+2023-03-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108937
+	* gfortran.dg/ibits_2.f90: New test.
+
+2023-03-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/96024
+	* gfortran.dg/pr96024.f90: New test.
+
+2023-03-05  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-21  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/96025
+	* gfortran.dg/pr96025.f90: New test.
+
+2023-03-03  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2023-03-03  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108877
+	* gdc.dg/imports/pr108877a.d: New test.
+	* gdc.dg/pr108877.d: New test.
+
+2023-02-27  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-02-14  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/96373
+	* gcc.target/powerpc/p9-vec-length-epil-1.c: Add -fno-trapping-math.
+	* gcc.target/powerpc/p9-vec-length-epil-2.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-epil-3.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-epil-4.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-epil-5.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-epil-6.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-epil-8.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-full-1.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-full-2.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-full-3.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-full-4.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-full-5.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-full-6.c: Likewise.
+	* gcc.target/powerpc/p9-vec-length-full-8.c: Likewise.
+	* gcc.target/powerpc/pr96373.c: New test.
+
+2023-02-20  Alex Coplan  <alex.coplan@arm.com>
+
+	Backported from master:
+	2023-02-06  Alex Coplan  <alex.coplan@arm.com>
+
+	PR target/104921
+	* gcc.target/aarch64/pr104921-1.c: New test.
+	* gcc.target/aarch64/pr104921-2.c: New test.
+	* gcc.target/aarch64/pr104921.x: Include file for new tests.
+
+2023-02-15  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2023-02-15  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/106675
+	* g++.dg/cpp0x/overload-conv-5.C: New test.
+
+2023-02-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-01-18  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/108348
+	* gcc.target/powerpc/pr108348-1.c: New test.
+	* gcc.target/powerpc/pr108348-2.c: New test.
+
+2023-02-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2023-01-16  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/108272
+	* gcc.target/powerpc/pr108272-1.c: New test.
+	* gcc.target/powerpc/pr108272-2.c: New test.
+	* gcc.target/powerpc/pr108272-3.c: New test.
+	* gcc.target/powerpc/pr108272-4.c: New test.
+
+2023-02-10  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2023-02-08  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103259
+	* gfortran.dg/pr103259.f90: New test.
+
+2023-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-07  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/95107
+	* gfortran.dg/save_7.f90: New test.
+
+2023-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-02-01  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108609
+	* gfortran.dg/pr108527.f90: Adjust test pattern.
+
+2023-02-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-28  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/108527
+	* gfortran.dg/pr108527.f90: New test.
+
+2023-02-07  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106809
+	* gcc.dg/torture/pr106809.c: New testcase.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108529
+	* gfortran.dg/pr108529.f90: New test.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-07-14  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/106209
+	* gfortran.dg/pr106209.f90: New test.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108501
+	* gfortran.dg/pr108501.f90: New test.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108502
+	* gfortran.dg/pr108502.f90: New test.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-17  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108421
+	* gfortran.dg/pr108421.f90: New test.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108420
+	* gfortran.dg/pr108420.f90: New test.
+
+2023-02-04  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2023-01-28  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108453
+	* gfortran.dg/common_27.f90: New test.
+
+2023-01-26  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-14  Richard Biener  <rguenther@suse.de>
+
+	* gcc.dg/pr107554.c: Restrict to lp64.
+
+2023-01-25  Christophe Lyon  <christophe.lyon@arm.com>
+
+	Backported from master:
+	2023-01-12  Christophe Lyon  <christophe.lyon@arm.com>
+		    Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/bitfield-abi-warning-align16-O2.c: New test.
+	* gcc.target/aarch64/bitfield-abi-warning-align16-O2-extra.c: New
+	test.
+	* gcc.target/aarch64/bitfield-abi-warning-align32-O2.c: New test.
+	* gcc.target/aarch64/bitfield-abi-warning-align32-O2-extra.c: New
+	test.
+	* gcc.target/aarch64/bitfield-abi-warning-align8-O2.c: New test.
+	* gcc.target/aarch64/bitfield-abi-warning.h: New test.
+	* g++.target/aarch64/bitfield-abi-warning-align16-O2.C: New test.
+	* g++.target/aarch64/bitfield-abi-warning-align16-O2-extra.C: New
+	test.
+	* g++.target/aarch64/bitfield-abi-warning-align32-O2.C: New test.
+	* g++.target/aarch64/bitfield-abi-warning-align32-O2-extra.C: New
+	test.
+	* g++.target/aarch64/bitfield-abi-warning-align8-O2.C: New test.
+	* g++.target/aarch64/bitfield-abi-warning.h: New test.
+
+2023-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-11-11  Richard Biener  <rguenther@suse.de>
+		    Nikita Voronov  <nik_1357@mail.ru>
+
+	PR tree-optimization/107554
+	* gcc.dg/pr107554.c: New testcase.
+
+2023-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107323
+	* gcc.dg/tree-ssa/pr107323.c: New testcase.
+
+2023-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107254
+	* gfortran.dg/vect/pr107254.f90: New testcase.
+
+2023-01-24  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107212
+	* gcc.dg/vect/pr107212-1.c: New testcase.
+	* gcc.dg/vect/pr107212-2.c: Likewise.
+
+2023-01-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/sso-17.c: New test.
+
+2023-01-10  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	Backported from master:
+	2022-12-30  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	PR target/107714
+	* gcc.target/arm/mve/intrinsics/vldst24q_reg_offset.c: New test.
+
+2023-01-08  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-12-23  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/108131
+	* gfortran.dg/pr103505.f90: Adjust expected patterns.
+	* gfortran.dg/pr108131.f90: New test.
+
+2023-01-06  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	Backported from master:
+	2021-12-29  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR testsuite/47334
+	PR testsuite/103823
+	* lib/prune.exp: Prune some warnings related to LTO and
+	visibility.
+
+2023-01-06  Martin Liska  <mliska@suse.cz>
+
+	Backported from master:
+	2021-05-12  Martin Liska  <mliska@suse.cz>
+
+	* lib/lto.exp: When running tests without jobserver, one can see
+	the following warning for tests that use 1to1 partitioning.
+
+2023-01-05  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106736
+	* gcc.target/powerpc/pr106736-1.c: New test.
+	* gcc.target/powerpc/pr106736-2.c: Likewise.
+	* gcc.target/powerpc/pr106736-3.c: Likewise.
+	* gcc.target/powerpc/pr106736-4.c: Likewise.
+	* gcc.target/powerpc/pr106736-5.c: Likewise.
+
+2022-12-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* g++.dg/guality/guality.exp: Skip on hppa*-*-hpux*.
+	* gcc.dg/guality/guality.exp: Likewise.
+	* gfortran.dg/guality/guality.exp: Likewise.
+
+2022-12-18  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from master:
+	2022-12-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/107872
+	* gfortran.dg/pr107872.f90: New test.
+
+2022-12-16  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-10-28  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102780
+	PR c++/108138
+	* g++.dg/cpp1z/fold13.C: New test.
+
+2022-12-15  Sebastian Pop  <spop@amazon.com>
+
+	PR target/98776
+	* gcc.target/aarch64/pr98776.c: New.
+	* gcc.target/aarch64/pr92424-2.c: Adjust pattern.
+	* gcc.target/aarch64/pr92424-3.c: Adjust pattern.
+
+2022-12-12  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-10-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/107107
+	* gcc.dg/pr107107.c: New testcase.
+
+2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-12-11  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/108050
+	* gdc.dg/imports/pr108050/mod1.d: New.
+	* gdc.dg/imports/pr108050/mod2.d: New.
+	* gdc.dg/imports/pr108050/package.d: New.
+	* gdc.dg/pr108050.d: New test.
+
+2022-12-01  liuhongt  <hongtao.liu@intel.com>
+
+	* gcc.target/i386/pr107863.c: New test.
+
+2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-11-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/107592
+	* gdc.dg/pr107592.d: New test.
+
+2022-11-25  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-11-18  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107576
+	* gfortran.dg/null_actual_3.f90: New test.
+
+2022-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt100.adb: New test.
+	* gnat.dg/opt100_pkg.adb, gnat.dg/opt100_pkg.ads: New helper.
+
+2022-11-25  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/sso18.adb: New test.
+
+2022-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/107183
+	* gcc.dg/ubsan/pr107183.c: New test.
+
+2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-11-18  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/104066
+	* g++.dg/cpp2a/constinit18.C: New test.
+
+2022-11-08  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-10-25  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107304
+	* gcc.target/i386/pr107304.c: New test.
+
+2022-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt99.adb: New test.
+	* gnat.dg/opt99_pkg1.ads, gnat.dg/opt99_pkg1.adb: New helper.
+	* gnat.dg/opt99_pkg2.ads: Likewise.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/107358
+	* c-c++-common/pr107358.c: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/105774
+	* g++.dg/cpp1y/constexpr-105774.C: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/107001
+	* c-c++-common/gomp/pr107001.c: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/106981
+	* c-c++-common/gomp/pr106981.c: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-08-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/cpp2a/volatile1.C: Adjust for de-deprecation of volatile
+	compound |=, &= and ^= operations.
+	* g++.dg/cpp2a/volatile3.C: Likewise.
+	* g++.dg/cpp2a/volatile5.C: Likewise.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-07-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/106261
+	* g++.dg/debug/pr106261.C: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/106032
+	* gcc.c-torture/execute/pr106032.c: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/106030
+	* gcc.c-torture/compile/pr106030.c: New test.
+
+2022-10-29  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-21  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100097
+	PR fortran/100098
+	* gfortran.dg/PR100097.f90: New test.
+	* gfortran.dg/PR100098.f90: New test.
+
+2022-10-28  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103413
+	* gfortran.dg/illegal_boz_arg_4.f90: New test.
+
+2022-10-26  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	Backported from master:
+	2022-10-06  Philipp Tomsich  <philipp.tomsich@vrull.eu>
+
+	* gcc.target/aarch64/cpunative/info_18: New test.
+	* gcc.target/aarch64/cpunative/native_cpu_18.c: New test.
+
+2022-10-25  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2022-10-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* gcc.target/s390/pr106355.h: Common code for new tests.
+	* gcc.target/s390/pr106355-1.c: New test.
+	* gcc.target/s390/pr106355-2.c: New test.
+	* gcc.target/s390/pr106355-3.c: New test.
+
+2022-10-24  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-05-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105725
+	* g++.dg/warn/Wmismatched-tags-10.C: New test.
+
+2022-10-23  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-10-20  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105633
+	* gfortran.dg/pr105633.f90: New test.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/acle/general/brka_1.c: Expect a separate
+	PTEST instruction.
+	* gcc.target/aarch64/sve/acle/general/brkb_1.c: Likewise.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/sve/acle/general/brkn_1.c: Expect separate
+	PTEST instructions.
+	* gcc.target/aarch64/sve/acle/general/brkn_2.c: New test.
+
+2022-10-20  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* gcc.target/aarch64/pragma_cpp_predefs_1.c: Add RCPC tests.
+
+2022-10-19  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/96072
+	* gcc.target/powerpc/pr96072.c: New test.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106934
+	* gfortran.dg/pr106934.f90: New testcase.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-09-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106892
+	* gcc.dg/torture/pr106892.c: New testcase.
+
+2022-10-17  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106189
+	* gcc.dg/pr106189.c: New testcase.
+
+2022-10-14  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backported from master:
+	2022-07-25  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/aarch64/acle/data-intrinsics.c: New test.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-08-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106513
+	* gcc.dg/torture/pr106513.c: New testcase.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-19  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/106331
+	* gfortran.dg/pr106331.f90: New testcase.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-07-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106131
+	* g++.dg/torture/pr106131.C: New testcase.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-06-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/106112
+	* gcc.dg/torture/pr106112.c: New testcase.
+
+2022-10-11  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-06-20  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/106027
+	* gcc.dg/pr106027.c: New testcase.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/106817
+	* gfortran.dg/intent_optimize_4.f90: New test.
+
+2022-10-10  Mikael Morin  <mikael@gcc.gnu.org>
+
+	Backported from master:
+	2022-09-25  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/105012
+	* gfortran.dg/intent_out_15.f90: New test.
+
+2022-10-08  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100029
+	PR fortran/100040
+	* gfortran.dg/PR100029.f90: New test.
+	* gfortran.dg/PR100040.f90: New test.
+
+2022-10-01  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-20  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100132
+	* gfortran.dg/PR100132.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-27  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/107054
+	* gfortran.dg/pr107054.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/82868
+	* gfortran.dg/associate_26a.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106985
+	* gfortran.dg/pr106985.f90: New test.
+
+2022-09-30  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-08-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103694
+	* gfortran.dg/pr103694.f90: New test.
+
+2022-09-29  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-09-28  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/107061
+	* gcc.target/i386/keylocker-encodekey128.c: Don't check
+	XMM4-XMM6.
+	* gcc.target/i386/keylocker-encodekey256.c: Likewise.
+
+2022-09-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-20  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106986
+	* gfortran.dg/pr106986.f90: New test.
+
+2022-09-24  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-03  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100245
+	* gfortran.dg/PR100245.f90: New test.
+
+2022-09-22  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-09-15  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/106857
+	* gfortran.dg/pr106857.f90: New test.
+
+2022-09-13  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-09-07  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/106345
+	* lib/target-supports.exp (check_effective_target_powerpc_sqrt): Add
+	a function definition to avoid pedwarn about empty translation unit.
+	(check_effective_target_has_arch_pwr5): Likewise.
+	(check_effective_target_has_arch_pwr6): Likewise.
+	(check_effective_target_has_arch_pwr7): Likewise.
+	(check_effective_target_has_arch_pwr8): Likewise.
+	(check_effective_target_has_arch_pwr9): Likewise.
+	(check_effective_target_has_arch_pwr10): Likewise.
+	(check_effective_target_has_arch_ppc64): Likewise.
+	(check_effective_target_ppc_float128): Likewise.
+	(check_effective_target_ppc_float128_insns): Likewise.
+	(check_effective_target_powerpc_vsx): Likewise.
+
+2022-09-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-09-01  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/101322
+	* g++.target/powerpc/pr101322.C: New test.
+
+2022-09-05  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	Backported from master:
+	2022-09-04  José Rui Faustino de Sousa  <jrfsousa@gmail.com>
+
+	PR fortran/100136
+	* gfortran.dg/PR100136.f90: New test.
+
+2022-08-30  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-08-28  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR target/106017
+	* gcc.target/powerpc/pr106017.c: New test.
+
+2022-08-24  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	Backported from master:
+	2022-08-16  Kewen.Lin  <linkw@gcc.gnu.org>
+
+	PR target/103353
+	* gcc.target/powerpc/pr103353.c: New test.
+
+2022-08-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-26  Segher Boessenkoool  <segher@kernel.crashing.org>
+
+	PR target/105349
+	* lib/target-supports.exp (check_effective_target_has_arch_pwr5): Use
+	the specified dg-options.
+	(check_effective_target_has_arch_pwr6): Ditto.
+	(check_effective_target_has_arch_pwr7): Ditto.
+	(check_effective_target_has_arch_pwr8): Ditto.
+	(check_effective_target_has_arch_pwr9): Ditto.
+	(check_effective_target_has_arch_pwr10): Ditto.
+	(check_effective_target_has_arch_ppc64): Ditto.
+
+2022-08-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* lib/target-supports.exp (check_effective_target_has_arch_ppc64): New.
+
+2022-08-17  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2022-08-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/106492
+	* g++.dg/gomp/pr106492.C: New test.
+
+2022-08-16  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-21  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/103197
+	PR target/102146
+	* gcc.target/powerpc/bswap-brw.c: Add xfail on scan-assembler for -m32.
+
+2022-08-12  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Peter Bergner  <bergner@linux.ibm.com>
+
+	PR c/106016
+	* gcc.target/powerpc/pr106016.c: New test.
+
+2022-08-04  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backported from master:
+	2022-03-25  Peter Bergner  <bergner@linux.ibm.com>
+
+	* g++.dg/pr65240-1.C: Use -mdejagnu-cpu=.  Remove dg-skip-if.
+	* g++.dg/pr65240-2.C: Likewise.
+	* g++.dg/pr65240-3.C: Likewise.
+	* g++.dg/pr65240-4.C: Likewise.
+	* g++.dg/pr65242.C: Likewise.
+	* g++.dg/pr67211.C: Likewise.
+	* g++.dg/pr69667.C: Likewise.
+	* g++.dg/pr71294.C: Likewise.
+	* g++.dg/pr84279.C: Likewise.
+	* g++.dg/torture/ppc-ldst-array.C: Likewise.
+	* gfortran.dg/nint_p7.f90: Likewise.
+	* gfortran.dg/pr102860.f90: Likewise.
+	* gcc.target/powerpc/fusion.c: Use -mdejagnu-cpu= and -mdejagnu-tune=.
+	* gcc.target/powerpc/fusion2.c: Likewise.
+	* gcc.target/powerpc/int_128bit-runnable.c: Use -mdejagnu-cpu=.
+	* gcc.target/powerpc/test_mffsl.c: Likewise.
+	* gfortran.dg/pr47614.f: Likewise.
+	* gfortran.dg/pr58968.f: Likewise.
+
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* c-c++-common/pr97498.c: New test.
+	* gcc.dg/pragma-message.c: Adapt for improved warning locations.
+
+2022-08-02  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-07-26  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR target/106091
+	* gcc.target/powerpc/pr106091.c: New test.
+
+2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-07-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/103504
+	* gfortran.dg/pr103504.f90: New test.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-17  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105618
+	* gcc.dg/tree-ssa/ssa-sink-19.c: New testcase.
+
+2022-07-22  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/103116
+	* gcc.dg/vect/pr103116-1.c: New testcase.
+	* gcc.dg/vect/pr103116-2.c: Likewise.
+
+2022-07-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106361
+	* g++.dg/cpp2a/spaceship-eq14.C: New test.
+
+2022-07-21  Surya Kumari Jangala  <jskumari@linux.vnet.ibm.com>
+
+	Backported from master:
+	2022-06-14  Surya Kumari Jangala  <jskumari@linux.ibm.com>
+
+	PR rtl-optimization/105041
+	* gcc.target/powerpc/pr105041.c: New test.
+
+2022-07-16  Steve Kargl  <kargl@gcc.gnu.org>
+
+	Backported from master:
+	2022-07-15  Steve Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/104313
+	* gfortran.dg/pr104313.f: New test.
+
+2022-07-12  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-07-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/105860
+	* gcc.dg/tree-ssa/alias-access-path-13.c: New test.
+	* gcc.dg/tree-ssa/pr105860.c: Likewise.
+
+2022-07-04  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backported from master:
+	2022-03-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/104869
+	* g++.dg/pr104869.C: New test.
+
+2022-07-04  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-29  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	PR d/106139
+	* gdc.dg/pr106139a.d: New test.
+	* gdc.dg/pr106139b.d: New test.
+	* gdc.dg/pr106139c.d: New test.
+	* gdc.dg/pr106139d.d: New test.
+	* gdc.test/fail_compilation/ice20264.d: New test.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-30  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/103137
+	PR fortran/103138
+	PR fortran/103693
+	PR fortran/105243
+	* gfortran.dg/class_58.f90: Fix test.
+	* gfortran.dg/class_73.f90: New test.
+
+2022-07-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-29  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/106121
+	* gfortran.dg/extends_type_of_4.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105954
+	* gfortran.dg/pr105954.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-26  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105691
+	* gfortran.dg/index_6.f90: New test.
+
+2022-07-01  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-06-24  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/105813
+	* gfortran.dg/unpack_vector_1.f90: New test.
+
+2022-07-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/106024
+	* g++.dg/cpp2a/lambda-generic10.C: New test.
+
+2022-06-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105925
+	* g++.dg/cpp2a/desig26.C: New test.
+
+2022-06-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-06-17  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/105209
+	* gcc.target/alpha/pr105209.c: New test.
+
+2022-06-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backported from master:
+	2022-06-17  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/105970
+	* gcc.target/i386/pr105970.c: New test.
+
+2022-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/105998
+	* c-c++-common/pr105998.c: New test.
+
+2022-06-20  Jan Hubicka  <jh@suse.cz>
+
+	Backported from master:
+	2022-06-14  Jan Hubicka  <hubicka@ucw.cz>
+
+	* gcc.dg/ipa/pr105739.c: New test.
+
+2022-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105729
+	* g++.dg/ubsan/pr105729.C: New test.
+
+2022-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/105732
+	* c-c++-common/cpp/va-opt-10.c: New test.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* gdc.dg/Wpadded.d: New test.
+
+2022-06-15  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105726
+	* g++.dg/warn/Warray-bounds-27.C: New testcase.
+
+2022-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/104637
+	* gcc.target/i386/pr104637.c: Don't run on ia32.  Add -Wno-div-by-zero
+	to dg-options.
+	(foo): Remove extraneous initializer.
+
+2022-06-14  Vladimir N. Makarov  <vmakarov@redhat.com>
+
+	PR rtl-optimization/104637
+	* gcc.target/i386/pr104637.c: New.
+
+2022-06-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105852
+	PR c++/105761
+	* g++.dg/modules/tpl-friend-2_a.C: Adjust expected dump.
+	* g++.dg/template/friend74.C: New test.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105761
+	* g++.dg/cpp1y/auto-fn64.C: New test.
+
+2022-06-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105795
+	* g++.dg/cpp1z/constexpr-aggr-base1.C: New test.
+
+2022-06-02  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105437
+	* g++.dg/vect/pr105437.cc: New testcase.
+
+2022-05-31  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102307
+	* g++.dg/cpp1z/constexpr-array2.C: New test.
+
+2022-05-27  Kewen Lin  <linkw@linux.ibm.com>
+
+	Backported from master:
+	2022-04-18  Kewen Lin  <linkw@linux.ibm.com>
+
+	PR testsuite/105266
+	* gcc.dg/pr105250.c: Skip for powerpc*-*-* and s390*-*-*.
+
+2022-05-25  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backported from master:
+	2022-04-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/105147
+	* gcc.dg/pr105140.c: Skip for s390*-*-*.
+
+2022-05-25  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backported from master:
+	2022-04-06  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/105147
+	* gcc.dg/pr105140.c: Skip for powerpc*-*-*.
+
+2022-05-24  Qing Zhao  <qing.zhao@oracle.com>
+
+	Backported from master:
+	2022-05-09  Qing Zhao  <qing.zhao@oracle.com>
+
+	* gcc.target/i386/zero-scratch-regs-1.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-10.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-13.c: Add -msse.
+	* gcc.target/i386/zero-scratch-regs-14.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-15.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-16.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-17.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-18.c: Add -fno-stack-protector
+	-fno-PIC, adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-19.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-2.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-20.c: Add -msse.
+	* gcc.target/i386/zero-scratch-regs-21.c: Add -fno-stack-protector
+	-fno-PIC, Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-22.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-23.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-26.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-27.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-28.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-3.c: Add -fno-stack-protector.
+	* gcc.target/i386/zero-scratch-regs-31.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-4.c: Add -fno-stack-protector
+	-fno-PIC.
+	* gcc.target/i386/zero-scratch-regs-5.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-6.c: Add -fno-stack-protector.
+	* gcc.target/i386/zero-scratch-regs-7.c: Likewise.
+	* gcc.target/i386/zero-scratch-regs-8.c: Adjust mov to xor.
+	* gcc.target/i386/zero-scratch-regs-9.c: Add -fno-stack-protector.
+
+2022-05-19  Michael Meissner  <meissner@linux.ibm.com>
+
+	Backported from master:
+	2022-05-06  Michael Meissner  <meissner@linux.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/102059
+	* gcc.target/powerpc/pr102059-4.c: New test.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-20  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105312
+	* gcc.target/arm/pr105312.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105263
+	* gcc.dg/pr105263.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105173
+	* gcc.dg/pr105173.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105163
+	* gcc.dg/torture/pr105163.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105148
+	* gcc.dg/torture/pr105148.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/105250
+	* gcc.dg/pr105250.c: New testcase.
+
+2022-05-19  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/105140
+	* gcc.dg/pr105140.c: New testcase.
+
+2022-05-19  Martin Jambor  <mjambor@suse.cz>
+
+	Backported from master:
+	2022-04-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/100413
+	* g++.dg/ipa/pr100413.C: New test.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-05-11  Harald Anlauf  <anlauf@gmx.de>
+		    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/105230
+	* gfortran.dg/pr105230.f90: New test.
+
+2022-05-16  Harald Anlauf  <anlauf@gmx.de>
+
+	Backported from master:
+	2022-03-09  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/104849
+	* gfortran.dg/pr104849.f90: New test.
+
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* gcc.target/aarch64/sync-comp-swap-ool.c: New.
+	* gcc.target/aarch64/sync-op-acquire-ool.c: New.
+	* gcc.target/aarch64/sync-op-full-ool.c: New.
+	* gcc.target/aarch64/target_attr_20.c: Update check.
+	* gcc.target/aarch64/target_attr_21.c: Same.
+
+2022-05-16  Richard Biener  <rguenther@suse.de>
+
+	Backported from master:
+	2022-05-16  Richard Biener  <rguenther@suse.de>
+
+	* gcc.dg/torture/pr105598.c: New testcase.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101442
+	* g++.dg/cpp0x/initlist-nrv1.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/101698
+	* g++.dg/template/conv19.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/65211
+	* g++.target/i386/vec-tmpl1.C: New test.
+
+2022-05-13  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2021-09-27  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/102479
+	* g++.dg/cpp1z/class-deduction12.C: Also test alias CTAD in the
+	same way.
+	* g++.dg/cpp1z/class-deduction99.C: New test.
+
+2022-05-13  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102300
+	* g++.dg/parse/no-typename1.C: Remove expected error.
+	* g++.dg/template/nested7.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102629
+	* g++.dg/cpp2a/lambda-pack-init7.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104646
+	* g++.dg/cpp0x/constexpr-fno-elide-ctors1.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82980
+	* g++.dg/cpp0x/lambda/lambda-current-inst1.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105265
+	PR c++/100838
+	* g++.dg/cpp0x/initlist-new6.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/105245
+	PR c++/100111
+	* g++.dg/cpp1y/constexpr-empty2.C: Add -fno-elide-constructors.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104669
+	* g++.target/i386/mv31.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/102071
+	* g++.dg/cpp1z/aligned-new9.C: New test.
+
+2022-05-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/104142
+	* g++.dg/opt/const7.C: New test.
+
+2022-05-10  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-05-10  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR target/105472
+	* gcc.target/i386/iamcu/asm-support.S: Add .note.GNU-stack section
+	only for Linux.
+	* gcc.target/x86_64/abi/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512f/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/ms-sysv/do-test.S: Likewise.
+
+2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/105528
+	* gcc.dg/pr105528.c: New test.
+
+2022-05-10  Jeff Law  <jeffreyalaw@gmail.com>
+
+	Backported from master:
+	2022-04-28  Jeff Law  <jeffreyalaw@gmail.com>
+
+	* lib/prune.exp (prune_gcc_output): Prune new linker warning.
+
+2022-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20220510-1.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/cpp23/lambda-attr1.C: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105331
+	* gcc.dg/pr105331.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/105396
+	* gcc.dg/asan/pr105396.c: New test.
+
+2022-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/105333
+	* gcc.dg/pr105333.c: New test.
+
+2022-05-06  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backported from master:
+	2022-05-02  H.J. Lu  <hjl.tools@gmail.com>
+
+	PR testsuite/105433
+	* gcc.target/i386/iamcu/asm-support.S: Add .note.GNU-stack.
+	* gcc.target/x86_64/abi/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/avx512f/asm-support.S: Likewise.
+	* gcc.target/x86_64/abi/ms-sysv/do-test.S: Likewise.
+
+2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	* gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c: Update
+	the expected message for the case in which unaligned accesses
+	are not allowed.
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105365
+	PR analyzer/105366
+	* gcc.dg/analyzer/pr105365.c: New test.
+	* gcc.dg/analyzer/pr105366.c: New test.
+
+2022-04-28  David Malcolm  <dmalcolm@redhat.com>
+
+	PR analyzer/105252
+	* gcc.dg/analyzer/pr105252.c: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105386
+	* g++.dg/cpp0x/decltype81.C: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105304
+	* g++.dg/cpp2a/concepts-requires30.C: New test.
+
+2022-04-28  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-04-26  Patrick Palka  <ppalka@redhat.com>
+
+	PR c++/105289
+	PR c++/86193
+	* g++.dg/template/partial-specialization11.C: New test.
+	* g++.dg/template/partial-specialization12.C: New test.
+
+2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-28  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90107
+	* g++.dg/parse/qualified6.C: New test.
+
+2022-04-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR testsuite/105095
+	* gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c: Update for
+	codegen.
+	* gcc.dg/vect/complex/fast-math-complex-add-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c:
+	Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mla-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mls-half-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-double.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-float.c: Likewise.
+	* gcc.dg/vect/complex/fast-math-complex-mul-half-float.c: Likewise.
+	* gcc.dg/vect/vect.exp: Add extra letter to filter.
+
+2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105398
+	* g++.dg/cpp1y/lambda-generic-enum2.C: New test.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* gcc.target/i386/sse-14.c: Add tests for new macro.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105321
+	* g++.dg/cpp0x/constexpr-105321.C: New test.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97296
+	* g++.dg/cpp0x/ref-bind4.C: Add dg-error.
+	* g++.dg/cpp0x/ref-bind8.C: New test.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* gfortran.dg/dec_union_12.f90: New test.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* gcc.dg/pr105257.c: New test.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/105203
+	* gfortran.dg/g77/pr105203.f: New test.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/testsuite/c-c++-common/Wsign-compare-2.c b/gcc/testsuite/c-c++-common/Wsign-compare-2.c
new file mode 100644
index 00000000000..71a7c9899fb
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/Wsign-compare-2.c
@@ -0,0 +1,112 @@
+/* { dg-do compile { target { ilp32 || lp64 } } } */
+/* { dg-options "-Wsign-compare" } */
+
+int
+f1 (unsigned char x)
+{
+  return (unsigned short) (~(unsigned short) x) == 0;		/* { dg-warning "promoted bitwise complement of an unsigned value is always nonzero" "" { target c } } */
+}
+
+int
+f2 (unsigned char x)
+{
+  return (unsigned short) (~(unsigned short) x) == 5;		/* { dg-warning "comparison of promoted bitwise complement of an unsigned value with constant" "" { target c }  } */
+}
+
+int
+f3 (unsigned char x)
+{
+  return (unsigned int) (~(unsigned short) x) == 0xffff0005U;	/* { dg-warning "comparison of promoted bitwise complement of an unsigned value with constant" } */
+}
+
+int
+f4 (unsigned char x)
+{
+  return (unsigned int) (~(unsigned short) x) == 0xffff0005ULL;	/* { dg-warning "comparison of promoted bitwise complement of an unsigned value with constant" } */
+}
+
+int
+f5 (unsigned char x)
+{
+  return (unsigned int) (~(unsigned short) x) == 0xffffff05U;	/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with constant" } */
+}
+
+int
+f6 (unsigned char x)
+{
+  return (unsigned int) (~(unsigned short) x) == 0xffffff05ULL;	/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with constant" } */
+}
+
+int
+f7 (unsigned char x)
+{
+  return (unsigned long long) (~(unsigned short) x) == 0xffffffffffffff05ULL;	/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with constant" } */
+}
+
+typedef unsigned short T;
+
+int
+f8 (T x)
+{
+  return (unsigned short) (~(unsigned short) x) == 0;		/* { dg-bogus "promoted bitwise complement of an unsigned value is always nonzero" } */
+}
+
+int
+f9 (T x)
+{
+  return (unsigned short) (~(unsigned short) x) == 5;		/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with constant" } */
+}
+
+int
+f10 (T x, unsigned char y)
+{
+  return (unsigned short) (~(unsigned short) x) == y;		/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with unsigned" } */
+}
+
+int
+f11 (T x, unsigned char y)
+{
+  return (unsigned short) (~(unsigned short) x) == y;		/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with unsigned" } */
+}
+
+int
+f12 (unsigned char x, unsigned char y)
+{
+  return (unsigned short) (~(unsigned short) x) == y;		/* { dg-warning "comparison of promoted bitwise complement of an unsigned value with unsigned" "" { target c } } */
+}
+
+int
+f13 (unsigned char x, unsigned char y)
+{
+  return (unsigned short) (~(unsigned short) x) == y;		/* { dg-warning "comparison of promoted bitwise complement of an unsigned value with unsigned" "" { target c } } */
+}
+
+int
+f14 (unsigned char x, unsigned int y)
+{
+  return (unsigned long long) (~x) == y;			/* { dg-warning "comparison of promoted bitwise complement of an unsigned value with unsigned" } */
+}
+
+int
+f15 (unsigned short x, unsigned int y)
+{
+  return (long long) (~x) == y;					/* { dg-warning "comparison of promoted bitwise complement of an unsigned value with unsigned" } */
+}
+
+int
+f16 (unsigned char x, unsigned short y)
+{
+  return (unsigned short) (~(unsigned short) x) == y;		/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with unsigned" } */
+}
+
+int
+f17 (unsigned char x, unsigned short y)
+{
+  return (unsigned short) (~(unsigned short) x) == y;		/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with unsigned" } */
+}
+
+int
+f18 (unsigned char x)
+{
+  return (unsigned int) (short) (~(unsigned short) x) == 0xffffff05ULL;	/* { dg-bogus "comparison of promoted bitwise complement of an unsigned value with constant" } */
+}
diff --git a/gcc/testsuite/c-c++-common/cold-2.c b/gcc/testsuite/c-c++-common/cold-2.c
new file mode 100644
index 00000000000..7f78496fb82
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cold-2.c
@@ -0,0 +1,19 @@
+/* PR ipa/105685 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wsuggest-attribute=cold" } */
+
+extern void foo (char *, char const *, int);
+
+__attribute__((cold)) char *
+bar (int x)
+{
+  static char b[42];
+  foo (b, "foo", x);
+  return b;
+}
+
+__attribute__((cold)) char *
+baz (int x)		/* { dg-bogus "function might be candidate for attribute 'cold'" } */
+{
+  return bar (x);
+}
diff --git a/gcc/testsuite/c-c++-common/cpp/va-opt-10.c b/gcc/testsuite/c-c++-common/cpp/va-opt-10.c
new file mode 100644
index 00000000000..f810b429dd6
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/va-opt-10.c
@@ -0,0 +1,18 @@
+/* PR preprocessor/105732 */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu99" { target c } } */
+/* { dg-options "-std=c++20" { target c++ } } */
+
+#define m1(p1, p2, p3) p3
+#define m2(p1, ...) 1##__VA_OPT__(foo)
+#define m3(...) m1(1, 2, m2)
+#define m4(p1, ...) 1 __VA_OPT__()
+#define m5(...) m1(1, 2, m4)
+#if m3(,)(,)
+#else
+#error
+#endif
+#if m5(,)(,)
+#else
+#error
+#endif
diff --git a/gcc/testsuite/c-c++-common/gomp/doacross-8.c b/gcc/testsuite/c-c++-common/gomp/doacross-8.c
new file mode 100644
index 00000000000..6de06341af7
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/doacross-8.c
@@ -0,0 +1,17 @@
+/* PR middle-end/108685 */
+/* { dg-do compile } */
+
+void
+foo (int a)
+{
+  for (int m = 0; m < 10; m++)
+    #pragma omp for collapse(2) ordered(4)
+    for (int i = 0; i < 2; i++)
+      for (int j = 0; j < a; j++)
+	for (int k = 0; k < 2; k++)
+	  for (int l = 0; l < a; l++)
+	    {
+	      #pragma omp ordered depend (source)
+	      __builtin_abort ();
+	    }
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr106981.c b/gcc/testsuite/c-c++-common/gomp/pr106981.c
new file mode 100644
index 00000000000..a21d3c2029d
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr106981.c
@@ -0,0 +1,9 @@
+/* PR c/106981 */
+/* { dg-do compile } */
+
+void
+foo (int a, double *b, double *c, double *d, long long e)
+{
+#pragma omp atomic capture
+  c[a] = d[((int) (e / 10 + 1))] = b[a] + d[((int) e / 10 + 1)];	/* { dg-error "invalid form" } */
+}
diff --git a/gcc/testsuite/c-c++-common/gomp/pr107001.c b/gcc/testsuite/c-c++-common/gomp/pr107001.c
new file mode 100644
index 00000000000..9c19d9b8745
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/gomp/pr107001.c
@@ -0,0 +1,14 @@
+/* PR c/107001 */
+/* { dg-do compile } */
+/* { dg-options "-O0 -fopenmp -fexceptions" } */
+/* { dg-require-effective-target exceptions } */
+
+void bar (void);
+void foo (void)
+{
+  #pragma omp taskgroup
+  {
+    #pragma omp taskgroup
+    bar ();
+  }
+}
diff --git a/gcc/testsuite/c-c++-common/pr105998.c b/gcc/testsuite/c-c++-common/pr105998.c
new file mode 100644
index 00000000000..85277b97007
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr105998.c
@@ -0,0 +1,12 @@
+/* PR middle-end/105998 */
+
+typedef int __attribute__((__vector_size__ (sizeof (long long)))) V;
+
+V v;
+
+long long
+foo (void)
+{
+  long long l = (long long) ((0 | v) - ((V) { } == 0));
+  return l;
+}
diff --git a/gcc/testsuite/c-c++-common/pr107358.c b/gcc/testsuite/c-c++-common/pr107358.c
new file mode 100644
index 00000000000..d976da7393a
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr107358.c
@@ -0,0 +1,30 @@
+/* PR c++/107358 */
+/* { dg-do compile { target c } } */
+/* { dg-options "-O2 -fexcess-precision=standard" } */
+
+typedef float __attribute__((vector_size (4 * sizeof (float)))) A;
+typedef double __attribute__((vector_size (2 * sizeof (double)))) B;
+
+void
+foo (A *x)
+{
+  *x = *x - 124.225514990f;
+}
+
+void
+bar (A *x, float y)
+{
+  *x = *x - y;
+}
+
+void
+baz (B *x)
+{
+  *x = *x + 124.225514990f;
+}
+
+void
+qux (B *x, double y)
+{
+  *x = *x + y;
+}
diff --git a/gcc/testsuite/c-c++-common/pr107465.c b/gcc/testsuite/c-c++-common/pr107465.c
new file mode 100644
index 00000000000..7c9ff24bc83
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr107465.c
@@ -0,0 +1,22 @@
+/* PR c/107465 */
+/* { dg-do compile } */
+/* { dg-options "-Wsign-compare" } */
+
+void baz (void);
+typedef unsigned short T;
+
+#if __SIZEOF_SHORT__ * __CHAR_BIT__ == 16
+void
+foo (unsigned short x)
+{
+  if (!(x ^ 0xFFFF))
+    baz ();
+}
+
+void
+bar (T x)
+{
+  if (!(x ^ 0xFFFF))	/* { dg-bogus "promoted bitwise complement of an unsigned value is always nonzero" } */
+    baz ();
+}
+#endif
diff --git a/gcc/testsuite/c-c++-common/pr97498.c b/gcc/testsuite/c-c++-common/pr97498.c
new file mode 100644
index 00000000000..f5fa420415b
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr97498.c
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-Wunused-function" } */
+#pragma GCC diagnostic ignored "-Wunused-function"
+static void f() {} _Pragma("GCC diagnostic error \"-Wunused-function\"") /* { dg-bogus "-Wunused-function" } */
diff --git a/gcc/testsuite/c-c++-common/ubsan/div-by-zero-8.c b/gcc/testsuite/c-c++-common/ubsan/div-by-zero-8.c
new file mode 100644
index 00000000000..02e1d7cfc95
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/ubsan/div-by-zero-8.c
@@ -0,0 +1,14 @@
+/* PR c/109151 */
+/* { dg-do run } */
+/* { dg-options "-fsanitize=integer-divide-by-zero -Wno-div-by-zero -fno-sanitize-recover=integer-divide-by-zero" } */
+/* { dg-shouldfail "ubsan" } */
+
+int d;
+
+int
+main ()
+{
+  d = ((short) (d == 1 | d > 9)) / 0;
+}
+
+/* { dg-output "division by zero" } */
diff --git a/gcc/testsuite/g++.dg/concepts/explicit-spec1a.C b/gcc/testsuite/g++.dg/concepts/explicit-spec1a.C
new file mode 100644
index 00000000000..ec678740cb8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/explicit-spec1a.C
@@ -0,0 +1,11 @@
+// A version of explicit-spec1.C where the template g has trailing instead of
+// template requirements.
+// PR c++/107864
+// { dg-do compile { target concepts } }
+
+template<typename T> concept C = __is_class(T);
+struct Y { int n; } y;
+template<class T> void g(T) requires C<T> { }
+int called;
+template<> void g(Y) { called = 3; }
+int main() { g(y); }
diff --git a/gcc/testsuite/g++.dg/coroutines/co-await-initlist1.C b/gcc/testsuite/g++.dg/coroutines/co-await-initlist1.C
new file mode 100644
index 00000000000..b8e8923a9c8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/coroutines/co-await-initlist1.C
@@ -0,0 +1,21 @@
+// PR c++/103871
+// { dg-do compile { target c++20 } }
+
+#include <coroutine>
+#include <initializer_list>
+
+struct my_coro {
+  struct promise_type {
+    my_coro get_return_object();
+    std::suspend_never initial_suspend();
+    std::suspend_never final_suspend() noexcept;
+    void unhandled_exception();
+  };
+};
+
+std::suspend_never inner(std::initializer_list<int>);
+
+my_coro doesnt_work()
+{
+  co_await inner({ 1,2,3 });
+}
diff --git a/gcc/testsuite/g++.dg/coroutines/co-await-moveonly1.C b/gcc/testsuite/g++.dg/coroutines/co-await-moveonly1.C
new file mode 100644
index 00000000000..e2831c104bf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/coroutines/co-await-moveonly1.C
@@ -0,0 +1,63 @@
+// PR c++/105406
+// { dg-do compile { target c++20 } }
+
+#include <coroutine>
+#include <exception>
+
+// A move-only awaitable
+class MoveOnlyAwaitable {
+public:
+    MoveOnlyAwaitable() = default;
+    MoveOnlyAwaitable(MoveOnlyAwaitable &&) = default;
+    MoveOnlyAwaitable &operator=(MoveOnlyAwaitable &&) = default;
+
+    MoveOnlyAwaitable(const MoveOnlyAwaitable &) = delete;
+    MoveOnlyAwaitable &operator=(const MoveOnlyAwaitable &) = delete;
+
+    bool await_ready() const noexcept { return false; }
+    void await_suspend(std::coroutine_handle<>) noexcept {}
+    void await_resume() {}
+};
+
+struct task {
+    struct promise_type {
+        auto initial_suspend() const { return std::suspend_never{}; }
+        auto final_suspend() const noexcept { return std::suspend_never(); }
+        auto get_return_object() { return task{}; }
+        void return_void() {}
+        void unhandled_exception() {}
+
+        template<typename T>
+        T &&await_transform(T &&t) {
+            return static_cast<T &&>(t);
+        }
+
+
+    };
+
+    bool await_ready() const { return false; }
+    void await_suspend(std::coroutine_handle<> awaiter) {}
+    void await_resume() {}
+};
+
+task myCoroutine() {
+    // GCC: OK
+    // clang: OK
+    {
+        co_await MoveOnlyAwaitable();
+    }
+    // GCC: OK
+    // clang: OK
+    {
+        auto moveonly = MoveOnlyAwaitable();
+        co_await std::move(moveonly);
+    }
+
+    // GCC <= 11.2: OK
+    // GCC 11.3:ERROR:  error: use of deleted function 'MoveOnlyAwaitable::MoveOnlyAwaitable(const MoveOnlyAwaitable&)
+    // clang: OK
+    {
+        auto moveonly = MoveOnlyAwaitable();
+        co_await moveonly;
+    }
+}
diff --git a/gcc/testsuite/g++.dg/coroutines/pr106188.C b/gcc/testsuite/g++.dg/coroutines/pr106188.C
new file mode 100644
index 00000000000..9db3778d079
--- /dev/null
+++ b/gcc/testsuite/g++.dg/coroutines/pr106188.C
@@ -0,0 +1,34 @@
+// { dg-do run { target c++20 } }
+// test case from pr106188, w/o workaround
+#include <coroutine>
+
+struct task {
+  struct promise_type {
+    task get_return_object() { return task{}; }
+    void return_void() {}
+    void unhandled_exception() {}
+    auto initial_suspend() noexcept { return std::suspend_never{}; }
+    auto final_suspend() noexcept { return std::suspend_never{}; }
+  };
+};
+
+struct suspend_and_resume {
+  bool await_ready() const { return false; }
+  void await_suspend(std::coroutine_handle<> h) { h.resume(); }
+  void await_resume() {}
+};
+
+task f() {
+  if (co_await suspend_and_resume{}, false) {}
+}
+
+task g() {
+  switch (co_await suspend_and_resume{}, 0) {
+    default: break;
+  }
+}
+
+int main() {
+  f();
+  g();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C
new file mode 100644
index 00000000000..adb6830ff22
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C
@@ -0,0 +1,18 @@
+// PR c++/105321
+// { dg-do compile { target c++11 } }
+
+bool handle_error();
+
+constexpr int echo(int value, bool yes = true) noexcept
+{
+    return (yes || handle_error()), value;
+}
+
+static_assert(echo(10) == 10, "");
+
+constexpr int echo2(int value, bool no = false) noexcept
+{
+    return (!no || handle_error()), value;
+}
+
+static_assert(echo2(10) == 10, "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C
new file mode 100644
index 00000000000..71c76fa0247
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-fno-elide-ctors1.C
@@ -0,0 +1,89 @@
+// PR c++/104646
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fno-elide-constructors }
+
+template <typename _T1> struct pair {
+  _T1 first;
+  int second;
+};
+template <typename _Iterator> class __normal_iterator {
+  _Iterator __traits_type;
+
+public:
+  constexpr __normal_iterator() {}
+};
+template <typename> class allocator;
+template <typename> struct allocator_traits;
+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
+  using value_type = _Tp;
+  template <typename _Up> using rebind_alloc = allocator<_Up>;
+};
+template <typename _Alloc> struct __alloc_traits {
+  typedef allocator_traits<_Alloc> _Base_type;
+  typedef typename _Base_type::value_type &const_reference;
+  template <typename _Tp> struct rebind {
+    typedef typename _Base_type::template rebind_alloc<_Tp> other;
+  };
+};
+template <typename _Tp, typename _Alloc> struct _Vector_base {
+  typedef typename __alloc_traits<_Alloc>::template rebind<_Tp>::other _Tp_alloc_type;
+};
+template <typename _Tp, typename _Alloc = allocator<_Tp>> class vector {
+public:
+  typename __alloc_traits<
+      typename _Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::const_reference
+  operator[](long);
+};
+enum match_flag_type {};
+template <typename, typename> class Trans_NS___cxx11_basic_regex;
+class Trans_NS___cxx11_match_results;
+enum _RegexExecutorPolicy { _S_auto };
+template <typename, typename, typename _CharT, typename _TraitsT,
+          _RegexExecutorPolicy, bool>
+bool __regex_algo_impl(Trans_NS___cxx11_match_results &,
+                       const Trans_NS___cxx11_basic_regex<_CharT, _TraitsT> &);
+template <typename, typename, typename, bool> class _Executor;
+template <typename _Ch_type, typename = _Ch_type>
+class Trans_NS___cxx11_basic_regex {};
+class Trans_NS___cxx11_match_results : vector<int> {
+  template <typename, typename, typename _Cp, typename _Rp,
+            _RegexExecutorPolicy, bool>
+  friend bool __regex_algo_impl(Trans_NS___cxx11_match_results &,
+                                const Trans_NS___cxx11_basic_regex<_Cp, _Rp> &);
+};
+template <typename _Bi_iter, typename _Alloc, typename _Ch_type,
+          typename _Rx_traits>
+void regex_search(_Bi_iter, _Alloc,
+                  Trans_NS___cxx11_basic_regex<_Ch_type, _Rx_traits>) {
+  __regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits, _S_auto, false>;
+}
+match_flag_type __regex_algo_impl___flags;
+template <typename, typename, typename _CharT, typename _TraitsT,
+          _RegexExecutorPolicy, bool>
+bool __regex_algo_impl(
+    Trans_NS___cxx11_match_results &__m,
+    const Trans_NS___cxx11_basic_regex<_CharT, _TraitsT> &__re) {
+  __normal_iterator<const char *> __e, __s;
+  _Executor<int, int, _TraitsT, false> __executor(__s, __e, __m, __re,
+                                                  __regex_algo_impl___flags);
+  __executor._M_match();
+  return false;
+}
+template <typename, typename, typename, bool> class _Executor {
+public:
+  _Executor(__normal_iterator<const char *>, __normal_iterator<const char *>,
+            vector<int>, Trans_NS___cxx11_basic_regex<char>, match_flag_type);
+  void _M_match() { _M_dfs(); }
+  void _M_dfs();
+  vector<pair<__normal_iterator<char *>>> _M_rep_count;
+};
+long _M_rep_once_more___i;
+template <typename _BiIter, typename _Alloc, typename _TraitsT, bool __dfs_mode>
+void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::_M_dfs() {
+  auto __rep_count = _M_rep_count[_M_rep_once_more___i];
+}
+char main___trans_tmp_1;
+void main___trans_tmp_2() {
+  Trans_NS___cxx11_basic_regex<char> re;
+  regex_search(main___trans_tmp_1, main___trans_tmp_2, re);
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-pmf3.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-pmf3.C
new file mode 100644
index 00000000000..14daea312b7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-pmf3.C
@@ -0,0 +1,13 @@
+// PR c++/105996
+// { dg-do compile { target c++11 } }
+
+struct A {
+  void CB() {}
+};
+struct B : public A { };
+
+using APMF = void (A::*)();
+using BPMF = void (B::*)();
+
+constexpr APMF foo () { return &A::CB; };
+static constexpr BPMF b = foo();
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype81.C b/gcc/testsuite/g++.dg/cpp0x/decltype81.C
new file mode 100644
index 00000000000..7d25db39d9c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype81.C
@@ -0,0 +1,15 @@
+// PR c++/105386
+// { dg-do compile { target c++11 } }
+
+template<class T> struct NoInst {
+  static_assert(sizeof(T) == 9999, "NoInst instantiated");
+};
+
+template<class T> NoInst<T> f(T);
+
+template<class>
+struct A {
+  using type = decltype(f(0));
+};
+
+A<int> a;
diff --git a/gcc/testsuite/g++.dg/cpp0x/enum43.C b/gcc/testsuite/g++.dg/cpp0x/enum43.C
new file mode 100644
index 00000000000..b2cd9797a06
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/enum43.C
@@ -0,0 +1,11 @@
+// PR c++/101869
+
+enum E { A };
+E operator & (E e)
+{
+  return e;
+}
+E f(void)
+{
+    return &E::A;	 // { dg-error "not a class" "" { target c++98_only } }
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C b/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C
new file mode 100644
index 00000000000..0ef27806acf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-new6.C
@@ -0,0 +1,39 @@
+// PR c++/105265
+// { dg-do run { target c++11 } }
+
+int c;
+
+class Block
+{
+public:
+  Block(int n) : data{new char[n]}, size{n}
+  {
+    ++c;
+  }
+
+  ~Block()
+  {
+    --c;
+    delete[] data;
+  }
+
+private:
+  char* data;
+  int size;
+};
+
+struct Cargo
+{
+  Block const& block;
+};
+
+int main()
+{
+  {
+    Cargo* c = new Cargo{{4000}};
+    delete c;
+  }
+  if (c != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C b/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C
new file mode 100644
index 00000000000..e44dbecfece
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-nrv1.C
@@ -0,0 +1,34 @@
+// PR c++/101442
+// { dg-do run { target c++11 } }
+
+bool destroyed = false;
+
+struct A
+{
+  A() {}
+  A(const A &) = delete;
+  A &operator=(const A &) = delete;
+  ~A() {destroyed = true;}
+};
+
+struct B
+{
+  const A &a;
+  struct string {
+    string(const char*) { }
+    ~string() { }
+  } s;
+};
+
+B foo()
+{
+  B ret{ A{}, "" };
+  return ret;
+}
+
+int main()
+{
+  B b = foo();
+  if (!destroyed)
+    __builtin_abort();
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const11.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const11.C
new file mode 100644
index 00000000000..26af75bf132
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const11.C
@@ -0,0 +1,14 @@
+// PR c++/108975
+// { dg-do compile { target c++11 } }
+
+template<class T>
+void f() {
+  constexpr int dim = 1;
+  auto l = [&] {
+    int n[dim * 1];
+  };
+  // In f<int>, we shouldn't actually capture dim.
+  static_assert (sizeof(l) == 1, "");
+}
+
+template void f<int>();
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C
new file mode 100644
index 00000000000..a6631c5ca99
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-current-inst1.C
@@ -0,0 +1,18 @@
+// PR c++/82980
+// { dg-do compile { target c++11 } }
+
+template <class T>
+struct Outer
+{
+  template <class U>
+  void f();
+
+  void bar(Outer outer) {
+    [outer](){ outer.f<int>(); };
+  }
+  void baz(Outer *p) {
+    [&](){ p->f<int>(); };
+  }
+};
+
+int main() { }
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept78.C b/gcc/testsuite/g++.dg/cpp0x/noexcept78.C
new file mode 100644
index 00000000000..e8156eb7c6f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept78.C
@@ -0,0 +1,16 @@
+// PR c++/109761
+// { dg-do compile { target c++11 } }
+
+struct base {
+  virtual void foo() noexcept { }
+  virtual ~base() { }
+};
+
+struct outer : base {
+  struct nested {
+    void foo() noexcept(noexcept(g())); // { dg-bogus "looser" }
+    ~nested() noexcept(noexcept(g()));  // { dg-bogus "looser" }
+  };
+  static void g();
+};
+
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi-array2.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi-array2.C
new file mode 100644
index 00000000000..5ad60f56510
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi-array2.C
@@ -0,0 +1,15 @@
+// PR c++/109666
+// { dg-do compile { target c++11 } }
+
+struct Point {
+  int value_;
+};
+template <int n> struct StaticVector {
+  static StaticVector create() {
+    StaticVector output;
+    return output;
+  }
+  Point _M_elems[n]{};
+
+};
+void f() { StaticVector<3>::create(); }
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi-template25.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template25.C
new file mode 100644
index 00000000000..368e745540e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi-template25.C
@@ -0,0 +1,18 @@
+// PR c++/106890
+// { dg-do compile { target c++11 } }
+
+struct A
+{
+  int p;
+};
+
+template<typename T>
+struct B : virtual public A
+{
+  B() { }
+  B(int) { }
+
+  int k = this->p;
+};
+
+template struct B<int>;
diff --git a/gcc/testsuite/g++.dg/cpp0x/overload-conv-5.C b/gcc/testsuite/g++.dg/cpp0x/overload-conv-5.C
new file mode 100644
index 00000000000..b1e7766e42b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/overload-conv-5.C
@@ -0,0 +1,21 @@
+// PR c++/106675
+// { dg-do compile { target c++11 } }
+
+struct foo {
+    int n_;
+    foo(int n) : n_(n) {}
+};
+
+struct bar {
+    int n_;
+
+    operator foo() const {
+        return foo(n_);
+    }
+    operator foo &() { return *reinterpret_cast<foo *>(n_); }
+    operator foo const &() = delete;
+
+    void crashgcc() {
+        foo tmp(*this); // { dg-error "ambiguous" }
+    }
+};
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr107065.C b/gcc/testsuite/g++.dg/cpp0x/pr107065.C
new file mode 100644
index 00000000000..5e18bb91cff
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/pr107065.C
@@ -0,0 +1,14 @@
+// PR c++/107065
+// { dg-do compile { target c++11 } }
+
+template<class, class> struct is_same { static constexpr bool value = false; };
+template<class T> struct is_same<T, T> { static constexpr bool value = true; };
+
+int
+main ()
+{
+  bool b = true;
+  static_assert (is_same<decltype (!(!b)), bool>::value, "");
+  auto bb = (!(!b));
+  static_assert (is_same<decltype (bb), bool>::value, "");
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C b/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
index 85ac9fbfd79..d296d7c3b72 100644
--- a/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
@@ -51,6 +51,6 @@ g (int *p, const int *pc, const int **q)
      similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-
      qualification signature of type T1 is a proper subset of  the  cv-
      qualification signature of type T2  */
-  f8 (q);
+  f8 (q); // { dg-error "call of overloaded" }
   f9 (q);
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C b/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C
new file mode 100644
index 00000000000..eee78fd5e74
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C
@@ -0,0 +1,10 @@
+// PR c++/97296
+// { dg-do compile }
+
+void f(const int * const &);
+void f(const int *);
+int *x;
+int main()
+{
+  f(x); // { dg-error "call of overloaded" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C b/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C
new file mode 100644
index 00000000000..13f3175da45
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/auto-fn64.C
@@ -0,0 +1,12 @@
+// PR c++/105761
+// { dg-do compile { target c++14 } }
+// { dg-additional-options -Wno-non-template-friend }
+
+template <class T>
+class X {
+  friend auto f(X);
+};
+
+struct Y : X<long> {
+  friend auto f(X) { return 0L; }
+};
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-105774.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-105774.C
new file mode 100644
index 00000000000..8ca6fce7570
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-105774.C
@@ -0,0 +1,15 @@
+// PR c++/105774
+// { dg-do compile { target c++14 } }
+
+constexpr signed char
+foo ()
+{
+#if __SCHAR_MAX__ < __INT_MAX__
+  signed char x = __SCHAR_MAX__;
+#else
+  signed char x = 0;
+#endif
+  return ++x;
+}
+
+constexpr auto a = foo ();
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
index 2acfa98364b..9768b89904e 100644
--- a/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-empty2.C
@@ -1,4 +1,5 @@
 // { dg-do compile { target c++14 } }
+// { dg-additional-options -fno-elide-constructors }
 
 struct A
 {
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C
new file mode 100644
index 00000000000..77cf0bb9d02
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C
@@ -0,0 +1,15 @@
+// PR c++/105398
+// { dg-do compile { target c++14 } }
+
+auto f = [](auto &&m) {
+    enum E { _,e3,e2,e1,C4,C3,C2,C1 };
+    static constexpr int x_coeffs[3][4] = {
+        {e1,C2,C3,C4},
+        {e2,C1,C3,C4},
+        {e3,C1,C2,C4},
+    };
+};
+
+int main() {
+    f(0);
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ78.C b/gcc/testsuite/g++.dg/cpp1y/var-templ78.C
new file mode 100644
index 00000000000..48366c92775
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ78.C
@@ -0,0 +1,12 @@
+// PR c++/108468
+// { dg-do compile { target c++14 } }
+
+template<int> struct C {
+  template<class, class>
+  static constexpr int x = 1;
+};
+
+template<int I> template<class... A>
+int C<I>::x<void(A...), void(A...)> = 2;
+
+int y = C<0>::x<void(int), void()>;
diff --git a/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C b/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C
new file mode 100644
index 00000000000..3fa0ed996bd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/aligned-new9.C
@@ -0,0 +1,30 @@
+// PR c++/102071
+// { dg-do run { target c++17 } }
+// { dg-additional-options -faligned-new=2 }
+
+#include <new>
+
+int nalign;
+void *operator new (std::size_t s, std::align_val_t a)
+{
+  nalign = (int)a;
+  return operator new (s);
+}
+
+struct X { ~X(); int c; };
+
+int align = (alignof (X) > alignof (std::size_t)
+	     ? alignof (X) : alignof (std::size_t));
+
+int n = 4;
+
+int main()
+{
+  X *p = new X[n];
+  if (nalign != align)
+    __builtin_abort ();
+
+  X *p2 = new X;
+  if (nalign != alignof (X))
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
index a31cc1526db..f0d7ea0e16b 100644
--- a/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction12.C
@@ -15,3 +15,9 @@ A a(&i,2,B<42>());
 template <class,class> class same;
 template <class T> class same<T,T> {};
 same<decltype(a), A<int*>> s;
+
+#if __cpp_deduction_guides >= 201907
+template <class T> using C = A<const T*>;
+
+same<decltype(C(&i, 2, B<42>())), A<const int*>> t;
+#endif
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C
new file mode 100644
index 00000000000..6daa4b7c55c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction99.C
@@ -0,0 +1,35 @@
+// PR c++/102479
+// { dg-do compile { target c++17 } }
+
+template<class T> struct A;
+
+template<class T>
+struct tuple {
+  tuple(T);
+
+  template<template<class> class Tmpl>
+  tuple(Tmpl<T>);
+
+  template<template<class> class Tmpl, typename A<Tmpl<char>>::type = 0>
+  tuple(Tmpl<T>);
+
+  template<template<class> class Tmpl, typename A<Tmpl<long>>::type = 0>
+  tuple(Tmpl<T>);
+};
+
+template<class T> struct B { };
+
+using ty1 = tuple<int>;
+using ty1 = decltype(tuple(0));
+using ty1 = decltype(tuple(B<int>{}));
+
+#if __cpp_deduction_guides >= 201907
+template<class T> using const_tuple = tuple<const T>;
+
+using ty2 = const_tuple<int>;
+using ty2 = decltype(const_tuple(0));
+using ty2 = decltype(const_tuple(B<const int>{}));
+
+using ty3 = const_tuple<B<int>>;
+using ty3 = decltype(const_tuple(B<int>{}));
+#endif
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C
new file mode 100644
index 00000000000..06acb4a9f78
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-aggr-base1.C
@@ -0,0 +1,27 @@
+// PR c++/105795
+// { dg-do compile { target c++17 } }
+
+struct empty
+{};
+
+template <typename T>
+struct tuple_holder
+{
+    [[no_unique_address]] T value;
+};
+
+struct tuple : tuple_holder<int>, tuple_holder<empty>
+{};
+
+constexpr auto make_tuple(int&& i, empty&& e)
+{
+    return tuple{i, e};
+}
+
+constexpr int foo()
+{
+    auto tuple = make_tuple(1, empty{});
+    return static_cast<const tuple_holder<int>&>(tuple).value;
+}
+
+static_assert (foo() == 1);
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C
new file mode 100644
index 00000000000..c30e3f2361d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-array2.C
@@ -0,0 +1,12 @@
+// PR c++/102307
+// { dg-do compile { target c++11 } }
+
+#include <array>
+template <unsigned N, unsigned M> struct Matrix {
+  constexpr Matrix(double const (&arr)[N][M]); // { dg-warning "never defined" }
+  constexpr Matrix(std::array<std::array<double, M>, N> const &arr);
+};
+int main() {
+  constexpr Matrix<2, 3>
+    mat {{ {1.0, 2.0, 3.0}, {4.0, 5.0, 6.0} }}; // { dg-error "before its definition" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda5.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda5.C
new file mode 100644
index 00000000000..d2bf0221743
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if-lambda5.C
@@ -0,0 +1,15 @@
+// PR c++/100295
+// { dg-do compile { target c++17 } }
+
+template<typename... Ts>
+void f(Ts... ts) {
+  auto lambda = [=](auto x) {
+    if constexpr (sizeof((ts+x) + ...) != 0)
+      (..., ts);
+  };
+  lambda(0);
+}
+
+int main() {
+  f(0, 'a');
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp57.C b/gcc/testsuite/g++.dg/cpp1z/decomp57.C
new file mode 100644
index 00000000000..923862e78d1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp57.C
@@ -0,0 +1,27 @@
+// PR c++/108474
+// { dg-do link { target c++17 } }
+
+struct T { int i, j; };
+T h;
+auto [i, j] = h;
+int &r = i;
+int s = i;
+int *t = &i;
+
+void
+foo (int **p, int *q)
+{
+  static int &u = i;
+  static int v = i;
+  static int *w = &i;
+  int &x = i;
+  int y = i;
+  int *z = &i;
+  *p = &i;
+  *q = i;
+}
+
+int
+main ()
+{
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp58.C b/gcc/testsuite/g++.dg/cpp1z/decomp58.C
new file mode 100644
index 00000000000..b2604373bde
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp58.C
@@ -0,0 +1,39 @@
+// PR c++/108474
+// { dg-do link { target c++17 } }
+
+namespace std {
+  template <typename T> struct tuple_size;
+  template <int, typename> struct tuple_element;
+}
+
+struct A {
+  int i;
+  template <int I> int& get() { return i; }
+};
+
+template <> struct std::tuple_size <A> { static const int value = 2; };
+template <int I> struct std::tuple_element <I, A> { using type = int; };
+
+struct A a;
+auto [i, j] = a;
+int &r = i;
+int s = i;
+int *t = &i;
+
+void
+foo (int **p, int *q)
+{
+  static int &u = i;
+  static int v = i;
+  static int *w = &i;
+  int &x = i;
+  int y = i;
+  int *z = &i;
+  *p = &i;
+  *q = i;
+}
+
+int
+main ()
+{
+}
diff --git a/gcc/testsuite/g++.dg/cpp1z/fold13.C b/gcc/testsuite/g++.dg/cpp1z/fold13.C
new file mode 100644
index 00000000000..9d7554f8999
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/fold13.C
@@ -0,0 +1,29 @@
+// { dg-do compile { target c++17 } }
+// Verify constexpr evaluation of a large left fold logical expression
+// isn't quadratic in the size of the expanded expression.
+
+template<int> struct S { static constexpr bool value = true; };
+
+template<class T, T...> struct integer_sequence { };
+
+template<class T, T N>
+using make_integer_sequence
+#if __has_builtin(__make_integer_seq)
+  = __make_integer_seq<integer_sequence, T, N>;
+#else
+  = integer_sequence<T, __integer_pack(N)...>;
+#endif
+
+template<int... Is>
+constexpr bool f_impl(integer_sequence<int, Is...>) {
+  return (... && S<Is>::value);
+}
+
+static_assert(f_impl(make_integer_sequence<int, 1024>()));
+
+template<int... Is>
+constexpr bool g_impl(integer_sequence<int, Is...>) {
+  return (... || !S<Is>::value);
+}
+
+static_assert(!g_impl(make_integer_sequence<int, 1024>()));
diff --git a/gcc/testsuite/g++.dg/cpp1z/has-unique-obj-representations3.C b/gcc/testsuite/g++.dg/cpp1z/has-unique-obj-representations3.C
new file mode 100644
index 00000000000..349c93e3c2b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1z/has-unique-obj-representations3.C
@@ -0,0 +1,10 @@
+// PR c++/109096
+// { dg-do compile { target c++11 } }
+
+#define INTB (__SIZEOF_INT__ * __CHAR_BIT__)
+struct U { int i : INTB * 3 / 4; int : INTB / 4; };
+struct V { int : INTB * 3 / 4; int j : INTB / 4; };
+struct W { int i; int : 0; int j; };
+static_assert (__has_unique_object_representations (U) == false, "");
+static_assert (__has_unique_object_representations (V) == false, "");
+static_assert (sizeof (W) != 2 * sizeof (int) || __has_unique_object_representations (W) == true, "");
diff --git a/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C b/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C
new file mode 100644
index 00000000000..1528f734461
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp23/lambda-attr1.C
@@ -0,0 +1,29 @@
+// P2173R1 - Attributes on Lambda-Expressions
+// { dg-do compile { target c++11 } }
+
+void
+foo (bool x, bool y)
+{
+  auto a = [][[noreturn]] () {};	// { dg-warning "'noreturn' function does return" }
+  if (x)
+    a ();
+  auto b = [][[noreturn]] {};		// { dg-warning "'noreturn' function does return" }
+  if (y)
+    b ();
+  auto c = [] [[ deprecated ]] () {};	// { dg-bogus "is deprecated" }
+  c ();					// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is deprecated" }
+  auto d = [][[deprecated]] {};		// { dg-bogus "is deprecated" }
+  d ();					// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>' is deprecated" }
+#if __cpp_generic_lambdas >= 201304
+  auto e = [] [[deprecated]] (auto x) {};	// { dg-bogus "is deprecated" }
+  e (0.0);				// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(auto:1\\\)>\[^\n\r]*' is deprecated" "" { target c++14 } }
+#endif
+#if __cpp_generic_lambdas >= 201707
+  auto f = [] <typename T> [[deprecated]] (T) {};	// { dg-bogus "is deprecated" }
+  f (1);				// { dg-warning "'foo\\\(bool, bool\\\)::<lambda\\\(T\\\)>\[^\n\r]*' is deprecated" "" { target c++20 } }
+#endif
+  auto g = [][[nodiscard]](int) { return 1; };
+  g (1);				// { dg-warning "ignoring return value of 'foo\\\(bool, bool\\\)::<lambda\\\(int\\\)>', declared with attribute 'nodiscard'" }
+  auto h = [] [[nodiscard]] { return 0; };
+  h ();					// { dg-warning "ignoring return value of 'foo\\\(bool, bool\\\)::<lambda\\\(\\\)>', declared with attribute 'nodiscard'" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C b/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C
new file mode 100644
index 00000000000..f500af3f616
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C
@@ -0,0 +1,10 @@
+// PR c++/105304
+// { dg-do compile { target c++20 } }
+// { dg-additional-options "-Wall -Wsequence-point" }
+
+struct A { };
+
+int main() {
+  if (requires { A(); })
+    ;
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-requires31.C b/gcc/testsuite/g++.dg/cpp2a/concepts-requires31.C
new file mode 100644
index 00000000000..cd26b9ca077
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-requires31.C
@@ -0,0 +1,15 @@
+// PR c++/107179
+// { dg-do compile { target c++20 } }
+
+template<bool B> struct bool_constant { static constexpr bool value = B; };
+
+template<typename T>
+  struct is_implicitly_default_constructible
+  : bool_constant<requires { T(); }>
+  { };
+
+struct X { private: X(); };
+struct Y { };
+
+static_assert( !is_implicitly_default_constructible<X>::value );
+static_assert(  is_implicitly_default_constructible<Y>::value );
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-return-req4.C b/gcc/testsuite/g++.dg/cpp2a/concepts-return-req4.C
new file mode 100644
index 00000000000..471946bc8eb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-return-req4.C
@@ -0,0 +1,24 @@
+// PR c++/104527
+// { dg-do compile { target c++20 } }
+
+template<class T, class U>
+concept is_same = __is_same(T, U);
+
+template<class T>
+struct A {
+  template<class...>
+    requires requires { { 0 } -> is_same<T>; }
+  struct B {};
+
+  template<class...>
+    requires requires { { 1 } -> is_same<T>; }
+  static void f();
+};
+
+A<int>::B<> a1;
+A<bool>::B<> a2; // { dg-error "constraint" }
+
+int main() {
+  A<int>::f();
+  A<bool>::f(); // { dg-error "no match" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-traits3.C b/gcc/testsuite/g++.dg/cpp2a/concepts-traits3.C
new file mode 100644
index 00000000000..f20608b6918
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-traits3.C
@@ -0,0 +1,66 @@
+// PR c++/100474
+// { dg-do compile { target c++20 } }
+
+struct S { S() = delete; S(const S&); };
+
+template<class T>
+concept Aggregate = __is_aggregate(T);
+// { dg-message "'S' is not an aggregate" "" { target *-*-* } .-1  }
+
+template<class T>
+concept TriviallyCopyable = __is_trivially_copyable(T);
+// { dg-message "'S' is not trivially copyable" "" { target *-*-* } .-1  }
+
+template<class T, class U>
+concept Assignable = __is_assignable(T, U);
+// { dg-message "'S' is not assignable from 'int'" "" { target *-*-* } .-1  }
+
+template<class T, class U>
+concept TriviallyAssignable = __is_trivially_assignable(T, U);
+// { dg-message "'S' is not trivially assignable from 'int'" "" { target *-*-* } .-1  }
+
+template<class T, class U>
+concept NothrowAssignable = __is_nothrow_assignable(T, U);
+// { dg-message "'S' is not 'nothrow' assignable from 'int'" "" { target *-*-* } .-1  }
+
+template<class T, class... Args>
+concept Constructible = __is_constructible(T, Args...);
+// { dg-message "'S' is not default constructible" "" { target *-*-* } .-1  }
+// { dg-message "'S' is not constructible from 'int'" "" { target *-*-* } .-2  }
+// { dg-message "'S' is not constructible from 'int, char'" "" { target *-*-* } .-3  }
+
+template<class T, class... Args>
+concept TriviallyConstructible = __is_trivially_constructible(T, Args...);
+// { dg-message "'S' is not trivially default constructible" "" { target *-*-* } .-1  }
+// { dg-message "'S' is not trivially constructible from 'int'" "" { target *-*-* } .-2  }
+// { dg-message "'S' is not trivially constructible from 'int, char'" "" { target *-*-* } .-3  }
+
+template<class T, class... Args>
+concept NothrowConstructible = __is_nothrow_constructible(T, Args...);
+// { dg-message "'S' is not 'nothrow' default constructible" "" { target *-*-* } .-1  }
+// { dg-message "'S' is not 'nothrow' constructible from 'int'" "" { target *-*-* } .-2  }
+// { dg-message "'S' is not 'nothrow' constructible from 'int, char'" "" { target *-*-* } .-3  }
+
+template<class T>
+concept UniqueObjReps = __has_unique_object_representations(T);
+// { dg-message "'S' does not have unique object representations" "" { target *-*-* } .-1  }
+
+static_assert(Aggregate<S>); // { dg-error "assert" }
+static_assert(TriviallyCopyable<S>); // { dg-error "assert" }
+static_assert(Assignable<S, int>); // { dg-error "assert" }
+static_assert(TriviallyAssignable<S, int>); // { dg-error "assert" }
+static_assert(NothrowAssignable<S, int>); // { dg-error "assert" }
+
+static_assert(Constructible<S>); // { dg-error "assert" }
+static_assert(Constructible<S, int>); // { dg-error "assert" }
+static_assert(Constructible<S, int, char>); // { dg-error "assert" }
+
+static_assert(TriviallyConstructible<S>); // { dg-error "assert" }
+static_assert(TriviallyConstructible<S, int>); // { dg-error "assert" }
+static_assert(TriviallyConstructible<S, int, char>); // { dg-error "assert" }
+
+static_assert(NothrowConstructible<S>); // { dg-error "assert" }
+static_assert(NothrowConstructible<S, int>); // { dg-error "assert" }
+static_assert(NothrowConstructible<S, int, char>); // { dg-error "assert" }
+
+static_assert(UniqueObjReps<S>); // { dg-error "assert" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/constinit18.C b/gcc/testsuite/g++.dg/cpp2a/constinit18.C
new file mode 100644
index 00000000000..51b4f0273be
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/constinit18.C
@@ -0,0 +1,12 @@
+// PR c++/104066
+// { dg-do compile { target c++20 } }
+
+constinit void (*p)() = nullptr;
+constinit void (*pp)() = nullptr;
+void fn();
+constinit void (&r)() = fn;
+
+extern constinit long (* const syscall_reexported) (long, ...);
+
+constinit void bad (); // { dg-error ".constinit. on function return type is not allowed" }
+constinit void bad () { } // { dg-error ".constinit. on function return type is not allowed" }
diff --git a/gcc/testsuite/g++.dg/cpp2a/desig26.C b/gcc/testsuite/g++.dg/cpp2a/desig26.C
new file mode 100644
index 00000000000..443fa3d089d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/desig26.C
@@ -0,0 +1,22 @@
+// PR c++/105925
+// { dg-do compile { target c++20 } }
+
+struct V
+{
+    int i;
+    double d;
+};
+
+struct X
+{
+    union
+    {
+        int x;
+        V y;
+    };
+};
+
+X foo()
+{
+    return {.y = {0, 0.0}};
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-generic10.C b/gcc/testsuite/g++.dg/cpp2a/lambda-generic10.C
new file mode 100644
index 00000000000..773fb948cee
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-generic10.C
@@ -0,0 +1,14 @@
+// PR c++/106024
+// { dg-do compile { target c++20 } }
+
+void sink(...);
+template <int... args> void f()
+{
+  sink ([] <int T> (int...) { return 1; }
+        .operator()<args>(args...)...); // { dg-error "" }
+} // { dg-prune-output {expected '\)'} }
+
+int main()
+{
+  f<1,2,3>();
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-generic11.C b/gcc/testsuite/g++.dg/cpp2a/lambda-generic11.C
new file mode 100644
index 00000000000..62affac542e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-generic11.C
@@ -0,0 +1,13 @@
+// PR c++/108999
+// { dg-do compile { target c++20 } }
+
+template<typename T>
+void ice(T a) {
+  auto aa = a;
+  auto lambda = []<int I>() {
+    if constexpr (sizeof(aa) + I != 42) { }
+  };
+  lambda.template operator()<17>();
+}
+
+template void ice(int);
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C
new file mode 100644
index 00000000000..f3c3899e97a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-pack-init7.C
@@ -0,0 +1,18 @@
+// PR c++/102629
+// { dg-do compile { target c++20 } }
+
+template <class T> T&& forward(T&);
+template <class T> T&& forward(T&&);
+
+struct S {};
+
+template <typename... Args>
+void foo(Args&&... args) {
+  [...args = forward<Args> /*(args)*/] { // { dg-error "" }
+    [](auto...) { } (forward<Args>(args)...);
+  };
+}
+
+void bar( ) {
+  foo(S{});
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/spaceship-eq14.C b/gcc/testsuite/g++.dg/cpp2a/spaceship-eq14.C
new file mode 100644
index 00000000000..896e5232bf6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/spaceship-eq14.C
@@ -0,0 +1,17 @@
+// PR c++/106361
+// { dg-do compile { target c++20 } }
+
+struct foo {
+  int x;
+};
+
+struct bar {
+  foo f;			// { dg-error "operator==" }
+  friend bool operator==(const bar& a, const bar& b);
+};
+
+bool operator==(const bar& a, const bar& b) = default;
+
+int main() {
+  return bar{} == bar{};	// { dg-error "deleted" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/volatile1.C b/gcc/testsuite/g++.dg/cpp2a/volatile1.C
index 7ea6b477ca2..a0264a47bc7 100644
--- a/gcc/testsuite/g++.dg/cpp2a/volatile1.C
+++ b/gcc/testsuite/g++.dg/cpp2a/volatile1.C
@@ -56,6 +56,9 @@ fn2 ()
   vi = i;
   vi = i = 42;
   i = vi = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  i = vi |= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  i = vi &= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  i = vi ^= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   &(vi = i); // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   (vi = 42, 45);
   (i = vi = 42, 10); // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
@@ -74,8 +77,9 @@ fn2 ()
   vi += i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   vi -= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   vi %= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
-  vi ^= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
-  vi |= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  vi ^= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
+  vi |= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
+  vi &= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
   vi /= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   vi = vi += 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
   vi += vi = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
@@ -131,7 +135,8 @@ void raccoon ()
   volatile T t, u;
   t = 42;
   u = t = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
-  t &= 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  t += 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" "" { target c++20 } }
+  t &= 42; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
 }
 
 void
diff --git a/gcc/testsuite/g++.dg/cpp2a/volatile3.C b/gcc/testsuite/g++.dg/cpp2a/volatile3.C
index f10a29756a9..58816dc3084 100644
--- a/gcc/testsuite/g++.dg/cpp2a/volatile3.C
+++ b/gcc/testsuite/g++.dg/cpp2a/volatile3.C
@@ -57,6 +57,9 @@ fn2 ()
   vi = i;
   vi = i = 42;
   i = vi = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
+  i = vi |= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" }
+  i = vi &= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" }
+  i = vi ^= 42; // { dg-warning "using value of assignment with .volatile.-qualified left operand is deprecated" }
   &(vi = i); // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   (vi = 42, 45);
   (i = vi = 42, 10); // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
@@ -75,8 +78,9 @@ fn2 ()
   vi += i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   vi -= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   vi %= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
-  vi ^= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
-  vi |= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
+  vi ^= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
+  vi |= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
+  vi &= i; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
   vi /= i; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   vi = vi += 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
   vi += vi = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
@@ -132,7 +136,8 @@ void raccoon ()
   volatile T t, u;
   t = 42;
   u = t = 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
-  t &= 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
+  t += 42; // { dg-warning "assignment with .volatile.-qualified left operand is deprecated" }
+  t &= 42; // { dg-bogus "assignment with .volatile.-qualified left operand is deprecated" }
 }
 
 void
diff --git a/gcc/testsuite/g++.dg/cpp2a/volatile5.C b/gcc/testsuite/g++.dg/cpp2a/volatile5.C
index 1f9d23845b4..3684be9837e 100644
--- a/gcc/testsuite/g++.dg/cpp2a/volatile5.C
+++ b/gcc/testsuite/g++.dg/cpp2a/volatile5.C
@@ -8,8 +8,8 @@ f (bool b)
 {
   (b ? x : y) = 1;
   (b ? x : y) += 1; // { dg-warning "compound assignment" "" { target c++20 } }
-  z = (b ? x : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
-  ((z = 2) ? x : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
-  (b ? (x = 2) : y) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
-  (b ? x : (y = 5)) = 1; // { dg-warning "using value of simple assignment" "" { target c++20 } }
+  z = (b ? x : y) = 1; // { dg-warning "using value of assignment" "" { target c++20 } }
+  ((z = 2) ? x : y) = 1; // { dg-warning "using value of assignment" "" { target c++20 } }
+  (b ? (x = 2) : y) = 1; // { dg-warning "using value of assignment" "" { target c++20 } }
+  (b ? x : (y = 5)) = 1; // { dg-warning "using value of assignment" "" { target c++20 } }
 }
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/pr108716.C b/gcc/testsuite/g++.dg/debug/dwarf2/pr108716.C
new file mode 100644
index 00000000000..59ed52424da
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/pr108716.C
@@ -0,0 +1,14 @@
+// PR debug/108716
+// { dg-options "-O0 -gdwarf-5 -dA -fno-merge-debug-strings" }
+// { dg-final { scan-assembler "DIE \\(\[^\n\r\]*\\) DW_TAG_imported_module\[^\n\r\]*\[\n\r]*\[^\n\r\]* DW_AT_decl_file\[^\n\r\]*\[\n\r]*\[^\n\r\]*0xc\[^\n\r\]* DW_AT_decl_line\[^\n\r\]*\[\n\r]*(\[^\n\r\]*0x13\[^\n\r\]* DW_AT_decl_column\[^\n\r\]*\[\n\r]*)?" } }
+
+namespace M {
+  int x = 1;
+}
+
+int
+main ()
+{
+  using namespace M;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/debug/pr106261.C b/gcc/testsuite/g++.dg/debug/pr106261.C
new file mode 100644
index 00000000000..6dee7e68ff5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/pr106261.C
@@ -0,0 +1,36 @@
+// PR debug/106261
+// { dg-do compile }
+// { dg-options "-dx -fno-dwarf2-cfi-asm" }
+
+struct A
+{
+  virtual void foo ();
+  int a;
+};
+class C : virtual public A
+{
+};
+struct B
+{
+  A *b;
+
+  B (A *x) : b (x) { b->foo (); }
+};
+struct E
+{
+  virtual ~E ();
+};
+class D : public C, E
+{
+};
+struct F : D
+{
+  F (int);
+
+  static void bar ()
+  {
+    F a (0);
+    B b (&a);
+  }
+};
+void baz () { F::bar (); }
diff --git a/gcc/testsuite/g++.dg/debug/pr108967.C b/gcc/testsuite/g++.dg/debug/pr108967.C
new file mode 100644
index 00000000000..b50dadc5925
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/pr108967.C
@@ -0,0 +1,41 @@
+// PR debug/108967
+// { dg-do compile }
+
+struct F { unsigned short r[8]; };
+extern void foo (F);
+
+static inline F
+bar (F a, F b)
+{
+  for (int i = 0; i < 8; ++i)
+    a.r[i] = a.r[i] + b.r[i] < (unsigned short) -1 ? a.r[i] + b.r[i] : (unsigned short) -1;
+  return a;
+}
+
+static inline void
+baz (F v)
+{
+  foo (v);
+}
+
+void
+qux (F a, F b)
+{
+  F c = bar (a, b);
+  baz (c);
+}
+
+static inline F
+corge (F a, F b)
+{
+  for (int i = 0; i < 8; ++i)
+    a.r[i] = a.r[i] - b.r[i] > 0 ? a.r[i] - b.r[i] : 0;
+  return a;
+}
+
+void
+garply (F a, F b)
+{
+  F c = corge (a, b);
+  baz (c);
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr106124.C b/gcc/testsuite/g++.dg/gomp/pr106124.C
new file mode 100644
index 00000000000..3129749804b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr106124.C
@@ -0,0 +1,19 @@
+// { dg-do compile }
+// { dg-require-effective-target c++11 }
+// { dg-options "-g -O2 -fopenmp -fkeep-inline-functions" }
+
+int q;
+struct A
+{
+  typedef int T;
+#pragma omp declare reduction (x : T : omp_out += omp_in + [] (){ return q; }()) initializer (omp_priv = [](){ return 0; }())
+  static void foo ();
+};
+void bar (int &, int &);
+void
+A::foo ()
+{
+  int r = 0, s = 0;
+#pragma omp parallel reduction (x : r, s)
+  bar (r, s);
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr106492.C b/gcc/testsuite/g++.dg/gomp/pr106492.C
new file mode 100644
index 00000000000..f263bb42710
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr106492.C
@@ -0,0 +1,49 @@
+/* PR middle-end/106492 */
+
+template <typename T>
+struct S {
+  T a : 12;
+  S () : a(0)
+  {
+#pragma omp for simd linear(a)
+    for (int k = 0; k < 64; ++k)
+      a++;
+  }
+};
+struct U {
+  int a : 12;
+  U () : a(0)
+  {
+#pragma omp for simd linear(a)
+    for (int k = 0; k < 64; ++k)
+      a++;
+  }
+};
+
+S<int> s;
+U u;
+
+
+template <typename T>
+struct Sptr {
+  T a;
+  Sptr (T init) : a(init)
+  {
+#pragma omp for simd linear(a)
+    for (int k = 0; k < 64; ++k)
+      a++;
+  }
+};
+struct Uptr {
+  int *a;
+  Uptr (int *init) : a(init)
+  {
+#pragma omp for simd linear(a)
+    for (int k = 0; k < 64; ++k)
+      a++;
+  }
+};
+
+int i[1024];
+Sptr<int *> sptr(i);
+Uptr uptr(&i[100]);
diff --git a/gcc/testsuite/g++.dg/gomp/pr107558.C b/gcc/testsuite/g++.dg/gomp/pr107558.C
new file mode 100644
index 00000000000..8a6b8d45df7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr107558.C
@@ -0,0 +1,14 @@
+// PR c++/107558
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-fmerge-all-constants" }
+// { dg-additional-options "-flto" { target lto } }
+
+int a = 15;
+
+void
+foo ()
+{
+  auto &&l = [&]() { return a; };
+#pragma omp target parallel
+  l ();
+}
diff --git a/gcc/testsuite/g++.dg/gomp/pr108607.C b/gcc/testsuite/g++.dg/gomp/pr108607.C
new file mode 100644
index 00000000000..b0eb0483a8a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/pr108607.C
@@ -0,0 +1,33 @@
+// PR c++/108607
+// { dg-do compile { target c++14 } }
+// { dg-options "-fopenmp" }
+
+constexpr int
+bar (int x)
+{
+  return x;
+}
+
+constexpr int
+baz (int x)
+{
+  switch (x)
+    {
+    case 42:
+      return 0;
+    case 3:
+      #pragma omp parallel	// { dg-error "statement is not a constant expression" }
+      x = bar (x);
+      return x;
+    case 4:
+      #pragma omp task		// { dg-error "statement is not a constant expression" }
+      x = bar (x);
+      return x;
+    default:
+      return -1;
+    }
+}
+
+constexpr int b = baz (42);
+constexpr int d = baz (3);
+constexpr int e = baz (4);
diff --git a/gcc/testsuite/g++.dg/guality/guality.exp b/gcc/testsuite/g++.dg/guality/guality.exp
index 1d5b65fef57..2d736d292e9 100644
--- a/gcc/testsuite/g++.dg/guality/guality.exp
+++ b/gcc/testsuite/g++.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
     return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
diff --git a/gcc/testsuite/g++.dg/init/pr53932.C b/gcc/testsuite/g++.dg/init/pr53932.C
new file mode 100644
index 00000000000..3b129e7d68a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/init/pr53932.C
@@ -0,0 +1,25 @@
+// PR c++/53932
+// { dg-do link }
+
+static union { int i; };
+int &r = i;
+int s = i;
+int *t = &i;
+
+void
+foo (int **p, int *q)
+{
+  static int &u = i;
+  static int v = i;
+  static int *w = &i;
+  int &x = i;
+  int y = i;
+  int *z = &i;
+  *p = &i;
+  *q = i;
+}
+
+int
+main ()
+{
+}
diff --git a/gcc/testsuite/g++.dg/ipa/pr100413.C b/gcc/testsuite/g++.dg/ipa/pr100413.C
new file mode 100644
index 00000000000..96d71e7cf35
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr100413.C
@@ -0,0 +1,64 @@
+/* { dg-do compile } */
+/* { dg-options "-std=c++11 -O2 -fno-guess-branch-probability -fno-inline-functions-called-once -fipa-cp-clone -fipa-pta -fnon-call-exceptions --param=ipa-cp-eval-threshold=0" } */
+
+
+template <typename> class allocator {
+public:
+  ~allocator();
+};
+template <typename> struct allocator_traits;
+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
+  using allocator_type = allocator<_Tp>;
+  template <typename _Up> using rebind_alloc = allocator<_Up>;
+  static void deallocate(allocator_type);
+};
+template <typename _ForwardIterator, typename _Tp>
+void _Destroy(_ForwardIterator, _ForwardIterator, _Tp);
+struct __alloc_traits : allocator_traits<allocator<int>> {
+  struct rebind {
+    typedef rebind_alloc<int> other;
+  };
+};
+struct _Vector_base {
+  struct _Vector_impl_data {
+    int _M_start;
+    int _M_finish;
+  };
+  struct _Vector_impl : __alloc_traits::rebind::other, _Vector_impl_data {};
+  __alloc_traits::rebind::other _M_get_Tp_allocator();
+  ~_Vector_base() { _M_deallocate(); }
+  _Vector_impl _M_impl;
+  void _M_deallocate() { __alloc_traits::deallocate(_M_impl); }
+};
+class vector : _Vector_base {
+public:
+  vector() noexcept {
+    allocator<int> __trans_tmp_1 = _M_get_Tp_allocator();
+    _Destroy(_M_impl._M_start, _M_impl._M_finish, __trans_tmp_1);
+  }
+  void size();
+};
+struct HTTPCallback {
+  virtual void OnFailure();
+};
+struct ContentCallback {
+  virtual void OnDownloadProgress();
+};
+class ClientNetworkContentSocketHandler : ContentCallback, HTTPCallback {
+  vector requested;
+  vector infos;
+  vector lastActivity;
+  void OnFailure();
+public:
+  int IDLE_TIMEOUT = 0;
+  ClientNetworkContentSocketHandler();
+  void DownloadSelectedContent();
+} _network_content_client;
+void ClientNetworkContentSocketHandler::DownloadSelectedContent() {
+  vector content;
+  content.size();
+}
+void ClientNetworkContentSocketHandler::OnFailure() {
+  DownloadSelectedContent();
+}
+ClientNetworkContentSocketHandler::ClientNetworkContentSocketHandler() {}
diff --git a/gcc/testsuite/g++.dg/lookup/friend24.C b/gcc/testsuite/g++.dg/lookup/friend24.C
new file mode 100644
index 00000000000..9a45410d2a7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lookup/friend24.C
@@ -0,0 +1,9 @@
+// PR c++/69410
+
+void a();
+void f() {
+    class A {
+        friend void ::a();
+        friend class Z;
+    };
+}
diff --git a/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C b/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
index 3acacf8ee34..c12857fbf69 100644
--- a/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
+++ b/gcc/testsuite/g++.dg/modules/tpl-friend-2_a.C
@@ -16,5 +16,5 @@ template class TPL<int>;  // instantiate
 void foo (int, void *);
 
 // { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl definition '::template TPL'\n(  \[.\]=[^\n]*'\n)*  \[.\]=decl declaration '::template foo'\n(  \[.\]=[^\n]*'\n)*  \[.\]=binding '::TPL'} module } }
-// { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl declaration '::foo<int>'\n  \[.\]=binding '::foo'} module } }
+// { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=decl declaration '::foo'\n  \[.\]=binding '::foo'} module } }
 // { dg-final { scan-lang-dump {Cluster members:\n  \[0\]=specialization definition '::TPL<int>'} module } }
diff --git a/gcc/testsuite/g++.dg/opt/const7.C b/gcc/testsuite/g++.dg/opt/const7.C
new file mode 100644
index 00000000000..5bcf94897a8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/const7.C
@@ -0,0 +1,7 @@
+// PR c++/104142
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -Wunused-variable }
+
+struct B { B()=default; };
+static const B b_var;		//  { dg-bogus "" }
+// { dg-final { scan-assembler-symbol-section {b_var} {^\.(const|rodata)|\[RO\]} } }
diff --git a/gcc/testsuite/g++.dg/opt/pr108365.C b/gcc/testsuite/g++.dg/opt/pr108365.C
new file mode 100644
index 00000000000..47eefa2b29a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr108365.C
@@ -0,0 +1,13 @@
+// PR c++/108365
+// { dg-do run }
+
+char b = 1;
+
+int
+main ()
+{
+#if __CHAR_BIT__ == 8 && __SIZEOF_SHORT__ == 2 && __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8
+  while ((short) ((long long) (unsigned long long) (-__INT_MAX__ - 1) / (long long) (b ? -1 : 0)))
+    ;
+#endif
+}
diff --git a/gcc/testsuite/g++.dg/opt/pr108854.C b/gcc/testsuite/g++.dg/opt/pr108854.C
new file mode 100644
index 00000000000..9f2d9030f75
--- /dev/null
+++ b/gcc/testsuite/g++.dg/opt/pr108854.C
@@ -0,0 +1,37 @@
+// PR middle-end/108854
+// { dg-do compile { target c++11 } }
+// { dg-options "-O3" }
+// { dg-additional-options "-fPIC" { target fpic } }
+
+struct A { A (int); ~A (); };
+struct B { B (int, bool); ~B (); };
+template <typename T>
+struct C { void m1 (T); void m2 (T &&); };
+class D;
+struct E { virtual void m3 (); };
+template <typename>
+struct F { virtual bool m4 (D &); };
+struct D { virtual D m5 () { return D (); } };
+void foo (void *, void *);
+struct G {
+  int a;
+  C <D *> b;
+  void m4 (D &r) { B l (a, true); r.m5 (); b.m1 (&r); b.m2 (&r); }
+};
+struct H : E, F <int> {
+  template <typename T>
+  H (int, T);
+  bool m4 (D &r) { A l (a); b.m4 (r); if (c) return true; } // { dg-warning "control reaches end of non-void function" }
+  int a;
+  bool c;
+  G b;
+};
+inline void bar (F <int> &p) { D s, t; p.m4 (t); foo (&p, &s); }
+enum I { I1, I2 };
+template <I>
+struct J;
+template <class, class T, class, class, class, class>
+void baz () { int g = 0, h = 0; T i (g, h); bar (i); }
+template <class, int, I T>
+void qux () { baz <int, H, int, int, E, J<T>> (); }
+void corge () { qux <int, I2, I1> (); qux <int, I2, I2> (); }
diff --git a/gcc/testsuite/g++.dg/parse/no-typename1.C b/gcc/testsuite/g++.dg/parse/no-typename1.C
index 711c621e26a..f40ea0ec13c 100644
--- a/gcc/testsuite/g++.dg/parse/no-typename1.C
+++ b/gcc/testsuite/g++.dg/parse/no-typename1.C
@@ -6,6 +6,6 @@ template <typename T> struct A
 {
     template <typename U> struct B
     {
-        A<T>::template B<U> foo(); // { dg-error "" "" { target c++17_down } }
+        A<T>::template B<U> foo();
     };
 };
diff --git a/gcc/testsuite/g++.dg/parse/qualified6.C b/gcc/testsuite/g++.dg/parse/qualified6.C
new file mode 100644
index 00000000000..68b51f771ec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/parse/qualified6.C
@@ -0,0 +1,10 @@
+// PR c++/90107
+// { dg-do compile }
+
+struct A;
+namespace N { extern A a; }
+struct A {} ::N::a;
+
+struct A1;
+struct B { static A1 a1; };
+struct A1 {} ::B::a1;
diff --git a/gcc/testsuite/g++.dg/pr104869.C b/gcc/testsuite/g++.dg/pr104869.C
new file mode 100644
index 00000000000..9a6ef88adbd
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr104869.C
@@ -0,0 +1,78 @@
+// PR rtl-optimization/104869
+// { dg-do run }
+// { dg-options "-O2 -fvisibility=hidden -std=c++11" }
+// { dg-require-visibility "" }
+
+struct QBasicAtomicInteger {
+  [[gnu::noipa]] int loadRelaxed() { return 1; }
+};
+struct RefCount {
+  bool deref() {
+    int count = atomic.loadRelaxed();
+    if (count)
+      return false;
+    return deref();
+  }
+  QBasicAtomicInteger atomic;
+};
+struct QArrayData {
+  RefCount ref;
+};
+struct QString {
+  ~QString();
+  QArrayData d;
+};
+int ok;
+QString::~QString() { d.ref.deref(); }
+struct Label {
+  bool isValid() { return generator; }
+  int *generator;
+  int index;
+};
+struct ControlFlow;
+struct Codegen {
+  [[gnu::noipa]] bool visit();
+  ControlFlow *controlFlow;
+};
+struct ControlFlow {
+  enum UnwindType { EE };
+  struct UnwindTarget {
+    Label linkLabel;
+  };
+  ControlFlow *parent;
+  UnwindType unwindTarget_type;
+  UnwindTarget unwindTarget() {
+    QString label;
+    ControlFlow *flow = this;
+    while (flow) {
+      Label l = getUnwindTarget(unwindTarget_type, label);
+      if (l.isValid())
+        return {l};
+      flow = flow->parent;
+    }
+    return UnwindTarget();
+  }
+  [[gnu::noipa]] Label getUnwindTarget(UnwindType, QString &) {
+    Label l = { &ok, 0 };
+    return l;
+  }
+};
+[[gnu::noipa]] void foo(int) {
+  ok = 1;
+}
+[[gnu::noipa]] bool Codegen::visit() {
+  if (!controlFlow)
+    return false;
+  ControlFlow::UnwindTarget target = controlFlow->unwindTarget();
+  if (target.linkLabel.isValid())
+    foo(2);
+  return false;
+}
+int
+main() {
+  ControlFlow cf = { nullptr, ControlFlow::UnwindType::EE };
+  Codegen c = { &cf };
+  c.visit();
+  if (!ok)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/pr65240-1.C b/gcc/testsuite/g++.dg/pr65240-1.C
index d2e25b65fca..ff8910df6a1 100644
--- a/gcc/testsuite/g++.dg/pr65240-1.C
+++ b/gcc/testsuite/g++.dg/pr65240-1.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=small -mno-fp-in-toc -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=small -mno-fp-in-toc -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr65240-2.C b/gcc/testsuite/g++.dg/pr65240-2.C
index 38d5020bd19..bdb7a62d73d 100644
--- a/gcc/testsuite/g++.dg/pr65240-2.C
+++ b/gcc/testsuite/g++.dg/pr65240-2.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=small -mfp-in-toc -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=small -mfp-in-toc -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr65240-3.C b/gcc/testsuite/g++.dg/pr65240-3.C
index e8463c91494..f37db9025d1 100644
--- a/gcc/testsuite/g++.dg/pr65240-3.C
+++ b/gcc/testsuite/g++.dg/pr65240-3.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3 -ffast-math -mcmodel=medium -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3 -ffast-math -mcmodel=medium -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr65240-4.C b/gcc/testsuite/g++.dg/pr65240-4.C
index a119752d18e..efb6a6c06e7 100644
--- a/gcc/testsuite/g++.dg/pr65240-4.C
+++ b/gcc/testsuite/g++.dg/pr65240-4.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power7 -O3 -ffast-math -Wno-return-type" } */
+/* { dg-options "-mdejagnu-cpu=power7 -O3 -ffast-math -Wno-return-type" } */
 
 /* target/65240, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr65242.C b/gcc/testsuite/g++.dg/pr65242.C
index be2ddaa85b2..662f375015f 100644
--- a/gcc/testsuite/g++.dg/pr65242.C
+++ b/gcc/testsuite/g++.dg/pr65242.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8 -O3" } */
+/* { dg-options "-mdejagnu-cpu=power8 -O3" } */
 
 class A {
 public:
diff --git a/gcc/testsuite/g++.dg/pr67211.C b/gcc/testsuite/g++.dg/pr67211.C
index cb3d342c122..ac241818ab5 100644
--- a/gcc/testsuite/g++.dg/pr67211.C
+++ b/gcc/testsuite/g++.dg/pr67211.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power7 -mtune=power8 -O3 -w" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3 -w" } */
 
 /* target/67211, compiler got a 'insn does not satisfy its constraints' error.  */
 
diff --git a/gcc/testsuite/g++.dg/pr69667.C b/gcc/testsuite/g++.dg/pr69667.C
index 76f7cb3d40b..422116dd599 100644
--- a/gcc/testsuite/g++.dg/pr69667.C
+++ b/gcc/testsuite/g++.dg/pr69667.C
@@ -1,8 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
-/* { dg-options "-mcpu=power8 -w -std=c++14" } */
+/* { dg-options "-mdejagnu-cpu=power8 -w -std=c++14" } */
 
 /* target/69667, compiler got
    internal compiler error: Max. number of generated reload insns per insn is achieved (90)  */
diff --git a/gcc/testsuite/g++.dg/pr71294.C b/gcc/testsuite/g++.dg/pr71294.C
index 67675dd7e30..716fa0d44b2 100644
--- a/gcc/testsuite/g++.dg/pr71294.C
+++ b/gcc/testsuite/g++.dg/pr71294.C
@@ -1,7 +1,6 @@
 // { dg-do compile { target { powerpc64*-*-* && lp64 } } }
 // { dg-require-effective-target powerpc_p8vector_ok } */
-// { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } }
-// { dg-options "-mcpu=power8 -O3 -fstack-protector" }
+// { dg-options "-mdejagnu-cpu=power8 -O3 -fstack-protector" }
 
 // PAR target/71294 failed because RELOAD could not figure how create a V2DI
 // vector that auto vectorization created with each element being the same
diff --git a/gcc/testsuite/g++.dg/pr84279.C b/gcc/testsuite/g++.dg/pr84279.C
index b2b5b8eabab..e78201c30db 100644
--- a/gcc/testsuite/g++.dg/pr84279.C
+++ b/gcc/testsuite/g++.dg/pr84279.C
@@ -2,8 +2,7 @@
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-require-effective-target fpic } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-O3 -mcpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
+/* { dg-options "-O3 -mdejagnu-cpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
 
 template <typename, typename T> struct E { T e; };
 struct J {
diff --git a/gcc/testsuite/g++.dg/template/conv19.C b/gcc/testsuite/g++.dg/template/conv19.C
new file mode 100644
index 00000000000..7a3da939c1f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/conv19.C
@@ -0,0 +1,34 @@
+// PR c++/101698
+// { dg-do compile { target c++11 } }
+
+class Base {
+ public:
+  template <class T>
+  operator const T&() const = delete;
+
+  virtual operator const int&() const {
+    static int res;
+    return res;
+  }
+};
+
+template <class T>
+class Derive : public Base {
+ public:
+  operator const T&() const override {
+    using Y = int;
+    //static_assert(__is_same_as(T,Y), "");
+
+    static int res;
+
+    res = Base::operator const Y&(); // OK
+    res = Base::operator const T&(); // { dg-bogus "deleted" }
+    return res;
+  }
+};
+
+int main() {
+  Derive<int> a;
+  const int& b = a;
+  (void)b;
+}
diff --git a/gcc/testsuite/g++.dg/template/friend74.C b/gcc/testsuite/g++.dg/template/friend74.C
new file mode 100644
index 00000000000..51708334d81
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/friend74.C
@@ -0,0 +1,8 @@
+// PR c++/105852
+// { dg-additional-options -w }
+
+template <class> struct Local { friend Local False(int *); };
+Local<int> loc;
+Local<int> False(int *);
+void New() { False; }
+Local<int> False(int *) { return Local<int>(); }
diff --git a/gcc/testsuite/g++.dg/template/friend78.C b/gcc/testsuite/g++.dg/template/friend78.C
new file mode 100644
index 00000000000..6100528468e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/friend78.C
@@ -0,0 +1,18 @@
+// PR c++/106740
+// { dg-additional-options -Wno-non-template-friend }
+
+template <typename> struct EnumClass { friend int toString(EnumClass); };
+struct AmhsConvInfoCoFw {
+  enum AftnTypeXMsgTypeEnum {};
+  typedef EnumClass<AftnTypeXMsgTypeEnum> AftnTypeXMsgType;
+  const int getAftnTypeXMsgTypeAsStr() const;
+  struct MtcuAxgwInfo {
+    AftnTypeXMsgType mAftnTypeXMsgType;
+  };
+};
+const int AmhsConvInfoCoFw::getAftnTypeXMsgTypeAsStr() const {
+  MtcuAxgwInfo __trans_tmp_1;
+  toString(__trans_tmp_1.mAftnTypeXMsgType);
+  return 0;
+}
+int toString(AmhsConvInfoCoFw::AftnTypeXMsgType);
diff --git a/gcc/testsuite/g++.dg/template/nested7.C b/gcc/testsuite/g++.dg/template/nested7.C
new file mode 100644
index 00000000000..3a5930c0f31
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/nested7.C
@@ -0,0 +1,12 @@
+// PR c++/102300
+
+template<typename T>
+struct holder
+{
+  template<typename F> struct fn {};
+
+  struct t1 : fn<T> {};                      // pass
+  struct t2 : holder<T >::fn<T> {};          // fail
+  struct t3 : holder<T >::template fn<T> {}; // fail
+  struct t4 : holder<T*>::template fn<T> {}; // pass
+};
diff --git a/gcc/testsuite/g++.dg/template/partial-specialization11.C b/gcc/testsuite/g++.dg/template/partial-specialization11.C
new file mode 100644
index 00000000000..556224a3104
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/partial-specialization11.C
@@ -0,0 +1,11 @@
+// PR c++/86193
+// CWG 455 (active)
+// { dg-options "" } // clear -pedantic-errors
+
+template<class T> struct value_type;
+
+template<class T, typename value_type<T>::type V>
+struct A;
+
+template<class T, int V>
+struct A<T*, V> { }; // { dg-warning "not more specialized" }
diff --git a/gcc/testsuite/g++.dg/template/partial-specialization12.C b/gcc/testsuite/g++.dg/template/partial-specialization12.C
new file mode 100644
index 00000000000..5f51e8a27de
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/partial-specialization12.C
@@ -0,0 +1,12 @@
+// PR c++/105289
+// CWG 455 (active)
+// { dg-do compile { target c++11 } }
+
+template<class T>
+struct value_type;
+
+template<class List, typename value_type<List>::type Element>
+struct push_front_vlist;
+
+template<template<class X, X...> class XList, class T, T Arg, T... Vs>
+struct push_front_vlist<XList<T, Vs...>, Arg> { }; // { dg-error "not more specialized" }
diff --git a/gcc/testsuite/g++.dg/template/template-keyword4.C b/gcc/testsuite/g++.dg/template/template-keyword4.C
new file mode 100644
index 00000000000..a7ab9bb8ca6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/template-keyword4.C
@@ -0,0 +1,18 @@
+// PR c++/106310
+
+template <class T>
+struct set{};
+
+template< typename T >
+struct Base
+{
+  template< int > int set(T const &);
+};
+
+template< typename T >
+struct Derived : Base< T >
+{
+  void f(T const &arg) {
+    this->template set< 0 >(arg);
+  }
+};
diff --git a/gcc/testsuite/g++.dg/tls/thread_local13-aux.cc b/gcc/testsuite/g++.dg/tls/thread_local13-aux.cc
new file mode 100644
index 00000000000..691f308cff1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tls/thread_local13-aux.cc
@@ -0,0 +1,35 @@
+// PR c++/109164
+
+struct S { virtual void foo (); int s; };
+extern bool baz ();
+
+void
+S::foo ()
+{
+  if (s != 42)
+    __builtin_abort ();
+}
+
+S s;
+
+S &
+qux ()
+{
+  s.s = 42;
+  return s;
+}
+
+thread_local S &t = qux ();
+
+bool
+bar ()
+{
+  return false;
+}
+
+int
+main ()
+{
+  if (baz ())
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/tls/thread_local13.C b/gcc/testsuite/g++.dg/tls/thread_local13.C
new file mode 100644
index 00000000000..b424b9f8acf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tls/thread_local13.C
@@ -0,0 +1,21 @@
+// PR c++/109164
+// { dg-do run { target c++11 } }
+// { dg-options "-O2" }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+// { dg-additional-sources "thread_local13-aux.cc" }
+
+struct S { virtual void foo (); int s; };
+extern thread_local S &t;
+bool bar ();
+
+bool
+baz ()
+{
+  while (1)
+    {
+      t.foo ();
+      if (!bar ())
+        return false;
+    }
+}
diff --git a/gcc/testsuite/g++.dg/tls/thread_local14-aux.cc b/gcc/testsuite/g++.dg/tls/thread_local14-aux.cc
new file mode 100644
index 00000000000..e8f2a243fc1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tls/thread_local14-aux.cc
@@ -0,0 +1,26 @@
+// PR c++/109164
+
+extern bool baz ();
+
+int
+qux ()
+{
+  return 42;
+}
+
+extern thread_local const int t = qux ();
+
+bool
+bar (int x)
+{
+  if (x != 42)
+    __builtin_abort ();
+  return false;
+}
+
+int
+main ()
+{
+  if (baz ())
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/g++.dg/tls/thread_local14.C b/gcc/testsuite/g++.dg/tls/thread_local14.C
new file mode 100644
index 00000000000..a7402d0d631
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tls/thread_local14.C
@@ -0,0 +1,19 @@
+// PR c++/109164
+// { dg-do run { target c++11 } }
+// { dg-options "-O2" }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+// { dg-additional-sources "thread_local14-aux.cc" }
+
+extern thread_local const int t;
+bool bar (int);
+
+bool
+baz ()
+{
+  while (1)
+    {
+      if (!bar (t))
+        return false;
+    }
+}
diff --git a/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C b/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C
index 75862e2b5be..fef69e7cf09 100644
--- a/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C
+++ b/gcc/testsuite/g++.dg/torture/ppc-ldst-array.C
@@ -1,6 +1,5 @@
 /* { dg-do compile { target { powerpc64*-*-* } } } */
-/* { dg-skip-if "do not override mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
-/* { dg-options "-mcpu=power8" } */
+/* { dg-options "-mdejagnu-cpu=power8" } */
 
 /* When compiled with C++, this code was breaking because of different
    tree representations of arrays between C and C++.  */
diff --git a/gcc/testsuite/g++.dg/torture/pr104450.C b/gcc/testsuite/g++.dg/torture/pr104450.C
new file mode 100644
index 00000000000..402a4849e54
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr104450.C
@@ -0,0 +1,16 @@
+// { dg-do compile }
+// { dg-additional-options "-fnon-call-exceptions" }
+// { dg-additional-options "-mavx512f" { target x86_64-*-* i?86-*-* } }
+
+#define vectsize 64
+typedef int __attribute__((__vector_size__ (vectsize))) V;
+typedef float __attribute__((__vector_size__ (vectsize))) F;
+F f;
+V v;
+struct g{~g();};
+void
+foo (void)
+{
+  g t;
+  v += (V) (0 <= f);
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr106131.C b/gcc/testsuite/g++.dg/torture/pr106131.C
new file mode 100644
index 00000000000..e110f4a8fe6
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr106131.C
@@ -0,0 +1,34 @@
+// { dg-do run { target c++11 } }
+
+struct Pair {
+    int a, b;
+    Pair(const Pair &) = default;
+    Pair(int _a, int _b) : a(_a), b(_b) {}
+    Pair &operator=(const Pair &z) {
+	a = z.a;
+	b = z.b;
+	return *this;
+    }
+};
+
+const int &max(const int &a, const int &b)
+{
+  return a < b ? b : a;
+}
+
+int foo(Pair x, Pair y)
+{
+  return max(x.b, y.b);
+}
+
+int main()
+{
+  auto f = new Pair[3] {{0, -11}, {0, -8}, {0, 2}};
+  for (int i = 0; i < 1; i++) {
+      f[i] = f[0];
+      if(i == 0)
+	f[i] = f[2];
+      if (foo(f[i], f[1]) != 2)
+	__builtin_abort();
+  }
+}
diff --git a/gcc/testsuite/g++.dg/torture/pr109724.C b/gcc/testsuite/g++.dg/torture/pr109724.C
new file mode 100644
index 00000000000..4a88e1519d0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr109724.C
@@ -0,0 +1,32 @@
+// { dg-do compile }
+
+double &SkTMax(double &a, double &b) { return a ?: b; }
+struct SkDPoint {
+  double fX;
+};
+struct SkDCubic {
+  SkDPoint &operator[](int n) { return fPts[n]; }
+  SkDPoint fPts[4];
+};
+struct SkDCurve {
+  SkDCubic fCubic;
+  SkDPoint &operator[](int n) { return fCubic[n]; }
+};
+struct SkDCurveSweep {
+  SkDCurve fCurve;
+};
+int endsIntersect_rPts;
+double endsIntersect_maxX;
+struct SkOpAngle {
+  void endsIntersect();
+  SkDCurveSweep fPart;
+} endsIntersect_rh;
+void SkOpAngle::endsIntersect() {
+  for (int index = 0;; ++index) {
+    SkDCurve &curve = index ? endsIntersect_rh.fPart.fCurve : fPart.fCurve;
+    for (int idx2 = 0; endsIntersect_rPts; ++idx2) {
+      SkDPoint &__trans_tmp_1 = curve[idx2];
+      endsIntersect_maxX = SkTMax(endsIntersect_maxX, __trans_tmp_1.fX);
+    }
+  }
+}
diff --git a/gcc/testsuite/g++.dg/ubsan/pr105729.C b/gcc/testsuite/g++.dg/ubsan/pr105729.C
new file mode 100644
index 00000000000..fb676630994
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ubsan/pr105729.C
@@ -0,0 +1,29 @@
+// PR sanitizer/105729
+// { dg-do run }
+// { dg-options "-fsanitize=null -fno-sanitize-recover=null" }
+
+int
+foo (int x)
+{
+  throw 0;
+}
+
+struct S {};
+struct T {
+  S *data;
+  T () : data (0) {}
+  const S &bar (int x) const { return data[foo (x)]; }
+};
+
+int
+main ()
+{
+  T t;
+  try
+    {
+      t.bar (-1);
+    }
+  catch (...)
+    {
+    }
+}
diff --git a/gcc/testsuite/g++.dg/vect/pr105437.cc b/gcc/testsuite/g++.dg/vect/pr105437.cc
new file mode 100644
index 00000000000..b3b440debef
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr105437.cc
@@ -0,0 +1,24 @@
+// { dg-do compile }
+
+struct ControlClass
+{
+    virtual ~ControlClass();
+
+    int Width;
+    int Height;
+    unsigned IsToRepaint : 1;
+};
+
+struct SelectClass : ControlClass
+{
+    SelectClass(void);
+};
+
+int Non_Folded_Value();
+
+SelectClass::SelectClass(void)
+{
+    int factor = Non_Folded_Value();
+    Width = 32 << factor;
+    Height = 24 << factor;
+}
diff --git a/gcc/testsuite/g++.dg/vect/pr109573.cc b/gcc/testsuite/g++.dg/vect/pr109573.cc
new file mode 100644
index 00000000000..d96f86f9579
--- /dev/null
+++ b/gcc/testsuite/g++.dg/vect/pr109573.cc
@@ -0,0 +1,91 @@
+// { dg-do compile }
+// { dg-require-effective-target c++20 }
+
+void *operator new(__SIZE_TYPE__, void *__p) { return __p; }
+template <typename _Head> struct _Head_base {
+  _Head _M_head_impl;
+};
+template <unsigned long, typename...> struct _Tuple_impl;
+template <unsigned long _Idx, typename _Head, typename... _Tail>
+struct _Tuple_impl<_Idx, _Head, _Tail...> : _Tuple_impl<_Idx + 1, _Tail...>,
+                                            _Head_base<_Head> {
+  template <typename _UHead, typename... _UTail>
+  _Tuple_impl(_UHead __head, _UTail... __tail)
+      : _Tuple_impl<_Idx + 1, _Tail...>(__tail...), _Head_base<_Head>(__head) {}
+};
+template <unsigned long _Idx, typename _Head> struct _Tuple_impl<_Idx, _Head> {
+  template <typename _UHead> _Tuple_impl(_UHead);
+};
+template <typename... _Elements> struct tuple : _Tuple_impl<0, _Elements...> {
+  template <typename... _UElements>
+  tuple(_UElements... __elements)
+      : _Tuple_impl<0, _Elements...>(__elements...) {}
+};
+unsigned long position_;
+struct Zone {
+  template <typename T, typename... Args> T *New(Args... args) {
+    return new (reinterpret_cast<void *>(position_)) T(args...);
+  }
+};
+struct Label {
+  int pos_;
+  int near_link_pos_;
+};
+enum Condition { below_equal };
+void bind(Label *);
+Zone *zone();
+unsigned long deopt_info_address();
+int MakeDeferredCode___trans_tmp_2, MakeDeferredCode___trans_tmp_3,
+    Prologue___trans_tmp_6, MakeDeferredCode___trans_tmp_1;
+struct MaglevAssembler {
+  template <typename Function, typename... Args>
+  void MakeDeferredCode(Function &&, Args &&...);
+  template <typename Function, typename... Args>
+  void JumpToDeferredIf(Condition, Function, Args... args) {
+    MakeDeferredCode(Function(), args...);
+  }
+  void Prologue();
+};
+struct ZoneLabelRef {
+  ZoneLabelRef(Zone *zone) : label_(zone->New<Label>()) {}
+  ZoneLabelRef(MaglevAssembler *) : ZoneLabelRef(zone()) {}
+  Label *operator*() { return label_; }
+  Label *label_;
+};
+template <typename Function>
+struct FunctionArgumentsTupleHelper
+    : FunctionArgumentsTupleHelper<decltype(&Function::operator())> {};
+template <typename C, typename R, typename... A>
+struct FunctionArgumentsTupleHelper<R (C::*)(A...) const> {
+  using Tuple = tuple<A...>;
+};
+template <typename> struct StripFirstTupleArg;
+template <typename T1, typename... T>
+struct StripFirstTupleArg<tuple<T1, T...>> {
+  using Stripped = tuple<T...>;
+};
+template <typename Function> struct DeferredCodeInfoImpl {
+  template <typename... InArgs>
+  DeferredCodeInfoImpl(int *, int, int, Function, InArgs... args)
+      : args(args...) {}
+  StripFirstTupleArg<
+      typename FunctionArgumentsTupleHelper<Function>::Tuple>::Stripped args;
+};
+template <typename Function, typename... Args>
+void MaglevAssembler::MakeDeferredCode(Function &&deferred_code_gen,
+                                       Args &&...args) {
+  zone()->New<DeferredCodeInfoImpl<Function>>(
+      &MakeDeferredCode___trans_tmp_1, MakeDeferredCode___trans_tmp_2,
+      MakeDeferredCode___trans_tmp_3, deferred_code_gen, args...);
+}
+void MaglevAssembler::Prologue() {
+  int *__trans_tmp_9;
+  ZoneLabelRef deferred_call_stack_guard_return(this);
+  __trans_tmp_9 = reinterpret_cast<int *>(deopt_info_address());
+  JumpToDeferredIf(
+      below_equal, [](MaglevAssembler, int *, ZoneLabelRef, int, int) {},
+      __trans_tmp_9, deferred_call_stack_guard_return, Prologue___trans_tmp_6,
+      0);
+  Label __trans_tmp_7 = **deferred_call_stack_guard_return;
+  bind(&__trans_tmp_7);
+}
diff --git a/gcc/testsuite/g++.dg/warn/Warray-bounds-27.C b/gcc/testsuite/g++.dg/warn/Warray-bounds-27.C
new file mode 100644
index 00000000000..06ce089c4b0
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Warray-bounds-27.C
@@ -0,0 +1,16 @@
+// PR105726
+// { dg-do compile }
+// { dg-require-effective-target c++11 }
+// { dg-options "-O2 -Warray-bounds" }
+
+#include <array>
+#include <cstring>
+
+struct X {
+    char pad[4];
+    std::array<char, 1> mField;
+};
+
+void encode(char* aBuffer, const X& aMessage) {
+    strncpy(aBuffer, aMessage.mField.data(), 1); // { dg-bogus "bounds" }
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wignored-qualifiers2.C b/gcc/testsuite/g++.dg/warn/Wignored-qualifiers2.C
new file mode 100644
index 00000000000..c4c37545c02
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wignored-qualifiers2.C
@@ -0,0 +1,17 @@
+// PR c++/92752
+// { dg-do compile }
+// { dg-additional-options "-Wignored-qualifiers" }
+
+struct X;
+
+template<class T>
+struct Wrap {
+  T data;
+  Wrap() : data() {}
+};
+
+typedef int (X::*type)();
+Wrap<const type> x;
+#if __cpp_initializer_lists
+const type t{};
+#endif
diff --git a/gcc/testsuite/g++.dg/warn/Wmismatched-tags-10.C b/gcc/testsuite/g++.dg/warn/Wmismatched-tags-10.C
new file mode 100644
index 00000000000..d7e10743bb4
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wmismatched-tags-10.C
@@ -0,0 +1,10 @@
+// PR c++/105725
+// { dg-do compile { target c++14 } }
+// { dg-options "-Wall -Wmismatched-tags" }
+
+template <bool> struct enable_if;
+template <bool Cond> using enable_if_t = typename enable_if<Cond>::type;
+template <typename> bool is_class_v;
+template <class, class> bool B;
+template <class T>
+bool B<T, enable_if_t<is_class_v<class T::foo>>>;
diff --git a/gcc/testsuite/g++.dg/warn/Wsequence-point-5.C b/gcc/testsuite/g++.dg/warn/Wsequence-point-5.C
new file mode 100644
index 00000000000..0354ab09f53
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wsequence-point-5.C
@@ -0,0 +1,37 @@
+// PR c++/107163
+// { dg-additional-options "-Wsequence-point" }
+
+struct BaseType  {
+  int i;
+};
+
+template< int Seq >
+class DerivedType : public DerivedType< Seq - 1 > { };
+
+template<>
+class DerivedType< -1 > : public BaseType { };
+
+int main() {
+  DerivedType< 400 > d;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  d.i = 42;
+  return d.i;
+}
diff --git a/gcc/testsuite/g++.dg/warn/pr108365.C b/gcc/testsuite/g++.dg/warn/pr108365.C
new file mode 100644
index 00000000000..6d40957c9b3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/pr108365.C
@@ -0,0 +1,5 @@
+// PR c++/108365
+// { dg-do compile { target { { { ilp32 || lp64 } || llp64 } && c++11 } } }
+
+constexpr char b = 1;
+long t = (short) ((long long) (unsigned long long) (-__INT_MAX__ - 1) / (long long) (b ? -1 : 0)); // { dg-bogus "integer overflow in expression of type" }
diff --git a/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align16-O2-extra.C b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align16-O2-extra.C
new file mode 100644
index 00000000000..fb3194bd231
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align16-O2-extra.C
@@ -0,0 +1,86 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps -Wno-narrowing" } */
+
+#define ALIGN 16
+//#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+/* In f1, f2, f4, f8, f16, f16p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 12 { xfail *-*-* } } } */
+/* In fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 10 { xfail *-*-* } } } */
+
+/* Bitfield parameter in registers.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} "" { target *-*-* } 47 } f1 */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} "" { target *-*-* } 48 } f2 */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} "" { target *-*-* } 49 } f4 */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} "" { target *-*-* } 50 } f8 */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 53 }  fp */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 54 } f1p */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 55 } f2p */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 56 } f4p */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 57 } f8p */
+
+/* Bitfield call argument in registers.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} ""  { target *-*-* } 60 } g1 */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} ""  { target *-*-* } 61 } g2 */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} ""  { target *-*-* } 62 } g4 */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} ""  { target *-*-* } 63 } g8 */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 66 }  gp */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 67 } g1p */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 68 } g2p */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 69 } g4p */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 70 } g8p */
+
+
+/* Bitfield parameter in stack.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} "" { target *-*-* } 74 } f1_stack */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} "" { target *-*-* } 75 } f2_stack */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} "" { target *-*-* } 76 } f4_stack */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} "" { target *-*-* } 77 } f8_stack */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 80 }  fp_stack */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 81 } f1p_stack */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 82 } f2p_stack */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 83 } f4p_stack */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 84 } f8p_stack */
+
+/* Bitfield call argument in stack.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} ""  { target *-*-* } 87 } g1_stack */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} ""  { target *-*-* } 88 } g2_stack */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} ""  { target *-*-* } 89 } g4_stack */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} ""  { target *-*-* } 90 } g8_stack */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 93 }  gp_stack */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 94 } g1p_stack */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 95 } g2p_stack */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 96 } g4p_stack */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 97 } g8p_stack */
+
+
+/* Bitfield parameter in stdarg.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} "" { target *-*-* } 101 } f1_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} "" { target *-*-* } 102 } f2_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} "" { target *-*-* } 103 } f4_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} "" { target *-*-* } 104 } f8_stdarg */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 107 }  fp_stdarg */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 108 } f1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 109 } f2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 110 } f4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 111 } f8p_stdarg */
+
+/* Bitfield call argument in stdarg.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} ""  { target *-*-* } 114 } g1_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} ""  { target *-*-* } 115 } g2_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} ""  { target *-*-* } 116 } g4_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} ""  { target *-*-* } 117 } g8_stdarg */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 120 }  gp_stdarg */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 121 } g1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 122 } g2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 123 } g4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 124 } g8p_stdarg */
diff --git a/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align16-O2.C b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align16-O2.C
new file mode 100644
index 00000000000..edb02141dd5
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align16-O2.C
@@ -0,0 +1,87 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps -Wno-narrowing" } */
+
+#define ALIGN 16
+#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+/* In f1, f2, f4, f8, f16, f16p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 12 { xfail *-*-* } } } */
+/* In fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 10 { xfail *-*-* } } } */
+
+/* Bitfield parameter in registers.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} "" { target *-*-* } 47 } f1 */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} "" { target *-*-* } 48 } f2 */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} "" { target *-*-* } 49 } f4 */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} "" { target *-*-* } 50 } f8 */
+
+/* No change in parameter passing in GCC 9.1 for lines 53-57 (fp, f1p, f2p,
+   f4p, f8p) (because the argument fits in a single register).  Should not
+   warn, but aarch64_function_arg_boundary would need to take the argument size
+   into account as well as whether it's passed via registers or the stack.  */
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 53 }  fp */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 54 } f1p */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 55 } f2p */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 56 } f4p */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 57 } f8p */
+
+/* Bitfield call argument in registers.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} ""  { target *-*-* } 60 } g1 */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} ""  { target *-*-* } 61 } g2 */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} ""  { target *-*-* } 62 } g4 */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} ""  { target *-*-* } 63 } g8 */
+
+/* No change in parameter passing in GCC 9.1 for lines 66-70 (gp, g1p, g2p,
+   g4p, g8p), no warning expected.  */
+
+
+/* Bitfield parameter in stack.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} "" { target *-*-* } 74 } f1_stack */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} "" { target *-*-* } 75 } f2_stack */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} "" { target *-*-* } 76 } f4_stack */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} "" { target *-*-* } 77 } f8_stack */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 80 }  fp_stack */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 81 } f1p_stack */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 82 } f2p_stack */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 83 } f4p_stack */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 84 } f8p_stack */
+
+/* Bitfield call argument in stack.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} ""  { target *-*-* } 87 } g1_stack */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} ""  { target *-*-* } 88 } g2_stack */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} ""  { target *-*-* } 89 } g4_stack */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} ""  { target *-*-* } 90 } g8_stack */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 93 }  gp_stack */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 94 } g1p_stack */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 95 } g2p_stack */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 96 } g4p_stack */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 97 } g8p_stack */
+
+
+/* Bitfield parameter in stdarg.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} "" { target *-*-* } 101 } f1_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} "" { target *-*-* } 102 } f2_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} "" { target *-*-* } 103 } f4_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} "" { target *-*-* } 104 } f8_stdarg */
+
+/* Parameter passing for these should not have changed in GCC 9.1 (PR 105549).
+   Fortunately we warn. Note the discrepancy with lines 120-124 below: we warn
+   in the callee, but not in the caller.  */
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1} "" { target *-*-* } 107 }  fp_stdarg */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 108 } f1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 109 } f2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 110 } f4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 111 } f8p_stdarg */
+
+/* Bitfield call argument in stdarg.  */
+/* { dg-message {parameter passing for argument of type 'S1' changed in GCC 9.1} ""  { target *-*-* } 114 } g1_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2' changed in GCC 9.1} ""  { target *-*-* } 115 } g2_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4' changed in GCC 9.1} ""  { target *-*-* } 116 } g4_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8' changed in GCC 9.1} ""  { target *-*-* } 117 } g8_stdarg */
+
+/* No change in parameter passing in GCC 9.1 for lines 120-124 (gp_stdarg
+   g1p_stdarg, g2p_stdarg, g4p_stdarg, g8p_stdarg), no warning expected.  */
diff --git a/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align32-O2-extra.C b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align32-O2-extra.C
new file mode 100644
index 00000000000..a2ee5972cd7
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align32-O2-extra.C
@@ -0,0 +1,119 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps -Wno-narrowing" } */
+
+#define ALIGN 32
+//#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+
+/* In f1, f2, f4, f8, f16 (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "ldr\tx0, \\\[x1\\\]" 10 } } */
+
+/* In fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 10 { xfail *-*-* } } } */
+
+/* In f16p (and stdarg version):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 2 { xfail *-*-* } } } */
+
+/* In f1_stack, f2_stack, f4_stack, f8_stack, f16_stack, f8p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tx\[0-9\]+, \\\[sp, 8\\\]" 6 { xfail *-*-* } } } */
+
+/* In fp_stack, f1p_stack:  */
+/* { dg-final { scan-assembler-times "ldrb\tw0, \\\[sp, 8\\\]" 2 { xfail *-*-* } } } */
+
+/* In f2p_stack:  */
+/* { dg-final { scan-assembler-times "ldrh\tw0, \\\[sp, 8\\\]" 1 { xfail *-*-* } } } */
+
+/* In f4p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tw0, \\\[sp, 8\\\]" 1 { xfail *-*-* } } } */
+
+/* In f16p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tx0, \\\[sp, 16\\\]" 1 { xfail *-*-* } } } */
+
+/* Bitfield parameter in registers.  */
+/* No change in parameter passing in GCC 9.1 for lines 47-51 (f1, f2, f4, f8, f16)
+   because the overall alignment is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 53-57 (fp, f1p, f2p,
+   f4p, f8p) because the argument fits in a single register.  Should not warn,
+   but aarch64_function_arg_boundary would need to take the argument size into
+   account as well as whether it's passed via registers or the stack.  */
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1}  "" { target *-*-* } 53 } fp */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 54 } f1p */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 55 } f2p */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 56 } f4p */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 57 } f8p */
+
+/* Changed in GCC 9.1, but we fail to emit a warning since GCC 11 (was OK with GCC 9).  */
+/* { dg-message {parameter passing for argument of type 'S16p' changed in GCC 9.1} "" { xfail *-*-* } 58 } f16p */
+
+
+/* Bitfield call argument in registers.  */
+/* No change in parameter passing in GCC 9.1 for lines 60-64 (g1, g2, g4, g8, g16)
+   because the overall alignment is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 66-70 (gp, g1p, g2p,
+   g4p, g8p), no warning expected.  */
+
+/* Changed in GCC 9.1, but we fail to emit a warning.  */
+/* { dg-message {parameter passing for argument of type 'S16p' changed in GCC 9.1} "" { xfail *-*-* } 71 } g16p */
+
+
+/* Bitfield parameter in stack.  */
+/* No change in parameter passing in GCC 9.1 for lines 74-78 (f1_stack,
+   f2_stack, f4_stack, f8_stack, f16_stack) because the overall alignment is >
+   16.  No warning expected.  */
+
+/* Changed in GCC 9.1.  */
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1}  "" { target *-*-* } 80 } fp_stack */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 81 } f1p_stack */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 82 } f2p_stack */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 83 } f4p_stack */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 84 } f8p_stack */
+
+/* No change in parameter passing in GCC 9.1 for line 85 (f16p_stack) because
+   the overall alignment is >= 16.  No warning expected.  */
+
+
+/* Bitfield call argument in stack.  */
+/* No change in parameter passing in GCC 9.1 for lines 87-91 (g1_stack,
+   g2_stack, g4_stack, g8_stack, g16_stack) because the overall alignment is >
+   16.  No warning expected.  */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1}  "" { target *-*-* } 93 } gp_stack */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 94 } g1p_stack */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 95 } g2p_stack */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 96 } g4p_stack */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 97 } g8p_stack */
+
+
+/* No change in parameter passing in GCC 9.1 for line 98 (g16p_stack).  No
+   warning expected.  */
+
+
+/* Bitfield parameter in stdarg.  */
+/* No change in parameter passing in GCC 9.1 for lines 101-105 (f1_stdarg,
+   f2_stdarg, f4_stdarg, f8_stdarg, f16_stdarg) because the overall alignment
+   is > 16.  No warning expected.  */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1}   "" { target *-*-* } 107 } fp_stdarg */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1}  "" { target *-*-* } 108 } f1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1}  "" { target *-*-* } 109 } f2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1}  "" { target *-*-* } 110 } f4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1}  "" { target *-*-* } 111 } f8p_stdarg */
+
+/* No change in parameter passing in GCC 9.1 for line 112 (f16p_stdarg).
+   Should not warn.  */
+/* { dg-message {parameter passing for argument of type 'S16p' changed in GCC 9.1} "" { target *-*-* } 112 } f16p_stdarg */
+
+/* Bitfield call argument in stdarg.  */
+/* No change in parameter passing in GCC 9.1 for lines 114-118 (g1_stdarg,
+   g2_stdarg, g4_stdarg, g8_stdarg, g16_stdarg) because the overall alignment
+   is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 120-124 (gp_stdarg,
+   g1p_stdarg, g2p_stdarg, g4p_stdarg, g8p_stdarg), no warning expected.  */
+
+/* Changed in GCC 9.1, but we fail to emit a warning.  */
+/* { dg-message {parameter passing for argument of type 'S16p' changed in GCC 9.1} "" { xfail *-*-* } 125 } g16p_stdarg */
diff --git a/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align32-O2.C b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align32-O2.C
new file mode 100644
index 00000000000..44d77791a63
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align32-O2.C
@@ -0,0 +1,119 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps -Wno-narrowing" } */
+
+#define ALIGN 32
+#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+/* In f1, f2, f4, f8, f16 (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "ldr\tx0, \\\[x1\\\]" 10 } } */
+
+/* In fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 10 { xfail *-*-* } } } */
+
+/* In f16p (and stdarg version):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 2 { xfail *-*-* } } } */
+
+/* In f1_stack, f2_stack, f4_stack, f8_stack, f16_stack, f8p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tx\[0-9\]+, \\\[sp, 8\\\]" 6 { xfail *-*-* } } } */
+
+/* In fp_stack, f1p_stack:  */
+/* { dg-final { scan-assembler-times "ldrb\tw0, \\\[sp, 8\\\]" 2 { xfail *-*-* } } } */
+
+/* In f2p_stack:  */
+/* { dg-final { scan-assembler-times "ldrh\tw0, \\\[sp, 8\\\]" 1 { xfail *-*-* } } } */
+
+/* In f4p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tw0, \\\[sp, 8\\\]" 1 { xfail *-*-* } } } */
+
+/* In f16p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tx0, \\\[sp, 16\\\]" 1 { xfail *-*-* } } } */
+
+/* Bitfield parameter in registers.  */
+/* No change in parameter passing in GCC 9.1 for lines 47-51 (f1, f2, f4, f8, f16)
+   because the overall alignment is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 53-57 (fp, f1p, f2p,
+   f4p, f8p) because the argument fits in a single register.  Should not warn,
+   but aarch64_function_arg_boundary would need to take the argument size into
+   account as well as whether it's passed via registers or the stack.  */
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1}  "" { target *-*-* } 53 } fp */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 54 } f1p */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 55 } f2p */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 56 } f4p */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 57 } f8p */
+
+/* Changed in GCC 9.1, but we fail to emit a warning since GCC 11 (was OK with GCC 9).  */
+/* { dg-message {parameter passing for argument of type 'S16p' changed in GCC 9.1} "" { xfail *-*-* } 58 } f16p */
+
+
+/* Bitfield call argument in registers.  */
+/* No change in parameter passing in GCC 9.1 for lines 60-64 (g1, g2, g4, g8, g16)
+   because the overall alignment is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 66-70 (gp, g1p, g2p,
+   g4p, g8p), no warning expected.  */
+
+/* Changed in GCC 9.1, but we fail to emit a warning.  */
+/* { dg-message {parameter passing for argument of type 'S16p' changed in GCC 9.1} "" { xfail *-*-* } 71 } g16p */
+
+
+/* Bitfield parameter in stack.  */
+/* No change in parameter passing in GCC 9.1 for lines 74-78 (f1_stack,
+   f2_stack, f4_stack, f8_stack, f16_stack) because the overall alignment is >
+   16.  No warning expected.  */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1}  "" { target *-*-* } 80 } fp_stack */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 81 } f1p_stack */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 82 } f2p_stack */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 83 } f4p_stack */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 84 } f8p_stack */
+
+/* No change in parameter passing in GCC 9.1 for line 85 (f16p_stack) because
+   the overall alignment is >= 16.  No warning expected.  */
+
+/* Bitfield call argument in stack.  */
+/* No change in parameter passing in GCC 9.1 for lines 87-91 (g1_stack,
+   g2_stack, g4_stack, g8_stack, g16_stack) because the overall alignment is >
+   16.  No warning expected.  */
+
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1}  "" { target *-*-* } 93 } gp_stack */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1} "" { target *-*-* } 94 } g1p_stack */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1} "" { target *-*-* } 95 } g2p_stack */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1} "" { target *-*-* } 96 } g4p_stack */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1} "" { target *-*-* } 97 } g8p_stack */
+
+
+/* No change in parameter passing in GCC 9.1 for line 98 (g16p_stack).  No
+   warning expected.  */
+
+
+/* Bitfield parameter in stdarg.  */
+/* No change in parameter passing in GCC 9.1 for lines 101-105 (f1_stdarg,
+   f2_stdarg, f4_stdarg, f8_stdarg, f16_stdarg) because the overall alignment
+   is > 16.  No warning expected.  */
+
+/* Parameter passing for these should not have changed in GCC 9.1 (PR 105549).
+   Fortunately we warn. Note the discrepancy with lines 120-124 below: we warn
+   in the callee, but not in the caller.  */
+/* { dg-message {parameter passing for argument of type 'Sp' changed in GCC 9.1}   "" { target *-*-* } 107 } fp_stdarg */
+/* { dg-message {parameter passing for argument of type 'S1p' changed in GCC 9.1}  "" { target *-*-* } 108 } f1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S2p' changed in GCC 9.1}  "" { target *-*-* } 109 } f2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S4p' changed in GCC 9.1}  "" { target *-*-* } 110 } f4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'S8p' changed in GCC 9.1}  "" { target *-*-* } 111 } f8p_stdarg */
+
+/* No change in parameter passing in GCC 9.1 for line 112 (f16p_stdarg).
+   Should not warn.  */
+/* { dg-message {parameter passing for argument of type 'S16p' changed in GCC 9.1} "" { target *-*-* } 112 } f16p_stdarg */
+
+/* Bitfield call argument in stdarg.  */
+/* No change in parameter passing in GCC 9.1 for lines 114-118 (g1_stdarg,
+   g2_stdarg, g4_stdarg, g8_stdarg, g16_stdarg) because the overall alignment
+   is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 120-124 (gp_stdarg,
+   g1p_stdarg, g2p_stdarg, g4p_stdarg, g8p_stdarg), no warning expected.  */
+
+/* Changed in GCC 9.1, but we fail to emit a warning.  */
+/* { dg-message {parameter passing for argument of type 'S16p' changed in GCC 9.1} "" { xfail *-*-* } 125 } g16p_stdarg */
diff --git a/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align8-O2.C b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align8-O2.C
new file mode 100644
index 00000000000..b1764d97ea0
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning-align8-O2.C
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps -Wno-narrowing" } */
+
+#define ALIGN 8
+#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+/* In f1, f2, f4, f8, fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 18 } } */
+
+/* In f16, f16p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 4 } } */
+
+/* In f1, f2, f4, f8, f16, fp, f1p, f2p, f4p, f8p, f16p stack versions:  */
+/* { dg-final { scan-assembler-times "and\tw0, w0, 1" 11 } } */
diff --git a/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning.h b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning.h
new file mode 100644
index 00000000000..3940b714ef8
--- /dev/null
+++ b/gcc/testsuite/g++.target/aarch64/bitfield-abi-warning.h
@@ -0,0 +1,125 @@
+#include <stdarg.h>
+
+typedef unsigned long long ull __attribute__((aligned(ALIGN)));
+
+#ifndef EXTRA
+#define EXTRA unsigned long long x;
+#endif
+
+struct S1  { __attribute__((aligned(1))) ull i : 1; EXTRA };
+struct S2  { __attribute__((aligned(2))) ull i : 1; EXTRA };
+struct S4  { __attribute__((aligned(4))) ull i : 1; EXTRA };
+struct S8  { __attribute__((aligned(8))) ull i : 1; EXTRA };
+struct S16 { __attribute__((aligned(16))) ull i : 1; EXTRA };
+
+struct Sp   { ull i : 1; EXTRA }__attribute__((packed));
+struct S1p  { __attribute__((packed, aligned(1))) ull i : 1; EXTRA };
+struct S2p  { __attribute__((packed, aligned(2))) ull i : 1; EXTRA };
+struct S4p  { __attribute__((packed, aligned(4))) ull i : 1; EXTRA };
+struct S8p  { __attribute__((packed, aligned(8))) ull i : 1; EXTRA };
+struct S16p { __attribute__((packed, aligned(16))) ull i : 1; EXTRA };
+
+/* Bitfield in registers.  */
+#define PARAMS(xx) int a0, struct S##xx s, ull a1
+/* Bitfield passed by the stack.  */
+#define PARAMS_STACK(xx) int a0, ull a1, ull a2, ull a3, ull a4, ull a5, ull a6, ull a7, ull a8, struct S##xx t
+/* Bitfield passed via stdarg.  */
+#define PARAMS_STDARG(xx) int a0, ...
+
+#define CODE(xx)				\
+  return s.i;
+
+#define CODE_STACK(xx)				\
+  return t.i;
+
+#define CODE_STDARG(xx)				\
+  va_list ap;					\
+  struct S##xx arg;				\
+  __builtin_va_start(ap,a0);			\
+  arg = __builtin_va_arg(ap, struct S##xx);	\
+  return arg.i;
+
+#define ARGS(xx) x, (struct S##xx) { x }, x
+#define ARGS_STACK(xx) x, x, x, x, x, x, x, x, x, (struct S##xx) { x }
+#define ARGS_STDARG(xx) x, (struct S##xx) { x }
+
+/* Bitfield in registers.  */
+int __attribute__ ((noipa)) f1 (PARAMS(1))  { CODE(1) }
+int __attribute__ ((noipa)) f2 (PARAMS(2))  { CODE(2) }
+int __attribute__ ((noipa)) f4 (PARAMS(4))  { CODE(4) }
+int __attribute__ ((noipa)) f8 (PARAMS(8))  { CODE(8) }
+int __attribute__ ((noipa)) f16(PARAMS(16)) { CODE(16) }
+
+int __attribute__ ((noipa)) fp  (PARAMS(p))   { CODE(p) }
+int __attribute__ ((noipa)) f1p (PARAMS(1p))  { CODE(1p) }
+int __attribute__ ((noipa)) f2p (PARAMS(2p))  { CODE(2p) }
+int __attribute__ ((noipa)) f4p (PARAMS(4p))  { CODE(4p) }
+int __attribute__ ((noipa)) f8p (PARAMS(8p))  { CODE(8p) }
+int __attribute__ ((noipa)) f16p(PARAMS(16p)) { CODE(16p) }
+
+int g1 (int x) { return f1 (ARGS(1)); }
+int g2 (int x) { return f2 (ARGS(2)); }
+int g4 (int x) { return f4 (ARGS(4)); }
+int g8 (int x) { return f8 (ARGS(8)); }
+int g16(int x) { return f16 (ARGS(16)); }
+
+int gp  (int x) { return fp   (ARGS(p)); }
+int g1p (int x) { return f1p  (ARGS(1p)); }
+int g2p (int x) { return f2p  (ARGS(2p)); }
+int g4p (int x) { return f4p  (ARGS(4p)); }
+int g8p (int x) { return f8p  (ARGS(8p)); }
+int g16p(int x) { return f16p (ARGS(16p)); }
+
+/* Bitfield in the stack.  */
+int __attribute__ ((noipa)) f1_stack (PARAMS_STACK(1))  { CODE_STACK(1) }
+int __attribute__ ((noipa)) f2_stack (PARAMS_STACK(2))  { CODE_STACK(2) }
+int __attribute__ ((noipa)) f4_stack (PARAMS_STACK(4))  { CODE_STACK(4) }
+int __attribute__ ((noipa)) f8_stack (PARAMS_STACK(8))  { CODE_STACK(8) }
+int __attribute__ ((noipa)) f16_stack(PARAMS_STACK(16)) { CODE_STACK(16) }
+
+int __attribute__ ((noipa)) fp_stack  (PARAMS_STACK(p))   { CODE_STACK(p) }
+int __attribute__ ((noipa)) f1p_stack (PARAMS_STACK(1p))  { CODE_STACK(1p) }
+int __attribute__ ((noipa)) f2p_stack (PARAMS_STACK(2p))  { CODE_STACK(2p) }
+int __attribute__ ((noipa)) f4p_stack (PARAMS_STACK(4p))  { CODE_STACK(4p) }
+int __attribute__ ((noipa)) f8p_stack (PARAMS_STACK(8p))  { CODE_STACK(8p) }
+int __attribute__ ((noipa)) f16p_stack(PARAMS_STACK(16p)) { CODE_STACK(16p) }
+
+int g1_stack (int x) { return f1_stack (ARGS_STACK(1)); }
+int g2_stack (int x) { return f2_stack (ARGS_STACK(2)); }
+int g4_stack (int x) { return f4_stack (ARGS_STACK(4)); }
+int g8_stack (int x) { return f8_stack (ARGS_STACK(8)); }
+int g16_stack(int x) { return f16_stack (ARGS_STACK(16)); }
+
+int gp_stack  (int x) { return fp_stack (ARGS_STACK(p)); }
+int g1p_stack (int x) { return f1p_stack (ARGS_STACK(1p)); }
+int g2p_stack (int x) { return f2p_stack (ARGS_STACK(2p)); }
+int g4p_stack (int x) { return f4p_stack (ARGS_STACK(4p)); }
+int g8p_stack (int x) { return f8p_stack (ARGS_STACK(8p)); }
+int g16p_stack(int x) { return f16p_stack (ARGS_STACK(16p)); }
+
+/* Bitfield  via stdarg.  */
+int __attribute__ ((noipa)) f1_stdarg (PARAMS_STDARG(1))  { CODE_STDARG(1) }
+int __attribute__ ((noipa)) f2_stdarg (PARAMS_STDARG(2))  { CODE_STDARG(2) }
+int __attribute__ ((noipa)) f4_stdarg (PARAMS_STDARG(4))  { CODE_STDARG(4) }
+int __attribute__ ((noipa)) f8_stdarg (PARAMS_STDARG(8))  { CODE_STDARG(8) }
+int __attribute__ ((noipa)) f16_stdarg(PARAMS_STDARG(16)) { CODE_STDARG(16) }
+
+int __attribute__ ((noipa)) fp_stdarg  (PARAMS_STDARG(p))   { CODE_STDARG(p) }
+int __attribute__ ((noipa)) f1p_stdarg (PARAMS_STDARG(1p))  { CODE_STDARG(1p) }
+int __attribute__ ((noipa)) f2p_stdarg (PARAMS_STDARG(2p))  { CODE_STDARG(2p) }
+int __attribute__ ((noipa)) f4p_stdarg (PARAMS_STDARG(4p))  { CODE_STDARG(4p) }
+int __attribute__ ((noipa)) f8p_stdarg (PARAMS_STDARG(8p))  { CODE_STDARG(8p) }
+int __attribute__ ((noipa)) f16p_stdarg(PARAMS_STDARG(16p)) { CODE_STDARG(16p) }
+
+int g1_stdarg (int x) { return f1_stdarg (ARGS_STDARG(1)); }
+int g2_stdarg (int x) { return f2_stdarg (ARGS_STDARG(2)); }
+int g4_stdarg (int x) { return f4_stdarg (ARGS_STDARG(4)); }
+int g8_stdarg (int x) { return f8_stdarg (ARGS_STDARG(8)); }
+int g16_stdarg(int x) { return f16_stdarg (ARGS_STDARG(16)); }
+
+int gp_stdarg  (int x) { return fp_stdarg (ARGS_STDARG(p)); }
+int g1p_stdarg (int x) { return f1p_stdarg (ARGS_STDARG(1p)); }
+int g2p_stdarg (int x) { return f2p_stdarg (ARGS_STDARG(2p)); }
+int g4p_stdarg (int x) { return f4p_stdarg (ARGS_STDARG(4p)); }
+int g8p_stdarg (int x) { return f8p_stdarg (ARGS_STDARG(8p)); }
+int g16p_stdarg(int x) { return f16p_stdarg (ARGS_STDARG(16p)); }
diff --git a/gcc/testsuite/g++.target/i386/mv31.C b/gcc/testsuite/g++.target/i386/mv31.C
new file mode 100644
index 00000000000..5d8fd1ddf75
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/mv31.C
@@ -0,0 +1,10 @@
+// PR c++/104669
+
+void bar()
+{
+  int foo(void);
+  int foo(void) __attribute__((target("sse")));
+  int foo(void) __attribute__((target("default")));
+  int (*p)(void) = &foo;
+  return;
+}
diff --git a/gcc/testsuite/g++.target/i386/pr106875.C b/gcc/testsuite/g++.target/i386/pr106875.C
new file mode 100644
index 00000000000..1b3f4c8b25c
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/pr106875.C
@@ -0,0 +1,26 @@
+// PR target/106875
+// { dg-do compile { target { c++11 && lp64 } } }
+// { dg-options "-O0 -mabi=ms -fabi-version=3 -mcall-ms2sysv-xlogues" }
+
+#pragma GCC target "avx"
+template <typename> struct A {};
+#pragma GCC push_options
+#pragma GCC target "avx,avx2,bmi,bmi2,fma,f16c"
+template <typename T> using B = A<T>;
+template <typename> struct C;
+template <> struct C<float> {
+  __attribute__((always_inline)) float operator()(long) { return .0f; }
+};
+long d;
+template <typename T> void e(B<T>) {
+  T{C<T>()(d)};
+}
+template <typename T, typename FromT> void f(T d, FromT) {
+  e(d);
+}
+int g;
+void h() {
+  A<float> i;
+  f(i, g);
+}
+#pragma GCC pop_options
diff --git a/gcc/testsuite/g++.target/i386/vec-tmpl1.C b/gcc/testsuite/g++.target/i386/vec-tmpl1.C
new file mode 100644
index 00000000000..e0865e3515b
--- /dev/null
+++ b/gcc/testsuite/g++.target/i386/vec-tmpl1.C
@@ -0,0 +1,17 @@
+// PR c++/65211
+// { dg-additional-options "-Wno-psabi" }
+// { dg-final { scan-assembler-not "movdqa" } }
+
+typedef unsigned v4ui __attribute__ ((vector_size(16), aligned (16)));
+
+template<int I>
+static v4ui t1(unsigned *dest_data)
+{
+  typedef unsigned v4ui_1 __attribute__ ((vector_size (16), aligned (4)));
+  return ((const v4ui_1*)dest_data)[0];
+}
+
+v4ui f(unsigned int *array)
+{
+    return t1<1>(array+7);
+}
diff --git a/gcc/testsuite/g++.target/powerpc/pr101322.C b/gcc/testsuite/g++.target/powerpc/pr101322.C
new file mode 100644
index 00000000000..43eaf3afcd4
--- /dev/null
+++ b/gcc/testsuite/g++.target/powerpc/pr101322.C
@@ -0,0 +1,17 @@
+/* PR target/101322 */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+/* Verify we don't ICE on the following test cases.  */
+
+void
+foo (char *resp, char *vpp)
+{
+  __builtin_vsx_disassemble_pair (resp, (__vector_pair *) vpp);
+}
+
+void
+bar (char *resp, char *vpp)
+{
+  __builtin_mma_disassemble_acc (resp, (__vector_quad *)vpp);
+}
diff --git a/gcc/testsuite/g++.target/powerpc/pr105325.C b/gcc/testsuite/g++.target/powerpc/pr105325.C
new file mode 100644
index 00000000000..18a2e520d6c
--- /dev/null
+++ b/gcc/testsuite/g++.target/powerpc/pr105325.C
@@ -0,0 +1,28 @@
+/* { dg-do assemble } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-require-effective-target powerpc_prefixed_addr } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10 -fstack-protector" } */
+
+/* PR target/105324.  Test that power10 fusion does not generate an LWA/CMPDI
+   with a large offset that the assembler rejects.  Instead it should a
+   PLWZ/CMPWI combination.
+
+   Originally, the code was dying because the fusion load + compare -1/0/1
+   patterns did not handle the possibility that the load might be prefixed.
+   The -fstack-protector option is needed to show the bug.  */
+
+struct Ath__array1D {
+  int _current;
+  int getCnt() { return _current; }
+};
+struct extMeasure {
+  int _mapTable[10000];
+  Ath__array1D _metRCTable;
+};
+void measureRC() {
+  extMeasure m;
+  for (; m._metRCTable.getCnt();)
+    for (;;)
+      ;
+}
diff --git a/gcc/testsuite/g++.target/powerpc/pr110741.C b/gcc/testsuite/g++.target/powerpc/pr110741.C
new file mode 100644
index 00000000000..0214936b06d
--- /dev/null
+++ b/gcc/testsuite/g++.target/powerpc/pr110741.C
@@ -0,0 +1,552 @@
+/* { dg-do run { target { power10_hw } } } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+#include <altivec.h>
+
+typedef unsigned char uint8_t;
+
+template <uint8_t kTernLogOp>
+static inline vector unsigned long long
+VSXTernaryLogic (vector unsigned long long a, vector unsigned long long b,
+		 vector unsigned long long c)
+{
+  return vec_ternarylogic (a, b, c, kTernLogOp);
+}
+
+static vector unsigned long long
+VSXTernaryLogic (vector unsigned long long a, vector unsigned long long b,
+		 vector unsigned long long c, int ternary_logic_op)
+{
+  switch (ternary_logic_op & 0xFF)
+    {
+    case 0:
+      return VSXTernaryLogic<0> (a, b, c);
+    case 1:
+      return VSXTernaryLogic<1> (a, b, c);
+    case 2:
+      return VSXTernaryLogic<2> (a, b, c);
+    case 3:
+      return VSXTernaryLogic<3> (a, b, c);
+    case 4:
+      return VSXTernaryLogic<4> (a, b, c);
+    case 5:
+      return VSXTernaryLogic<5> (a, b, c);
+    case 6:
+      return VSXTernaryLogic<6> (a, b, c);
+    case 7:
+      return VSXTernaryLogic<7> (a, b, c);
+    case 8:
+      return VSXTernaryLogic<8> (a, b, c);
+    case 9:
+      return VSXTernaryLogic<9> (a, b, c);
+    case 10:
+      return VSXTernaryLogic<10> (a, b, c);
+    case 11:
+      return VSXTernaryLogic<11> (a, b, c);
+    case 12:
+      return VSXTernaryLogic<12> (a, b, c);
+    case 13:
+      return VSXTernaryLogic<13> (a, b, c);
+    case 14:
+      return VSXTernaryLogic<14> (a, b, c);
+    case 15:
+      return VSXTernaryLogic<15> (a, b, c);
+    case 16:
+      return VSXTernaryLogic<16> (a, b, c);
+    case 17:
+      return VSXTernaryLogic<17> (a, b, c);
+    case 18:
+      return VSXTernaryLogic<18> (a, b, c);
+    case 19:
+      return VSXTernaryLogic<19> (a, b, c);
+    case 20:
+      return VSXTernaryLogic<20> (a, b, c);
+    case 21:
+      return VSXTernaryLogic<21> (a, b, c);
+    case 22:
+      return VSXTernaryLogic<22> (a, b, c);
+    case 23:
+      return VSXTernaryLogic<23> (a, b, c);
+    case 24:
+      return VSXTernaryLogic<24> (a, b, c);
+    case 25:
+      return VSXTernaryLogic<25> (a, b, c);
+    case 26:
+      return VSXTernaryLogic<26> (a, b, c);
+    case 27:
+      return VSXTernaryLogic<27> (a, b, c);
+    case 28:
+      return VSXTernaryLogic<28> (a, b, c);
+    case 29:
+      return VSXTernaryLogic<29> (a, b, c);
+    case 30:
+      return VSXTernaryLogic<30> (a, b, c);
+    case 31:
+      return VSXTernaryLogic<31> (a, b, c);
+    case 32:
+      return VSXTernaryLogic<32> (a, b, c);
+    case 33:
+      return VSXTernaryLogic<33> (a, b, c);
+    case 34:
+      return VSXTernaryLogic<34> (a, b, c);
+    case 35:
+      return VSXTernaryLogic<35> (a, b, c);
+    case 36:
+      return VSXTernaryLogic<36> (a, b, c);
+    case 37:
+      return VSXTernaryLogic<37> (a, b, c);
+    case 38:
+      return VSXTernaryLogic<38> (a, b, c);
+    case 39:
+      return VSXTernaryLogic<39> (a, b, c);
+    case 40:
+      return VSXTernaryLogic<40> (a, b, c);
+    case 41:
+      return VSXTernaryLogic<41> (a, b, c);
+    case 42:
+      return VSXTernaryLogic<42> (a, b, c);
+    case 43:
+      return VSXTernaryLogic<43> (a, b, c);
+    case 44:
+      return VSXTernaryLogic<44> (a, b, c);
+    case 45:
+      return VSXTernaryLogic<45> (a, b, c);
+    case 46:
+      return VSXTernaryLogic<46> (a, b, c);
+    case 47:
+      return VSXTernaryLogic<47> (a, b, c);
+    case 48:
+      return VSXTernaryLogic<48> (a, b, c);
+    case 49:
+      return VSXTernaryLogic<49> (a, b, c);
+    case 50:
+      return VSXTernaryLogic<50> (a, b, c);
+    case 51:
+      return VSXTernaryLogic<51> (a, b, c);
+    case 52:
+      return VSXTernaryLogic<52> (a, b, c);
+    case 53:
+      return VSXTernaryLogic<53> (a, b, c);
+    case 54:
+      return VSXTernaryLogic<54> (a, b, c);
+    case 55:
+      return VSXTernaryLogic<55> (a, b, c);
+    case 56:
+      return VSXTernaryLogic<56> (a, b, c);
+    case 57:
+      return VSXTernaryLogic<57> (a, b, c);
+    case 58:
+      return VSXTernaryLogic<58> (a, b, c);
+    case 59:
+      return VSXTernaryLogic<59> (a, b, c);
+    case 60:
+      return VSXTernaryLogic<60> (a, b, c);
+    case 61:
+      return VSXTernaryLogic<61> (a, b, c);
+    case 62:
+      return VSXTernaryLogic<62> (a, b, c);
+    case 63:
+      return VSXTernaryLogic<63> (a, b, c);
+    case 64:
+      return VSXTernaryLogic<64> (a, b, c);
+    case 65:
+      return VSXTernaryLogic<65> (a, b, c);
+    case 66:
+      return VSXTernaryLogic<66> (a, b, c);
+    case 67:
+      return VSXTernaryLogic<67> (a, b, c);
+    case 68:
+      return VSXTernaryLogic<68> (a, b, c);
+    case 69:
+      return VSXTernaryLogic<69> (a, b, c);
+    case 70:
+      return VSXTernaryLogic<70> (a, b, c);
+    case 71:
+      return VSXTernaryLogic<71> (a, b, c);
+    case 72:
+      return VSXTernaryLogic<72> (a, b, c);
+    case 73:
+      return VSXTernaryLogic<73> (a, b, c);
+    case 74:
+      return VSXTernaryLogic<74> (a, b, c);
+    case 75:
+      return VSXTernaryLogic<75> (a, b, c);
+    case 76:
+      return VSXTernaryLogic<76> (a, b, c);
+    case 77:
+      return VSXTernaryLogic<77> (a, b, c);
+    case 78:
+      return VSXTernaryLogic<78> (a, b, c);
+    case 79:
+      return VSXTernaryLogic<79> (a, b, c);
+    case 80:
+      return VSXTernaryLogic<80> (a, b, c);
+    case 81:
+      return VSXTernaryLogic<81> (a, b, c);
+    case 82:
+      return VSXTernaryLogic<82> (a, b, c);
+    case 83:
+      return VSXTernaryLogic<83> (a, b, c);
+    case 84:
+      return VSXTernaryLogic<84> (a, b, c);
+    case 85:
+      return VSXTernaryLogic<85> (a, b, c);
+    case 86:
+      return VSXTernaryLogic<86> (a, b, c);
+    case 87:
+      return VSXTernaryLogic<87> (a, b, c);
+    case 88:
+      return VSXTernaryLogic<88> (a, b, c);
+    case 89:
+      return VSXTernaryLogic<89> (a, b, c);
+    case 90:
+      return VSXTernaryLogic<90> (a, b, c);
+    case 91:
+      return VSXTernaryLogic<91> (a, b, c);
+    case 92:
+      return VSXTernaryLogic<92> (a, b, c);
+    case 93:
+      return VSXTernaryLogic<93> (a, b, c);
+    case 94:
+      return VSXTernaryLogic<94> (a, b, c);
+    case 95:
+      return VSXTernaryLogic<95> (a, b, c);
+    case 96:
+      return VSXTernaryLogic<96> (a, b, c);
+    case 97:
+      return VSXTernaryLogic<97> (a, b, c);
+    case 98:
+      return VSXTernaryLogic<98> (a, b, c);
+    case 99:
+      return VSXTernaryLogic<99> (a, b, c);
+    case 100:
+      return VSXTernaryLogic<100> (a, b, c);
+    case 101:
+      return VSXTernaryLogic<101> (a, b, c);
+    case 102:
+      return VSXTernaryLogic<102> (a, b, c);
+    case 103:
+      return VSXTernaryLogic<103> (a, b, c);
+    case 104:
+      return VSXTernaryLogic<104> (a, b, c);
+    case 105:
+      return VSXTernaryLogic<105> (a, b, c);
+    case 106:
+      return VSXTernaryLogic<106> (a, b, c);
+    case 107:
+      return VSXTernaryLogic<107> (a, b, c);
+    case 108:
+      return VSXTernaryLogic<108> (a, b, c);
+    case 109:
+      return VSXTernaryLogic<109> (a, b, c);
+    case 110:
+      return VSXTernaryLogic<110> (a, b, c);
+    case 111:
+      return VSXTernaryLogic<111> (a, b, c);
+    case 112:
+      return VSXTernaryLogic<112> (a, b, c);
+    case 113:
+      return VSXTernaryLogic<113> (a, b, c);
+    case 114:
+      return VSXTernaryLogic<114> (a, b, c);
+    case 115:
+      return VSXTernaryLogic<115> (a, b, c);
+    case 116:
+      return VSXTernaryLogic<116> (a, b, c);
+    case 117:
+      return VSXTernaryLogic<117> (a, b, c);
+    case 118:
+      return VSXTernaryLogic<118> (a, b, c);
+    case 119:
+      return VSXTernaryLogic<119> (a, b, c);
+    case 120:
+      return VSXTernaryLogic<120> (a, b, c);
+    case 121:
+      return VSXTernaryLogic<121> (a, b, c);
+    case 122:
+      return VSXTernaryLogic<122> (a, b, c);
+    case 123:
+      return VSXTernaryLogic<123> (a, b, c);
+    case 124:
+      return VSXTernaryLogic<124> (a, b, c);
+    case 125:
+      return VSXTernaryLogic<125> (a, b, c);
+    case 126:
+      return VSXTernaryLogic<126> (a, b, c);
+    case 127:
+      return VSXTernaryLogic<127> (a, b, c);
+    case 128:
+      return VSXTernaryLogic<128> (a, b, c);
+    case 129:
+      return VSXTernaryLogic<129> (a, b, c);
+    case 130:
+      return VSXTernaryLogic<130> (a, b, c);
+    case 131:
+      return VSXTernaryLogic<131> (a, b, c);
+    case 132:
+      return VSXTernaryLogic<132> (a, b, c);
+    case 133:
+      return VSXTernaryLogic<133> (a, b, c);
+    case 134:
+      return VSXTernaryLogic<134> (a, b, c);
+    case 135:
+      return VSXTernaryLogic<135> (a, b, c);
+    case 136:
+      return VSXTernaryLogic<136> (a, b, c);
+    case 137:
+      return VSXTernaryLogic<137> (a, b, c);
+    case 138:
+      return VSXTernaryLogic<138> (a, b, c);
+    case 139:
+      return VSXTernaryLogic<139> (a, b, c);
+    case 140:
+      return VSXTernaryLogic<140> (a, b, c);
+    case 141:
+      return VSXTernaryLogic<141> (a, b, c);
+    case 142:
+      return VSXTernaryLogic<142> (a, b, c);
+    case 143:
+      return VSXTernaryLogic<143> (a, b, c);
+    case 144:
+      return VSXTernaryLogic<144> (a, b, c);
+    case 145:
+      return VSXTernaryLogic<145> (a, b, c);
+    case 146:
+      return VSXTernaryLogic<146> (a, b, c);
+    case 147:
+      return VSXTernaryLogic<147> (a, b, c);
+    case 148:
+      return VSXTernaryLogic<148> (a, b, c);
+    case 149:
+      return VSXTernaryLogic<149> (a, b, c);
+    case 150:
+      return VSXTernaryLogic<150> (a, b, c);
+    case 151:
+      return VSXTernaryLogic<151> (a, b, c);
+    case 152:
+      return VSXTernaryLogic<152> (a, b, c);
+    case 153:
+      return VSXTernaryLogic<153> (a, b, c);
+    case 154:
+      return VSXTernaryLogic<154> (a, b, c);
+    case 155:
+      return VSXTernaryLogic<155> (a, b, c);
+    case 156:
+      return VSXTernaryLogic<156> (a, b, c);
+    case 157:
+      return VSXTernaryLogic<157> (a, b, c);
+    case 158:
+      return VSXTernaryLogic<158> (a, b, c);
+    case 159:
+      return VSXTernaryLogic<159> (a, b, c);
+    case 160:
+      return VSXTernaryLogic<160> (a, b, c);
+    case 161:
+      return VSXTernaryLogic<161> (a, b, c);
+    case 162:
+      return VSXTernaryLogic<162> (a, b, c);
+    case 163:
+      return VSXTernaryLogic<163> (a, b, c);
+    case 164:
+      return VSXTernaryLogic<164> (a, b, c);
+    case 165:
+      return VSXTernaryLogic<165> (a, b, c);
+    case 166:
+      return VSXTernaryLogic<166> (a, b, c);
+    case 167:
+      return VSXTernaryLogic<167> (a, b, c);
+    case 168:
+      return VSXTernaryLogic<168> (a, b, c);
+    case 169:
+      return VSXTernaryLogic<169> (a, b, c);
+    case 170:
+      return VSXTernaryLogic<170> (a, b, c);
+    case 171:
+      return VSXTernaryLogic<171> (a, b, c);
+    case 172:
+      return VSXTernaryLogic<172> (a, b, c);
+    case 173:
+      return VSXTernaryLogic<173> (a, b, c);
+    case 174:
+      return VSXTernaryLogic<174> (a, b, c);
+    case 175:
+      return VSXTernaryLogic<175> (a, b, c);
+    case 176:
+      return VSXTernaryLogic<176> (a, b, c);
+    case 177:
+      return VSXTernaryLogic<177> (a, b, c);
+    case 178:
+      return VSXTernaryLogic<178> (a, b, c);
+    case 179:
+      return VSXTernaryLogic<179> (a, b, c);
+    case 180:
+      return VSXTernaryLogic<180> (a, b, c);
+    case 181:
+      return VSXTernaryLogic<181> (a, b, c);
+    case 182:
+      return VSXTernaryLogic<182> (a, b, c);
+    case 183:
+      return VSXTernaryLogic<183> (a, b, c);
+    case 184:
+      return VSXTernaryLogic<184> (a, b, c);
+    case 185:
+      return VSXTernaryLogic<185> (a, b, c);
+    case 186:
+      return VSXTernaryLogic<186> (a, b, c);
+    case 187:
+      return VSXTernaryLogic<187> (a, b, c);
+    case 188:
+      return VSXTernaryLogic<188> (a, b, c);
+    case 189:
+      return VSXTernaryLogic<189> (a, b, c);
+    case 190:
+      return VSXTernaryLogic<190> (a, b, c);
+    case 191:
+      return VSXTernaryLogic<191> (a, b, c);
+    case 192:
+      return VSXTernaryLogic<192> (a, b, c);
+    case 193:
+      return VSXTernaryLogic<193> (a, b, c);
+    case 194:
+      return VSXTernaryLogic<194> (a, b, c);
+    case 195:
+      return VSXTernaryLogic<195> (a, b, c);
+    case 196:
+      return VSXTernaryLogic<196> (a, b, c);
+    case 197:
+      return VSXTernaryLogic<197> (a, b, c);
+    case 198:
+      return VSXTernaryLogic<198> (a, b, c);
+    case 199:
+      return VSXTernaryLogic<199> (a, b, c);
+    case 200:
+      return VSXTernaryLogic<200> (a, b, c);
+    case 201:
+      return VSXTernaryLogic<201> (a, b, c);
+    case 202:
+      return VSXTernaryLogic<202> (a, b, c);
+    case 203:
+      return VSXTernaryLogic<203> (a, b, c);
+    case 204:
+      return VSXTernaryLogic<204> (a, b, c);
+    case 205:
+      return VSXTernaryLogic<205> (a, b, c);
+    case 206:
+      return VSXTernaryLogic<206> (a, b, c);
+    case 207:
+      return VSXTernaryLogic<207> (a, b, c);
+    case 208:
+      return VSXTernaryLogic<208> (a, b, c);
+    case 209:
+      return VSXTernaryLogic<209> (a, b, c);
+    case 210:
+      return VSXTernaryLogic<210> (a, b, c);
+    case 211:
+      return VSXTernaryLogic<211> (a, b, c);
+    case 212:
+      return VSXTernaryLogic<212> (a, b, c);
+    case 213:
+      return VSXTernaryLogic<213> (a, b, c);
+    case 214:
+      return VSXTernaryLogic<214> (a, b, c);
+    case 215:
+      return VSXTernaryLogic<215> (a, b, c);
+    case 216:
+      return VSXTernaryLogic<216> (a, b, c);
+    case 217:
+      return VSXTernaryLogic<217> (a, b, c);
+    case 218:
+      return VSXTernaryLogic<218> (a, b, c);
+    case 219:
+      return VSXTernaryLogic<219> (a, b, c);
+    case 220:
+      return VSXTernaryLogic<220> (a, b, c);
+    case 221:
+      return VSXTernaryLogic<221> (a, b, c);
+    case 222:
+      return VSXTernaryLogic<222> (a, b, c);
+    case 223:
+      return VSXTernaryLogic<223> (a, b, c);
+    case 224:
+      return VSXTernaryLogic<224> (a, b, c);
+    case 225:
+      return VSXTernaryLogic<225> (a, b, c);
+    case 226:
+      return VSXTernaryLogic<226> (a, b, c);
+    case 227:
+      return VSXTernaryLogic<227> (a, b, c);
+    case 228:
+      return VSXTernaryLogic<228> (a, b, c);
+    case 229:
+      return VSXTernaryLogic<229> (a, b, c);
+    case 230:
+      return VSXTernaryLogic<230> (a, b, c);
+    case 231:
+      return VSXTernaryLogic<231> (a, b, c);
+    case 232:
+      return VSXTernaryLogic<232> (a, b, c);
+    case 233:
+      return VSXTernaryLogic<233> (a, b, c);
+    case 234:
+      return VSXTernaryLogic<234> (a, b, c);
+    case 235:
+      return VSXTernaryLogic<235> (a, b, c);
+    case 236:
+      return VSXTernaryLogic<236> (a, b, c);
+    case 237:
+      return VSXTernaryLogic<237> (a, b, c);
+    case 238:
+      return VSXTernaryLogic<238> (a, b, c);
+    case 239:
+      return VSXTernaryLogic<239> (a, b, c);
+    case 240:
+      return VSXTernaryLogic<240> (a, b, c);
+    case 241:
+      return VSXTernaryLogic<241> (a, b, c);
+    case 242:
+      return VSXTernaryLogic<242> (a, b, c);
+    case 243:
+      return VSXTernaryLogic<243> (a, b, c);
+    case 244:
+      return VSXTernaryLogic<244> (a, b, c);
+    case 245:
+      return VSXTernaryLogic<245> (a, b, c);
+    case 246:
+      return VSXTernaryLogic<246> (a, b, c);
+    case 247:
+      return VSXTernaryLogic<247> (a, b, c);
+    case 248:
+      return VSXTernaryLogic<248> (a, b, c);
+    case 249:
+      return VSXTernaryLogic<249> (a, b, c);
+    case 250:
+      return VSXTernaryLogic<250> (a, b, c);
+    case 251:
+      return VSXTernaryLogic<251> (a, b, c);
+    case 252:
+      return VSXTernaryLogic<252> (a, b, c);
+    case 253:
+      return VSXTernaryLogic<253> (a, b, c);
+    case 254:
+      return VSXTernaryLogic<254> (a, b, c);
+    case 255:
+      return VSXTernaryLogic<255> (a, b, c);
+    default:
+      return a;
+    }
+}
+
+int
+main (int argc, char **argv)
+{
+  vector unsigned long long a = {0xD8, 0xDB};
+  vector unsigned long long b = {0x6C, 0x6C};
+  vector unsigned long long c = {0x56, 0x56};
+  vector unsigned long long ternlog_result = VSXTernaryLogic (a, b, c, 0xB6);
+
+  if (ternlog_result[0] != 0xffffffffffffff3dull
+      || ternlog_result[1] != 0xffffffffffffff3eull)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr106030.c b/gcc/testsuite/gcc.c-torture/compile/pr106030.c
new file mode 100644
index 00000000000..7514b348ff9
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr106030.c
@@ -0,0 +1,16 @@
+/* PR middle-end/106030 */
+
+int a, b, c;
+
+char
+foo (int x, int y)
+{
+  return x * y;
+}
+
+void
+bar (void)
+{
+  char d = (foo <= b) * a;
+  c = foo (2 != bar, d);
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr106751.c b/gcc/testsuite/gcc.c-torture/compile/pr106751.c
new file mode 100644
index 00000000000..5fbf93bd332
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr106751.c
@@ -0,0 +1,17 @@
+/* PR rtl-optimization/106751 */
+
+int *foo (void);
+
+void
+bar (void)
+{
+  asm goto ("" : : : : lab);
+  __builtin_unreachable ();
+lab:
+  while (1)
+    {
+      int o;
+      asm ("" : "=r" (o) : "g" (1));
+      *foo () = o;
+    }
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr107997.c b/gcc/testsuite/gcc.c-torture/compile/pr107997.c
new file mode 100644
index 00000000000..89e1fd349c3
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr107997.c
@@ -0,0 +1,23 @@
+/* PR tree-optimization/107997 */
+
+int a, b;
+void bar (int);
+int baz (void);
+
+void *
+foo (int x, void *y)
+{
+  asm goto ("" : : "r" (x || !a) : : l);
+l:
+  if (y)
+    return 0;
+  bar (b ? b : x);
+  while (x--)
+    {
+      if (!baz ())
+	baz ();
+      asm goto ("" : : : : l2);
+    l2:;
+    }
+  return y;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr108237.c b/gcc/testsuite/gcc.c-torture/compile/pr108237.c
new file mode 100644
index 00000000000..52b7f9d177f
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr108237.c
@@ -0,0 +1,14 @@
+/* PR middle-end/108237 */
+
+typedef unsigned char __attribute__((__vector_size__ (1))) U;
+typedef unsigned long long __attribute__((__vector_size__ (16))) V;
+
+U u;
+V v;
+
+V
+foo (void)
+{
+  V w = v != ((unsigned char) ((unsigned char) u == u) & v);
+  return w;
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr108596.c b/gcc/testsuite/gcc.c-torture/compile/pr108596.c
new file mode 100644
index 00000000000..4de6c49d7ce
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr108596.c
@@ -0,0 +1,26 @@
+/* PR rtl-optimization/108596 */
+
+__attribute__((__cold__)) void foo (void);
+void bar (void);
+
+void
+baz (void)
+{
+  asm goto ("" : : : : l1, l0);
+  goto l0;
+l1:
+  bar ();
+l0:
+  foo ();
+}
+
+void
+qux (void)
+{
+  asm goto ("" : : : : l1, l0);
+  __builtin_unreachable ();
+l1:
+  bar ();
+l0:
+  foo ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr108688-1.c b/gcc/testsuite/gcc.c-torture/compile/pr108688-1.c
new file mode 100644
index 00000000000..43d782d62bd
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr108688-1.c
@@ -0,0 +1,15 @@
+
+
+union U { signed int d : 7; signed int e : 2; } u;
+int a, b;
+
+void
+foo (void)
+{
+  for (int i = 0; i < 64; i++)
+    {
+      u.d = a;
+      u.e ^= b;
+    }
+}
+
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr111699-1.c b/gcc/testsuite/gcc.c-torture/compile/pr111699-1.c
new file mode 100644
index 00000000000..87b127ed199
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr111699-1.c
@@ -0,0 +1,7 @@
+typedef unsigned char __attribute__((__vector_size__ (8))) V;
+
+void
+foo (V *v)
+{
+  *v =  (V) 0x107B9A7FF >= (*v <= 0);
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr106032.c b/gcc/testsuite/gcc.c-torture/execute/pr106032.c
new file mode 100644
index 00000000000..d2ccf6a5b52
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr106032.c
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/106032 */
+
+__attribute__((noipa)) int
+foo (int x, int *y)
+{
+  int a = 0;
+  if (x < 0)
+    a = *y;
+  return a;  
+}
+
+int
+main ()
+{
+  int a = 42;
+  if (foo (0, 0) != 0 || foo (1, 0) != 0)
+    __builtin_abort ();
+  if (foo (-1, &a) != 42 || foo (-42, &a) != 42)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr108498-1.c b/gcc/testsuite/gcc.c-torture/execute/pr108498-1.c
new file mode 100644
index 00000000000..217c1e4ecd2
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr108498-1.c
@@ -0,0 +1,82 @@
+/* PR tree-optimization/108498 */
+
+struct A
+{
+  signed char a1;
+  int a2;
+};
+
+struct B
+{
+  struct A b1;
+  unsigned char b2:1, b3:1, b4:2, b5:1, b6:1, b7[4];
+};
+
+struct C
+{
+  unsigned char c1;
+  char c2;
+  signed char c3;
+  unsigned char c4, c5[4], c6:1, c7:1, c8:1, c9:3, c10:1;
+  struct A c11;
+  struct B c12[3];
+};
+
+static inline struct C
+foo (unsigned char a, unsigned b, int c, struct A d,
+     unsigned e, struct B f, struct B g, struct B h)
+{
+  struct C x
+    = { .c1 = b, .c2 = 0, .c3 = c, .c6 = a, .c4 = e, .c7 = 0,
+        .c8 = 0, .c9 = 7, .c10 = 0, .c5 = {0, 1, 2, 3}, .c11 = d,
+        .c12 = {f, g, h} };
+  return x;
+}
+
+static inline struct A
+bar (int a, int b)
+{
+  struct A x = { .a1 = a, .a2 = b };
+  return x;
+}
+
+static inline struct B
+baz (struct A b1)
+{
+  struct B x = { .b1 = b1, .b6 = 0, .b5 = 0, .b7 = {0, 1, 2, 3}, .b2 = 0 };
+  return x;
+}
+
+struct C
+qux (void)
+{
+  const struct B a = baz (bar (0, 0));
+  struct C b;
+  struct B c[2];
+  struct A d = { 0, 1 };
+  c[0].b1.a1 = 0;
+  c[0].b1.a2 = 2;
+  c[1].b1.a1 = 4;
+  c[1].b1.a2 = 8;
+  return foo (0, 2, -1, d, 3, c[0], c[1], a);
+}
+
+__attribute__((noipa)) void
+corge (struct C *x)
+{
+  char buf[1024];
+  __builtin_memset (buf, 0xaa, sizeof (buf));
+  asm volatile ("" : : "r" (buf));
+  __builtin_memset (x, 0x55, sizeof (struct C));
+  asm volatile ("" : : "r" (x));
+}
+
+int
+main ()
+{
+  struct C x;
+  corge (&x);
+  x = qux ();
+  if (x.c6 || x.c9 != 7)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr108498-2.c b/gcc/testsuite/gcc.c-torture/execute/pr108498-2.c
new file mode 100644
index 00000000000..ad930488c33
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr108498-2.c
@@ -0,0 +1,91 @@
+/* PR tree-optimization/108498 */
+
+struct U { char c[16]; };
+struct V { char c[16]; };
+struct S { unsigned int a : 3, b : 8, c : 21; struct U d; unsigned int e; struct V f; unsigned int g : 5, h : 27; };
+struct T { unsigned int a : 16, b : 8, c : 8; struct U d; unsigned int e; struct V f; unsigned int g : 5, h : 27; };
+
+__attribute__((noipa)) void
+foo (struct S *p)
+{
+  p->b = 231;
+  p->c = 42;
+  p->d = (struct U) { "abcdefghijklmno" };
+  p->e = 0xdeadbeef;
+  p->f = (struct V) { "ABCDEFGHIJKLMNO" };
+}
+
+__attribute__((noipa)) void
+bar (struct S *p)
+{
+  p->b = 231;
+  p->c = 42;
+  p->d = (struct U) { "abcdefghijklmno" };
+  p->e = 0xdeadbeef;
+  p->f = (struct V) { "ABCDEFGHIJKLMNO" };
+  p->g = 12;
+}
+
+__attribute__((noipa)) void
+baz (struct T *p)
+{
+  p->c = 42;
+  p->d = (struct U) { "abcdefghijklmno" };
+  p->e = 0xdeadbeef;
+  p->f = (struct V) { "ABCDEFGHIJKLMNO" };
+  p->g = 12;
+}
+
+int
+main ()
+{
+  if (__CHAR_BIT__ != 8 || __SIZEOF_INT__ != 4)
+    return 0;
+  struct S s = {};
+  struct T t = {};
+  foo (&s);
+  if (s.a != 0 || s.b != 231 || s.c != 42
+      || __builtin_memcmp (&s.d.c, "abcdefghijklmno", 16) || s.e != 0xdeadbeef
+      || __builtin_memcmp (&s.f.c, "ABCDEFGHIJKLMNO", 16) || s.g != 0 || s.h != 0)
+    __builtin_abort ();
+  __builtin_memset (&s, 0, sizeof (s));
+  s.a = 7;
+  s.g = 31;
+  s.h = (1U << 27) - 1;
+  foo (&s);
+  if (s.a != 7 || s.b != 231 || s.c != 42
+      || __builtin_memcmp (&s.d.c, "abcdefghijklmno", 16) || s.e != 0xdeadbeef
+      || __builtin_memcmp (&s.f.c, "ABCDEFGHIJKLMNO", 16) || s.g != 31 || s.h != (1U << 27) - 1)
+    __builtin_abort ();
+  __builtin_memset (&s, 0, sizeof (s));
+  bar (&s);
+  if (s.a != 0 || s.b != 231 || s.c != 42
+      || __builtin_memcmp (&s.d.c, "abcdefghijklmno", 16) || s.e != 0xdeadbeef
+      || __builtin_memcmp (&s.f.c, "ABCDEFGHIJKLMNO", 16) || s.g != 12 || s.h != 0)
+    __builtin_abort ();
+  __builtin_memset (&s, 0, sizeof (s));
+  s.a = 7;
+  s.g = 31;
+  s.h = (1U << 27) - 1;
+  bar (&s);
+  if (s.a != 7 || s.b != 231 || s.c != 42
+      || __builtin_memcmp (&s.d.c, "abcdefghijklmno", 16) || s.e != 0xdeadbeef
+      || __builtin_memcmp (&s.f.c, "ABCDEFGHIJKLMNO", 16) || s.g != 12 || s.h != (1U << 27) - 1)
+    __builtin_abort ();
+  baz (&t);
+  if (t.a != 0 || t.b != 0 || t.c != 42
+      || __builtin_memcmp (&t.d.c, "abcdefghijklmno", 16) || t.e != 0xdeadbeef
+      || __builtin_memcmp (&t.f.c, "ABCDEFGHIJKLMNO", 16) || t.g != 12 || t.h != 0)
+    __builtin_abort ();
+  __builtin_memset (&s, 0, sizeof (s));
+  t.a = 7;
+  t.b = 255;
+  t.g = 31;
+  t.h = (1U << 27) - 1;
+  baz (&t);
+  if (t.a != 7 || t.b != 255 || t.c != 42
+      || __builtin_memcmp (&t.d.c, "abcdefghijklmno", 16) || t.e != 0xdeadbeef
+      || __builtin_memcmp (&t.f.c, "ABCDEFGHIJKLMNO", 16) || t.g != 12 || t.h != (1U << 27) - 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr109778.c b/gcc/testsuite/gcc.c-torture/execute/pr109778.c
new file mode 100644
index 00000000000..309fbf413e0
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr109778.c
@@ -0,0 +1,26 @@
+/* PR tree-optimization/109778 */
+
+int a, b, c, d, *e = &c;
+
+static inline unsigned
+foo (unsigned char x)
+{
+  x = 1 | x << 1;
+  x = x >> 4 | x << 4;
+  return x;
+}
+
+static inline void
+bar (unsigned x)
+{
+  *e = 8 > foo (x + 86) - 86;
+}
+
+int
+main ()
+{
+  d = a && b;
+  bar (d + 4);
+  if (c != 1)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr110914.c b/gcc/testsuite/gcc.c-torture/execute/pr110914.c
new file mode 100644
index 00000000000..ccc04e1bdd4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr110914.c
@@ -0,0 +1,22 @@
+/* PR tree-optimization/110914 */
+
+__attribute__ ((noipa)) int
+foo (const char *s, unsigned long l)
+{
+  unsigned char r = 0;
+  __builtin_memcpy (&r, s, l != 0);
+  return r;
+}
+
+int
+main ()
+{
+  const char *p = "123456";
+  int a = foo (p, __builtin_strlen (p) - 5);
+  int b = foo (p, __builtin_strlen (p) - 6);
+  if (a != '1')
+    __builtin_abort ();
+  if (b != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105252.c b/gcc/testsuite/gcc.dg/analyzer/pr105252.c
new file mode 100644
index 00000000000..a093eababc5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105252.c
@@ -0,0 +1,20 @@
+/* { dg-additional-options "-fnon-call-exceptions -O" } */
+
+typedef unsigned char C;
+typedef unsigned char __attribute__((__vector_size__ (4))) V;
+
+C m;
+
+static inline void
+bar (C c, V v, V *r)
+{
+  v %= (c | v) % m;
+  *r = v;
+}
+
+void
+foo (void)
+{
+  V x;
+  bar (0, (V){2}, &x);
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105365.c b/gcc/testsuite/gcc.dg/analyzer/pr105365.c
new file mode 100644
index 00000000000..aa576d08632
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105365.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target int128 } */
+
+typedef _Float32 f32;
+typedef _Complex _Float32 cf32;
+_Float32 g;
+__int128 i;
+
+extern void bar(int);
+
+void
+foo(_Float32 k) {
+  f32 f = 0;
+  f /= (_Complex char)__builtin_llround(g);
+  k /= (cf32)__builtin_copysignf(0, i);
+  bar(f + k);
+  foo(0);
+}
diff --git a/gcc/testsuite/gcc.dg/analyzer/pr105366.c b/gcc/testsuite/gcc.dg/analyzer/pr105366.c
new file mode 100644
index 00000000000..3dba870e4e9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/analyzer/pr105366.c
@@ -0,0 +1,19 @@
+/* { dg-require-effective-target int128 } */
+/* { dg-additional-options "-O" } */
+
+extern void bar(int);
+extern void baz(void);
+
+typedef unsigned u32;
+
+void
+foo(u32 u, __int128 i) {
+  baz();
+  _Complex int c = i;
+  c /= (u32)(__UINTPTR_TYPE__)foo;
+  short s = (short)(__UINTPTR_TYPE__)foo;
+  u /= (_Complex short)s;
+  u32 r = u + c;
+  bar(r);
+  foo(0, 0);
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr105396.c b/gcc/testsuite/gcc.dg/asan/pr105396.c
new file mode 100644
index 00000000000..d4bd7f12476
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asan/pr105396.c
@@ -0,0 +1,19 @@
+/* PR sanitizer/105396 */
+/* { dg-do run } */
+/* { dg-skip-if "" { *-*-* } { "*" } { "-O0" } } */
+/* { dg-shouldfail "asan" } */
+
+int
+main ()
+{
+  int a;
+  int *b[1];
+  int c[10];
+  int d[1][1];
+  for (a = 0; a < 1; a++)
+    d[1][a] = 0;
+  return 0;
+}
+
+/* { dg-output "ERROR: AddressSanitizer: stack-buffer-overflow on address.*(\n|\r\n|\r)" } */
+/* { dg-output "WRITE of size.*" } */
diff --git a/gcc/testsuite/gcc.dg/asan/pr106190.c b/gcc/testsuite/gcc.dg/asan/pr106190.c
new file mode 100644
index 00000000000..10eb2789a49
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asan/pr106190.c
@@ -0,0 +1,15 @@
+/* PR middle-end/106190 */
+/* { dg-do compile } */
+/* { dg-options "-fnon-call-exceptions -fsanitize=address,undefined -fno-sanitize-recover=all" } */
+
+int
+main ()
+{
+  int a;
+  int *b[1];
+  int c[10];
+  int d[1][1];
+  for (a = 0; a < 1; a++)
+    d[1][a] = 0;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/asan/pr107317.c b/gcc/testsuite/gcc.dg/asan/pr107317.c
new file mode 100644
index 00000000000..dd7ad7d2449
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/asan/pr107317.c
@@ -0,0 +1,13 @@
+/* PR middle-end/107317 */
+/* { dg-do compile { target ilp32 } } */
+/* { dg-options "-fsanitize=address -ffat-lto-objects" } */
+
+void bar (float *, float *);
+
+void
+foo (void)		/* { dg-error "exceeds maximum" } */
+{
+  float a[400000000];
+  float b[200000000];
+  bar (a, b);
+}
diff --git a/gcc/testsuite/gcc.dg/attr-aligned.c b/gcc/testsuite/gcc.dg/attr-aligned.c
index ec545639f79..a2e11c96180 100644
--- a/gcc/testsuite/gcc.dg/attr-aligned.c
+++ b/gcc/testsuite/gcc.dg/attr-aligned.c
@@ -12,8 +12,12 @@
 #  define ALIGN_MAX_STATIC      0x1000
    /* Excessive alignment for functions and objects with static storage
       duration that's expected to trigger an error.  */
-#elif __MACH__
-#  define ALIGN_MAX_STATIC      0x8000
+#elif __APPLE__
+# if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1070
+#   define ALIGN_MAX_STATIC      0x8000
+# else
+#   define ALIGN_MAX_STATIC      ALIGN_MAX_HARD
+# endif
 #elif pdp11
 #  define ALIGN_MAX_STATIC      2
 /* Work around a pdp11 ICE (see PR target/87821).  */
diff --git a/gcc/testsuite/gcc.dg/darwin-aligned-globals.c b/gcc/testsuite/gcc.dg/darwin-aligned-globals.c
new file mode 100644
index 00000000000..18b71e7e327
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/darwin-aligned-globals.c
@@ -0,0 +1,24 @@
+/* { dg-do compile { target *-*-darwin* } } */
+/* { dg-additional-options "-fcommon" } */
+
+/* Test alignment rules which differ for earlier hosts (so we must
+   work on the principle that this test will be exercised by self-
+   hosted compilers. */
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1070
+#define align_OK (1ul << 28)
+#define align_BAD (1ul << 29)
+#else
+#define align_OK (1ul << 15)
+#define align_BAD (1ul << 16)
+#endif
+
+/* All non common vars are allowed larger alignment on modern systems.  */
+static int xn __attribute__ ((aligned (align_OK)));
+static int xi __attribute__ ((aligned (align_OK))) = 5  ;
+int gxi __attribute__ ((aligned (align_OK))) = 6 ;
+
+/* test that we detect bad cases.  */
+static int yn __attribute__ ((aligned (align_BAD))); /* { dg-error {requested alignment .[0-9]+. exceeds object file maximum} } */
+static int yi __attribute__ ((aligned (align_BAD))) = 5;  /* { dg-error {requested alignment .[0-9]+. exceeds object file maximum} } */
+int yni __attribute__ ((aligned (align_BAD))) = 6;  /* { dg-error {requested alignment .[0-9]+. exceeds object file maximum} } */
diff --git a/gcc/testsuite/gcc.dg/darwin-comm-1.c b/gcc/testsuite/gcc.dg/darwin-comm-1.c
new file mode 100644
index 00000000000..46519984fd8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/darwin-comm-1.c
@@ -0,0 +1,5 @@
+/* { dg-do compile { target *-*-darwin[912]* } } */
+/* { dg-options "-fcommon" } */
+
+/* In all cases, common has a max alignment of 2^15.  */
+int badcommon __attribute__ ((aligned (65536))); /* { dg-error "common variables must have an alignment" } */
diff --git a/gcc/testsuite/gcc.dg/darwin-minversion-link.c b/gcc/testsuite/gcc.dg/darwin-minversion-link.c
index 765fb799a91..b6ede31c985 100644
--- a/gcc/testsuite/gcc.dg/darwin-minversion-link.c
+++ b/gcc/testsuite/gcc.dg/darwin-minversion-link.c
@@ -15,7 +15,8 @@
 /* { dg-additional-options "-mmacosx-version-min=010.013.06 -DCHECK=101306" { target *-*-darwin17* } } */
 /* { dg-additional-options "-mmacosx-version-min=010.014.05 -DCHECK=101405" { target *-*-darwin18* } } */
 /* { dg-additional-options "-mmacosx-version-min=010.015.06 -DCHECK=101506" { target *-*-darwin19* } } */
-/* { dg-additional-options "-mmacosx-version-min=011.000.00 -DCHECK=110000" { target *-*-darwin20 } } */
+/* { dg-additional-options "-mmacosx-version-min=011.000.00 -DCHECK=110000" { target *-*-darwin20* } } */
+/* { dg-additional-options "-mmacosx-version-min=012.000.00 -DCHECK=120000" { target *-*-darwin21* } } */
 
 int
 main ()
diff --git a/gcc/testsuite/gcc.dg/dfp/pr108068.c b/gcc/testsuite/gcc.dg/dfp/pr108068.c
new file mode 100644
index 00000000000..6cbb0fbe602
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/dfp/pr108068.c
@@ -0,0 +1,14 @@
+/* PR tree-optimization/108068 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+int
+main ()
+{
+  _Decimal64 x = -1;
+  while (x != 0)
+    x /= 10;
+  double d = x;
+  if (!__builtin_signbit (d))
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/gomp/pr108435.c b/gcc/testsuite/gcc.dg/gomp/pr108435.c
new file mode 100644
index 00000000000..ca692ad0451
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/gomp/pr108435.c
@@ -0,0 +1,18 @@
+/* PR middle-end/108435 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fopenmp" } */
+
+int
+main ()
+{
+  int i, j;
+  void
+  bar (void)
+  {
+    #pragma omp for simd collapse(2)
+     for (i = 1; i <= 16; i++)
+       for (j = 1; j <= 16; j++)
+	 ;
+  }
+  bar ();
+}
diff --git a/gcc/testsuite/gcc.dg/guality/guality.exp b/gcc/testsuite/gcc.dg/guality/guality.exp
index ba87132aef2..075bebe34e8 100644
--- a/gcc/testsuite/gcc.dg/guality/guality.exp
+++ b/gcc/testsuite/gcc.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
     return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
diff --git a/gcc/testsuite/gcc.dg/ipa/pr105739.c b/gcc/testsuite/gcc.dg/ipa/pr105739.c
new file mode 100644
index 00000000000..8dbe8fc2494
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ipa/pr105739.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+
+__attribute__((noinline))
+static int
+test2(int a)
+{
+        if (__builtin_constant_p (a))
+                __builtin_abort ();
+        return a;
+}
+static int
+test(int *a)
+{
+        int val = *(volatile int *)a;
+        if (__builtin_constant_p (val))
+                __builtin_abort ();
+        if (val)
+          return test2(val);
+        return 0;
+}
+int a;
+int
+main()
+{
+        a = 0;
+        return test (&a);
+}
+/* { dg-final { scan-tree-dump "test2" "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/lto/pr109778_0.c b/gcc/testsuite/gcc.dg/lto/pr109778_0.c
new file mode 100644
index 00000000000..3c6e1b8f7b7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr109778_0.c
@@ -0,0 +1,22 @@
+/* PR tree-optimization/109778 */
+/* { dg-lto-do run } */
+/* { dg-lto-options { "-O2 -flto" } } */
+/* { dg-require-effective-target int32 } */
+
+int bar (int);
+
+__attribute__((noipa)) int
+foo (int x)
+{
+  x = bar (x);
+  x = (x << 16) | (int) ((unsigned) x >> 16);
+  return x & 0x10000000;
+}
+
+int
+main ()
+{
+  if (foo (0) || foo (-1))
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/lto/pr109778_1.c b/gcc/testsuite/gcc.dg/lto/pr109778_1.c
new file mode 100644
index 00000000000..d18a7209983
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/lto/pr109778_1.c
@@ -0,0 +1,7 @@
+int
+bar (int x)
+{
+  x &= 0x22222222;
+  x |= (int) 0xf1234567U;
+  return x;
+}
diff --git a/gcc/testsuite/gcc.dg/pr104464.c b/gcc/testsuite/gcc.dg/pr104464.c
new file mode 100644
index 00000000000..ed6a22c39d5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr104464.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fnon-call-exceptions -fno-tree-dce -fno-tree-forwprop -fsignaling-nans" } */
+
+typedef double __attribute__((__vector_size__(16))) F;
+F f;
+
+void
+foo(void)
+{
+  f += (F)(f != (F){}[0]);
+}
diff --git a/gcc/testsuite/gcc.dg/pr105140.c b/gcc/testsuite/gcc.dg/pr105140.c
new file mode 100644
index 00000000000..7d30985e850
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105140.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -w -Wno-psabi" } */
+/* { dg-skip-if "PR105147" { powerpc*-*-* s390*-*-* } } */
+
+typedef char __attribute__((__vector_size__ (16 * sizeof (char)))) U;
+typedef int __attribute__((__vector_size__ (16 * sizeof (int)))) V;
+
+void bar ();
+
+bar (int i, int j, int k, V v)
+{
+}
+
+void
+foo (void)
+{
+  bar ((V){}, (V){}, (V){}, (U){});
+}
diff --git a/gcc/testsuite/gcc.dg/pr105173.c b/gcc/testsuite/gcc.dg/pr105173.c
new file mode 100644
index 00000000000..3effb2996b0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105173.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-Ofast" } */
+
+int i;
+
+int
+foo(char c, _Decimal32 d)
+{
+  d *= i;
+  d *= -(_Decimal64)c;
+  return d;
+}
diff --git a/gcc/testsuite/gcc.dg/pr105250.c b/gcc/testsuite/gcc.dg/pr105250.c
new file mode 100644
index 00000000000..4683e0e63a2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105250.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-w -Wno-psabi -O2" } */
+/* { dg-skip-if "PR105266" { powerpc*-*-* s390*-*-* } } */
+
+typedef int __attribute__((__vector_size__(4))) T;
+typedef int __attribute__((__vector_size__(8))) U;
+typedef int __attribute__((__vector_size__(16))) V;
+typedef int __attribute__((__vector_size__(32))) W;
+typedef _Float32 __attribute__((__vector_size__(16))) F;
+typedef _Float64 __attribute__((__vector_size__(32))) G;
+void foo();
+
+foo(int, int, int, int, U, U, V, V, W, W, int,
+     T, int, U, U, V, V, W, W, T,
+     T, int, U, U, V, V, W, W, T,
+     T, int, W, W, T, T, int, int, int,
+     int, int, int, W, int, int, int, int, int, int,
+     V, W, T, int, int, U, F, int, int, int,
+     int, int, int, G)
+{
+  foo(0, 0, 0, 0, (U){}, (U){}, (V){}, (V){}, (W){},
+       (W){}, 2, (T){}, 0, 0, 0, 0, (U){}, (U){},
+       (V){}, (V){}, (W){}, (W){}, (T){},
+       (T){}, 0, 0, 0, 0, (U){}, (U){}, (V){},
+       (V){}, (W){}, (W){}, (T){}, (T){}, 0, 0, 0,
+       0, 0, 0, (T){},
+       (T){}, (W){},
+       (W){}, (T){}, (T){}, 0, 0, 0, 0, 0, 0, (W){},
+       (V){}, (W){}, (T){}, 0, 0, (U){}, (F){});
+}
diff --git a/gcc/testsuite/gcc.dg/pr105257.c b/gcc/testsuite/gcc.dg/pr105257.c
new file mode 100644
index 00000000000..4232942d791
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105257.c
@@ -0,0 +1,16 @@
+/* PR target/105257 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+extern int sigsetjmp (void **, int);
+void *buf[32];
+void (*fn) (void);
+
+const char *
+bar (void)
+{
+  sigsetjmp (buf, 0);
+  fn ();
+  return "";
+}
diff --git a/gcc/testsuite/gcc.dg/pr105263.c b/gcc/testsuite/gcc.dg/pr105263.c
new file mode 100644
index 00000000000..5cb7fcd09a2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105263.c
@@ -0,0 +1,15 @@
+/* { dg-do compile { target dfp } } */
+/* { dg-options "-O -ffast-math -w -Wno-psabi" } */
+
+typedef _Decimal64 __attribute__((__vector_size__ (8))) U;
+typedef _Decimal64 __attribute__((__vector_size__ (16))) V;
+
+V v;
+
+U
+foo (U u)
+{
+  u *= u;
+  u *= -(U){ v[1] };
+  return u;
+}
diff --git a/gcc/testsuite/gcc.dg/pr105331.c b/gcc/testsuite/gcc.dg/pr105331.c
new file mode 100644
index 00000000000..06cf6d6d901
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105331.c
@@ -0,0 +1,11 @@
+/* PR target/105331 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+#include <stdarg.h>
+
+int
+foo (va_list *va)
+{
+  return va_arg (*va, double _Complex);	/* { dg-bogus "may be used uninitialized" } */
+}
diff --git a/gcc/testsuite/gcc.dg/pr105333.c b/gcc/testsuite/gcc.dg/pr105333.c
new file mode 100644
index 00000000000..bd8bd4cd56c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105333.c
@@ -0,0 +1,21 @@
+/* PR rtl-optimization/105333 */
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-Og -fno-tree-coalesce-vars -fno-tree-fre" } */
+
+int g;
+short s;
+
+static inline unsigned short
+bar (short a, __int128 b)
+{
+  b ^= (unsigned long) -a;
+  __builtin_strncpy ((void *) &s, (void *) &a, 1);
+  b *= 14;
+  return b;
+}
+
+void
+foo (void)
+{
+  g *= (__int128) bar (1, 1);
+}
diff --git a/gcc/testsuite/gcc.dg/pr105528.c b/gcc/testsuite/gcc.dg/pr105528.c
new file mode 100644
index 00000000000..e380d56ee06
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105528.c
@@ -0,0 +1,23 @@
+/* PR tree-optimization/105528 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wno-psabi -fcompare-debug" } */
+/* { dg-additional-options "-mavx512f" { target i?86-*-* x86_64-*-* } } */
+
+typedef unsigned V __attribute__((__vector_size__ (64)));
+V g;
+
+V
+bar (V v)
+{
+  V w;
+  v <<= (V){(V){}[53]} >= v & 5;
+  w[w[5]] -= ~0;
+  v %= ~0;
+  return v + w;
+}
+
+void
+foo (void)
+{
+  g -= (V){bar((V){~0})[3]};
+}
diff --git a/gcc/testsuite/gcc.dg/pr106027.c b/gcc/testsuite/gcc.dg/pr106027.c
new file mode 100644
index 00000000000..735205fb252
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr106027.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+int
+foo (unsigned int x, int y)
+{
+  return x <= (((y != y) < 0) ? y < 1 : 0);
+}
diff --git a/gcc/testsuite/gcc.dg/pr106189.c b/gcc/testsuite/gcc.dg/pr106189.c
new file mode 100644
index 00000000000..0eca8343c56
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr106189.c
@@ -0,0 +1,5 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Warray-bounds=2 -w" } */
+
+int a_n_0_0_a[][0];
+void a_n_0_0() { T(((char *)a_n_0_0_a)[1]); }
diff --git a/gcc/testsuite/gcc.dg/pr106719.c b/gcc/testsuite/gcc.dg/pr106719.c
new file mode 100644
index 00000000000..772bd4a2d3e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr106719.c
@@ -0,0 +1,13 @@
+/* PR debug/106719 */
+/* { dg-do compile { target sync_char_short } } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+extern short int esi, easi[2];
+
+void
+foo (void)
+{
+  short int *psi = &easi[1];
+  __atomic_nand_fetch (psi, esi, 0);
+  psi = &easi[1];
+}
diff --git a/gcc/testsuite/gcc.dg/pr107107.c b/gcc/testsuite/gcc.dg/pr107107.c
new file mode 100644
index 00000000000..5ad6a63159e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr107107.c
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-tail-merge" } */
+
+static inline void set_longish(int is_long_long, void *p, long x)
+{
+  if (is_long_long)
+    *(long long*)p = x;
+  else
+    *(long*)p = x;
+}
+static long test(long long *p, int index, int mode)
+{
+  *p = 1;
+  set_longish(mode, p+index, 2);
+  return *p;
+}
+long (*volatile vtest)(long long*, int, int) = test;
+int main(void)
+{
+  long long x;
+  long result = vtest(&x, 0, 1);
+  if (result != 2 || x != 2)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr107127.c b/gcc/testsuite/gcc.dg/pr107127.c
new file mode 100644
index 00000000000..d25cced6b33
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr107127.c
@@ -0,0 +1,13 @@
+/* PR c/107127 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+int *v;
+
+_Complex double
+foo (_Complex double a, double b, double c)
+{
+  return v[0] / ((((c * (0 - 0 / a + 699.0 + 7.05 - 286.0 - +-4.65 + 1.57 + 0) * 0.1 - 3.28 + 4.22 + 0.1)) * b + 5.06)
+		 * 1.23 * 8.0 * 12.0 * 16.0 * 2.0 * 2.0 * 0.25 * 0.125 * 18.2 * -15.25 * 0.0001
+		 * 42.0 * 0.012 - 8.45 + 0 + 88.0 + 6.96 + 867.0 + 9.10 - 7.04 * -1.0);
+}
diff --git a/gcc/testsuite/gcc.dg/pr107554.c b/gcc/testsuite/gcc.dg/pr107554.c
new file mode 100644
index 00000000000..61ef2bcd90a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr107554.c
@@ -0,0 +1,12 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O -foptimize-strlen" } */
+
+#define ELEMS 0x40000000
+
+int a[ELEMS];
+int b[ELEMS];
+
+int main()
+{
+  __builtin_memcpy(a, b, ELEMS*sizeof(int));
+}
diff --git a/gcc/testsuite/gcc.dg/pr108095.c b/gcc/testsuite/gcc.dg/pr108095.c
new file mode 100644
index 00000000000..fb76caae72e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr108095.c
@@ -0,0 +1,15 @@
+/* PR tree-optimization/108095 */
+/* { dg-do compile } */
+/* { dg-options "-Os -g" } */
+
+int v;
+typedef unsigned T;
+
+void
+foo (void)
+{
+  unsigned s;
+  asm goto ("" : "=r" (*(T *) &s) : : : lab);
+  v = 0;
+lab:
+}
diff --git a/gcc/testsuite/gcc.dg/pr108264.c b/gcc/testsuite/gcc.dg/pr108264.c
new file mode 100644
index 00000000000..ff9aa261d67
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr108264.c
@@ -0,0 +1,27 @@
+/* PR middle-end/108264 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+int v;
+extern int bar (void);
+
+static inline void
+foo (char *d)
+{
+  switch (bar ())
+    {
+    case 2:
+      d[0] = d[1] = d[2] = d[3] = v;
+      break;
+    case 4:
+      d[0] = 0;
+    }
+}
+
+int
+baz (int x)
+{
+  foo ((char *) &x);
+  return x;
+}
diff --git a/gcc/testsuite/gcc.dg/pr108573.c b/gcc/testsuite/gcc.dg/pr108573.c
new file mode 100644
index 00000000000..5dd18043b2b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr108573.c
@@ -0,0 +1,18 @@
+/* PR debug/108573 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fcompare-debug" } */
+
+unsigned g;
+
+int bar (void);
+int baz (int);
+
+void
+foo (unsigned short s, long l)
+{
+  unsigned u = bar ();
+  s &= __builtin_add_overflow_p (0, u, 0);
+  s %= g;
+  s -= l >> s;
+  baz (s);
+}
diff --git a/gcc/testsuite/gcc.dg/pr108625.c b/gcc/testsuite/gcc.dg/pr108625.c
new file mode 100644
index 00000000000..03fc2889c4f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr108625.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-forwprop1 -fdump-tree-optimized" } */
+
+unsigned char foo(int x)
+{
+  int t = -x;
+  unsigned char t1 = t;
+  unsigned char t2 = t;
+  /* We may not rewrite this as (unsigned char)(t - x).  */
+  return t1 + t2;
+}
+
+/* { dg-final { scan-tree-dump-times "x_" 1 "forwprop1" } } */
+/* { dg-final { scan-tree-dump-times "x_" 1 "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/pr108692.c b/gcc/testsuite/gcc.dg/pr108692.c
new file mode 100644
index 00000000000..fc25bf54e45
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr108692.c
@@ -0,0 +1,31 @@
+/* PR tree-optimization/108692 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-vectorize" } */
+
+__attribute__((noipa)) int
+foo (signed char *x, signed char *y, int n)
+{
+  int i, r = 0;
+  signed char a, b;
+  for (i = 0; i < n; i++)
+    {
+      a = x[i];
+      b = y[i];
+      int c = (unsigned char) a - (unsigned char) b;
+      r = r + (c < 0 ? -c : c);
+    }
+  return r;
+}
+
+int
+main ()
+{
+  signed char x[64] = {}, y[64] = {};
+  if (__CHAR_BIT__ != 8 || __SIZEOF_INT__ != 4)
+    return 0;
+  x[32] = -128;
+  y[32] = 1;
+  if (foo (x, y, 64) != 127)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr109410.c b/gcc/testsuite/gcc.dg/pr109410.c
new file mode 100644
index 00000000000..a6401fc100c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr109410.c
@@ -0,0 +1,19 @@
+/* PR tree-optimization/109410 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+__attribute__((returns_twice)) int baz (int, int);
+
+int
+bar (int x)
+{
+  return x;
+}
+
+int
+foo (int x, int y)
+{
+  baz (x, y);
+  int a = bar (x);
+  return y || a == 42 || a > 42;
+}
diff --git a/gcc/testsuite/gcc.dg/pr111015.c b/gcc/testsuite/gcc.dg/pr111015.c
new file mode 100644
index 00000000000..599a14e6ecc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr111015.c
@@ -0,0 +1,28 @@
+/* PR tree-optimization/111015 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-O2" } */
+
+struct S { unsigned a : 4, b : 4; unsigned __int128 c : 70; } d;
+
+__attribute__((noipa)) void
+foo (unsigned __int128 x, unsigned char y, unsigned char z)
+{
+  d.a = y;
+  d.b = z;
+  d.c = x;
+}
+
+int
+main ()
+{
+  foo (-1, 12, 5);
+  if (d.a != 12
+      || d.b != 5
+      || d.c != (-1ULL | (((unsigned __int128) 0x3f) << 64)))
+    __builtin_abort ();
+  foo (0x123456789abcdef0ULL | (((unsigned __int128) 26) << 64), 7, 11);
+  if (d.a != 7
+      || d.b != 11
+      || d.c != (0x123456789abcdef0ULL | (((unsigned __int128) 26) << 64)))
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/pr64536.c b/gcc/testsuite/gcc.dg/pr64536.c
index f2728fbc938..18afa9d0232 100644
--- a/gcc/testsuite/gcc.dg/pr64536.c
+++ b/gcc/testsuite/gcc.dg/pr64536.c
@@ -40,8 +40,8 @@ bar (int x)
 	      h->q = *f;
 	    }
 	  else
-	    i = (long *) (h->q = *f);
-	  *c++ = (long) f;
+	    i = (long *) (__INTPTR_TYPE__) (h->q = *f);
+	  *c++ = (__INTPTR_TYPE__) f;
 	  e += 6;
 	}
       else
@@ -54,8 +54,8 @@ bar (int x)
 	      h->q = *f;
 	    }
 	  else
-	    i = (long *) (h->q = *f);
-	  *c++ = (long) f;
+	    i = (long *) (__INTPTR_TYPE__) (h->q = *f);
+	  *c++ = (__INTPTR_TYPE__) f;
 	  e += 6;
 	}
     }
diff --git a/gcc/testsuite/gcc.dg/pragma-message.c b/gcc/testsuite/gcc.dg/pragma-message.c
index 2f44b617710..1b7cf09de0a 100644
--- a/gcc/testsuite/gcc.dg/pragma-message.c
+++ b/gcc/testsuite/gcc.dg/pragma-message.c
@@ -42,9 +42,11 @@
 #pragma message ("Okay " THREE)  /* { dg-message "Okay 3" } */
 
 /* Create a TODO() that prints a message on compilation.  */
-#define DO_PRAGMA(x) _Pragma (#x)
-#define TODO(x) DO_PRAGMA(message ("TODO - " #x))
-TODO(Okay 4)                     /* { dg-message "TODO - Okay 4" } */
+#define DO_PRAGMA(x) _Pragma (#x) /* { dg-line pragma_loc1 } */
+#define TODO(x) DO_PRAGMA(message ("TODO - " #x)) /* { dg-line pragma_loc2 } */
+TODO(Okay 4) /* { dg-message "in expansion of macro 'TODO'" } */
+/* { dg-message "TODO - Okay 4" "test4.1" { target *-*-* } pragma_loc1 } */
+/* { dg-message "in expansion of macro 'DO_PRAGMA'" "test4.2" { target *-*-* } pragma_loc2 } */
 
 #if 0
 #pragma message ("Not printed")
diff --git a/gcc/testsuite/gcc.dg/sso-17.c b/gcc/testsuite/gcc.dg/sso-17.c
new file mode 100644
index 00000000000..67e2d3793fd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/sso-17.c
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#define REV_ENDIANNESS __attribute__((scalar_storage_order("big-endian")))
+#else
+#define REV_ENDIANNESS __attribute__((scalar_storage_order("little-endian")))
+#endif
+
+typedef unsigned long long u64;
+
+union DST {
+  u64 val;
+
+  struct {
+    u64 x : 1;
+    u64 y : 1;
+    u64 r: 62;
+  } REV_ENDIANNESS;
+} REV_ENDIANNESS;
+
+
+struct SRC {
+  u64 a;
+} REV_ENDIANNESS;
+
+[[gnu::noipa]]
+void foo () {__builtin_abort();}
+
+[[gnu::noinline]]
+int bar(struct SRC *src)
+{
+  union DST dst;
+  
+  dst.val = src->a;
+
+  if (dst.y) {
+    foo();
+  }
+  return 0;
+}
+
+int main(void)
+{
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+  struct SRC t = {-1ull & (~(0x01ull<<62))};
+#else
+  struct SRC t = {-1ull & (~(0x01ull<<1))};
+#endif
+  bar(&t);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105148.c b/gcc/testsuite/gcc.dg/torture/pr105148.c
new file mode 100644
index 00000000000..3338b0f3281
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105148.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+
+extern void foo (void);
+
+static inline int
+bar (int n)
+{
+  for (int i = 0; i < n; i++)
+    {
+      foo ();
+      int y[1][i];
+      y[n][i] = 0;
+    }
+}
+
+int
+baz (void)
+{
+  return bar (5);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105163.c b/gcc/testsuite/gcc.dg/torture/pr105163.c
new file mode 100644
index 00000000000..23e04107f68
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105163.c
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target nonlocal_goto } */
+
+#include <setjmp.h>
+
+extern int bar (unsigned int *);
+extern jmp_buf *baz (void);
+struct C { int c1; };
+void foo (struct C *x, int *z, int e)
+{
+  unsigned int d = 0;
+  long f;
+  setjmp (*baz());
+  f = 1 + ~d;
+  d = 8;
+  if ((!0) && !e && bar(z)) *z = 1 + f;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105484.c b/gcc/testsuite/gcc.dg/torture/pr105484.c
new file mode 100644
index 00000000000..f2a5eb8a7ee
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105484.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fnon-call-exceptions -fno-tree-dce -fno-tree-forwprop" } */
+/* { dg-additional-options "-march=cannonlake" { target x86_64-*-* i?86-*-* } } */
+
+typedef int __attribute__((__vector_size__ (16))) V;
+
+void bar (int i);
+
+void
+foo (int i)
+{
+  V v;
+  __builtin_mul_overflow (7, i, &v[i]);
+  bar ((V){}[3]);
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr105598.c b/gcc/testsuite/gcc.dg/torture/pr105598.c
new file mode 100644
index 00000000000..0a4ea3b0bd1
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr105598.c
@@ -0,0 +1,32 @@
+/* { dg-do run } */
+
+typedef struct { unsigned int num; } info_t;
+typedef struct { unsigned int flag, type; } block_t;
+info_t info;
+block_t blocks[] = { {2,0}, {3,0}, {1,0}, {1,0} };
+
+static block_t *
+f (info_t *i, block_t *b)
+{
+  while (1) {
+    unsigned int is_last = b->flag & 0x01;
+    i->num++;
+    if (b->flag & 0x02) {
+      if (b->type != 0x1) b->type = b->type;
+      b = f (i, b+1);
+    }
+    if (is_last)
+      break;
+    b++;
+  }
+  return b;
+}
+
+int
+main ()
+{
+  f(&info, &blocks[0]);
+  if (info.num != 4)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106112.c b/gcc/testsuite/gcc.dg/torture/pr106112.c
new file mode 100644
index 00000000000..bd7f63c0935
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106112.c
@@ -0,0 +1,16 @@
+/* { dg-do run } */
+
+__INT32_TYPE__ a = 5, b, c, d;
+__UINT64_TYPE__ e = 20862985922;
+int main()
+{
+  __UINT32_TYPE__ f = 4294967292;
+  e = e | f;
+  c = -1 % ((~f ^ 4294967292) - (e - d));
+  b = ~-~e % ~-d;
+  if (b)
+    a = 0;
+  if (a < 1)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106513.c b/gcc/testsuite/gcc.dg/torture/pr106513.c
new file mode 100644
index 00000000000..aa4f4d513d7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106513.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+
+typedef __INT64_TYPE__ int64_t;
+
+__attribute__((noinline)) int64_t
+swap64 (int64_t n)
+{
+  return (((n & (((int64_t) 0xff) )) << 56) |
+          ((n & (((int64_t) 0xff) << 8)) << 40) |
+          ((n & (((int64_t) 0xff) << 16)) << 24) |
+          ((n & (((int64_t) 0xff) << 24)) << 8) |
+          ((n & (((int64_t) 0xff) << 32)) >> 8) |
+          ((n & (((int64_t) 0xff) << 40)) >> 24) |
+          ((n & (((int64_t) 0xff) << 48)) >> 40) |
+          ((n & ((int64_t)(0xffull << 56))) >> 56));
+}
+
+int main (void)
+{
+  volatile int64_t n = 0x8000000000000000ll;
+
+  if (swap64(n) != 0xffffffffffffff80ll)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106809.c b/gcc/testsuite/gcc.dg/torture/pr106809.c
new file mode 100644
index 00000000000..11e158185cf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106809.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-Wuninitialized" } */
+
+int foo (int x, int *val)
+{
+  switch (x)
+    {
+#define C(n) \
+    case n + 0: return *val; \
+    case n + 1: return *val; \
+    case n + 2: return *val; \
+    case n + 3: return *val; \
+    case n + 4: return *val; \
+    case n + 5: return *val; \
+    case n + 6: return *val; \
+    case n + 7: return *val; \
+    case n + 8: return *val; \
+    case n + 9: return *val;
+#define C1(n) \
+    C(n+00) C(n+10) C(n+20) C(n+30) C(n+40) \
+    C(n+50) C(n+60) C(n+70) C(n+80) C(n+90)
+#define C10(n) \
+    C1(n+000) C1(n+100) C1(n+200) C1(n+300) C1(n+400) \
+    C1(n+500) C1(n+600) C1(n+700) C1(n+800) C1(n+900)
+    C10(1000)
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr106892.c b/gcc/testsuite/gcc.dg/torture/pr106892.c
new file mode 100644
index 00000000000..73a66a037b7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr106892.c
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+
+int a, b, c, d, e;
+int f[8];
+static int g() {
+  while (a)
+    a >>= 4;
+  return 0;
+}
+static int h(int i) {
+  if (i >= '0')
+    return i - '0';
+  //__builtin_unreachable ();
+}
+void __attribute__((noipa)) j(int i) {
+  for (b = 2; g() <= 7; b++)
+    if (i) {
+      for (; e <= 7; e++)
+        for (c = 1; c <= 7; c++) {
+          d = h(b + '0');
+          f[-d + 4] ^= 3;
+        }
+      return;
+    }
+}
+int main() {
+  j(1);
+  if (f[2] != 0)
+    __builtin_abort ();
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr107451.c b/gcc/testsuite/gcc.dg/torture/pr107451.c
new file mode 100644
index 00000000000..a17574c6896
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr107451.c
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-additional-options "-ftree-vectorize -fno-vect-cost-model" } */
+/* { dg-additional-options "-mavx2" { target avx2_runtime } } */
+
+double getdot(int n, const double *x, int inc_x, const double *y)
+{
+  int i, ix = 0;
+  double dot[4] = { 0.0, 0.0, 0.0, 0.0 } ;
+
+  for(i = 0; i < n; i++) {
+      dot[0] += x[ix]   * y[ix]   ;
+      dot[1] += x[ix+1] * y[ix+1] ;
+      dot[2] += x[ix]   * y[ix+1] ;
+      dot[3] += x[ix+1] * y[ix]   ;
+      ix += inc_x ;
+  }
+
+  return dot[0] + dot[1] + dot[2] + dot[3];
+}
+
+int main()
+{
+  double x[2] = {0, 0}, y[2] = {0, 0};
+  if (getdot(1, x, 4096*4096, y) != 0.)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr108076.c b/gcc/testsuite/gcc.dg/torture/pr108076.c
new file mode 100644
index 00000000000..ebe2e51bee0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr108076.c
@@ -0,0 +1,17 @@
+/* { dg-do link } */
+
+static void *j;
+int v, g;
+__attribute__((__leaf__)) int atoi (const char *);
+
+int
+main ()
+{
+  j = &&lab1;
+  &&lab2;
+  atoi ("42");
+lab1:
+lab2:
+  if (v)
+    goto *j;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr109585.c b/gcc/testsuite/gcc.dg/torture/pr109585.c
new file mode 100644
index 00000000000..f92de7c1f2e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr109585.c
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+#include <stdlib.h>
+
+struct P {
+    long v;
+    struct P *n;
+};
+
+struct F {
+    long x;
+    struct P fam[];
+};
+
+int __attribute__((noipa))
+f(struct F *f, int i)
+{
+  struct P *p = f->fam;
+  asm("" : "+r"(f): "r"(p));
+  p->v = 0;
+  p->n = 0;
+  return f->fam->n != 0;
+}
+
+int
+main()
+{
+  struct F *m = malloc (sizeof (long) + 2 * sizeof (struct P));
+  m->fam[0].n = &m->fam[1];
+  if (f (m, 0))
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-13.c b/gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-13.c
new file mode 100644
index 00000000000..87a94f5bf31
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-13.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-fre1" } */
+
+struct inn
+{
+  int val;
+};
+
+struct biggerstruct
+{
+  int a, b;
+};
+
+union foo
+{
+  struct inn inn;
+  struct biggerstruct baz;
+} *fooptr;
+
+struct bar
+{
+  union foo foo;
+  int val2;
+} *barptr;
+
+int
+test ()
+{
+  union foo foo;
+  foo.inn.val = 0;
+  barptr->val2 = 123;
+  *fooptr = foo;
+  return barptr->val2;
+}
+
+/* { dg-final { scan-tree-dump-times "return 123" 1 "fre1"} } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr105860.c b/gcc/testsuite/gcc.dg/tree-ssa/pr105860.c
new file mode 100644
index 00000000000..77bcb4a6739
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr105860.c
@@ -0,0 +1,63 @@
+/* { dg-do run } */
+/* { dg-options "-O1" } */
+
+struct S1  {
+        unsigned int _0;
+        unsigned int _1;
+} ;
+struct S2  {
+        struct S1 _s1;
+        unsigned long _x2;
+} ;
+
+struct ufld_type1  {
+        unsigned int _u1t;
+        struct S2 _s2;
+} ;
+
+struct ufld_type2  {
+        unsigned int _u2t;
+        struct S1 _s1;
+} ;
+struct parm_type {
+        union {
+                struct ufld_type1 var_1;
+                struct ufld_type2 var_2;
+        } U;
+};
+
+struct parm_type  bad_function( struct parm_type arg0 )
+{
+        struct parm_type rv;
+        struct S2 var4;
+        switch( arg0.U.var_2._u2t ) {
+        case 4294967041:
+                var4._s1 = arg0.U.var_1._s2._s1;
+                rv.U.var_1._u1t = 4294967041;
+                rv.U.var_1._s2 = var4;
+                break;
+        case 4294967043:
+                rv.U.var_2._u2t = 4294967043;
+                rv.U.var_2._s1 = arg0.U.var_2._s1;
+                break;
+        default:
+                break;
+        }
+        return rv;
+}
+
+int main() {
+        struct parm_type val;
+        struct parm_type out;
+        val.U.var_2._u2t = 4294967043;
+        val.U.var_2._s1._0 = 0x01010101;
+        val.U.var_2._s1._1 = 0x02020202;
+        out = bad_function(val);
+	if (val.U.var_2._u2t != 4294967043)
+	  __builtin_abort ();
+        if (out.U.var_2._s1._0 != 0x01010101)
+	  __builtin_abort ();
+        if (val.U.var_2._s1._1 != 0x02020202 )
+	  __builtin_abort ();
+	return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr107323.c b/gcc/testsuite/gcc.dg/tree-ssa/pr107323.c
new file mode 100644
index 00000000000..1204b6e36d5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr107323.c
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-vectorize" } */
+
+int A[4];
+int B[4];
+
+static const char *__attribute__((noipa)) foo()
+{
+  return "1";
+}
+
+int main()
+{
+  const char *s = foo();
+
+  A[0] = 1000;
+  for(int i = 1; i < 4; ++i) {
+      B[i] = 0;
+      A[i] = 0;
+      if(s[0])
+	B[i] = 1;
+      A[i] = A[i - 1];
+  }
+
+  if (A[3] != 1000)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-24.c b/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-24.c
new file mode 100644
index 00000000000..6b463490a91
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-24.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-lim2-details -fdump-tree-optimized" } */
+
+extern volatile int *x;
+static int gCrc;
+
+static int __attribute__((noinline)) crc16Add(int crc, int b)
+{
+  return crc + b;
+}
+
+void f(int data, int dataSz)
+{
+  int i;
+
+  for(i=0;i<dataSz;i++)
+  {
+    gCrc = crc16Add(gCrc, data);
+    *x = data;
+  }
+}
+
+/* { dg-final { scan-tree-dump "Executing store motion of gCrc" "lim2" } } */
+/* { dg-final { scan-tree-dump-not "Re-issueing" "lim2" } } */
+/* { dg-final { scan-tree-dump-times "\\*x" 1 "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-19.c b/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-19.c
new file mode 100644
index 00000000000..f3eb0ef3a4e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-19.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-sink-details -fdump-tree-cddce2-details" } */
+
+static int b=4;
+int c;
+
+int
+main()
+{
+  int e[5] = {1,1,1,1,1};
+  for (; b >= 0; b--) {
+    c = e[b];
+  }
+  return 0;
+}
+
+/* We should sink e[b] out of the loop which is possible after
+   applying store motion to c and b.  */
+/* { dg-final { scan-tree-dump "Sinking # VUSE" "sink" } } */
+/* And remove the loop after final value replacement.  */
+/* { dg-final { scan-tree-dump "fix_loop_structure: removing loop" "cddce2" } } */
diff --git a/gcc/testsuite/gcc.dg/ubsan/pr107183.c b/gcc/testsuite/gcc.dg/ubsan/pr107183.c
new file mode 100644
index 00000000000..e54a361c7c9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/ubsan/pr107183.c
@@ -0,0 +1,12 @@
+/* PR target/107183 */
+/* { dg-do compile } */
+/* { dg-options "-O -fsanitize=float-cast-overflow -fcompare-debug" } */
+
+long double a, b, c;
+
+int
+foo (void)
+{
+  unsigned u = b || __builtin_rintl (c);
+  return u + (unsigned) a;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
index 827687b92fa..8eb8baceb31 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
@@ -1,10 +1,11 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target vect_complex_add_float } */
+/* { dg-additional-options "-fno-tree-loop-vectorize" } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
 #define N 16
 #include "complex-mul-template.c"
 
-/* { dg-final { scan-tree-dump "Found COMPLEX_MUL_CONJ" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_MUL" "vect" } } */
+/* { dg-final { scan-tree-dump "Found COMPLEX_MUL_CONJ" "slp1" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump "Found COMPLEX_MUL" "slp1" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
index f935405e3d9..5cff373b80d 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
@@ -6,7 +6,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_double } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect"  { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect"  { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
index 71f391db7bb..312df88ee68 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
@@ -6,7 +6,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_float } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
index e5b826f1ca7..046f014240b 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
 /* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
@@ -6,5 +7,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_half } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect" { target { vect_complex_add_half } } } } */
+/* Vectorization is failing for these cases.  They should work but for now ignore.  */
+
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
index 5b70d834c24..9c8b99bc003 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
@@ -6,8 +6,7 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
index 3ef05645a2c..ca5f5b257d3 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
@@ -6,8 +6,7 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
index 06a9216add7..c6617f5dad0 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-require-effective-target vect_float } */
+/* { dg-require-effective-target vect_complex_add_half } */
 /* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
@@ -7,10 +7,8 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_half } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_half } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_half } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_half } && ! target { arm*-*-* } } } } */
 
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
index 34146f3d1e7..7beb6b8b5d8 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
@@ -1,5 +1,7 @@
 /* { dg-do compile } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 
 #define TYPE _Float16
 #define N 200
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
index 0982a2b8ead..fc4cd6151c7 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_double } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE double
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
index a069533b22a..43a77ff8591 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
@@ -1,10 +1,10 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_float } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
 #define N 200
 #include "complex-mls-template.c"
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMA" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS_CONJ" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
index 89ac54c2a42..3d1c5755bef 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
@@ -1,9 +1,10 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
 #define TYPE _Float16
 #define N 200
 #include "complex-mls-template.c"
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS_CONJ" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
index 56a8ea4ae02..b6b21529a10 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_double } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE double
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
index 969416d7dc7..aa8efb4c2db 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_float } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
index da1b9213a6b..51331625745 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
@@ -1,4 +1,6 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
 #define TYPE _Float16
diff --git a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
index 72b4930d9bb..c57f065cccd 100644
--- a/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
+++ b/gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c
@@ -46,5 +46,5 @@ int main (void)
   return main1 ();
 } 
 
-/* { dg-final { scan-tree-dump-times "not vectorized: unsupported unaligned store" 1 "vect" { target { ! vect_hw_misalign } } } } */
+/* { dg-final { scan-tree-dump-times "unsupported unaligned access" 1 "vect" { target { ! vect_hw_misalign } } } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 0 "vect" { target { ! vect_hw_misalign } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr103116-1.c b/gcc/testsuite/gcc.dg/vect/pr103116-1.c
new file mode 100644
index 00000000000..d3639fc8cfd
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr103116-1.c
@@ -0,0 +1,50 @@
+/* { dg-require-effective-target mmap } */
+
+#include <sys/mman.h>
+#include <stdio.h>
+
+#define COUNT 128
+#define MMAP_SIZE 0x20000
+#define ADDRESS 0x1122000000
+#define TYPE unsigned int
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+void __attribute__((noipa))
+loop (TYPE *restrict x, TYPE *restrict y)
+{
+  for (int i = 0; i < COUNT; ++i)
+    {
+      x[i * 4] = y[i * 2] + 1;
+      x[i * 4 + 1] = y[i * 2] + 2;
+      x[i * 4 + 2] = y[i * 2 + 1] + 3;
+      x[i * 4 + 3] = y[i * 2 + 1] + 4;
+    }
+}
+
+TYPE x[COUNT * 4];
+
+int
+main (void)
+{
+  void *y;
+  TYPE *end_y;
+
+  y = mmap ((void *) ADDRESS, MMAP_SIZE, PROT_READ | PROT_WRITE,
+            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  if (y == MAP_FAILED)
+    {
+      perror ("mmap");
+      return 1;
+    }
+
+  end_y = (TYPE *) ((char *) y + MMAP_SIZE);
+
+  loop (x, end_y - COUNT * 2);
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "Data access with gaps requires scalar epilogue loop" "vect" { target { vect_perm && vect_int } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr103116-2.c b/gcc/testsuite/gcc.dg/vect/pr103116-2.c
new file mode 100644
index 00000000000..2f4ed0f404c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr103116-2.c
@@ -0,0 +1,59 @@
+/* { dg-require-effective-target mmap } */
+/* { dg-additional-options "-mssse3" { target x86_64-*-* i?86-*-* } } */
+
+#include <sys/mman.h>
+#include <stdio.h>
+#include "tree-vect.h"
+
+#define COUNT 128
+#define MMAP_SIZE 0x20000
+#define ADDRESS 0x1122000000
+#define TYPE unsigned short
+#define GROUP_SIZE 2
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+void __attribute__((noipa))
+loop (TYPE *restrict x, TYPE *restrict y)
+{
+  for (int i = 0; i < COUNT; ++i)
+    {
+      x[i * 8] = y[i * GROUP_SIZE] + 1;
+      x[i * 8 + 1] = y[i * GROUP_SIZE] + 2;
+      x[i * 8 + 2] = y[i * GROUP_SIZE + 1] + 3;
+      x[i * 8 + 3] = y[i * GROUP_SIZE + 1] + 4;
+      x[i * 8 + 4] = y[i * GROUP_SIZE] + 5;
+      x[i * 8 + 5] = y[i * GROUP_SIZE] + 6;
+      x[i * 8 + 6] = y[i * GROUP_SIZE + 1] + 7;
+      x[i * 8 + 7] = y[i * GROUP_SIZE + 1] + 8;
+    }
+}
+
+TYPE x[COUNT * 4];
+
+int
+main (void)
+{
+  void *y;
+  TYPE *end_y;
+
+  check_vect ();
+
+  y = mmap ((void *) ADDRESS, MMAP_SIZE, PROT_READ | PROT_WRITE,
+            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  if (y == MAP_FAILED)
+    {
+      perror ("mmap");
+      return 1;
+    }
+
+  end_y = (TYPE *) ((char *) y + MMAP_SIZE);
+
+  loop (x, end_y - COUNT * GROUP_SIZE);
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "peeling for gaps insufficient for access" "vect" { target { vect_perm_short } } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr107212-1.c b/gcc/testsuite/gcc.dg/vect/pr107212-1.c
new file mode 100644
index 00000000000..5343f9b6b23
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr107212-1.c
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+int main()
+{
+  check_vect ();
+
+  unsigned int tab[6][2] = { {69, 73}, {36, 40}, {24, 16},
+        {16, 11}, {4, 5}, {3, 1} };
+
+  int sum_0 = 0;
+  int sum_1 = 0;
+
+  for(int t=0; t<6; t++) {
+      sum_0 += tab[t][0];
+      sum_1 += tab[t][1];
+  }
+
+  int x1 = (sum_0 < 100);
+  int x2 = (sum_0 > 200);
+
+  if (x1 || x2 || sum_1 != 146)
+    __builtin_abort ();
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr107212-2.c b/gcc/testsuite/gcc.dg/vect/pr107212-2.c
new file mode 100644
index 00000000000..109c2b991a6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr107212-2.c
@@ -0,0 +1,23 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+int sum_1 = 0;
+
+int main()
+{
+  check_vect ();
+
+  unsigned int tab[6][2] = {{150, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}};
+  
+  int sum_0 = 0;
+  
+  for (int t = 0; t < 6; t++) {
+    sum_0 += tab[t][0];
+    sum_1 += tab[t][0];
+  }
+  
+  if (sum_0 < 100 || sum_0 > 200)
+    __builtin_abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr108950.c b/gcc/testsuite/gcc.dg/vect/pr108950.c
new file mode 100644
index 00000000000..ecf076c964b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr108950.c
@@ -0,0 +1,14 @@
+/* { dg-require-effective-target vect_simd_clones } */
+/* { dg-do compile } */
+
+int m;
+short int n;
+
+__attribute__ ((simd)) int
+foo (void)
+{
+  m += n;
+  m += n;
+}
+
+/* { dg-final { scan-tree-dump-not "widen_sum" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr109473.c b/gcc/testsuite/gcc.dg/vect/pr109473.c
new file mode 100644
index 00000000000..9dee5515dc6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr109473.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O" } */
+
+struct spa_buffer {
+  __UINT32_TYPE__ *metas;
+};
+void do_port_use_buffers(struct spa_buffer **buffers, void *endptr, void *mem)
+{
+  for (int i = 0; i < 128; i++)
+    {
+      for (int j = 0; j < 128; j++)
+	endptr = (void *)((__UINTPTR_TYPE__)endptr + buffers[i]->metas[j]);
+      if (endptr > mem)
+	return;
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr109502.c b/gcc/testsuite/gcc.dg/vect/pr109502.c
new file mode 100644
index 00000000000..970c63e931b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr109502.c
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+/* { dg-additional-options "-O" } */
+
+unsigned g;
+
+unsigned
+foo (void)
+{
+  unsigned a = !g;
+  a += !(a % 6);
+  return a;
+}
+
+int
+main ()
+{
+  unsigned x = foo ();
+  if (x != 1)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr97428.c b/gcc/testsuite/gcc.dg/vect/pr97428.c
index bbd743a76c4..ad6416096aa 100644
--- a/gcc/testsuite/gcc.dg/vect/pr97428.c
+++ b/gcc/testsuite/gcc.dg/vect/pr97428.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_double } */
 
 typedef struct { double re, im; } dcmlx_t;
 typedef struct { double re[4], im[4]; } dcmlx4_t;
diff --git a/gcc/testsuite/gcc.dg/vect/vect.exp b/gcc/testsuite/gcc.dg/vect/vect.exp
index dca9a4db6f6..3c60eff7072 100644
--- a/gcc/testsuite/gcc.dg/vect/vect.exp
+++ b/gcc/testsuite/gcc.dg/vect/vect.exp
@@ -118,7 +118,7 @@ et-dg-runtest dg-runtest [lsort \
 set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS
 lappend DEFAULT_VECTCFLAGS "-ffast-math"
 et-dg-runtest dg-runtest [lsort \
-	[glob -nocomplain $srcdir/$subdir/fast-math-\[ipsv\]*.\[cS\]]] \
+	[glob -nocomplain $srcdir/$subdir/fast-math-\[ipsvc\]*.\[cS\]]] \
 	"" $DEFAULT_VECTCFLAGS
 
 # -ffast-math SLP tests
diff --git a/gcc/testsuite/gcc.target/aarch64/acle/data-intrinsics.c b/gcc/testsuite/gcc.target/aarch64/acle/data-intrinsics.c
new file mode 100644
index 00000000000..e067ef20bbd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/acle/data-intrinsics.c
@@ -0,0 +1,468 @@
+/* Test the ACLE data intrinsics.  */
+/* { dg-do assemble } */
+/* { dg-additional-options "--save-temps -O1" } */
+/* { dg-final { check-function-bodies "**" "" "" } } */
+
+#include "arm_acle.h"
+
+/*
+** test_clz:
+**	clz	w0, w0
+**	ret
+*/
+
+unsigned int test_clz (uint32_t a)
+{
+  return __clz (a);
+}
+
+/*
+** test_clzl:
+**	clz	[wx]0, [wx]0
+**	ret
+*/
+
+unsigned int test_clzl (unsigned long a)
+{
+  return __clzl (a);
+}
+
+/*
+** test_clzll:
+**	clz	x0, x0
+**	ret
+*/
+
+unsigned int test_clzll (uint64_t a)
+{
+  return __clzll (a);
+}
+
+/*
+** test_cls:
+**	cls	w0, w0
+**	ret
+*/
+
+unsigned int test_cls (uint32_t a)
+{
+  return __cls (a);
+}
+
+/*
+** test_clsl:
+**	cls	[wx]0, [wx]0
+**	ret
+*/
+
+unsigned int test_clsl (unsigned long a)
+{
+  return __clsl (a);
+}
+
+/*
+** test_clsll:
+**	cls	x0, x0
+**	ret
+*/
+
+unsigned int test_clsll (uint64_t a)
+{
+  return __clsll (a);
+}
+
+/*
+** test_rbit:
+**	rbit	w0, w0
+**	ret
+*/
+
+uint32_t test_rbit (uint32_t a)
+{
+  return __rbit (a);
+}
+
+/*
+** test_rbitl:
+**	rbit	[wx]0, [wx]0
+**	ret
+*/
+
+unsigned long test_rbitl (unsigned long a)
+{
+  return __rbitl (a);
+}
+
+/*
+** test_rbitll:
+**	rbit	x0, x0
+**	ret
+*/
+
+uint64_t test_rbitll (uint64_t a)
+{
+  return __rbitll (a);
+}
+
+/*
+** test_rev:
+**	rev	w0, w0
+**	ret
+*/
+
+uint32_t test_rev (uint32_t a)
+{
+  return __rev (a);
+}
+
+/*
+** test_revl:
+**	rev	[wx]0, [wx]0
+**	ret
+*/
+
+unsigned long test_revl (unsigned long a)
+{
+  return __revl (a);
+}
+
+/*
+** test_revll:
+**	rev	x0, x0
+**	ret
+*/
+
+uint64_t test_revll (uint64_t a)
+{
+  return __revll (a);
+}
+
+/*
+** test_rev16:
+**	rev16	w0, w0
+**	ret
+*/
+
+uint32_t test_rev16 (uint32_t a)
+{
+  return __rev16 (a);
+}
+
+/*
+** test_rev16l:
+**	rev16	[wx]0, [wx]0
+**	ret
+*/
+
+unsigned long test_rev16l (unsigned long a)
+{
+  return __rev16l (a);
+}
+
+/*
+** test_rev16ll:
+**	rev16	x0, x0
+**	ret
+*/
+
+uint64_t test_rev16ll (uint64_t a)
+{
+  return __rev16ll (a);
+}
+
+/*
+** test_ror:
+**	ror	w0, w0, w1
+**	ret
+*/
+
+uint32_t test_ror (uint32_t a, uint32_t r)
+{
+  return __ror (a, r);
+}
+
+/*
+** test_rorl:
+**	ror	[wx]0, [wx]0, [wx]1
+**	ret
+*/
+
+unsigned long test_rorl (unsigned long a, uint32_t r)
+{
+  return __rorl (a, r);
+}
+
+/*
+** test_rorll:
+**	ror	x0, x0, x1
+**	ret
+*/
+
+uint64_t test_rorll (uint64_t a, uint32_t r)
+{
+  return __rorll (a, r);
+}
+
+/*
+** test_revsh:
+**	rev16	w0, w0
+**	ret
+*/
+
+int16_t test_revsh (int16_t a)
+{
+  return __revsh (a);
+}
+
+uint32_t *g32;
+unsigned long *gul;
+uint64_t *g64;
+unsigned int *gui;
+int16_t *g16;
+
+/*
+** test_clz_mem:
+**	...
+**	clz	w[0-9]+, w[0-9]+
+**	...
+**	ret
+*/
+
+void test_clz_mem (uint32_t *a)
+{
+  *gui = __clz (*a);
+}
+
+/*
+** test_clzl_mem:
+**	...
+**	clz	[wx][0-9]+, [wx][0-9]+
+**	...
+**	ret
+*/
+
+void test_clzl_mem (unsigned long *a)
+{
+  *gui = __clzl (*a);
+}
+
+/*
+** test_clzll_mem:
+**	...
+**	clz	x[0-9]+, x[0-9]+
+**	...
+**	ret
+*/
+
+void test_clzll_mem (uint64_t *a)
+{
+  *gui = __clzll (*a);
+}
+
+/*
+** test_cls_mem:
+**	...
+**	cls	w[0-9]+, w[0-9]+
+**	...
+**	ret
+*/
+
+void test_cls_mem (uint32_t *a)
+{
+  *gui = __cls (*a);
+}
+
+/*
+** test_clsl_mem:
+**	...
+**	cls	[wx][0-9]+, [wx][0-9]+
+**	...
+**	ret
+*/
+
+void test_clsl_mem (unsigned long *a)
+{
+  *gui = __clsl (*a);
+}
+
+/*
+** test_clsll_mem:
+**	...
+**	cls	x[0-9]+, x[0-9]+
+**	...
+**	ret
+*/
+
+void test_clsll_mem (uint64_t *a)
+{
+  *gui = __clsll (*a);
+}
+
+/*
+** test_rbit_mem:
+**	...
+**	rbit	w[0-9]+, w[0-9]+
+**	...
+**	ret
+*/
+
+void test_rbit_mem (uint32_t *a)
+{
+  *g32 = __rbit (*a);
+}
+
+/*
+** test_rbitl_mem:
+**	...
+**	rbit	[wx][0-9]+, [wx][0-9]+
+**	...
+**	ret
+*/
+
+void test_rbitl_mem (unsigned long *a)
+{
+  *gul = __rbitl (*a);
+}
+
+/*
+** test_rbitll_mem:
+**	...
+**	rbit	x[0-9]+, x[0-9]+
+**	...
+**	ret
+*/
+
+void test_rbitll_mem (uint64_t *a)
+{
+  *g64 = __rbitll (*a);
+}
+
+/*
+** test_rev_mem:
+**	...
+**	rev	w[0-9]+, w[0-9]+
+**	...
+**	ret
+*/
+
+void test_rev_mem (uint32_t *a)
+{
+  *g32 = __rev (*a);
+}
+
+/*
+** test_revl_mem:
+**	...
+**	rev	[wx][0-9]+, [wx][0-9]+
+**	...
+**	ret
+*/
+
+void test_revl_mem (unsigned long *a)
+{
+  *gul = __revl (*a);
+}
+
+/*
+** test_revll_mem:
+**	...
+**	rev	x[0-9]+, x[0-9]+
+**	...
+**	ret
+*/
+
+void test_revll_mem (uint64_t *a)
+{
+  *g64 = __revll (*a);
+}
+
+/*
+** test_rev16_mem:
+**	...
+**	rev16	w[0-9]+, w[0-9]+
+**	...
+**	ret
+*/
+
+void test_rev16_mem (uint32_t *a)
+{
+  *g32 = __rev16 (*a);
+}
+
+/*
+** test_rev16l_mem:
+**	...
+**	rev16	[wx][0-9]+, [wx][0-9]+
+**	...
+**	ret
+*/
+
+void test_rev16l_mem (unsigned long *a)
+{
+  *gul = __rev16l (*a);
+}
+
+/*
+** test_rev16ll_mem:
+**	...
+**	rev16	x[0-9]+, x[0-9]+
+**	...
+**	ret
+*/
+
+void test_rev16ll_mem (uint64_t *a)
+{
+  *g64 = __rev16ll (*a);
+}
+
+/*
+** test_ror_mem:
+**	...
+**	ror	w[0-9]+, w[0-9]+, w[0-9]+
+**	...
+**	ret
+*/
+
+void test_ror_mem (uint32_t *a, uint32_t *r)
+{
+  *g32 = __ror (*a, *r);
+}
+
+/*
+** test_rorl_mem:
+**	...
+**	ror	[wx][0-9]+, [wx][0-9]+, [wx][0-9]+
+**	...
+**	ret
+*/
+
+void test_rorl_mem (unsigned long *a, uint32_t *r)
+{
+  *gul = __rorl (*a, *r);
+}
+
+/*
+** test_rorll_mem:
+**	...
+**	ror	x[0-9]+, x[0-9]+, x[0-9]+
+**	...
+**	ret
+*/
+
+void test_rorll_mem (uint64_t *a, uint32_t *r)
+{
+  *g64 = __rorll (*a, *r);
+}
+
+/*
+** test_revsh_mem:
+**	...
+**	rev16	w[0-9]+, w[0-9]+
+**	...
+**	ret
+*/
+
+void test_revsh_mem (int16_t *a)
+{
+  *g16 = __revsh (*a);
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/ampere1-no_ldp_combine.c b/gcc/testsuite/gcc.target/aarch64/ampere1-no_ldp_combine.c
new file mode 100644
index 00000000000..bc871f4481d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/ampere1-no_ldp_combine.c
@@ -0,0 +1,11 @@
+/* { dg-options "-O3 -mtune=ampere1" } */
+
+long
+foo (long a[])
+{
+  return a[0] + a[1];
+}
+
+/* We should see two ldrs instead of one ldp. */
+/* { dg-final { scan-assembler {\tldr\t} } } */
+/* { dg-final { scan-assembler-not {\tldp\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align16-O2-extra.c b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align16-O2-extra.c
new file mode 100644
index 00000000000..56f056daa27
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align16-O2-extra.c
@@ -0,0 +1,86 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+#define ALIGN 16
+//#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+/* In f1, f2, f4, f8, f16, f16p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 12 { xfail *-*-* } } } */
+/* In fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 10 { xfail *-*-* } } } */
+
+/* Bitfield parameter in registers.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} "" { target *-*-* } 47 } f1 */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} "" { target *-*-* } 48 } f2 */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} "" { target *-*-* } 49 } f4 */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} "" { target *-*-* } 50 } f8 */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 53 }  fp */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 54 } f1p */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 55 } f2p */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 56 } f4p */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 57 } f8p */
+
+/* Bitfield call argument in registers.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} ""  { target *-*-* } 60 } g1 */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} ""  { target *-*-* } 61 } g2 */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} ""  { target *-*-* } 62 } g4 */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} ""  { target *-*-* } 63 } g8 */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 66 }  gp */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 67 } g1p */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 68 } g2p */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 69 } g4p */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 70 } g8p */
+
+
+/* Bitfield parameter in stack.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} "" { target *-*-* } 74 } f1_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} "" { target *-*-* } 75 } f2_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} "" { target *-*-* } 76 } f4_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} "" { target *-*-* } 77 } f8_stack */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 80 }  fp_stack */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 81 } f1p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 82 } f2p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 83 } f4p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 84 } f8p_stack */
+
+/* Bitfield call argument in stack.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} ""  { target *-*-* } 87 } g1_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} ""  { target *-*-* } 88 } g2_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} ""  { target *-*-* } 89 } g4_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} ""  { target *-*-* } 90 } g8_stack */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 93 }  gp_stack */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 94 } g1p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 95 } g2p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 96 } g4p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 97 } g8p_stack */
+
+
+/* Bitfield parameter in stdarg.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} "" { target *-*-* } 101 } f1_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} "" { target *-*-* } 102 } f2_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} "" { target *-*-* } 103 } f4_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} "" { target *-*-* } 104 } f8_stdarg */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 107 }  fp_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 108 } f1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 109 } f2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 110 } f4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 111 } f8p_stdarg */
+
+/* Bitfield call argument in stdarg.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} ""  { target *-*-* } 114 } g1_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} ""  { target *-*-* } 115 } g2_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} ""  { target *-*-* } 116 } g4_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} ""  { target *-*-* } 117 } g8_stdarg */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 120 }  gp_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 121 } g1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 122 } g2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 123 } g4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 124 } g8p_stdarg */
diff --git a/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align16-O2.c b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align16-O2.c
new file mode 100644
index 00000000000..add33e479a6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align16-O2.c
@@ -0,0 +1,87 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+#define ALIGN 16
+#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+/* In f1, f2, f4, f8, f16, f16p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 12 { xfail *-*-* } } } */
+/* In fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 10 { xfail *-*-* } } } */
+
+/* Bitfield parameter in registers.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} "" { target *-*-* } 47 } f1 */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} "" { target *-*-* } 48 } f2 */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} "" { target *-*-* } 49 } f4 */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} "" { target *-*-* } 50 } f8 */
+
+/* No change in parameter passing in GCC 9.1 for lines 53-57 (fp, f1p, f2p,
+   f4p, f8p) (because the argument fits in a single register).  Should not
+   warn, but aarch64_function_arg_boundary would need to take the argument size
+   into account as well as whether it's passed via registers or the stack.  */
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 53 }  fp */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 54 } f1p */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 55 } f2p */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 56 } f4p */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 57 } f8p */
+
+/* Bitfield call argument in registers.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} ""  { target *-*-* } 60 } g1 */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} ""  { target *-*-* } 61 } g2 */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} ""  { target *-*-* } 62 } g4 */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} ""  { target *-*-* } 63 } g8 */
+
+/* No change in parameter passing in GCC 9.1 for lines 66-70 (gp, g1p, g2p,
+   g4p, g8p), no warning expected.  */
+
+
+/* Bitfield parameter in stack.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} "" { target *-*-* } 74 } f1_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} "" { target *-*-* } 75 } f2_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} "" { target *-*-* } 76 } f4_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} "" { target *-*-* } 77 } f8_stack */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 80 }  fp_stack */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 81 } f1p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 82 } f2p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 83 } f4p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 84 } f8p_stack */
+
+/* Bitfield call argument in stack.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} ""  { target *-*-* } 87 } g1_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} ""  { target *-*-* } 88 } g2_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} ""  { target *-*-* } 89 } g4_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} ""  { target *-*-* } 90 } g8_stack */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 93 }  gp_stack */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 94 } g1p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 95 } g2p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 96 } g4p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 97 } g8p_stack */
+
+
+/* Bitfield parameter in stdarg.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} "" { target *-*-* } 101 } f1_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} "" { target *-*-* } 102 } f2_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} "" { target *-*-* } 103 } f4_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} "" { target *-*-* } 104 } f8_stdarg */
+
+/* Parameter passing for these should not have changed in GCC 9.1 (PR 105549).
+   Fortunately we warn. Note the discrepancy with lines 120-124 below: we warn
+   in the callee, but not in the caller.  */
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1} "" { target *-*-* } 107 }  fp_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 108 } f1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 109 } f2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 110 } f4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 111 } f8p_stdarg */
+
+/* Bitfield call argument in stdarg.  */
+/* { dg-message {parameter passing for argument of type 'struct S1' changed in GCC 9.1} ""  { target *-*-* } 114 } g1_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2' changed in GCC 9.1} ""  { target *-*-* } 115 } g2_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4' changed in GCC 9.1} ""  { target *-*-* } 116 } g4_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8' changed in GCC 9.1} ""  { target *-*-* } 117 } g8_stdarg */
+
+/* No change in parameter passing in GCC 9.1 for lines 120-124 (gp_stdarg
+   g1p_stdarg, g2p_stdarg, g4p_stdarg, g8p_stdarg), no warning expected.  */
diff --git a/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align32-O2-extra.c b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align32-O2-extra.c
new file mode 100644
index 00000000000..3228bbc64e5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align32-O2-extra.c
@@ -0,0 +1,119 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+#define ALIGN 32
+//#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+
+/* In f1, f2, f4, f8, f16 (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "ldr\tx0, \\\[x1\\\]" 10 } } */
+
+/* In fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 10 { xfail *-*-* } } } */
+
+/* In f16p (and stdarg version):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 2 { xfail *-*-* } } } */
+
+/* In f1_stack, f2_stack, f4_stack, f8_stack, f16_stack, f8p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tx\[0-9\]+, \\\[sp, 8\\\]" 6 { xfail *-*-* } } } */
+
+/* In fp_stack, f1p_stack:  */
+/* { dg-final { scan-assembler-times "ldrb\tw0, \\\[sp, 8\\\]" 2 { xfail *-*-* } } } */
+
+/* In f2p_stack:  */
+/* { dg-final { scan-assembler-times "ldrh\tw0, \\\[sp, 8\\\]" 1 { xfail *-*-* } } } */
+
+/* In f4p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tw0, \\\[sp, 8\\\]" 1 { xfail *-*-* } } } */
+
+/* In f16p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tx0, \\\[sp, 16\\\]" 1 { xfail *-*-* } } } */
+
+/* Bitfield parameter in registers.  */
+/* No change in parameter passing in GCC 9.1 for lines 47-51 (f1, f2, f4, f8, f16)
+   because the overall alignment is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 53-57 (fp, f1p, f2p,
+   f4p, f8p) because the argument fits in a single register.  Should not warn,
+   but aarch64_function_arg_boundary would need to take the argument size into
+   account as well as whether it's passed via registers or the stack.  */
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1}  "" { target *-*-* } 53 } fp */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 54 } f1p */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 55 } f2p */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 56 } f4p */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 57 } f8p */
+
+/* Changed in GCC 9.1, but we fail to emit a warning since GCC 11 (was OK with GCC 9).  */
+/* { dg-message {parameter passing for argument of type 'struct S16p' changed in GCC 9.1} "" { xfail *-*-* } 58 } f16p */
+
+
+/* Bitfield call argument in registers.  */
+/* No change in parameter passing in GCC 9.1 for lines 60-64 (g1, g2, g4, g8, g16)
+   because the overall alignment is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 66-70 (gp, g1p, g2p,
+   g4p, g8p), no warning expected.  */
+
+/* Changed in GCC 9.1, but we fail to emit a warning.  */
+/* { dg-message {parameter passing for argument of type 'struct S16p' changed in GCC 9.1} "" { xfail *-*-* } 71 } g16p */
+
+
+/* Bitfield parameter in stack.  */
+/* No change in parameter passing in GCC 9.1 for lines 74-78 (f1_stack,
+   f2_stack, f4_stack, f8_stack, f16_stack) because the overall alignment is >
+   16.  No warning expected.  */
+
+/* Changed in GCC 9.1.  */
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1}  "" { target *-*-* } 80 } fp_stack */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 81 } f1p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 82 } f2p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 83 } f4p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 84 } f8p_stack */
+
+/* No change in parameter passing in GCC 9.1 for line 85 (f16p_stack) because
+   the overall alignment is >= 16.  No warning expected.  */
+
+
+/* Bitfield call argument in stack.  */
+/* No change in parameter passing in GCC 9.1 for lines 87-91 (g1_stack,
+   g2_stack, g4_stack, g8_stack, g16_stack) because the overall alignment is >
+   16.  No warning expected.  */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1}  "" { target *-*-* } 93 } gp_stack */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 94 } g1p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 95 } g2p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 96 } g4p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 97 } g8p_stack */
+
+
+/* No change in parameter passing in GCC 9.1 for line 98 (g16p_stack).  No
+   warning expected.  */
+
+
+/* Bitfield parameter in stdarg.  */
+/* No change in parameter passing in GCC 9.1 for lines 101-105 (f1_stdarg,
+   f2_stdarg, f4_stdarg, f8_stdarg, f16_stdarg) because the overall alignment
+   is > 16.  No warning expected.  */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1}   "" { target *-*-* } 107 } fp_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1}  "" { target *-*-* } 108 } f1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1}  "" { target *-*-* } 109 } f2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1}  "" { target *-*-* } 110 } f4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1}  "" { target *-*-* } 111 } f8p_stdarg */
+
+/* No change in parameter passing in GCC 9.1 for line 112 (f16p_stdarg).
+   Should not warn.  */
+/* { dg-message {parameter passing for argument of type 'struct S16p' changed in GCC 9.1} "" { target *-*-* } 112 } f16p_stdarg */
+
+/* Bitfield call argument in stdarg.  */
+/* No change in parameter passing in GCC 9.1 for lines 114-118 (g1_stdarg,
+   g2_stdarg, g4_stdarg, g8_stdarg, g16_stdarg) because the overall alignment
+   is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 120-124 (gp_stdarg,
+   g1p_stdarg, g2p_stdarg, g4p_stdarg, g8p_stdarg), no warning expected.  */
+
+/* Changed in GCC 9.1, but we fail to emit a warning.  */
+/* { dg-message {parameter passing for argument of type 'struct S16p' changed in GCC 9.1} "" { xfail *-*-* } 125 } g16p_stdarg */
diff --git a/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align32-O2.c b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align32-O2.c
new file mode 100644
index 00000000000..22fa28a414b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align32-O2.c
@@ -0,0 +1,119 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+#define ALIGN 32
+#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+/* In f1, f2, f4, f8, f16 (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "ldr\tx0, \\\[x1\\\]" 10 } } */
+
+/* In fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 10 { xfail *-*-* } } } */
+
+/* In f16p (and stdarg version):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 2 { xfail *-*-* } } } */
+
+/* In f1_stack, f2_stack, f4_stack, f8_stack, f16_stack, f8p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tx\[0-9\]+, \\\[sp, 8\\\]" 6 { xfail *-*-* } } } */
+
+/* In fp_stack, f1p_stack:  */
+/* { dg-final { scan-assembler-times "ldrb\tw0, \\\[sp, 8\\\]" 2 { xfail *-*-* } } } */
+
+/* In f2p_stack:  */
+/* { dg-final { scan-assembler-times "ldrh\tw0, \\\[sp, 8\\\]" 1 { xfail *-*-* } } } */
+
+/* In f4p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tw0, \\\[sp, 8\\\]" 1 { xfail *-*-* } } } */
+
+/* In f16p_stack:  */
+/* { dg-final { scan-assembler-times "ldr\tx0, \\\[sp, 16\\\]" 1 { xfail *-*-* } } } */
+
+/* Bitfield parameter in registers.  */
+/* No change in parameter passing in GCC 9.1 for lines 47-51 (f1, f2, f4, f8, f16)
+   because the overall alignment is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 53-57 (fp, f1p, f2p,
+   f4p, f8p) because the argument fits in a single register.  Should not warn,
+   but aarch64_function_arg_boundary would need to take the argument size into
+   account as well as whether it's passed via registers or the stack.  */
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1}  "" { target *-*-* } 53 } fp */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 54 } f1p */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 55 } f2p */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 56 } f4p */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 57 } f8p */
+
+/* Changed in GCC 9.1, but we fail to emit a warning since GCC 11 (was OK with GCC 9).  */
+/* { dg-message {parameter passing for argument of type 'struct S16p' changed in GCC 9.1} "" { xfail *-*-* } 58 } f16p */
+
+
+/* Bitfield call argument in registers.  */
+/* No change in parameter passing in GCC 9.1 for lines 60-64 (g1, g2, g4, g8, g16)
+   because the overall alignment is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 66-70 (gp, g1p, g2p,
+   g4p, g8p), no warning expected.  */
+
+/* Changed in GCC 9.1, but we fail to emit a warning.  */
+/* { dg-message {parameter passing for argument of type 'struct S16p' changed in GCC 9.1} "" { xfail *-*-* } 71 } g16p */
+
+
+/* Bitfield parameter in stack.  */
+/* No change in parameter passing in GCC 9.1 for lines 74-78 (f1_stack,
+   f2_stack, f4_stack, f8_stack, f16_stack) because the overall alignment is >
+   16.  No warning expected.  */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1}  "" { target *-*-* } 80 } fp_stack */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 81 } f1p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 82 } f2p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 83 } f4p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 84 } f8p_stack */
+
+/* No change in parameter passing in GCC 9.1 for line 85 (f16p_stack) because
+   the overall alignment is >= 16.  No warning expected.  */
+
+/* Bitfield call argument in stack.  */
+/* No change in parameter passing in GCC 9.1 for lines 87-91 (g1_stack,
+   g2_stack, g4_stack, g8_stack, g16_stack) because the overall alignment is >
+   16.  No warning expected.  */
+
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1}  "" { target *-*-* } 93 } gp_stack */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1} "" { target *-*-* } 94 } g1p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1} "" { target *-*-* } 95 } g2p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1} "" { target *-*-* } 96 } g4p_stack */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1} "" { target *-*-* } 97 } g8p_stack */
+
+
+/* No change in parameter passing in GCC 9.1 for line 98 (g16p_stack).  No
+   warning expected.  */
+
+
+/* Bitfield parameter in stdarg.  */
+/* No change in parameter passing in GCC 9.1 for lines 101-105 (f1_stdarg,
+   f2_stdarg, f4_stdarg, f8_stdarg, f16_stdarg) because the overall alignment
+   is > 16.  No warning expected.  */
+
+/* Parameter passing for these should not have changed in GCC 9.1 (PR 105549).
+   Fortunately we warn. Note the discrepancy with lines 120-124 below: we warn
+   in the callee, but not in the caller.  */
+/* { dg-message {parameter passing for argument of type 'struct Sp' changed in GCC 9.1}   "" { target *-*-* } 107 } fp_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S1p' changed in GCC 9.1}  "" { target *-*-* } 108 } f1p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S2p' changed in GCC 9.1}  "" { target *-*-* } 109 } f2p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S4p' changed in GCC 9.1}  "" { target *-*-* } 110 } f4p_stdarg */
+/* { dg-message {parameter passing for argument of type 'struct S8p' changed in GCC 9.1}  "" { target *-*-* } 111 } f8p_stdarg */
+
+/* No change in parameter passing in GCC 9.1 for line 112 (f16p_stdarg).
+   Should not warn.  */
+/* { dg-message {parameter passing for argument of type 'struct S16p' changed in GCC 9.1} "" { target *-*-* } 112 } f16p_stdarg */
+
+/* Bitfield call argument in stdarg.  */
+/* No change in parameter passing in GCC 9.1 for lines 114-118 (g1_stdarg,
+   g2_stdarg, g4_stdarg, g8_stdarg, g16_stdarg) because the overall alignment
+   is > 16.  No warning expected.  */
+
+/* No change in parameter passing in GCC 9.1 for lines 120-124 (gp_stdarg,
+   g1p_stdarg, g2p_stdarg, g4p_stdarg, g8p_stdarg), no warning expected.  */
+
+/* Changed in GCC 9.1, but we fail to emit a warning.  */
+/* { dg-message {parameter passing for argument of type 'struct S16p' changed in GCC 9.1} "" { xfail *-*-* } 125 } g16p_stdarg */
diff --git a/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align8-O2.c b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align8-O2.c
new file mode 100644
index 00000000000..cb2a945a819
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning-align8-O2.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+#define ALIGN 8
+#define EXTRA
+
+#include "bitfield-abi-warning.h"
+
+/* In f1, f2, f4, f8, fp, f1p, f2p, f4p, f8p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w1, 1" 18 } } */
+
+/* In f16, f16p (and stdarg versions):  */
+/* { dg-final { scan-assembler-times "and\tw0, w2, 1" 4 } } */
+
+/* In f1, f2, f4, f8, f16, fp, f1p, f2p, f4p, f8p, f16p stack versions:  */
+/* { dg-final { scan-assembler-times "and\tw0, w0, 1" 11 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning.h b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning.h
new file mode 100644
index 00000000000..3940b714ef8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/bitfield-abi-warning.h
@@ -0,0 +1,125 @@
+#include <stdarg.h>
+
+typedef unsigned long long ull __attribute__((aligned(ALIGN)));
+
+#ifndef EXTRA
+#define EXTRA unsigned long long x;
+#endif
+
+struct S1  { __attribute__((aligned(1))) ull i : 1; EXTRA };
+struct S2  { __attribute__((aligned(2))) ull i : 1; EXTRA };
+struct S4  { __attribute__((aligned(4))) ull i : 1; EXTRA };
+struct S8  { __attribute__((aligned(8))) ull i : 1; EXTRA };
+struct S16 { __attribute__((aligned(16))) ull i : 1; EXTRA };
+
+struct Sp   { ull i : 1; EXTRA }__attribute__((packed));
+struct S1p  { __attribute__((packed, aligned(1))) ull i : 1; EXTRA };
+struct S2p  { __attribute__((packed, aligned(2))) ull i : 1; EXTRA };
+struct S4p  { __attribute__((packed, aligned(4))) ull i : 1; EXTRA };
+struct S8p  { __attribute__((packed, aligned(8))) ull i : 1; EXTRA };
+struct S16p { __attribute__((packed, aligned(16))) ull i : 1; EXTRA };
+
+/* Bitfield in registers.  */
+#define PARAMS(xx) int a0, struct S##xx s, ull a1
+/* Bitfield passed by the stack.  */
+#define PARAMS_STACK(xx) int a0, ull a1, ull a2, ull a3, ull a4, ull a5, ull a6, ull a7, ull a8, struct S##xx t
+/* Bitfield passed via stdarg.  */
+#define PARAMS_STDARG(xx) int a0, ...
+
+#define CODE(xx)				\
+  return s.i;
+
+#define CODE_STACK(xx)				\
+  return t.i;
+
+#define CODE_STDARG(xx)				\
+  va_list ap;					\
+  struct S##xx arg;				\
+  __builtin_va_start(ap,a0);			\
+  arg = __builtin_va_arg(ap, struct S##xx);	\
+  return arg.i;
+
+#define ARGS(xx) x, (struct S##xx) { x }, x
+#define ARGS_STACK(xx) x, x, x, x, x, x, x, x, x, (struct S##xx) { x }
+#define ARGS_STDARG(xx) x, (struct S##xx) { x }
+
+/* Bitfield in registers.  */
+int __attribute__ ((noipa)) f1 (PARAMS(1))  { CODE(1) }
+int __attribute__ ((noipa)) f2 (PARAMS(2))  { CODE(2) }
+int __attribute__ ((noipa)) f4 (PARAMS(4))  { CODE(4) }
+int __attribute__ ((noipa)) f8 (PARAMS(8))  { CODE(8) }
+int __attribute__ ((noipa)) f16(PARAMS(16)) { CODE(16) }
+
+int __attribute__ ((noipa)) fp  (PARAMS(p))   { CODE(p) }
+int __attribute__ ((noipa)) f1p (PARAMS(1p))  { CODE(1p) }
+int __attribute__ ((noipa)) f2p (PARAMS(2p))  { CODE(2p) }
+int __attribute__ ((noipa)) f4p (PARAMS(4p))  { CODE(4p) }
+int __attribute__ ((noipa)) f8p (PARAMS(8p))  { CODE(8p) }
+int __attribute__ ((noipa)) f16p(PARAMS(16p)) { CODE(16p) }
+
+int g1 (int x) { return f1 (ARGS(1)); }
+int g2 (int x) { return f2 (ARGS(2)); }
+int g4 (int x) { return f4 (ARGS(4)); }
+int g8 (int x) { return f8 (ARGS(8)); }
+int g16(int x) { return f16 (ARGS(16)); }
+
+int gp  (int x) { return fp   (ARGS(p)); }
+int g1p (int x) { return f1p  (ARGS(1p)); }
+int g2p (int x) { return f2p  (ARGS(2p)); }
+int g4p (int x) { return f4p  (ARGS(4p)); }
+int g8p (int x) { return f8p  (ARGS(8p)); }
+int g16p(int x) { return f16p (ARGS(16p)); }
+
+/* Bitfield in the stack.  */
+int __attribute__ ((noipa)) f1_stack (PARAMS_STACK(1))  { CODE_STACK(1) }
+int __attribute__ ((noipa)) f2_stack (PARAMS_STACK(2))  { CODE_STACK(2) }
+int __attribute__ ((noipa)) f4_stack (PARAMS_STACK(4))  { CODE_STACK(4) }
+int __attribute__ ((noipa)) f8_stack (PARAMS_STACK(8))  { CODE_STACK(8) }
+int __attribute__ ((noipa)) f16_stack(PARAMS_STACK(16)) { CODE_STACK(16) }
+
+int __attribute__ ((noipa)) fp_stack  (PARAMS_STACK(p))   { CODE_STACK(p) }
+int __attribute__ ((noipa)) f1p_stack (PARAMS_STACK(1p))  { CODE_STACK(1p) }
+int __attribute__ ((noipa)) f2p_stack (PARAMS_STACK(2p))  { CODE_STACK(2p) }
+int __attribute__ ((noipa)) f4p_stack (PARAMS_STACK(4p))  { CODE_STACK(4p) }
+int __attribute__ ((noipa)) f8p_stack (PARAMS_STACK(8p))  { CODE_STACK(8p) }
+int __attribute__ ((noipa)) f16p_stack(PARAMS_STACK(16p)) { CODE_STACK(16p) }
+
+int g1_stack (int x) { return f1_stack (ARGS_STACK(1)); }
+int g2_stack (int x) { return f2_stack (ARGS_STACK(2)); }
+int g4_stack (int x) { return f4_stack (ARGS_STACK(4)); }
+int g8_stack (int x) { return f8_stack (ARGS_STACK(8)); }
+int g16_stack(int x) { return f16_stack (ARGS_STACK(16)); }
+
+int gp_stack  (int x) { return fp_stack (ARGS_STACK(p)); }
+int g1p_stack (int x) { return f1p_stack (ARGS_STACK(1p)); }
+int g2p_stack (int x) { return f2p_stack (ARGS_STACK(2p)); }
+int g4p_stack (int x) { return f4p_stack (ARGS_STACK(4p)); }
+int g8p_stack (int x) { return f8p_stack (ARGS_STACK(8p)); }
+int g16p_stack(int x) { return f16p_stack (ARGS_STACK(16p)); }
+
+/* Bitfield  via stdarg.  */
+int __attribute__ ((noipa)) f1_stdarg (PARAMS_STDARG(1))  { CODE_STDARG(1) }
+int __attribute__ ((noipa)) f2_stdarg (PARAMS_STDARG(2))  { CODE_STDARG(2) }
+int __attribute__ ((noipa)) f4_stdarg (PARAMS_STDARG(4))  { CODE_STDARG(4) }
+int __attribute__ ((noipa)) f8_stdarg (PARAMS_STDARG(8))  { CODE_STDARG(8) }
+int __attribute__ ((noipa)) f16_stdarg(PARAMS_STDARG(16)) { CODE_STDARG(16) }
+
+int __attribute__ ((noipa)) fp_stdarg  (PARAMS_STDARG(p))   { CODE_STDARG(p) }
+int __attribute__ ((noipa)) f1p_stdarg (PARAMS_STDARG(1p))  { CODE_STDARG(1p) }
+int __attribute__ ((noipa)) f2p_stdarg (PARAMS_STDARG(2p))  { CODE_STDARG(2p) }
+int __attribute__ ((noipa)) f4p_stdarg (PARAMS_STDARG(4p))  { CODE_STDARG(4p) }
+int __attribute__ ((noipa)) f8p_stdarg (PARAMS_STDARG(8p))  { CODE_STDARG(8p) }
+int __attribute__ ((noipa)) f16p_stdarg(PARAMS_STDARG(16p)) { CODE_STDARG(16p) }
+
+int g1_stdarg (int x) { return f1_stdarg (ARGS_STDARG(1)); }
+int g2_stdarg (int x) { return f2_stdarg (ARGS_STDARG(2)); }
+int g4_stdarg (int x) { return f4_stdarg (ARGS_STDARG(4)); }
+int g8_stdarg (int x) { return f8_stdarg (ARGS_STDARG(8)); }
+int g16_stdarg(int x) { return f16_stdarg (ARGS_STDARG(16)); }
+
+int gp_stdarg  (int x) { return fp_stdarg (ARGS_STDARG(p)); }
+int g1p_stdarg (int x) { return f1p_stdarg (ARGS_STDARG(1p)); }
+int g2p_stdarg (int x) { return f2p_stdarg (ARGS_STDARG(2p)); }
+int g4p_stdarg (int x) { return f4p_stdarg (ARGS_STDARG(4p)); }
+int g8p_stdarg (int x) { return f8p_stdarg (ARGS_STDARG(8p)); }
+int g16p_stdarg(int x) { return f16p_stdarg (ARGS_STDARG(16p)); }
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/info_18 b/gcc/testsuite/gcc.target/aarch64/cpunative/info_18
new file mode 100644
index 00000000000..25061a4abe8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/info_18
@@ -0,0 +1,8 @@
+processor	: 0
+BogoMIPS	: 2000.00
+Features	: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma lrcpc dcpop sha3 asimddp sha512 asimdfhm dit uscat ilrcpc flagm ssbs sb dcpodp flagm2 frint i8mm bf16 rng ecv
+CPU implementer	: 0xc0
+CPU architecture: 8
+CPU variant	: 0x0
+CPU part	: 0xac3
+CPU revision	: 0
diff --git a/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_18.c b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_18.c
new file mode 100644
index 00000000000..b5f0a3005f5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/cpunative/native_cpu_18.c
@@ -0,0 +1,15 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-set-compiler-env-var GCC_CPUINFO "$srcdir/gcc.target/aarch64/cpunative/info_18" } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler {\.arch armv8.6-a\+crc\+fp16\+aes\+sha3\+rng} } } */
+
+/* Test one where the boundary of buffer size would overwrite the last
+   character read when stitching the fgets-calls together.  With the
+   test data provided, this would truncate the 'sha512' into 'ha512'
+   (dropping the 'sha3' feature). */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr104921-1.c b/gcc/testsuite/gcc.target/aarch64/pr104921-1.c
new file mode 100644
index 00000000000..dcf6fe7d90d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr104921-1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O2 -march=armv8.2-a+bf16 -std=gnu99 -save-temps" }  */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+#include "pr104921.x"
+
+/*
+**foo:
+**	mov	v([0-9]|1[0-5])\.8b, v16\.8b
+**	bfmlalb	v0\.4s, v1\.8h, v([0-9]|1[0-5])\.h\[0\]
+**	ret
+*/
diff --git a/gcc/testsuite/gcc.target/aarch64/pr104921-2.c b/gcc/testsuite/gcc.target/aarch64/pr104921-2.c
new file mode 100644
index 00000000000..211fcd0aca9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr104921-2.c
@@ -0,0 +1,6 @@
+/* { dg-do assemble } */
+/* { dg-add-options arm_v8_2a_bf16_neon }  */
+/* { dg-additional-options "-O2 -std=gnu99" }  */
+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */
+
+#include "pr104921.x"
diff --git a/gcc/testsuite/gcc.target/aarch64/pr104921.x b/gcc/testsuite/gcc.target/aarch64/pr104921.x
new file mode 100644
index 00000000000..1e1a6f24e22
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr104921.x
@@ -0,0 +1,9 @@
+#include <arm_neon.h>
+
+float32x4_t
+foo(float32x4_t x, bfloat16x8_t a)
+{
+  register bfloat16x4_t b asm ("v16");
+  asm volatile ("" : "=w"(b));
+  return vbfmlalbq_lane_f32 (x, a, b, 0);
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr108589.c b/gcc/testsuite/gcc.target/aarch64/pr108589.c
new file mode 100644
index 00000000000..861727f7268
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr108589.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-Os -O2 -mtune=ampere1a -fno-split-wide-types" } */
+
+int i;
+__int128 j;
+short s;
+
+void
+foo (void)
+{
+  j -= i;
+  int l = i - __builtin_sub_overflow_p (0, 61680, s);
+  j -= __builtin_mul_overflow_p (i, l, 0);
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/pr92424-2.c b/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
index 0e75657a153..86bb92e6f32 100644
--- a/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
+++ b/gcc/testsuite/gcc.target/aarch64/pr92424-2.c
@@ -9,4 +9,4 @@ __attribute__ ((target("branch-protection=bti"),
 f10_bti ()
 {
 }
-/* { dg-final { scan-assembler "f10_bti:\n\thint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\tret\n" } } */
+/* { dg-final { scan-assembler "hint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\tret\n" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr92424-3.c b/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
index 0a1f74d4096..daac2faf18e 100644
--- a/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
+++ b/gcc/testsuite/gcc.target/aarch64/pr92424-3.c
@@ -9,4 +9,4 @@ __attribute__ ((target("branch-protection=bti+pac-ret+leaf"),
 f10_pac ()
 {
 }
-/* { dg-final { scan-assembler "f10_pac:\n\thint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\thint\t25 // paciasp\n.*\thint\t29 // autiasp\n.*\tret\n" } } */
+/* { dg-final { scan-assembler "hint\t34 // bti c\n.*\.LPFE1:\n\tnop\n.*\thint\t25 // paciasp\n.*\thint\t29 // autiasp\n.*\tret\n" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pr98776.c b/gcc/testsuite/gcc.target/aarch64/pr98776.c
new file mode 100644
index 00000000000..d193df8e66d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/pr98776.c
@@ -0,0 +1,11 @@
+/* { dg-do "compile" } */
+/* { dg-options "-O1 -fpatchable-function-entry=1 -fasynchronous-unwind-tables" } */
+
+/* Test the placement of the .LPFE1 label.  */
+
+void
+foo (void)
+{
+}
+
+/* { dg-final { scan-assembler "\t\.cfi_startproc\n.*\.LPFE1:\n\tnop\n\tret\n" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c b/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
index bfb044f5d14..307fa3d67da 100644
--- a/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/pragma_cpp_predefs_1.c
@@ -248,6 +248,26 @@
 #error "__ARM_FEATURE_CRC32 is not defined but should be!"
 #endif
 
+#pragma GCC target ("arch=armv8.2-a")
+#ifdef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is defined but should not be!"
+#endif
+
+#pragma GCC target ("arch=armv8.2-a+rcpc")
+#ifndef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is not defined but should be!"
+#endif
+
+#pragma GCC target ("+norcpc")
+#ifdef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is defined but should not be!"
+#endif
+
+#pragma GCC target ("arch=armv8.3-a")
+#ifndef __ARM_FEATURE_RCPC
+#error "__ARM_FEATURE_RCPC is not defined but should be!"
+#endif
+
 int
 foo (int a)
 {
diff --git a/gcc/testsuite/gcc.target/aarch64/stack-check-prologue-17.c b/gcc/testsuite/gcc.target/aarch64/stack-check-prologue-17.c
new file mode 100644
index 00000000000..f0ec1389771
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/stack-check-prologue-17.c
@@ -0,0 +1,55 @@
+/* { dg-options "-O2 -fstack-clash-protection -fomit-frame-pointer --param stack-clash-protection-guard-size=12" } */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+void f(int, ...);
+void g();
+
+/*
+** test1:
+**	...
+**	str	x30, \[sp\]
+**	sub	sp, sp, #1024
+**	cbnz	w0, .*
+**	bl	g
+**	...
+*/
+int test1(int z) {
+  __uint128_t x = 0;
+  int y[0x400];
+  if (z)
+    {
+      f(0, 0, 0, 0, 0, 0, 0, &y,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x);
+    }
+  g();
+  return 1;
+}
+
+/*
+** test2:
+**	...
+**	str	x30, \[sp\]
+**	sub	sp, sp, #1040
+**	str	xzr, \[sp, #?1024\]
+**	cbnz	w0, .*
+**	bl	g
+**	...
+*/
+int test2(int z) {
+  __uint128_t x = 0;
+  int y[0x400];
+  if (z)
+    {
+      f(0, 0, 0, 0, 0, 0, 0, &y,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x);
+    }
+  g();
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/stack-check-prologue-18.c b/gcc/testsuite/gcc.target/aarch64/stack-check-prologue-18.c
new file mode 100644
index 00000000000..6383bec5ebc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/stack-check-prologue-18.c
@@ -0,0 +1,100 @@
+/* { dg-options "-O2 -fstack-clash-protection -fomit-frame-pointer --param stack-clash-protection-guard-size=12" } */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+void f(int, ...);
+void g();
+
+/*
+** test1:
+**	...
+**	str	x30, \[sp\]
+**	sub	sp, sp, #4064
+**	str	xzr, \[sp, #?1024\]
+**	cbnz	w0, .*
+**	bl	g
+**	...
+**	str	x26, \[sp, #?4128\]
+**	...
+*/
+int test1(int z) {
+  __uint128_t x = 0;
+  int y[0x400];
+  if (z)
+    {
+      asm volatile ("" :::
+		    "x19", "x20", "x21", "x22", "x23", "x24", "x25", "x26");
+      f(0, 0, 0, 0, 0, 0, 0, &y,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x);
+    }
+  g();
+  return 1;
+}
+
+/*
+** test2:
+**	...
+**	str	x30, \[sp\]
+**	sub	sp, sp, #1040
+**	str	xzr, \[sp, #?1024\]
+**	cbnz	w0, .*
+**	bl	g
+**	...
+*/
+int test2(int z) {
+  __uint128_t x = 0;
+  int y[0x400];
+  if (z)
+    {
+      asm volatile ("" :::
+		    "x19", "x20", "x21", "x22", "x23", "x24", "x25", "x26");
+      f(0, 0, 0, 0, 0, 0, 0, &y,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x);
+    }
+  g();
+  return 1;
+}
+
+/*
+** test3:
+**	...
+**	str	x30, \[sp\]
+**	sub	sp, sp, #1024
+**	cbnz	w0, .*
+**	bl	g
+**	...
+*/
+int test3(int z) {
+  __uint128_t x = 0;
+  int y[0x400];
+  if (z)
+    {
+      asm volatile ("" :::
+		    "x19", "x20", "x21", "x22", "x23", "x24", "x25", "x26");
+      f(0, 0, 0, 0, 0, 0, 0, &y,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,
+	x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x);
+    }
+  g();
+  return 1;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/stack-protector-8.c b/gcc/testsuite/gcc.target/aarch64/stack-protector-8.c
new file mode 100644
index 00000000000..e71d820e365
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/stack-protector-8.c
@@ -0,0 +1,95 @@
+/* { dg-options " -O -fstack-protector-strong -mstack-protector-guard=sysreg -mstack-protector-guard-reg=tpidr2_el0 -mstack-protector-guard-offset=16" } */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+void g(void *);
+__SVBool_t *h(void *);
+
+/*
+** test1:
+**	sub	sp, sp, #288
+**	stp	x29, x30, \[sp, #?272\]
+**	add	x29, sp, #?272
+**	mrs	(x[0-9]+), tpidr2_el0
+**	ldr	(x[0-9]+), \[\1, #?16\]
+**	str	\2, \[sp, #?264\]
+**	mov	\2, #?0
+**	add	x0, sp, #?8
+**	bl	g
+**	...
+**	mrs	.*
+**	...
+**	bne	.*
+**	...
+**	ldp	x29, x30, \[sp, #?272\]
+**	add	sp, sp, #?288
+**	ret
+**	bl	__stack_chk_fail
+*/
+int test1() {
+  int y[0x40];
+  g(y);
+  return 1;
+}
+
+/*
+** test2:
+**	stp	x29, x30, \[sp, #?-16\]!
+**	mov	x29, sp
+**	sub	sp, sp, #1040
+**	mrs	(x[0-9]+), tpidr2_el0
+**	ldr	(x[0-9]+), \[\1, #?16\]
+**	str	\2, \[sp, #?1032\]
+**	mov	\2, #?0
+**	add	x0, sp, #?8
+**	bl	g
+**	...
+**	mrs	.*
+**	...
+**	bne	.*
+**	...
+**	add	sp, sp, #?1040
+**	ldp	x29, x30, \[sp\], #?16
+**	ret
+**	bl	__stack_chk_fail
+*/
+int test2() {
+  int y[0x100];
+  g(y);
+  return 1;
+}
+
+#pragma GCC target "+sve"
+
+/*
+** test3:
+**	stp	x29, x30, \[sp, #?-16\]!
+**	mov	x29, sp
+**	addvl	sp, sp, #-18
+**	...
+**	str	p4, \[sp\]
+**	...
+**	sub	sp, sp, #272
+**	mrs	(x[0-9]+), tpidr2_el0
+**	ldr	(x[0-9]+), \[\1, #?16\]
+**	str	\2, \[sp, #?264\]
+**	mov	\2, #?0
+**	add	x0, sp, #?8
+**	bl	h
+**	...
+**	mrs	.*
+**	...
+**	bne	.*
+**	...
+**	add	sp, sp, #?272
+**	...
+**	ldr	p4, \[sp\]
+**	...
+**	addvl	sp, sp, #18
+**	ldp	x29, x30, \[sp\], #?16
+**	ret
+**	bl	__stack_chk_fail
+*/
+__SVBool_t test3() {
+  int y[0x40];
+  return *h(y);
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/stack-protector-9.c b/gcc/testsuite/gcc.target/aarch64/stack-protector-9.c
new file mode 100644
index 00000000000..58f322aa480
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/stack-protector-9.c
@@ -0,0 +1,33 @@
+/* { dg-options "-O2 -mcpu=neoverse-v1 -fstack-protector-all" } */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+/*
+** main:
+**	...
+**	stp	x29, x30, \[sp, #?-[0-9]+\]!
+**	...
+**	sub	sp, sp, #[0-9]+
+**	...
+**	str	x[0-9]+, \[x29, #?-8\]
+**	...
+*/
+int f(const char *);
+void g(void *);
+int main(int argc, char* argv[])
+{
+  int a;
+  int b;
+  char c[2+f(argv[1])];
+  int d[0x100];
+  char y;
+
+  y=42; a=4; b=10;
+  c[0] = 'h'; c[1] = '\0';
+
+  c[f(argv[2])] = '\0';
+
+  __builtin_printf("%d %d\n%s\n", a, b, c);
+  g(d);
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c
index 24aa8f317c4..6146ef82849 100644
--- a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brka_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkas\tp[0-9]+\.b, p[0-9]+/m,} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrka\t} } } */
+/* { dg-final { scan-assembler-times {\tbrka\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkas\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c
index 07e3622ed6a..7f1c75837de 100644
--- a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkb_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkbs\tp[0-9]+\.b, p[0-9]+/m,} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrkb\t} } } */
+/* { dg-final { scan-assembler-times {\tbrkb\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkbs\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c
index 7fd9318c13f..c548810f169 100644
--- a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_1.c
@@ -18,5 +18,6 @@ test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
   return svptest_any (pg, res);
 }
 
-/* { dg-final { scan-assembler-times {\tbrkns\t} 2 } } */
-/* { dg-final { scan-assembler-not {\tbrkn\t} } } */
+/* { dg-final { scan-assembler-times {\tbrkn\t} 2 } } */
+/* { dg-final { scan-assembler-times {\tptest\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkns\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_2.c b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_2.c
new file mode 100644
index 00000000000..74b6927410a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/acle/general/brkn_2.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+#include <arm_sve.h>
+
+void
+test1 (svbool_t pg, svbool_t x, svbool_t y, int *any, svbool_t *ptr)
+{
+  svbool_t res = svbrkn_z (pg, x, y);
+  *any = svptest_any (svptrue_b8 (), res);
+  *ptr = res;
+}
+
+int
+test2 (svbool_t pg, svbool_t x, svbool_t y, int *any)
+{
+  svbool_t res = svbrkn_z (pg, x, y);
+  return svptest_any (svptrue_b8 (), res);
+}
+
+/* { dg-final { scan-assembler-times {\tbrkns\t} 2 } } */
+/* { dg-final { scan-assembler-not {\tbrkn\t} } } */
+/* { dg-final { scan-assembler-not {\tptest\t} } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_3.c b/gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_3.c
index 3e01ec36c3a..3530a0d504b 100644
--- a/gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_3.c
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pcs/stack_clash_3.c
@@ -11,11 +11,10 @@
 **	mov	x11, sp
 **	...
 **	sub	sp, sp, x13
-**	str	p4, \[sp\]
 **	cbz	w0, [^\n]*
+**	str	p4, \[sp\]
 **	...
 **	ptrue	p0\.b, all
-**	ldr	p4, \[sp\]
 **	addvl	sp, sp, #1
 **	ldr	x24, \[sp\], 32
 **	ret
@@ -39,13 +38,12 @@ test_1 (int n)
 **	mov	x11, sp
 **	...
 **	sub	sp, sp, x13
-**	str	p4, \[sp\]
 **	cbz	w0, [^\n]*
+**	str	p4, \[sp\]
 **	str	p5, \[sp, #1, mul vl\]
 **	str	p6, \[sp, #2, mul vl\]
 **	...
 **	ptrue	p0\.b, all
-**	ldr	p4, \[sp\]
 **	addvl	sp, sp, #1
 **	ldr	x24, \[sp\], 32
 **	ret
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr109176.c b/gcc/testsuite/gcc.target/aarch64/sve/pr109176.c
new file mode 100644
index 00000000000..958edb86ce3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr109176.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/109176 */
+/* { dg-do compile } */
+/* { dg-additional-options "-O2" } */
+
+#include <arm_sve.h>
+
+svbool_t
+foo (svint8_t a, svint8_t b, svbool_t c)
+{
+  svbool_t d = svcmplt_s8 (svptrue_pat_b8 (SV_ALL), a, b);
+  return svsel_b (d, c, d);
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sve/pr109505.c b/gcc/testsuite/gcc.target/aarch64/sve/pr109505.c
new file mode 100644
index 00000000000..b975ae75ae6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sve/pr109505.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/109505 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=armv8.2-a+sve" } */
+
+#pragma GCC aarch64 "arm_sve.h"
+
+unsigned long
+foo (unsigned long x)
+{
+  unsigned long y = svcntb ();
+  return (x | 15) & y;
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c
new file mode 100644
index 00000000000..372f4aa8746
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-comp-swap-ool.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -fno-ipa-icf -moutline-atomics" } */
+
+#include "sync-comp-swap.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_cas4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c
new file mode 100644
index 00000000000..95d9c56b5e1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-op-acquire-ool.c
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -moutline-atomics" } */
+
+#include "sync-op-acquire.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_swp4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c b/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c
new file mode 100644
index 00000000000..2f3881d9755
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/sync-op-full-ool.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-march=armv8-a+nolse -O2 -moutline-atomics" } */
+
+#include "sync-op-full.x"
+
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldadd4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldclr4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldeor4_sync" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_ldset4_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/target_attr_20.c b/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
index 509fb039e84..c9454fc420b 100644
--- a/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
+++ b/gcc/testsuite/gcc.target/aarch64/target_attr_20.c
@@ -24,4 +24,4 @@ bar (void)
     }
 }
 
-/* { dg-final { scan-assembler-not "bl.*__aarch64_cas2_acq_rel" } } */
+/* { dg-final { scan-assembler-not "bl.*__aarch64_cas2_sync" } } */
diff --git a/gcc/testsuite/gcc.target/aarch64/target_attr_21.c b/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
index acace4c8f2a..b8e56223b02 100644
--- a/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
+++ b/gcc/testsuite/gcc.target/aarch64/target_attr_21.c
@@ -24,4 +24,4 @@ bar (void)
     }
 }
 
-/* { dg-final { scan-assembler-times "bl.*__aarch64_cas2_acq_rel" 1 } } */
+/* { dg-final { scan-assembler-times "bl.*__aarch64_cas2_sync" 1 } } */
diff --git a/gcc/testsuite/gcc.target/alpha/pr105209.c b/gcc/testsuite/gcc.target/alpha/pr105209.c
new file mode 100644
index 00000000000..b89be96dc1d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/alpha/pr105209.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftrapv -mcpu=ev4" } */
+
+typedef struct tnode_t {
+        struct tnode_t *tn_left, *tn_right;
+        int v_quad;
+} tnode_t;
+
+int constant_addr(const tnode_t *, long *);
+int constant_addr(const tnode_t *tn, long *offsp)
+{
+        long offs1 = 0, offs2 = 0;
+
+        if (tn->v_quad > 0) {
+                offs1 = tn->v_quad;
+                return 0;
+        } else if (tn->v_quad > -1) {
+                offs2 = tn->tn_right->v_quad;
+                if (!constant_addr(tn->tn_left, &offs1))
+                        return 0;
+        } else {
+                return 0;
+        }
+        *offsp = offs1 + offs2;
+        return 1;
+}
diff --git a/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldst24q_reg_offset.c b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldst24q_reg_offset.c
new file mode 100644
index 00000000000..d028b91e81a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/mve/intrinsics/vldst24q_reg_offset.c
@@ -0,0 +1,300 @@
+/* { dg-require-effective-target arm_v8_1m_mve_ok } */
+/* { dg-add-options arm_v8_1m_mve } */
+/* { dg-additional-options "-O1" } */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+#include "arm_mve.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+**test:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test(const uint8_t * in, uint8_t * out, int width)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in + width);
+  vst2q (out, rg);
+  vst2q (out + width, gb);
+}
+
+/*
+**test2:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]!
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]!
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test2(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in + 32);
+  vst2q (out, rg);
+  vst2q (out + 32, gb);
+}
+
+/*
+**test3:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test3(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in - 32);
+  vst2q (out, rg);
+  vst2q (out - 32, gb);
+}
+
+/*
+**test4:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test4(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in + 64);
+  vst2q (out, rg);
+  vst2q (out + 64, gb);
+}
+
+/*
+**test5:
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst20.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst21.8	{q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test5(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x2_t rg = vld2q(in);
+  uint8x16x2_t gb = vld2q(in + 42);
+  vst2q (out, rg);
+  vst2q (out + 42, gb);
+}
+
+/*
+**test6:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test6(const uint8_t * in, uint8_t * out, int width)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in + width);
+  vst4q (out, rg);
+  vst4q (out + width, gb);
+}
+
+/*
+**test7:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test7(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in + 32);
+  vst4q (out, rg);
+  vst4q (out + 32, gb);
+}
+
+/*
+**test8:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]!
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]!
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test8(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in + 64);
+  vst4q (out, rg);
+  vst4q (out + 64, gb);
+}
+
+/*
+**test9:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test9(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in - 64);
+  vst4q (out, rg);
+  vst4q (out - 64, gb);
+}
+
+/*
+**test10:
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vld40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vld43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+**	vst40.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst41.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst42.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	vst43.8	{q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+}, \[(?:ip|fp|r[0-9]+)\]
+**	...
+*/
+void
+test10(const uint8_t * in, uint8_t * out)
+{
+  uint8x16x4_t rg = vld4q(in);
+  uint8x16x4_t gb = vld4q(in + 42);
+  vst4q (out, rg);
+  vst4q (out + 42, gb);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/* { dg-final { scan-assembler-not "__ARM_undef" } } */
\ No newline at end of file
diff --git a/gcc/testsuite/gcc.target/arm/pr105312.c b/gcc/testsuite/gcc.target/arm/pr105312.c
new file mode 100644
index 00000000000..a02831bcbcf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pr105312.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-options "-mcpu=cortex-a15" } */
+/* { dg-add-options arm_neon } */
+
+typedef float stress_matrix_type_t;
+typedef unsigned int size_t;
+static void __attribute__((optimize("-O3"))) stress_matrix_xy_identity(
+ const size_t n,
+ stress_matrix_type_t a[restrict n][n],
+ stress_matrix_type_t b[restrict n][n],
+ stress_matrix_type_t r[restrict n][n])
+{
+ register size_t i;
+ (void)a;
+ (void)b;
+ for (i = 0; i < n; i++) {
+  register size_t j;
+  for (j = 0; j < n; j++)
+   r[i][j] = (i == j) ? 1.0 : 0.0;
+   return;
+ }
+}
diff --git a/gcc/testsuite/gcc.target/arm/pure-code/pr109800.c b/gcc/testsuite/gcc.target/arm/pure-code/pr109800.c
new file mode 100644
index 00000000000..d797b790232
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arm/pure-code/pr109800.c
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_hard_ok } */
+/* { dg-options "-O2 -march=armv7-m -mfloat-abi=hard -mfpu=fpv4-sp-d16 -mbig-endian -mpure-code" } */
+double f() { return 5.0; }
diff --git a/gcc/testsuite/gcc.target/i386/avx-vzeroupper-29.c b/gcc/testsuite/gcc.target/i386/avx-vzeroupper-29.c
new file mode 100644
index 00000000000..4af637757f7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx-vzeroupper-29.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -mavx -mtune=generic -mvzeroupper -dp" } */
+
+#include <immintrin.h>
+
+extern __m256 x, y;
+
+void
+foo ()
+{
+  x = y;
+}
+
+/* { dg-final { scan-assembler-times "avx_vzeroupper" 1 } } */
diff --git a/gcc/testsuite/gcc.target/i386/avx2-gather-2.c b/gcc/testsuite/gcc.target/i386/avx2-gather-2.c
index 1a704afd834..a8bcd0eb3f1 100644
--- a/gcc/testsuite/gcc.target/i386/avx2-gather-2.c
+++ b/gcc/testsuite/gcc.target/i386/avx2-gather-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O3 -mavx2 -fdump-tree-vect-details -mtune=skylake" } */
+/* { dg-options "-O3 -fdump-tree-vect-details -march=skylake -mtune=haswell" } */
 
 #include "avx2-gather-1.c"
 
diff --git a/gcc/testsuite/gcc.target/i386/avx2-gather-6.c b/gcc/testsuite/gcc.target/i386/avx2-gather-6.c
index b9119581ae2..067b251e393 100644
--- a/gcc/testsuite/gcc.target/i386/avx2-gather-6.c
+++ b/gcc/testsuite/gcc.target/i386/avx2-gather-6.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O3 -mavx2 -fno-common -fdump-tree-vect-details -mtune=skylake" } */
+/* { dg-options "-O3 -mavx2 -fno-common -fdump-tree-vect-details  -mtune=haswell" } */
 
 #include "avx2-gather-5.c"
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512bf16-pr108881.c b/gcc/testsuite/gcc.target/i386/avx512bf16-pr108881.c
new file mode 100644
index 00000000000..9428c53abec
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx512bf16-pr108881.c
@@ -0,0 +1,14 @@
+/* PR target/108881 */
+/* { dg-do compile } */
+/* { dg-options "-mavx512bf16 -mno-avx512vl" } */
+
+typedef float __m256 __attribute__((__vector_size__(32)));
+typedef short __v16hi __attribute__((__vector_size__(32)));
+__v16hi a;
+__m256 b, c;
+
+void
+foo (void)
+{
+  a = __builtin_ia32_cvtne2ps2bf16_v16hi (b, c);	/* { dg-warning "implicit declaration of function" } */
+}							/* { dg-error "incompatible types when assigning to type" "" { target *-*-* } .-1 } */
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr88464-1.c b/gcc/testsuite/gcc.target/i386/avx512f-pr88464-1.c
index 06d21bb0129..d1a2298618e 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-pr88464-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr88464-1.c
@@ -1,6 +1,6 @@
 /* PR tree-optimization/88464 */
 /* { dg-do compile } */
-/* { dg-options "-O3 -mavx512f -mprefer-vector-width=512 -mtune=skylake-avx512 -fdump-tree-vect-details" } */
+/* { dg-options "-O3 -mavx512f -mprefer-vector-width=512 -mtune=haswell -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "loop vectorized using 64 byte vectors" 4 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops in function" 4 "vect" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr88464-5.c b/gcc/testsuite/gcc.target/i386/avx512f-pr88464-5.c
index 462e951fdc1..d7b0b2b28cb 100644
--- a/gcc/testsuite/gcc.target/i386/avx512f-pr88464-5.c
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr88464-5.c
@@ -1,6 +1,6 @@
 /* PR tree-optimization/88464 */
 /* { dg-do compile } */
-/* { dg-options "-O3 -mavx512f -mprefer-vector-width=512 -mtune=skylake-avx512 -fdump-tree-vect-details" } */
+/* { dg-options "-O3 -mavx512f -mprefer-vector-width=512 -mtune=haswell -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "loop vectorized using 64 byte vectors" 4 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops in function" 4 "vect" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-1.c b/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-1.c
index 55a28dddbf8..07439185ec1 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-1.c
@@ -1,6 +1,6 @@
 /* PR tree-optimization/88464 */
 /* { dg-do compile } */
-/* { dg-options "-O3 -mavx512vl -mprefer-vector-width=256 -mtune=skylake-avx512 -fdump-tree-vect-details" } */
+/* { dg-options "-O3 -mavx512vl -mprefer-vector-width=256 -mtune=haswell -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "loop vectorized using 32 byte vectors" 4 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops in function" 4 "vect" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-11.c b/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-11.c
index 9696008855d..3a98108279a 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-11.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-11.c
@@ -1,6 +1,6 @@
 /* PR tree-optimization/88464 */
 /* { dg-do compile } */
-/* { dg-options "-O3 -mavx512vl -mprefer-vector-width=128 -mtune=skylake-avx512 -fdump-tree-vect-details" } */
+/* { dg-options "-O3 -mavx512vl -mprefer-vector-width=128 -mtune=haswell -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "loop vectorized using 16 byte vectors" 4 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops in function" 4 "vect" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-3.c b/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-3.c
index 6b0c8a85957..ac669e04812 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-3.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-3.c
@@ -1,6 +1,6 @@
 /* PR tree-optimization/88464 */
 /* { dg-do compile } */
-/* { dg-options "-O3 -mavx512vl -mprefer-vector-width=128 -mtune=skylake-avx512 -fdump-tree-vect-details" } */
+/* { dg-options "-O3 -mavx512vl -mprefer-vector-width=128 -mtune=haswell -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "loop vectorized using 16 byte vectors" 4 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops in function" 4 "vect" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-9.c b/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-9.c
index 3af568ab323..14a1083b6d1 100644
--- a/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-9.c
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-pr88464-9.c
@@ -1,6 +1,6 @@
 /* PR tree-optimization/88464 */
 /* { dg-do compile } */
-/* { dg-options "-O3 -mavx512vl -mprefer-vector-width=256 -mtune=skylake-avx512 -fdump-tree-vect-details" } */
+/* { dg-options "-O3 -mavx512vl -mprefer-vector-width=256 -mtune=haswell -fdump-tree-vect-details" } */
 /* { dg-final { scan-tree-dump-times "loop vectorized using 32 byte vectors" 4 "vect" } } */
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops in function" 4 "vect" } } */
 
diff --git a/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S b/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
index b4a4a140e54..9d6be88e7d5 100644
--- a/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
+++ b/gcc/testsuite/gcc.target/i386/iamcu/asm-support.S
@@ -300,3 +300,6 @@ iamcu_noprintf:
 	.align 4
 .LCiamcu_noprintf1:
 	.long	1132527616
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c b/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
index 805e0628673..57fa9bdc831 100644
--- a/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
+++ b/gcc/testsuite/gcc.target/i386/keylocker-encodekey128.c
@@ -6,7 +6,6 @@
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm0,\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm1,\[^\\n\\r\]*16\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm2,\[^\\n\\r\]*32\[^\\n\\r\]*" } } */
-/* { dg-final { scan-assembler "(?:movdqa|movaps)\[ \\t\]+\[^\\n\]*%xmm\[4-6\],\[^\\n\\r\]*" } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c b/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
index 26f04dcf014..a9398b4e7a2 100644
--- a/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
+++ b/gcc/testsuite/gcc.target/i386/keylocker-encodekey256.c
@@ -8,7 +8,6 @@
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm1,\[^\\n\\r\]*16\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm2,\[^\\n\\r\]*32\[^\\n\\r\]*" } } */
 /* { dg-final { scan-assembler "(?:movdqu|movups)\[ \\t\]+\[^\\n\]*%xmm3,\[^\\n\\r\]*48\[^\\n\\r\]*" } } */
-/* { dg-final { scan-assembler "(?:movdqa|movaps)\[ \\t\]+\[^\\n\]*%xmm\[4-6\],\[^\\n\\r\]*" } } */
 
 #include <immintrin.h>
 
diff --git a/gcc/testsuite/gcc.target/i386/pr104637.c b/gcc/testsuite/gcc.target/i386/pr104637.c
new file mode 100644
index 00000000000..36e8b6ed97d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr104637.c
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-Og -fno-forward-propagate -mavx -Wno-div-by-zero" } */
+
+typedef short __attribute__((__vector_size__ (64))) U;
+typedef unsigned long long __attribute__((__vector_size__ (32))) V;
+typedef long double __attribute__((__vector_size__ (64))) F;
+
+int i;
+U u;
+F f;
+
+void
+foo (char a, char b, _Complex char c, V v)
+{
+  u = (U) { u[0] / 0, u[1] / 0, u[2] / 0, u[3] / 0, u[4] / 0, u[5] / 0, u[6] / 0, u[7] / 0,
+	    u[8] / 0, u[9] / 0, u[10] / 0, u[11] / 0, u[12] / 0, u[13] / 0, u[14] / 0, u[15] / 0,
+	    u[16] / 0, u[17] / 0, u[18] / 0, u[19] / 0, u[20] / 0, u[21] / 0, u[22] / 0, u[23] / 0,
+	    u[24] / 0, u[25] / 0, u[26] / 0, u[27] / 0, u[28] / 0, u[29] / 0, u[30] / 0, u[31] / 0 };
+  c += i;
+  f = (F) { v[0], v[1], v[2], v[3] };
+  i = (char) (__imag__ c + i);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr105554.c b/gcc/testsuite/gcc.target/i386/pr105554.c
new file mode 100644
index 00000000000..08e90bb3368
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr105554.c
@@ -0,0 +1,10 @@
+/* PR target/105554 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wno-psabi -mno-sse3" } */
+
+typedef long long v4di __attribute__((__vector_size__(32)));
+
+__attribute__((target_clones ("arch=core-avx2", "default"))) void
+foo (v4di x)
+{
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr105970.c b/gcc/testsuite/gcc.target/i386/pr105970.c
new file mode 100644
index 00000000000..326486faebf
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr105970.c
@@ -0,0 +1,6 @@
+/* PR target/105970 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -mgeneral-regs-only -maddress-mode=long" } */
+
+#include "../../gcc.dg/torture/pr68037-1.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr107304.c b/gcc/testsuite/gcc.target/i386/pr107304.c
new file mode 100644
index 00000000000..24d68795e7f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr107304.c
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -march=tigerlake" } */
+
+#include <stdint.h>
+
+typedef union {
+  uint8_t v __attribute__((aligned(256))) __attribute__ ((vector_size(64 * sizeof(uint8_t))));
+  uint8_t i[64] __attribute__((aligned(256)));
+} stress_vec_u8_64_t;
+
+typedef struct {
+ struct {
+  stress_vec_u8_64_t s;
+  stress_vec_u8_64_t o;
+  stress_vec_u8_64_t mask1;
+  stress_vec_u8_64_t mask2;
+ } u8_64;
+} stress_vec_data_t;
+
+__attribute__((target_clones("arch=alderlake", "default"))) 
+void
+stress_vecshuf_u8_64(stress_vec_data_t *data)
+{
+  stress_vec_u8_64_t *__restrict s;
+  stress_vec_u8_64_t *__restrict mask1;
+  stress_vec_u8_64_t *__restrict mask2;
+  register int i;
+
+  s = &data->u8_64.s;
+  mask1 = &data->u8_64.mask1;
+  mask2 = &data->u8_64.mask2;
+
+  for (i = 0; i < 256; i++) {	/* was i < 65536 */
+      stress_vec_u8_64_t tmp;
+
+      tmp.v = __builtin_shuffle(s->v, mask1->v);
+      s->v = __builtin_shuffle(tmp.v, mask2->v);
+  }
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr107863.c b/gcc/testsuite/gcc.target/i386/pr107863.c
new file mode 100644
index 00000000000..99fd85d9765
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr107863.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-mavx2 -O" } */
+
+typedef char v16qi __attribute__((vector_size(16)));
+
+v16qi foo(v16qi a){
+  return __builtin_ia32_vec_set_v16qi (a, -1, 2);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr109276.c b/gcc/testsuite/gcc.target/i386/pr109276.c
new file mode 100644
index 00000000000..5d0827aa280
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr109276.c
@@ -0,0 +1,13 @@
+/* PR target/109276 */
+/* { dg-do compile } */
+/* { dg-options "-march=x86-64" } */
+/* { dg-additional-options "-mpreferred-stack-boundary=2" { target ia32 } } */
+
+long long a;
+long double b;
+
+void
+foo (void)
+{
+  b += a;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr110170-3.c b/gcc/testsuite/gcc.target/i386/pr110170-3.c
new file mode 100644
index 00000000000..70daa89e9aa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr110170-3.c
@@ -0,0 +1,11 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-O2 -fno-if-conversion -fno-if-conversion2" } */
+/* { dg-final { scan-assembler-not {(?n)movq.*r} } } */
+
+void __cond_swap(double* __x, double* __y) {
+  _Bool __r = (*__x < *__y);
+  double __tmp = __r ? *__x : *__y;
+  *__y = __r ? *__y : *__x;
+  *__x = __tmp;
+}
+
diff --git a/gcc/testsuite/gcc.target/i386/pr111340.c b/gcc/testsuite/gcc.target/i386/pr111340.c
new file mode 100644
index 00000000000..6539ae566c0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr111340.c
@@ -0,0 +1,9 @@
+/* PR target/111340 */
+/* { dg-do compile { target { fpic && int128 } } } */
+/* { dg-options "-O2 -fpic" } */
+
+void
+bar (void)
+{
+  __asm ("# %0" : : "g" ((((unsigned __int128) 0x123456789abcdef0ULL) << 64) | 0x0fedcba987654321ULL));
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr89261.c b/gcc/testsuite/gcc.target/i386/pr89261.c
index c5c4273439b..b599d49fd48 100644
--- a/gcc/testsuite/gcc.target/i386/pr89261.c
+++ b/gcc/testsuite/gcc.target/i386/pr89261.c
@@ -5,6 +5,7 @@
 typedef double __v2df __attribute__ ((vector_size (16), aligned (1 << 28)));
 
 __v2df foo = { 1.0, 2.0 };
-/* { dg-error {alignment of 'foo' is greater than maximum object file alignment 32768} "" { target *-*-darwin* } .-1 } */
+/* { dg-error {alignment of 'foo' is greater than maximum object file alignment 32768} "" { target { *-*-darwin[89]*  *-*-darwin10* } } .-1 } */
 
 /* { dg-final { scan-assembler "\.align\[ \t]+268435456" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "\.align\[ \t]+28" { target { *-*-darwin1[1-9]* *-*-darwin2* } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/sse-14.c b/gcc/testsuite/gcc.target/i386/sse-14.c
index 4ce0ffffaf3..4c728f230f7 100644
--- a/gcc/testsuite/gcc.target/i386/sse-14.c
+++ b/gcc/testsuite/gcc.target/i386/sse-14.c
@@ -429,7 +429,9 @@ test_3 (_mm_maskz_mul_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_mul_round_ps, __m512, __mmask16, __m512, __m512, 9)
 test_3 (_mm_maskz_mul_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_scalef_round_pd, __m512d, __mmask8, __m512d, __m512d, 9)
+test_3 (_mm_maskz_scalef_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_scalef_round_ps, __m512, __mmask16, __m512, __m512, 9)
+test_3 (_mm_maskz_scalef_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_shuffle_f32x4, __m512, __mmask16, __m512, __m512, 1)
 test_3 (_mm512_maskz_shuffle_f64x2, __m512d, __mmask8, __m512d, __m512d, 1)
 test_3 (_mm512_maskz_shuffle_i32x4, __m512i, __mmask16, __m512i, __m512i, 1)
@@ -543,7 +545,9 @@ test_4 (_mm_mask_mul_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_mul_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
 test_4 (_mm_mask_mul_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_scalef_round_pd, __m512d, __m512d, __mmask8, __m512d, __m512d, 9)
+test_4 (_mm_mask_scalef_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_scalef_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
+test_4 (_mm_mask_scalef_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_shuffle_f32x4, __m512, __m512, __mmask16, __m512, __m512, 1)
 test_4 (_mm512_mask_shuffle_f64x2, __m512d, __m512d, __mmask8, __m512d, __m512d, 1)
 test_4 (_mm512_mask_shuffle_i32x4, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
index 1ea6de880aa..818a56f1116 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -fno-stack-protector -fno-PIC" } */
 
 void
 foo (void)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
index 389b1142264..01f6857fb56 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c
@@ -11,11 +11,11 @@ foo (int x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
-/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[\t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
index 07d8de7c66f..4ed036e9f88 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7 -msse" } */
 
 void
 foo (void)
@@ -7,15 +7,28 @@ foo (void)
 }
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 7 { target { ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 15 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm8, %xmm8" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm9, %xmm9" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm10, %xmm10" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm11, %xmm11" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm12, %xmm12" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm13, %xmm13" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm14, %xmm14" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm15, %xmm15" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
index 55a272cc53f..c361c0b3afd 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c
@@ -9,11 +9,11 @@ foo (void)
 /* { dg-final { scan-assembler-times "vzeroall" 1 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
index d0e975cb3d3..4d45fa56b2a 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("used")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
index d41a2557d10..fb5e6ddc1cd 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("skip")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
index c79fcd39d7b..10cfa12f9ca 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -fno-stack-protector" } */
 
 int
 foo (int x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
index 6f90723cc8e..0e399d4ebb0 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 float
 foo (float z, float y, float x)
@@ -9,5 +9,5 @@ foo (float z, float y, float x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm1, %xmm2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm2, %xmm2" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-not "xorl\[ \t\]+%" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
index 491d2d56774..cb0d5ebce04 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 float
 foo (float z, float y, float x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
index 52406fc70aa..cb93209a8ba 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c
@@ -9,11 +9,11 @@ foo (void)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
index ccd491775c2..123bd05b51e 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all -march=corei7 -msse" } */
 
 float
 foo (float z, float y, float x)
@@ -8,16 +8,28 @@ foo (float z, float y, float x)
 }
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" { target { ia32 } } } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm0, %xmm\[0-9\]+" 7 { target { ia32 } } } } */
-/* { dg-final { scan-assembler-times "movaps\[ \t\]+%xmm1, %xmm\[0-9\]+" 14 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" { target { ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm8, %xmm8" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm9, %xmm9" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm10, %xmm10" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm11, %xmm11" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm12, %xmm12" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm13, %xmm13" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm14, %xmm14" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm15, %xmm15" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
index b3570f318c1..e8c3d9b5f3d 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip -march=corei7" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -march=corei7 -fno-stack-protector -fno-PIC" } */
 
 __attribute__ ((zero_call_used_regs("used")))
 float
@@ -10,5 +10,5 @@ foo (float z, float y, float x)
 
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler "pxor\[ \t\]+%xmm1, %xmm1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm1, %xmm2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm2, %xmm2" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-not "xorl\[ \t\]+%" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
index b25342065e9..63adbb9d356 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c
@@ -11,11 +11,11 @@ foo (void)
 /* { dg-final { scan-assembler-times "fstp\[ \t\]+%st\\(0\\)" 8 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
index 69d42d732fd..a3285bed8a0 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c
@@ -11,19 +11,19 @@ foo (void)
 /* { dg-final { scan-assembler-times "fstp\[ \t\]+%st\\(0\\)" 8 } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler "kxorw\[ \t\]+%k0, %k0, %k0" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k1" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k2" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k3" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k4" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k5" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k6" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "kmovw\[ \t\]+%k0, %k7" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k1, %k1, %k1" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k2, %k2, %k2" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k3, %k3, %k3" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k4, %k4, %k4" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k5, %k5, %k5" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k6, %k6, %k6" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "kxorw\[ \t\]+%k7, %k7, %k7" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
index 8fb5299be56..3f22375d2fa 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c
@@ -8,16 +8,16 @@ foo (int x)
 }
 
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "pxor\[ \t\]+%xmm0, %xmm0" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm1" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm2" } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm3" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm4" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm5" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm6" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movaps\[ \t\]+%xmm0, %xmm7" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm0, %xmm0" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm1, %xmm1" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm2, %xmm2" } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm3, %xmm3" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm4, %xmm4" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm5, %xmm5" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm6, %xmm6" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "\[a-z\]*xor\[a-z\]*\[ \t\]+%xmm7, %xmm7" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
index 26ceacf435d..b307d107319 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c
@@ -8,8 +8,8 @@ foo (int x)
 }
 
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
index 044e4af10f0..dfa8e01dc38 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c
@@ -10,9 +10,9 @@ __v2si ret_mmx (void)
 }
 
 /* { dg-final { scan-assembler "pxor\[ \t\]+%mm1, %mm1" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm2" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm3" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm4" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm5" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm6" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm7" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm2, %mm2" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm3, %mm3" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm4, %mm4" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm5, %mm5" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm6, %mm6" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm7, %mm7" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
index 89e69b8ba72..6cd5c4cb067 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector" } */
 
 void
 foo (void)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
index afa8b337b36..5a0e53110e6 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c
@@ -10,5 +10,5 @@ __v2si ret_mmx (void)
 }
 
 /* { dg-final { scan-assembler "pxor\[ \t\]+%mm1, %mm1" } } */
-/* { dg-final { scan-assembler "movq\[ \t\]+%mm1, %mm2" } } */
-/* { dg-final { scan-assembler-not "movq\[ \t\]+%mm1, %mm\[34567\]" } } */
+/* { dg-final { scan-assembler "pxor\[ \t\]+%mm2, %mm2" } } */
+/* { dg-final { scan-assembler-not "pxor\[ \t\]+%mm\[34567\], %mm\[34567\]" } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
index 1e98d17df7f..becc5b8b438 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector -fno-PIC" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("used-gpr")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
index 56aecdafad8..4367f96a859 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c
@@ -10,11 +10,11 @@ foo (void)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%eax, %eax" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%eax, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
index fa831857ad8..88e3156b132 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=all-gpr" } */
+/* { dg-options "-O2 -fzero-call-used-regs=all-gpr -fno-stack-protector" } */
 
 extern void foo (void) __attribute__ ((zero_call_used_regs("skip")));
 
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
index 0444a21f4da..460c301ec12 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=used-gpr" } */
+/* { dg-options "-O2 -fzero-call-used-regs=used-gpr -fno-stack-protector" } */
 
 int
 foo (int x)
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
index 75356db63c3..0eab76933f5 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c
@@ -10,10 +10,10 @@ foo (int x)
 /* { dg-final { scan-assembler-not "vzeroall" } } */
 /* { dg-final { scan-assembler-not "%xmm" } } */
 /* { dg-final { scan-assembler "xorl\[ \t\]+%edx, %edx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %ecx" } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %esi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %edi" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r8d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r9d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r10d" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]+%edx, %r11d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%ecx, %ecx" } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%esi, %esi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%edi, %edi" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r8d, %r8d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r9d, %r9d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r10d, %r10d" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "xorl\[ \t\]+%r11d, %r11d" { target { ! ia32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
index 64755b00c39..42dcaea4988 100644
--- a/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
+++ b/gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target *-*-linux* } } */
-/* { dg-options "-O2 -fzero-call-used-regs=skip" } */
+/* { dg-options "-O2 -fzero-call-used-regs=skip -fno-stack-protector" } */
 
 extern int foo (int) __attribute__ ((zero_call_used_regs("used-gpr")));
 
diff --git a/gcc/testsuite/gcc.target/powerpc/bswap-brw.c b/gcc/testsuite/gcc.target/powerpc/bswap-brw.c
index b3f923eea84..0ed2a7bd1d2 100644
--- a/gcc/testsuite/gcc.target/powerpc/bswap-brw.c
+++ b/gcc/testsuite/gcc.target/powerpc/bswap-brw.c
@@ -17,6 +17,6 @@ bswap_int_dbl (unsigned int a)
   /* Force the value to be loaded into a vector register.  */
   __asm__ (" # %x0" : "+wa" (b));
 
-  /* { dg-final { scan-assembler {\mxxbrw\M} } } */
+  /* { dg-final { scan-assembler {\mxxbrw\M} {xfail {has_arch_pwr10 && {! has_arch_ppc64}}} } } */
   return (double) __builtin_bswap32 (b);
 }
diff --git a/gcc/testsuite/gcc.target/powerpc/clone1.c b/gcc/testsuite/gcc.target/powerpc/clone1.c
index c69fd2aa1b8..74323ca0e8c 100644
--- a/gcc/testsuite/gcc.target/powerpc/clone1.c
+++ b/gcc/testsuite/gcc.target/powerpc/clone1.c
@@ -21,6 +21,7 @@ long mod_func_or (long a, long b, long c)
   return mod_func (a, b) | c;
 }
 
-/* { dg-final { scan-assembler-times {\mdivd\M}  1 } } */
-/* { dg-final { scan-assembler-times {\mmulld\M} 1 } } */
-/* { dg-final { scan-assembler-times {\mmodsd\M} 1 } } */
+/* { Fail due to RS6000_DISABLE_SCALAR_MODULO. */
+/* { dg-final { scan-assembler-times {\mdivd\M}  1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-times {\mmulld\M} 1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-times {\mmodsd\M} 1 { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/clone3.c b/gcc/testsuite/gcc.target/powerpc/clone3.c
index 911b88b781d..d3eb4dd2378 100644
--- a/gcc/testsuite/gcc.target/powerpc/clone3.c
+++ b/gcc/testsuite/gcc.target/powerpc/clone3.c
@@ -27,7 +27,8 @@ long mod_func_or (long a, long b, long c)
   return mod_func (a, b) | c;
 }
 
-/* { dg-final { scan-assembler-times {\mdivd\M}  1 } } */
-/* { dg-final { scan-assembler-times {\mmulld\M} 1 } } */
-/* { dg-final { scan-assembler-times {\mmodsd\M} 2 } } */
+/* { Fail due to RS6000_DISABLE_SCALAR_MODULO. */
+/* { dg-final { scan-assembler-times {\mdivd\M}  1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-times {\mmulld\M} 1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-times {\mmodsd\M} 2 { xfail *-*-* } } } */
 /* { dg-final { scan-assembler-times {\mpld\M}   1 } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-0.c b/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-0.c
new file mode 100644
index 00000000000..d8d3c63a083
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-0.c
@@ -0,0 +1,23 @@
+/* { dg-do compile { target powerpc*-*-darwin* } } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-Wno-long-long" } */
+
+#include "darwin-structs-0.h"
+
+int tcd[sizeof(cd) != 12 ? -1 : 1];
+int acd[__alignof__(cd) != 4 ? -1 : 1];
+
+int sdc[sizeof(dc) != 16 ? -1 : 1];
+int adc[__alignof__(dc) != 8 ? -1 : 1];
+
+int scL[sizeof(cL) != 12 ? -1 : 1];
+int acL[__alignof__(cL) != 4 ? -1 : 1];
+
+int sLc[sizeof(Lc) != 16 ? -1 : 1];
+int aLc[__alignof__(Lc) != 8 ? -1 : 1];
+
+int scD[sizeof(cD) != 32 ? -1 : 1];
+int acD[__alignof__(cD) != 16 ? -1 : 1];
+
+int sDc[sizeof(Dc) != 32 ? -1 : 1];
+int aDc[__alignof__(Dc) != 16 ? -1 : 1];
diff --git a/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-1.c b/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-1.c
new file mode 100644
index 00000000000..4d888d383fa
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-1.c
@@ -0,0 +1,27 @@
+/* { dg-do compile { target powerpc*-*-darwin* } } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-Wno-long-long" } */
+
+#pragma pack(push, 1)
+
+#include "darwin-structs-0.h"
+
+int tcd[sizeof(cd) != 9 ? -1 : 1];
+int acd[__alignof__(cd) != 1 ? -1 : 1];
+
+int sdc[sizeof(dc) != 9 ? -1 : 1];
+int adc[__alignof__(dc) != 1 ? -1 : 1];
+
+int scL[sizeof(cL) != 9 ? -1 : 1];
+int acL[__alignof__(cL) != 1 ? -1 : 1];
+
+int sLc[sizeof(Lc) != 9 ? -1 : 1];
+int aLc[__alignof__(Lc) != 1 ? -1 : 1];
+
+int scD[sizeof(cD) != 17 ? -1 : 1];
+int acD[__alignof__(cD) != 1 ? -1 : 1];
+
+int sDc[sizeof(Dc) != 17 ? -1 : 1];
+int aDc[__alignof__(Dc) != 1 ? -1 : 1];
+
+#pragma pack(pop)
diff --git a/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-2.c b/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-2.c
new file mode 100644
index 00000000000..3bd52c0a8f8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/darwin-abi-13-2.c
@@ -0,0 +1,27 @@
+/* { dg-do compile { target powerpc*-*-darwin* } } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-Wno-long-long" } */
+
+#pragma pack(push, 2)
+
+#include "darwin-structs-0.h"
+
+int tcd[sizeof(cd) != 10 ? -1 : 1];
+int acd[__alignof__(cd) != 2 ? -1 : 1];
+
+int sdc[sizeof(dc) != 10 ? -1 : 1];
+int adc[__alignof__(dc) != 2 ? -1 : 1];
+
+int scL[sizeof(cL) != 10 ? -1 : 1];
+int acL[__alignof__(cL) != 2 ? -1 : 1];
+
+int sLc[sizeof(Lc) != 10 ? -1 : 1];
+int aLc[__alignof__(Lc) != 2 ? -1 : 1];
+
+int scD[sizeof(cD) != 18 ? -1 : 1];
+int acD[__alignof__(cD) != 2 ? -1 : 1];
+
+int sDc[sizeof(Dc) != 18 ? -1 : 1];
+int aDc[__alignof__(Dc) != 2 ? -1 : 1];
+
+#pragma pack(pop)
diff --git a/gcc/testsuite/gcc.target/powerpc/darwin-structs-0.h b/gcc/testsuite/gcc.target/powerpc/darwin-structs-0.h
new file mode 100644
index 00000000000..1db44f7a808
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/darwin-structs-0.h
@@ -0,0 +1,29 @@
+typedef struct _cd {
+ char c;
+ double d;
+} cd;
+
+typedef struct _dc {
+ double d;
+ char c;
+} dc;
+
+typedef struct _cL {
+ char c;
+ long long L;
+} cL;
+
+typedef struct _Lc {
+ long long L;
+ char c;
+} Lc;
+
+typedef struct _cD {
+ char c;
+ long double D;
+} cD;
+
+typedef struct _Dc {
+ long double D;
+ char c;
+} Dc;
diff --git a/gcc/testsuite/gcc.target/powerpc/divic3-1.c b/gcc/testsuite/gcc.target/powerpc/divic3-1.c
new file mode 100644
index 00000000000..31dac82c25d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/divic3-1.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ppc_float128_sw } */
+/* { dg-options "-O2 -mabi=ieeelongdouble -Wno-psabi" } */
+
+/* When GCC is configured with an older library that does not support IEEE
+   128-bit, it issues a warning if you change the long double type. We use
+   -Wno-psabi to silence this warning.  Since this is a code generation test,
+   it does not matter if the library has full IEEE 128-bit support.  */
+
+/* Check that complex divide generates the right call for __ibm128 when long
+   double is IEEE 128-bit floating point.  */
+
+typedef _Complex long double c_ibm128_t __attribute__((mode(__IC__)));
+
+void
+divide (c_ibm128_t *p, c_ibm128_t *q, c_ibm128_t *r)
+{
+  *p = *q / *r;
+}
+
+/* { dg-final { scan-assembler {\mbl .*__divtc3\M} } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/divic3-2.c b/gcc/testsuite/gcc.target/powerpc/divic3-2.c
new file mode 100644
index 00000000000..1a5900e627e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/divic3-2.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ppc_float128_sw } */
+/* { dg-require-effective-target longdouble128 } */
+/* { dg-options "-O2 -mabi=ibmlongdouble -Wno-psabi" } */
+
+/* When GCC is configured with an older library that does not support IEEE
+   128-bit, it issues a warning if you change the long double type. We use
+   -Wno-psabi to silence this warning.  Since this is a code generation test,
+   it does not matter if the library has full IEEE 128-bit support.
+
+   We also need to require that the default long double is 128-bits, otherwise
+   the TC/TF modes might not be available.  */
+
+/* Check that complex divide generates the right call for __ibm128 when long
+   double is IBM 128-bit floating point.  */
+
+typedef _Complex long double c_ibm128_t __attribute__((mode(__TC__)));
+
+void
+divide (c_ibm128_t *p, c_ibm128_t *q, c_ibm128_t *r)
+{
+  *p = *q / *r;
+}
+
+/* { dg-final { scan-assembler {\mbl .*__divtc3\M} } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/fusion-p10-ldcmpi.c b/gcc/testsuite/gcc.target/powerpc/fusion-p10-ldcmpi.c
index 526a026d874..165bd9a07ad 100644
--- a/gcc/testsuite/gcc.target/powerpc/fusion-p10-ldcmpi.c
+++ b/gcc/testsuite/gcc.target/powerpc/fusion-p10-ldcmpi.c
@@ -54,15 +54,17 @@ TEST(uint8_t)
 TEST(int8_t)
 
 /* { dg-final { scan-assembler-times "lbz_cmpldi_cr0_QI_clobber_CCUNS_zero"   4 { target lp64 } } } */
-/* { dg-final { scan-assembler-times "ld_cmpdi_cr0_DI_DI_CC_none"             4 { target lp64 } } } */
-/* { dg-final { scan-assembler-times "ld_cmpdi_cr0_DI_clobber_CC_none"        4 { target lp64 } } } */
-/* { dg-final { scan-assembler-times "ld_cmpldi_cr0_DI_DI_CCUNS_none"         1 { target lp64 } } } */
-/* { dg-final { scan-assembler-times "ld_cmpldi_cr0_DI_clobber_CCUNS_none"    1 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "ld_cmpdi_cr0_DI_DI_CC_none"            24 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "ld_cmpdi_cr0_DI_clobber_CC_none"        8 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "ld_cmpldi_cr0_DI_DI_CCUNS_none"         2 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "ld_cmpldi_cr0_DI_clobber_CCUNS_none"    2 { target lp64 } } } */
 /* { dg-final { scan-assembler-times "lha_cmpdi_cr0_HI_clobber_CC_sign"      16 { target lp64 } } } */
 /* { dg-final { scan-assembler-times "lhz_cmpldi_cr0_HI_clobber_CCUNS_zero"   4 { target lp64 } } } */
 /* { dg-final { scan-assembler-times "lwa_cmpdi_cr0_SI_EXTSI_CC_sign"         0 { target lp64 } } } */
-/* { dg-final { scan-assembler-times "lwa_cmpdi_cr0_SI_clobber_CC_none"       4 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "lwz_cmpwi_cr0_SI_clobber_CC_none"       8 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "lwz_cmpwi_cr0_SI_SI_CC_none"            8 { target lp64 } } } */
 /* { dg-final { scan-assembler-times "lwz_cmpldi_cr0_SI_EXTSI_CCUNS_zero"     0 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "lwz_cmpldi_cr0_SI_SI_CCUNS_none"        2 { target lp64 } } } */
 /* { dg-final { scan-assembler-times "lwz_cmpldi_cr0_SI_clobber_CCUNS_none"   2 { target lp64 } } } */
 
 /* { dg-final { scan-assembler-times "lbz_cmpldi_cr0_QI_clobber_CCUNS_zero"   2 { target ilp32 } } } */
@@ -73,6 +75,8 @@ TEST(int8_t)
 /* { dg-final { scan-assembler-times "lha_cmpdi_cr0_HI_clobber_CC_sign"       8 { target ilp32 } } } */
 /* { dg-final { scan-assembler-times "lhz_cmpldi_cr0_HI_clobber_CCUNS_zero"   2 { target ilp32 } } } */
 /* { dg-final { scan-assembler-times "lwa_cmpdi_cr0_SI_EXTSI_CC_sign"         0 { target ilp32 } } } */
-/* { dg-final { scan-assembler-times "lwa_cmpdi_cr0_SI_clobber_CC_none"       9 { target ilp32 } } } */
+/* { dg-final { scan-assembler-times "lwz_cmpwi_cr0_SI_SI_CC_none"           36 { target ilp32 } } } */
+/* { dg-final { scan-assembler-times "lwz_cmpwi_cr0_SI_clobber_CC_none"      16 { target ilp32 } } } */
 /* { dg-final { scan-assembler-times "lwz_cmpldi_cr0_SI_EXTSI_CCUNS_zero"     0 { target ilp32 } } } */
 /* { dg-final { scan-assembler-times "lwz_cmpldi_cr0_SI_clobber_CCUNS_none"   6 { target ilp32 } } } */
+/* { dg-final { scan-assembler-times "lwz_cmpldi_cr0_SI_SI_CCUNS_none"        2 { target ilp32 } } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/fusion.c b/gcc/testsuite/gcc.target/powerpc/fusion.c
index 876b9f54d5a..2a115580439 100644
--- a/gcc/testsuite/gcc.target/powerpc/fusion.c
+++ b/gcc/testsuite/gcc.target/powerpc/fusion.c
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-options "-mdejagnu-cpu=power7 -mtune=power8 -O3 -dp" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3 -dp" } */
 
 #define LARGE 0x12345
 
diff --git a/gcc/testsuite/gcc.target/powerpc/fusion2.c b/gcc/testsuite/gcc.target/powerpc/fusion2.c
index b3f457a28e2..40ca00a7405 100644
--- a/gcc/testsuite/gcc.target/powerpc/fusion2.c
+++ b/gcc/testsuite/gcc.target/powerpc/fusion2.c
@@ -2,7 +2,7 @@
 /* { dg-skip-if "" { powerpc*-*-darwin* } } */
 /* { dg-skip-if "" { powerpc*le-*-* } } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
-/* { dg-options "-mdejagnu-cpu=power7 -mtune=power8 -O3" } */
+/* { dg-options "-mdejagnu-cpu=power7 -mdejagnu-tune=power8 -O3" } */
 
 vector double fusion_vector (vector double *p) { return p[2]; }
 
diff --git a/gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c b/gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c
index 1255ee9f0ab..9d216799a0f 100644
--- a/gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c
+++ b/gcc/testsuite/gcc.target/powerpc/int_128bit-runnable.c
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-mcpu=power10 -save-temps" } */
+/* { dg-options "-mdejagnu-cpu=power10 -save-temps" } */
 /* { dg-require-effective-target power10_hw } */
 
 /* Check that the expected 128-bit instructions are generated if the processor
@@ -90,7 +90,11 @@ int main ()
   vec_arg1_di[0] = 1000;
   vec_arg1_di[1] = -123456;
 
+#ifdef __BIG_ENDIAN__
+  expected_result = -123456;
+#else
   expected_result = 1000;
+#endif
 
   vec_result = vec_signextq (vec_arg1_di);
 
@@ -109,7 +113,11 @@ int main ()
   vec_arg1_di[0] = -123456;
   vec_arg1_di[1] = 1000;
 
+#ifdef __BIG_ENDIAN__
+  expected_result = 1000;
+#else
   expected_result = -123456;
+#endif
 
   vec_result = vec_signextq (vec_arg1_di);
 
diff --git a/gcc/testsuite/gcc.target/powerpc/mod-1.c b/gcc/testsuite/gcc.target/powerpc/mod-1.c
index 861ba670af4..8720ffb3346 100644
--- a/gcc/testsuite/gcc.target/powerpc/mod-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/mod-1.c
@@ -7,13 +7,14 @@ long lsmod (long a, long b) { return a%b; }
 unsigned int iumod (unsigned int a, unsigned int b) { return a%b; }
 unsigned long lumod (unsigned long a, unsigned long b) { return a%b; }
 
-/* { dg-final { scan-assembler-times "modsw " 1 } } */
-/* { dg-final { scan-assembler-times "modsd " 1 } } */
-/* { dg-final { scan-assembler-times "moduw " 1 } } */
-/* { dg-final { scan-assembler-times "modud " 1 } } */
-/* { dg-final { scan-assembler-not   "mullw "   } } */
-/* { dg-final { scan-assembler-not   "mulld "   } } */
-/* { dg-final { scan-assembler-not   "divw "    } } */
-/* { dg-final { scan-assembler-not   "divd "    } } */
-/* { dg-final { scan-assembler-not   "divwu "   } } */
-/* { dg-final { scan-assembler-not   "divdu "   } } */
+/* { Fail due to RS6000_DISABLE_SCALAR_MODULO. */
+/* { dg-final { scan-assembler-times {\mmodsw\M} 1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-times {\mmodsd\M} 1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-times {\mmoduw\M} 1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-times {\mmodud\M} 1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mmullw\M}   { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mmulld\M}   { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mdivw\M}    { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mdivd\M}    { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mdivwu\M}   { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mdivdu\M}   { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/mod-2.c b/gcc/testsuite/gcc.target/powerpc/mod-2.c
index 441ec5878f1..54bdca88607 100644
--- a/gcc/testsuite/gcc.target/powerpc/mod-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/mod-2.c
@@ -5,8 +5,9 @@
 int ismod (int a, int b) { return a%b; }
 unsigned int iumod (unsigned int a, unsigned int b) { return a%b; }
 
-/* { dg-final { scan-assembler-times "modsw " 1 } } */
-/* { dg-final { scan-assembler-times "moduw " 1 } } */
-/* { dg-final { scan-assembler-not   "mullw "   } } */
-/* { dg-final { scan-assembler-not   "divw "    } } */
-/* { dg-final { scan-assembler-not   "divwu "   } } */
+/* { Fail due to RS6000_DISABLE_SCALAR_MODULO. */
+/* { dg-final { scan-assembler-times {\mmodsw\M} 1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-times {\mmoduw\M} 1 { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mmullw\M}   { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mdivw\M}    { xfail *-*-* } } } */
+/* { dg-final { scan-assembler-not   {\mdivwu\M}   { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/mulic3-1.c b/gcc/testsuite/gcc.target/powerpc/mulic3-1.c
new file mode 100644
index 00000000000..664f7118167
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/mulic3-1.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ppc_float128_sw } */
+/* { dg-options "-O2 -mabi=ieeelongdouble -Wno-psabi" } */
+
+/* When GCC is configured with an older library that does not support IEEE
+   128-bit, it issues a warning if you change the long double type. We use
+   -Wno-psabi to silence this warning.  Since this is a code generation test,
+   it does not matter if the library has full IEEE 128-bit support.  */
+
+/* Check that complex multiply generates the right call for __ibm128 when long
+   double is IEEE 128-bit floating point.  */
+
+typedef _Complex long double c_ibm128_t __attribute__((mode(__IC__)));
+
+void
+multiply (c_ibm128_t *p, c_ibm128_t *q, c_ibm128_t *r)
+{
+  *p = *q * *r;
+}
+
+/* { dg-final { scan-assembler {\mbl .*__multc3\M} } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/mulic3-2.c b/gcc/testsuite/gcc.target/powerpc/mulic3-2.c
new file mode 100644
index 00000000000..c2c12dcd817
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/mulic3-2.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ppc_float128_sw } */
+/* { dg-require-effective-target longdouble128 } */
+/* { dg-options "-O2 -mabi=ibmlongdouble -Wno-psabi" } */
+
+/* When GCC is configured with an older library that does not support IEEE
+   128-bit, it issues a warning if you change the long double type. We use
+   -Wno-psabi to silence this warning.  Since this is a code generation test,
+   it does not matter if the library has full IEEE 128-bit support.
+
+   We also need to require that the default long double is 128-bits, otherwise
+   the TC/TF modes might not be available.  */
+
+/* Check that complex multiply generates the right call for __ibm128 when long
+   double is IBM 128-bit floating point.  */
+
+typedef _Complex long double c_ibm128_t __attribute__((mode(__TC__)));
+
+void
+multiply (c_ibm128_t *p, c_ibm128_t *q, c_ibm128_t *r)
+{
+  *p = *q * *r;
+}
+
+/* { dg-final { scan-assembler {\mbl .*__multc3\M} } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/p10-vdivq-vmodq.c b/gcc/testsuite/gcc.target/powerpc/p10-vdivq-vmodq.c
index 84685e5ff43..148998c8c9d 100644
--- a/gcc/testsuite/gcc.target/powerpc/p10-vdivq-vmodq.c
+++ b/gcc/testsuite/gcc.target/powerpc/p10-vdivq-vmodq.c
@@ -23,5 +23,6 @@ __int128 s_mod(__int128 a, __int128 b)
 
 /* { dg-final { scan-assembler {\mvdivsq\M} } } */
 /* { dg-final { scan-assembler {\mvdivuq\M} } } */
-/* { dg-final { scan-assembler {\mvmodsq\M} } } */
-/* { dg-final { scan-assembler {\mvmoduq\M} } } */
+/* { Fail due to RS6000_DISABLE_SCALAR_MODULO. */
+/* { dg-final { scan-assembler {\mvmodsq\M} { xfail *-*-* } } } */
+/* { dg-final { scan-assembler {\mvmoduq\M} { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-sign_extend-runnable.c b/gcc/testsuite/gcc.target/powerpc/p9-sign_extend-runnable.c
index fdcad019b96..03c0f1201e4 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-sign_extend-runnable.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-sign_extend-runnable.c
@@ -34,7 +34,12 @@ int main ()
   /* test sign extend byte to word */
   vec_arg_qi = (vector signed char) {1, 2, 3, 4, 5, 6, 7, 8,
 				     -1, -2, -3, -4, -5, -6, -7, -8};
+
+#ifdef __BIG_ENDIAN__
+  vec_expected_wi = (vector signed int) {4, 8, -4, -8};
+#else
   vec_expected_wi = (vector signed int) {1, 5, -1, -5};
+#endif
 
   vec_result_wi = vec_signexti (vec_arg_qi);
 
@@ -54,7 +59,12 @@ int main ()
   /* test sign extend byte to double */
   vec_arg_qi = (vector signed char){1, 2, 3, 4, 5, 6, 7, 8,
 				    -1, -2, -3, -4, -5, -6, -7, -8};
+
+#ifdef __BIG_ENDIAN__
+  vec_expected_di = (vector signed long long int){8, -8};
+#else
   vec_expected_di = (vector signed long long int){1, -1};
+#endif
 
   vec_result_di = vec_signextll(vec_arg_qi);
 
@@ -72,7 +82,12 @@ int main ()
 
   /* test sign extend short to word */
   vec_arg_hi = (vector signed short int){1, 2, 3, 4, -1, -2, -3, -4};
+
+#ifdef __BIG_ENDIAN__
+  vec_expected_wi = (vector signed int){2, 4, -2, -4};
+#else
   vec_expected_wi = (vector signed int){1, 3, -1, -3};
+#endif
 
   vec_result_wi = vec_signexti(vec_arg_hi);
 
@@ -90,7 +105,12 @@ int main ()
 
   /* test sign extend short to double word */
   vec_arg_hi = (vector signed short int ){1, 3, 5, 7,  -1, -3, -5, -7};
+
+#ifdef __BIG_ENDIAN__
+  vec_expected_di = (vector signed long long int){7, -7};
+#else
   vec_expected_di = (vector signed long long int){1, -1};
+#endif
 
   vec_result_di = vec_signextll(vec_arg_hi);
 
@@ -108,7 +128,12 @@ int main ()
 
   /* test sign extend word to double word */
   vec_arg_wi = (vector signed int ){1, 3, -1, -3};
+
+#ifdef __BIG_ENDIAN__
+  vec_expected_di = (vector signed long long int){3, -3};
+#else
   vec_expected_di = (vector signed long long int){1, -1};
+#endif
 
   vec_result_di = vec_signextll(vec_arg_wi);
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-1.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-1.c
index d248f091b52..dfcc0e95320 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=1" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-2.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-2.c
index 9f78a447ec7..e63f1bf2372 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=1" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-3.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-3.c
index a08797fcbca..4a99e3a3265 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-3.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=1" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-4.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-4.c
index ad051fb1cef..9fbee6a4324 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-4.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=1" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-5.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-5.c
index a24c30feeba..d023a998c3b 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-5.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-5.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=1" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-6.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-6.c
index 4eaeb3b005f..dbce90757e3 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-6.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-6.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=1" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-8.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-8.c
index 961df0d5646..b7b01fc14d8 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-8.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-epil-8.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=1" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-1.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-1.c
index 3336752edbb..f01f1c54fa5 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-1.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=2" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-2.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-2.c
index 98abf8b33b1..f546e97fa7d 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-2.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=2" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-3.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-3.c
index 0881d1a960a..65142b3fecd 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-3.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=2" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-4.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-4.c
index 8ce3dc19a60..a4cc7aafaeb 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-4.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=2" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-5.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-5.c
index f9f58ba11f5..4b0b9070c84 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-5.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-5.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=2" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-6.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-6.c
index 5d2357aabfa..65ddf2b098a 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-6.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-6.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=2" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-8.c b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-8.c
index 1fc2af1e753..7fe0dd00431 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-8.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vec-length-full-8.c
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { lp64 && powerpc_p9vector_ok } } } */
-/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops" } */
+/* { dg-options "-mdejagnu-cpu=power9 -O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops -fno-trapping-math" } */
 
 /* { dg-additional-options "--param=vect-partial-vector-usage=2" } */
 
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vparity.c b/gcc/testsuite/gcc.target/powerpc/p9-vparity.c
index f4aba1567cd..8f6f1239f7a 100644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vparity.c
+++ b/gcc/testsuite/gcc.target/powerpc/p9-vparity.c
@@ -105,3 +105,4 @@ parity_ti_4u (__uint128_t a)
 /* { dg-final { scan-assembler "vprtybd" } } */
 /* { dg-final { scan-assembler "vprtybq" } } */
 /* { dg-final { scan-assembler "vprtybw" } } */
+/* { dg-final { scan-assembler-not "vpopcntb" } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr102059-4.c b/gcc/testsuite/gcc.target/powerpc/pr102059-4.c
new file mode 100644
index 00000000000..4a0ad3daf73
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr102059-4.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+/* { dg-require-effective-target power10_ok } */
+
+/* Verify that power10 can explicity include functions compiled for power8.
+   The issue was -mcpu=power8 enables -mpower8-fusion, but -mcpu=power9 or
+   -mcpu=power10 do not set power8-fusion by default.  Thus when doing this
+   compilation, they would get an error that the inline function failed in its
+   inlining due to having incompatible options.  */
+
+static inline int __attribute__ ((always_inline,target("cpu=power8,no-htm")))
+foo (int *b)
+{
+  *b += 10;
+  return *b;
+}
+
+int
+bar (int *a)
+{
+  *a = foo (a);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr103353.c b/gcc/testsuite/gcc.target/powerpc/pr103353.c
new file mode 100644
index 00000000000..5d519fb1b7b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr103353.c
@@ -0,0 +1,22 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* If the default cpu type is power10 or later, MMA is enabled by default.
+   To keep the test point available all the time, this case specifies
+   -mdejagnu-cpu=power6 to make it be tested without MMA.  */
+/* { dg-options "-maltivec -mdejagnu-cpu=power6" } */
+
+/* Verify there is no ICE and don't check the error messages on MMA
+   requirement since they could be fragile and are not test points
+   of this case.  */
+/* { dg-excess-errors "pr103353" } */
+
+void
+foo (__vector_pair *dst, double *x)
+{
+  dst[0] = __builtin_vsx_lxvp (0, (__vector_pair *)(void *)x);
+}
+
+void
+bar (__vector_pair *src, double *x)
+{
+  __builtin_vsx_stxvp (src[0], 0, (__vector_pair *)(void *)x);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr105041.c b/gcc/testsuite/gcc.target/powerpc/pr105041.c
new file mode 100644
index 00000000000..c52b7a5ef30
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr105041.c
@@ -0,0 +1,22 @@
+/* { dg-options "-mdejagnu-cpu=power4 -O2 -fcompare-debug -frename-registers" } */
+
+double m;
+int n;
+
+unsigned int
+foo (unsigned int x, int y)
+{
+  long long int a = y, b = !a;
+  int c = 0;
+
+  if (b != x)
+    while ((int) m == a)
+      {
+        c = a;
+        a = 0;
+      }
+
+  n = b = y;
+
+  return x + c;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106016.c b/gcc/testsuite/gcc.target/powerpc/pr106016.c
new file mode 100644
index 00000000000..3db8345dcc6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106016.c
@@ -0,0 +1,14 @@
+/* PR target/106016 */
+/* { dg-require-effective-target power10_ok } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+/* Make sure we do not ICE on the following test case.  */
+
+extern void bar (__vector_quad *);
+
+void
+foo (__vector_quad *a, __vector_quad *b)
+{
+  __vector_quad arr[2] = {*a, *b};
+  bar (&arr[0]);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106017.c b/gcc/testsuite/gcc.target/powerpc/pr106017.c
new file mode 100644
index 00000000000..46d6c7a4a33
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106017.c
@@ -0,0 +1,19 @@
+/* PR target/106017 */
+/* { dg-options "-O1 -mdejagnu-cpu=power10" } */
+/* { dg-require-effective-target power10_ok } */
+
+/* Make sure we do not flag any errors on the following test cases.  */
+
+void takeacc(__vector_quad *);
+void
+foo (void)
+{
+  __vector_quad arr[4];
+  takeacc (arr);
+}
+
+unsigned char *
+bar (__vector_quad *a)
+{
+  return (unsigned char *)a;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106091.c b/gcc/testsuite/gcc.target/powerpc/pr106091.c
new file mode 100644
index 00000000000..61ce8cf4733
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106091.c
@@ -0,0 +1,15 @@
+/* { dg-options "-O -fnon-call-exceptions -fno-tree-dce -fno-tree-forwprop -w" } */
+
+/* Verify there is no ICE.  */
+
+typedef short __attribute__ ((__vector_size__ (64))) V;
+V v, w;
+
+inline V foo (V a, V b);
+
+V
+foo (V a, V b)
+{
+  b &= v < b;
+  return (V){foo (b, w)[3], (V){}[3]};
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-1.c b/gcc/testsuite/gcc.target/powerpc/pr106736-1.c
new file mode 100644
index 00000000000..65bd79d3dce
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-1.c
@@ -0,0 +1,20 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-1" } */
+
+extern void bar (__vector_quad *);
+
+void
+foo (__vector_quad *a, __vector_quad *b)
+{
+  __vector_quad arr[2] = {*a, *b};
+  bar (&arr[0]);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-2.c b/gcc/testsuite/gcc.target/powerpc/pr106736-2.c
new file mode 100644
index 00000000000..12ad936fccc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-2.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-2" } */
+
+void
+foo (__vector_pair *a, __vector_pair *b)
+{
+  *a = *b;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-3.c b/gcc/testsuite/gcc.target/powerpc/pr106736-3.c
new file mode 100644
index 00000000000..4fb368b8fb5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-3.c
@@ -0,0 +1,18 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-3" } */
+
+__vector_quad ga;
+void
+foo (__vector_quad *a)
+{
+  ga = *a;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-4.c b/gcc/testsuite/gcc.target/powerpc/pr106736-4.c
new file mode 100644
index 00000000000..4b366416b0a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-4.c
@@ -0,0 +1,19 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-4" } */
+
+__vector_quad ga;
+__vector_quad gb;
+void
+foo ()
+{
+  gb = ga;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr106736-5.c b/gcc/testsuite/gcc.target/powerpc/pr106736-5.c
new file mode 100644
index 00000000000..d7370b81e81
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr106736-5.c
@@ -0,0 +1,18 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr106736-5" } */
+
+__vector_pair ga;
+void
+foo (__vector_pair *a)
+{
+  *a = ga;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr108272-1.c b/gcc/testsuite/gcc.target/powerpc/pr108272-1.c
new file mode 100644
index 00000000000..b99e6a4d86d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr108272-1.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr108272-1" } */
+
+void
+foo (void)
+{
+  __vector_quad acc;
+  asm("#..." : "=d"(acc));
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr108272-2.c b/gcc/testsuite/gcc.target/powerpc/pr108272-2.c
new file mode 100644
index 00000000000..51b2100d0f1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr108272-2.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr108272-2" } */
+
+void
+foo (void)
+{
+  __vector_pair acc;
+  asm("#..." :: "d"(acc));
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr108272-3.c b/gcc/testsuite/gcc.target/powerpc/pr108272-3.c
new file mode 100644
index 00000000000..634a529b5c8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr108272-3.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr108272-3" } */
+
+void
+foo (void)
+{
+  volatile __vector_quad acc;
+  asm("#..." : "=d"(acc));
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr108272-4.c b/gcc/testsuite/gcc.target/powerpc/pr108272-4.c
new file mode 100644
index 00000000000..7eecd6c5a0d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr108272-4.c
@@ -0,0 +1,18 @@
+/* { dg-require-effective-target powerpc_p9modulo_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  */
+/* { dg-options "-mdejagnu-cpu=power9" } */
+
+/* Verify there is no ICE and don't check the error messages on unsupported
+   type since they could be fragile and are not test points of this case.  */
+
+/* { dg-excess-errors "pr108272-4" } */
+
+typedef __vector_pair vpair_t;
+void
+foo (void)
+{
+  vpair_t acc;
+  asm("#..." : "=d"(acc));
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr108348-1.c b/gcc/testsuite/gcc.target/powerpc/pr108348-1.c
new file mode 100644
index 00000000000..29cbe7abffc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr108348-1.c
@@ -0,0 +1,23 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* If the default cpu type is power10 or later, type __vector_quad is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  This needs -mabi=no-altivec
+   to do the copying for pass-by-reference function argument on 32 bit
+   environment.  */
+/* { dg-options "-mdejagnu-cpu=power9 -mabi=no-altivec" } */
+
+/* Verify there is no ICE on 32 bit and don't check the error messages
+   on unsupported type since they could be fragile and are not test
+   points of this case.  */
+
+/* { dg-excess-errors "pr108348-1" } */
+
+extern void bar (__vector_quad v);
+
+void
+foo (void)
+{
+  __vector_quad v;
+  bar (v);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr108348-2.c b/gcc/testsuite/gcc.target/powerpc/pr108348-2.c
new file mode 100644
index 00000000000..9aa8939e2f4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr108348-2.c
@@ -0,0 +1,23 @@
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* If the default cpu type is power10 or later, type __vector_pair is
+   supported.  To keep the test point available all the time, this case
+   specifies -mdejagnu-cpu=power9 here.  This needs -mabi=no-altivec
+   to do the copying for pass-by-reference function argument on 32 bit
+   environment.  */
+/* { dg-options "-mdejagnu-cpu=power9 -mabi=no-altivec" } */
+
+/* Verify there is no ICE on 32 bit and don't check the error messages
+   on unsupported type since they could be fragile and are not test
+   points of this case.  */
+
+/* { dg-excess-errors "pr108348-2" } */
+
+extern void bar (__vector_pair v);
+
+void
+foo (void)
+{
+  __vector_pair v;
+  bar (v);
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr108699.c b/gcc/testsuite/gcc.target/powerpc/pr108699.c
new file mode 100644
index 00000000000..f02bac130cc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr108699.c
@@ -0,0 +1,42 @@
+/* { dg-run } */
+/* { dg-options "-O2 -ftree-vectorize -fno-vect-cost-model" } */
+
+#define N 16
+
+unsigned long long vals[N];
+unsigned int res[N];
+unsigned int expects[N] = {0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+unsigned long long inputs[N]
+  = {0x0000000000000000ULL, 0x0000000000000001ULL, 0x8000000000000000ULL,
+     0x0000000000000002ULL, 0x4000000000000000ULL, 0x0000000100000000ULL,
+     0x0000000080000000ULL, 0xa5a5a5a5a5a5a5a5ULL, 0x5a5a5a5a5a5a5a5aULL,
+     0xcafecafe00000000ULL, 0x0000cafecafe0000ULL, 0x00000000cafecafeULL,
+     0x8070600000000000ULL, 0xffffffffffffffffULL};
+
+__attribute__ ((noipa)) void
+init ()
+{
+  for (int i = 0; i < N; i++)
+    vals[i] = inputs[i];
+}
+
+__attribute__ ((noipa)) void
+do_parity ()
+{
+  for (int i = 0; i < N; i++)
+    res[i] = __builtin_parityll (vals[i]);
+}
+
+int
+main (void)
+{
+  init ();
+  do_parity ();
+  for (int i = 0; i < N; i++)
+    if (res[i] != expects[i])
+      __builtin_abort();
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr109932-1.c b/gcc/testsuite/gcc.target/powerpc/pr109932-1.c
new file mode 100644
index 00000000000..374d9f60618
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr109932-1.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target int128 } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec -mno-vsx" } */
+
+/* Verify there is no ICE but one expected error message instead.  */
+
+#include <altivec.h>
+
+extern vector signed __int128 res_vslll;
+extern unsigned long long aull[2];
+
+void
+testVectorInt128Pack ()
+{
+  res_vslll = __builtin_pack_vector_int128 (aull[0], aull[1]); /* { dg-error "'__builtin_pack_vector_int128' requires the '-mvsx' option" } */
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr109932-2.c b/gcc/testsuite/gcc.target/powerpc/pr109932-2.c
new file mode 100644
index 00000000000..374d9f60618
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr109932-2.c
@@ -0,0 +1,17 @@
+/* { dg-require-effective-target int128 } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec -mno-vsx" } */
+
+/* Verify there is no ICE but one expected error message instead.  */
+
+#include <altivec.h>
+
+extern vector signed __int128 res_vslll;
+extern unsigned long long aull[2];
+
+void
+testVectorInt128Pack ()
+{
+  res_vslll = __builtin_pack_vector_int128 (aull[0], aull[1]); /* { dg-error "'__builtin_pack_vector_int128' requires the '-mvsx' option" } */
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr110011.c b/gcc/testsuite/gcc.target/powerpc/pr110011.c
new file mode 100644
index 00000000000..5b04d3e298a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr110011.c
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-require-effective-target float128_runtime } */
+/* Force long double to be with IBM format here, to verify
+   _Float128 constant still uses its own format (IEEE) for
+   encoding rather than IBM format.  */
+/* { dg-options "-mfp-in-toc -mabi=ibmlongdouble" } */
+/* { dg-add-options float128 } */
+
+#define MPFR_FLOAT128_MAX 0x1.ffffffffffffffffffffffffffffp+16383f128
+
+__attribute__ ((noipa))
+_Float128 f128_max ()
+{
+  return MPFR_FLOAT128_MAX;
+}
+
+typedef union
+{
+  int w[4];
+  _Float128 f128;
+} U;
+
+int main ()
+{
+
+  U umax;
+  umax.f128 = f128_max ();
+  /* ieee float128 max:
+     7ffeffff ffffffff ffffffff ffffffff.  */
+  if (umax.w[1] != 0xffffffff || umax.w[2] != 0xffffffff)
+    __builtin_abort ();
+#ifdef __LITTLE_ENDIAN__
+  if (umax.w[0] != 0xffffffff || umax.w[3] != 0x7ffeffff)
+    __builtin_abort ();
+#else
+  if (umax.w[3] != 0xffffffff || umax.w[0] != 0x7ffeffff)
+    __builtin_abort ();
+#endif
+
+  return 0;
+}
+
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70243.c b/gcc/testsuite/gcc.target/powerpc/pr70243.c
new file mode 100644
index 00000000000..18a5ce78792
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr70243.c
@@ -0,0 +1,41 @@
+/* { dg-do compile */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O2 -mvsx" } */
+
+/* PR 70423, Make sure we don't generate vmaddfp or vnmsubfp.  These
+   instructions have different rounding modes than the VSX instructions
+   xvmaddsp and xvnmsubsp.  These tests are written where the 3 inputs and
+   target are all separate registers.  Because vmaddfp and vnmsubfp are no
+   longer generated the compiler will have to generate an xsmaddsp or xsnmsubsp
+   instruction followed by a move operation.  */
+
+#include <altivec.h>
+
+vector float
+do_add1 (vector float dummy, vector float a, vector float b, vector float c)
+{
+  return (a * b) + c;
+}
+
+vector float
+do_nsub1 (vector float dummy, vector float a, vector float b, vector float c)
+{
+  return -((a * b) - c);
+}
+
+vector float
+do_add2 (vector float dummy, vector float a, vector float b, vector float c)
+{
+  return vec_madd (a, b, c);
+}
+
+vector float
+do_nsub2 (vector float dummy, vector float a, vector float b, vector float c)
+{
+  return vec_nmsub (a, b, c);
+}
+
+/* { dg-final { scan-assembler     {\mxvmadd[am]sp\M}  } } */
+/* { dg-final { scan-assembler     {\mxvnmsub[am]sp\M} } } */
+/* { dg-final { scan-assembler-not {\mvmaddfp\M}       } } */
+/* { dg-final { scan-assembler-not {\mvnmsubfp\M}      } } */
diff --git a/gcc/testsuite/gcc.target/powerpc/pr96072.c b/gcc/testsuite/gcc.target/powerpc/pr96072.c
new file mode 100644
index 00000000000..10341c91d2f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr96072.c
@@ -0,0 +1,14 @@
+/* { dg-options "-O2" } */
+
+/* This used to ICE with the SYSV ABI (PR96072).  */
+
+void
+he (int jn)
+{
+  {
+    int bh[jn];
+    if (jn != 0)
+      goto wa;
+  }
+wa:;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr96373.c b/gcc/testsuite/gcc.target/powerpc/pr96373.c
new file mode 100644
index 00000000000..f0471b6f68b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr96373.c
@@ -0,0 +1,31 @@
+/* { dg-do run { target { powerpc*-*-linux* } } } */
+/* { dg-options "-O2 -ftree-vectorize" } */
+
+/* Verify it can run successfully, especially on Power10 and later.   */
+
+#define _GNU_SOURCE
+#include <fenv.h>
+
+__attribute__ ((noipa)) void
+div (double *d, double *s, int n)
+{
+  for (; n; n--, d++, s++)
+    *d = *d / *s;
+}
+
+int main()
+{
+  double d[] = {1,2,3,4,5,6,7,8,9,10,11};
+  double s[] = {11,10,9,8,7,6,5,4,3,2,1};
+
+  feenableexcept(FE_DIVBYZERO|FE_INVALID);
+  div(d, s, 11);
+
+  int i;
+  for (i = 0; i < 11; i++)
+    __builtin_printf(" %f", d[i]);
+
+  __builtin_printf("\n");
+
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/pr96762.c b/gcc/testsuite/gcc.target/powerpc/pr96762.c
new file mode 100644
index 00000000000..a59deb42738
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr96762.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mdejagnu-cpu=power10" } */
+
+/* Verify there is no ICE on ilp32 env.  */
+
+extern void foo (char *);
+
+void
+bar (void)
+{
+  char zj[] = "XXXXXXXXXXXXXXXX";
+  foo (zj);
+}
diff --git a/gcc/testsuite/gcc.target/powerpc/test_mffsl.c b/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
index 41377efba1a..045d0bfa349 100644
--- a/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
+++ b/gcc/testsuite/gcc.target/powerpc/test_mffsl.c
@@ -1,5 +1,6 @@
 /* { dg-do run { target { powerpc*-*-* } } } */
-/* { dg-options "-O2 -std=c99" } */
+/* { dg-options "-O2 -std=c99 -mdejagnu-cpu=power9" } */
+/* { dg-require-effective-target p9vector_hw } */
 
 #ifdef DEBUG
 #include <stdio.h>
diff --git a/gcc/testsuite/gcc.target/s390/pr106355-1.c b/gcc/testsuite/gcc.target/s390/pr106355-1.c
new file mode 100644
index 00000000000..1ec0f6b25ac
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr106355-1.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+/* { dg-options "-foptimize-sibling-calls" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar4} } } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar8} } } */
+
+/* Parameter E is passed in GPR 6 which is call-saved which prohibits
+   sibling call optimization.  This must hold true also if the mode of the
+   parameter is BLKmode.  */
+
+/* 4 byte */
+
+typedef struct
+{
+  char x;
+  char y[3];
+} t4;
+
+extern t4 e4;
+
+extern void bar4 (int a, int b, int c, int d, t4 e4);
+
+void foo4 (int a, int b, int c, int d)
+{
+  bar4 (a, b, c, d, e4);
+}
+
+/* 8 byte */
+
+typedef struct
+{
+  short x;
+  char y[6];
+} t8;
+
+extern t8 e8;
+
+extern void bar8 (int a, int b, int c, int d, t8 e8);
+
+void foo8 (int a, int b, int c, int d)
+{
+  bar8 (a, b, c, d, e8);
+}
diff --git a/gcc/testsuite/gcc.target/s390/pr106355-2.c b/gcc/testsuite/gcc.target/s390/pr106355-2.c
new file mode 100644
index 00000000000..ddbdba5d278
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr106355-2.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target { s390-*-* } } } */
+/* { dg-options "-foptimize-sibling-calls -mzarch" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar} } } */
+
+/* This tests function s390_call_saved_register_used where
+   GET_CODE (parm_rtx) == PARALLEL holds.  */
+
+#include "pr106355.h"
diff --git a/gcc/testsuite/gcc.target/s390/pr106355-3.c b/gcc/testsuite/gcc.target/s390/pr106355-3.c
new file mode 100644
index 00000000000..39daea44fc4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr106355-3.c
@@ -0,0 +1,8 @@
+/* { dg-do compile { target { s390-*-* } } } */
+/* { dg-options "-foptimize-sibling-calls -mesa" } */
+/* { dg-final { scan-assembler {brasl\t%r\d+,bar} } } */
+
+/* This tests function s390_call_saved_register_used where
+   REG_P (parm_rtx) and nregs == 2 holds.  */
+
+#include "pr106355.h"
diff --git a/gcc/testsuite/gcc.target/s390/pr106355.h b/gcc/testsuite/gcc.target/s390/pr106355.h
new file mode 100644
index 00000000000..362908e5913
--- /dev/null
+++ b/gcc/testsuite/gcc.target/s390/pr106355.h
@@ -0,0 +1,18 @@
+/* For the S/390 ABI parameter D is passed in GPR 5 and 6 and the latter is
+   call-saved which prohibits sibling call optimization.  This must hold true
+   also if the mode of the parameter is BLKmode.  */
+
+typedef struct
+{
+  short x;
+  char y[6];
+} t;
+
+extern t d;
+
+extern void bar (int a, int b, int c, t d);
+
+void foo (int a, int b, int c)
+{
+  bar (a, b, c, d);
+}
diff --git a/gcc/testsuite/gcc.target/sparc/20220510-1.c b/gcc/testsuite/gcc.target/sparc/20220510-1.c
new file mode 100644
index 00000000000..f321cab8482
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20220510-1.c
@@ -0,0 +1,31 @@
+/* PR target/105292 */
+/* Reported by Koakuma <koachan+gccbugs@protonmail.com> */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -mvis2" } */
+
+extern void get_vbytes_v2 (unsigned);
+
+typedef struct {
+  unsigned ctt_info;
+  unsigned ctt_size;
+} ctf_type_t;
+
+typedef struct {
+  unsigned short cts_offset;
+  unsigned short cts_bits;
+} ctf_slice_t;
+
+void flip_types_len (ctf_type_t *t, int bsx1, int bsx2)
+{
+  const int kind = t->ctt_info;
+
+  get_vbytes_v2 (t->ctt_size);
+
+  if (kind == 4)
+    {
+      ctf_slice_t *s = (ctf_slice_t *)t;
+      s->cts_offset = __builtin_bswap16(bsx1);
+      s->cts_bits   = __builtin_bswap16(bsx2);
+    }
+}
diff --git a/gcc/testsuite/gcc.target/sparc/20230328-1.c b/gcc/testsuite/gcc.target/sparc/20230328-1.c
new file mode 100644
index 00000000000..becdc2ed3b3
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20230328-1.c
@@ -0,0 +1,19 @@
+/* PR target/109140 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mvis3 -std=c99" } */
+
+#define TYPE unsigned char
+
+struct S { TYPE ub[8]; };
+
+struct S s;
+
+TYPE v;
+
+void foo (void)
+{
+  for (int i = 0; i < 8; i++)
+    s.ub[i] = s.ub[i] > v;
+}
+
+/* { dg-final { scan-assembler "fucmpgt8\t%" } } */
diff --git a/gcc/testsuite/gcc.target/sparc/20230328-2.c b/gcc/testsuite/gcc.target/sparc/20230328-2.c
new file mode 100644
index 00000000000..d63d047db80
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20230328-2.c
@@ -0,0 +1,19 @@
+/* PR target/109140 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mvis4 -std=c99" } */
+
+#define TYPE char
+
+struct S { TYPE ub[8]; };
+
+struct S s;
+
+TYPE v;
+
+void foo (void)
+{
+  for (int i = 0; i < 8; i++)
+    s.ub[i] = s.ub[i] > v;
+}
+
+/* { dg-final { scan-assembler "fpcmpgt8\t%" } } */
diff --git a/gcc/testsuite/gcc.target/sparc/20230328-3.c b/gcc/testsuite/gcc.target/sparc/20230328-3.c
new file mode 100644
index 00000000000..8ad10bbf0af
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20230328-3.c
@@ -0,0 +1,19 @@
+/* PR target/109140 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mvis4 -std=c99" } */
+
+#define TYPE unsigned short
+
+struct S { TYPE ub[4]; };
+
+struct S s;
+
+TYPE v;
+
+void foo (void)
+{
+  for (int i = 0; i < 4; i++)
+    s.ub[i] = s.ub[i] > v;
+}
+
+/* { dg-final { scan-assembler "fpcmpugt16\t%" } } */
diff --git a/gcc/testsuite/gcc.target/sparc/20230328-4.c b/gcc/testsuite/gcc.target/sparc/20230328-4.c
new file mode 100644
index 00000000000..f3e4ecef7b8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/sparc/20230328-4.c
@@ -0,0 +1,19 @@
+/* PR target/109140 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -mvis3 -std=c99" } */
+
+#define TYPE short
+
+struct S { TYPE ub[4]; };
+
+struct S s;
+
+TYPE v;
+
+void foo (void)
+{
+  for (int i = 0; i < 4; i++)
+    s.ub[i] = s.ub[i] > v;
+}
+
+/* { dg-final { scan-assembler "fcmpgt16\t%" } } */
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
index 7a8ed03d119..b2ad67aef87 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/asm-support.S
@@ -82,3 +82,6 @@ snapshot_ret:
 	.comm	xmm_regs,256,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
index 73a59191d6d..24c8b3c9023 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx/asm-support.S
@@ -79,3 +79,6 @@ snapshot_ret:
 	.comm	ymm_regs,512,32
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
index 0ef82876dd9..86d54d11c58 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support.S
@@ -95,3 +95,6 @@ snapshot_ret:
 	.comm	zmm_regs,2048,64
 	.comm	x87_regs,128,32
 	.comm   volatile_var,8,8
+#ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+#endif
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S b/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
index 1d6cd9503e2..ed6f32ea041 100644
--- a/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
+++ b/gcc/testsuite/gcc.target/x86_64/abi/ms-sysv/do-test.S
@@ -30,6 +30,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #ifdef __ELF__
 # define FN_TYPE(fn) .type fn,@function
 # define FN_SIZE(fn) .size fn,.-fn
+# ifdef __linux__
+	.section	.note.GNU-stack,"",@progbits
+# endif
 #else
 # define FN_TYPE(fn)
 # define FN_SIZE(fn)
diff --git a/gcc/testsuite/gdc.dg/Wpadded.d b/gcc/testsuite/gdc.dg/Wpadded.d
new file mode 100644
index 00000000000..8a9cca7e225
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/Wpadded.d
@@ -0,0 +1,4 @@
+// { dg-do compile }
+// { dg-options "-Wpadded" }
+
+class EmptyClass { }
diff --git a/gcc/testsuite/gdc.dg/imports/pr108050/mod1.d b/gcc/testsuite/gdc.dg/imports/pr108050/mod1.d
new file mode 100644
index 00000000000..f27a13dc051
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/imports/pr108050/mod1.d
@@ -0,0 +1,2 @@
+module imports.pr108050.mod1;
+string[] split() { return null; }
diff --git a/gcc/testsuite/gdc.dg/imports/pr108050/mod2.d b/gcc/testsuite/gdc.dg/imports/pr108050/mod2.d
new file mode 100644
index 00000000000..29d8aa8f53e
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/imports/pr108050/mod2.d
@@ -0,0 +1,2 @@
+module imports.pr108050.mod2;
+string[] split() { return null; }
diff --git a/gcc/testsuite/gdc.dg/imports/pr108050/package.d b/gcc/testsuite/gdc.dg/imports/pr108050/package.d
new file mode 100644
index 00000000000..b8b03b832af
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/imports/pr108050/package.d
@@ -0,0 +1,2 @@
+module imports.pr108050;
+public import imports.pr108050.mod1, imports.pr108050.mod2;
diff --git a/gcc/testsuite/gdc.dg/imports/pr108877a.d b/gcc/testsuite/gdc.dg/imports/pr108877a.d
new file mode 100644
index 00000000000..a23c78ddf84
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/imports/pr108877a.d
@@ -0,0 +1,6 @@
+immutable struct ImmutableS { }
+const struct ConstS { }
+immutable class ImmutableC { }
+const class ConstC { }
+immutable enum ImmutableE { _ }
+const enum ConstE { _ }
diff --git a/gcc/testsuite/gdc.dg/pr106139a.d b/gcc/testsuite/gdc.dg/pr106139a.d
new file mode 100644
index 00000000000..f635eabc745
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr106139a.d
@@ -0,0 +1,36 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias A = int[4];
+
+static if (__traits(compiles, __vector(A))):
+
+A vector2array(__vector(A) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(A) v)
+{
+    a = cast(A)v;
+}
+
+__vector(A) array2vector(A a)
+{
+    return cast(__vector(A)) a;
+}
+
+void array2vector(ref __vector(A) v, A a)
+{
+    v = cast(__vector(A))a;
+}
+
+A vector2array_array(__vector(A) v)
+{
+    return v.array;
+}
+
+void vector2array_array(ref A a, __vector(A) v)
+{
+    a = v.array;
+}
diff --git a/gcc/testsuite/gdc.dg/pr106139b.d b/gcc/testsuite/gdc.dg/pr106139b.d
new file mode 100644
index 00000000000..f9caf026f86
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr106139b.d
@@ -0,0 +1,36 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias A = float[4];
+
+static if (__traits(compiles, __vector(A))):
+
+A vector2array(__vector(A) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(A) v)
+{
+    a = cast(A)v;
+}
+
+__vector(A) array2vector(A a)
+{
+    return cast(__vector(A)) a;
+}
+
+void array2vector(ref __vector(A) v, A a)
+{
+    v = cast(__vector(A))a;
+}
+
+A vector2array_array(__vector(A) v)
+{
+    return v.array;
+}
+
+void vector2array_array(ref A a, __vector(A) v)
+{
+    a = v.array;
+}
diff --git a/gcc/testsuite/gdc.dg/pr106139c.d b/gcc/testsuite/gdc.dg/pr106139c.d
new file mode 100644
index 00000000000..3b6b7a83341
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr106139c.d
@@ -0,0 +1,27 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias V = int[4];
+alias A = float[4];
+
+static if (__traits(compiles, __vector(V))):
+
+A vector2array(__vector(V) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(V) v)
+{
+    a = cast(A)v;
+}
+
+__vector(V) array2vector(A a)
+{
+    return cast(__vector(V)) a;
+}
+
+void array2vector(ref __vector(V) v, A a)
+{
+    v = cast(__vector(V))a;
+}
diff --git a/gcc/testsuite/gdc.dg/pr106139d.d b/gcc/testsuite/gdc.dg/pr106139d.d
new file mode 100644
index 00000000000..4c6f0ef3a3a
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr106139d.d
@@ -0,0 +1,27 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106139
+// { dg-do compile }
+
+alias V = float[4];
+alias A = int[4];
+
+static if (__traits(compiles, __vector(V))):
+
+A vector2array(__vector(V) v)
+{
+    return cast(A)v;
+}
+
+void vector2array(ref A a, __vector(V) v)
+{
+    a = cast(A)v;
+}
+
+__vector(V) array2vector(A a)
+{
+    return cast(__vector(V)) a;
+}
+
+void array2vector(ref __vector(V) v, A a)
+{
+    v = cast(__vector(V))a;
+}
diff --git a/gcc/testsuite/gdc.dg/pr107592.d b/gcc/testsuite/gdc.dg/pr107592.d
new file mode 100644
index 00000000000..59f34477356
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr107592.d
@@ -0,0 +1,13 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=107592
+// { dg-do compile }
+
+void test107592(Things...)(Things things)
+{
+    label:
+    foreach (thing; things)
+    {
+        continue label;
+    }
+}
+
+alias a107592 = test107592!(string);
diff --git a/gcc/testsuite/gdc.dg/pr108050.d b/gcc/testsuite/gdc.dg/pr108050.d
new file mode 100644
index 00000000000..69134e73137
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr108050.d
@@ -0,0 +1,4 @@
+// { dg-do compile }
+// { dg-additional-sources "imports/pr108050/package.d imports/pr108050/mod1.d imports/pr108050/mod2.d" }
+// { dg-options "-g" }
+import imports.pr108050 : split;
diff --git a/gcc/testsuite/gdc.dg/pr108842.d b/gcc/testsuite/gdc.dg/pr108842.d
new file mode 100644
index 00000000000..5aae9e5000d
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr108842.d
@@ -0,0 +1,4 @@
+// { dg-do compile }
+// { dg-options "-fno-rtti" }
+module object;
+enum int[] x = [0, 1, 2];
diff --git a/gcc/testsuite/gdc.dg/pr108877.d b/gcc/testsuite/gdc.dg/pr108877.d
new file mode 100644
index 00000000000..710551f3f9a
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr108877.d
@@ -0,0 +1,9 @@
+// { dg-options "-I $srcdir/gdc.dg" }
+// { dg-do compile }
+import imports.pr108877a :
+    ImmutableS,
+    ConstS,
+    ImmutableC,
+    ConstC,
+    ImmutableE,
+    ConstE;
diff --git a/gcc/testsuite/gdc.dg/pr110359.d b/gcc/testsuite/gdc.dg/pr110359.d
new file mode 100644
index 00000000000..bf69201d9a5
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/pr110359.d
@@ -0,0 +1,22 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=110359
+// { dg-do compile }
+// { dg-options "-fdump-tree-original" }
+double pow(in double x, in ulong p)
+{
+    import gcc.builtins : __builtin_expect;
+    if (__builtin_expect(p == 0, false))
+        return 1;
+    if (__builtin_expect(p == 1, false))
+        return x;
+
+    double s = x;
+    double v = 1;
+    for (ulong i = p; i > 1; i >>= 1)
+    {
+        v = (i & 0x1) ? s * v : v;
+        s = s * s;
+    }
+    return v * s;
+}
+// { dg-final { scan-tree-dump "if \\(__builtin_expect \\(p == 0, 0\\) != 0\\)" "original" } }
+// { dg-final { scan-tree-dump "if \\(__builtin_expect \\(p == 1, 0\\) != 0\\)" "original" } }
diff --git a/gcc/testsuite/gdc.dg/pr98277.d b/gcc/testsuite/gdc.dg/pr98277.d
index d3b859fcbda..33b15e9e435 100644
--- a/gcc/testsuite/gdc.dg/pr98277.d
+++ b/gcc/testsuite/gdc.dg/pr98277.d
@@ -11,3 +11,14 @@ ref int getSide(Side side, ref int left, ref int right)
 {
     return side == Side.left ? left : right;
 }
+
+enum SideA : int[]
+{
+    left = [0],
+    right = [1],
+}
+
+int getSideA(SideA side, ref int left, ref int right)
+{
+    return side == SideA.left ? left : right;
+}
diff --git a/gcc/testsuite/gdc.dg/torture/imports/pr109108.d b/gcc/testsuite/gdc.dg/torture/imports/pr109108.d
new file mode 100644
index 00000000000..cec5274098c
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/torture/imports/pr109108.d
@@ -0,0 +1,11 @@
+module imports.pr109108;
+private enum int function(ref int)[] funs =
+[
+    0: (ref idx) => 0,
+    1: (ref idx) => 1,
+];
+
+int test109108(I)(I idx)
+{
+    return funs[idx](idx);
+}
diff --git a/gcc/testsuite/gdc.dg/torture/pr109108.d b/gcc/testsuite/gdc.dg/torture/pr109108.d
new file mode 100644
index 00000000000..4a428bf85a6
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/torture/pr109108.d
@@ -0,0 +1,10 @@
+// { dg-additional-files "imports/pr109108.d" }
+// { dg-additional-options "-I[srcdir] -fno-moduleinfo" }
+// { dg-do link }
+// { dg-skip-if "needs gcc/config.d" { ! d_runtime } }
+import imports.pr109108;
+
+extern(C) int main()
+{
+    return test109108(0);
+}
diff --git a/gcc/testsuite/gdc.dg/torture/pr110516a.d b/gcc/testsuite/gdc.dg/torture/pr110516a.d
new file mode 100644
index 00000000000..276455ae408
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/torture/pr110516a.d
@@ -0,0 +1,12 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=110516
+// { dg-do compile }
+// { dg-options "-fno-moduleinfo -fdump-tree-optimized" }
+void fn110516(ubyte* ptr)
+{
+    import core.volatile : volatileLoad;
+    volatileLoad(ptr);
+    volatileLoad(ptr);
+    volatileLoad(ptr);
+    volatileLoad(ptr);
+}
+// { dg-final { scan-tree-dump-times " ={v} " 4 "optimized" } }
diff --git a/gcc/testsuite/gdc.dg/torture/pr110516b.d b/gcc/testsuite/gdc.dg/torture/pr110516b.d
new file mode 100644
index 00000000000..b7a67e716a5
--- /dev/null
+++ b/gcc/testsuite/gdc.dg/torture/pr110516b.d
@@ -0,0 +1,12 @@
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=110516
+// { dg-do compile }
+// { dg-options "-fno-moduleinfo -fdump-tree-optimized" }
+void fn110516(ubyte* ptr)
+{
+    import core.volatile : volatileStore;
+    volatileStore(ptr, 0);
+    volatileStore(ptr, 0);
+    volatileStore(ptr, 0);
+    volatileStore(ptr, 0);
+}
+// { dg-final { scan-tree-dump-times " ={v} " 4 "optimized" } }
diff --git a/gcc/testsuite/gdc.dg/torture/torture.exp b/gcc/testsuite/gdc.dg/torture/torture.exp
index da3297b47b2..13be801823e 100644
--- a/gcc/testsuite/gdc.dg/torture/torture.exp
+++ b/gcc/testsuite/gdc.dg/torture/torture.exp
@@ -19,6 +19,15 @@
 # Load support procs.
 load_lib gdc-dg.exp
 
+# Helper function allows adding tests that use imports/*, but don't compile
+# the sources in with dg-additional-sources.
+global testdir
+set testdir $srcdir/$subdir
+proc srcdir {} {
+    global testdir
+    return $testdir
+}
+
 # The default option list can be overridden by
 # TORTURE_OPTIONS="{ { list1 } ... { listN } }"
 
diff --git a/gcc/testsuite/gdc.test/compilable/test21794.d b/gcc/testsuite/gdc.test/compilable/test21794.d
new file mode 100644
index 00000000000..68e504bce56
--- /dev/null
+++ b/gcc/testsuite/gdc.test/compilable/test21794.d
@@ -0,0 +1,52 @@
+// https://issues.dlang.org/show_bug.cgi?id=21794
+/*
+TEST_OUTPUT:
+---
+0
+0u
+0L
+0LU
+0.0F
+0.0
+0.0L
+---
+*/
+
+bool fun(void* p) {
+    const x = cast(ulong)p;
+    return 1;
+}
+
+static assert(fun(null));
+
+T fun2(T)(void* p) {
+    const x = cast(T)p;
+    return x;
+}
+
+// These were an error before, they were returning a NullExp instead of IntegerExp/RealExp
+
+static assert(fun2!int(null)    == 0);
+static assert(fun2!uint(null)   == 0);
+static assert(fun2!long(null)   == 0);
+static assert(fun2!ulong(null)  == 0);
+static assert(fun2!float(null)  == 0);
+static assert(fun2!double(null) == 0);
+static assert(fun2!real(null)   == 0);
+
+// These were printing 'null' instead of the corresponding number
+
+const i = cast(int)null;
+const ui = cast(uint)null;
+const l = cast(long)null;
+const ul = cast(ulong)null;
+const f = cast(float)null;
+const d = cast(double)null;
+const r = cast(real)null;
+pragma(msg, i);
+pragma(msg, ui);
+pragma(msg, l);
+pragma(msg, ul);
+pragma(msg, f);
+pragma(msg, d);
+pragma(msg, r);
diff --git a/gcc/testsuite/gdc.test/fail_compilation/ice20264.d b/gcc/testsuite/gdc.test/fail_compilation/ice20264.d
new file mode 100644
index 00000000000..0d697e22c9f
--- /dev/null
+++ b/gcc/testsuite/gdc.test/fail_compilation/ice20264.d
@@ -0,0 +1,13 @@
+/*
+DISABLED: freebsd32 linux32 osx32 win32
+TEST_OUTPUT:
+---
+fail_compilation/ice20264.d(12): Error: `cast(__vector(float[4]))a` is not an lvalue and cannot be modified
+---
+*/
+
+void foo(float *a)
+{
+    alias float4 = __vector(float[4]);
+    cast(float4)(a) = 1.0f;
+}
diff --git a/gcc/testsuite/gfortran.dg/PR100029.f90 b/gcc/testsuite/gfortran.dg/PR100029.f90
new file mode 100644
index 00000000000..fd7e4c46032
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100029.f90
@@ -0,0 +1,22 @@
+! { dg-do run }
+!
+! Test the fix for PR100029
+!
+
+program foo_p
+  implicit none
+
+  type :: foo_t
+  end type foo_t
+  
+  class(foo_t), allocatable :: pout
+
+  call foo_s(pout)
+
+contains
+
+  subroutine foo_s(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+  end subroutine foo_s
+
+end program foo_p
diff --git a/gcc/testsuite/gfortran.dg/PR100040.f90 b/gcc/testsuite/gfortran.dg/PR100040.f90
new file mode 100644
index 00000000000..0a135ff30a3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100040.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+!
+! Test the fix for PR100040
+!
+
+program foo_p
+  implicit none
+
+  integer, parameter :: n = 11
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+  
+  type(foo_t), parameter :: a = foo_t(n)
+  
+  class(foo_t), allocatable :: pout
+
+  call foo_s(pout)
+  if(.not.allocated(pout)) stop 1
+  if(pout%i/=n) stop 2
+
+contains
+
+  subroutine foo_s(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(0)
+      that = a
+    rank default
+      stop 3
+    end select
+  end subroutine foo_s
+
+end program foo_p
diff --git a/gcc/testsuite/gfortran.dg/PR100097.f90 b/gcc/testsuite/gfortran.dg/PR100097.f90
new file mode 100644
index 00000000000..f927d293e2c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100097.f90
@@ -0,0 +1,41 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+!
+! Test the fix for PR100097
+!
+
+program main_p
+  implicit none
+
+  class(*), pointer     :: bar_p(:)
+  class(*), allocatable :: bar_a(:)
+
+  call foo_p(bar_p)
+  call foo_a(bar_a)
+
+contains
+
+  subroutine foo_p(that)
+    class(*), pointer, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+    rank default
+      stop 1
+    end select
+  end subroutine foo_p
+
+  subroutine foo_a(that)
+    class(*), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+    rank default
+      stop 2
+    end select
+  end subroutine foo_a
+
+end program main_p
+
+! { dg-final { scan-tree-dump "bar_a._data.dtype = \\{.* .rank=1,.*\\}" "original" } }
+! { dg-final { scan-tree-dump "bar_p._data.dtype = \\{.* .rank=1,.*\\}" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/PR100098.f90 b/gcc/testsuite/gfortran.dg/PR100098.f90
new file mode 100644
index 00000000000..26ac0c88425
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100098.f90
@@ -0,0 +1,45 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+!
+! Test the fix for PR100098
+!
+
+program main_p
+  implicit none
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+
+  class(foo_t), pointer     :: bar_p(:)
+  class(foo_t), allocatable :: bar_a(:)
+
+  call foo_p(bar_p)
+  call foo_a(bar_a)
+
+contains
+
+  subroutine foo_p(that)
+    class(foo_t), pointer, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+    rank default
+      stop 1
+    end select
+  end subroutine foo_p
+
+  subroutine foo_a(that)
+    class(foo_t), allocatable, intent(out) :: that(..)
+
+    select rank(that)
+    rank(1)
+    rank default
+      stop 2
+    end select
+  end subroutine foo_a
+
+end program main_p
+
+! { dg-final { scan-tree-dump "bar_a._data.dtype = \\{.* .rank=1,.*\\}" "original" } }
+! { dg-final { scan-tree-dump "bar_p._data.dtype = \\{.* .rank=1,.*\\}" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/PR100132.f90 b/gcc/testsuite/gfortran.dg/PR100132.f90
new file mode 100644
index 00000000000..78ae6702810
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100132.f90
@@ -0,0 +1,75 @@
+! { dg-do run }
+!
+! Test the fix for PR100132
+!
+
+module main_m
+  implicit none
+
+  private
+
+  public :: &
+    foo_t
+
+  public :: &
+    set,    &
+    get
+
+  type :: foo_t
+    integer :: i
+  end type foo_t
+
+  type(foo_t), save, pointer :: data => null()
+
+contains
+
+  subroutine set(this)
+    class(foo_t), pointer, intent(in) :: this
+
+    if(associated(data)) stop 1
+    data => this
+  end subroutine set
+
+  subroutine get(this)
+    type(foo_t), pointer, intent(out) :: this
+
+    if(.not.associated(data)) stop 4
+    this => data
+    nullify(data)
+  end subroutine get
+
+end module main_m
+
+program main_p
+
+  use :: main_m, only: &
+    foo_t, set, get
+
+  implicit none
+
+  integer, parameter :: n = 1000
+
+  type(foo_t), pointer :: ps
+  type(foo_t),  target :: s
+  integer              :: i, j, yay, nay
+
+  yay = 0
+  nay = 0
+  do i = 1, n
+    s%i = i
+    call set(s)
+    call get(ps)
+    if(.not.associated(ps)) stop 13
+    j = ps%i
+    if(i/=j) stop 14
+    if(i/=s%i) stop 15
+    if(ps%i/=s%i) stop 16
+    if(associated(ps, s))then
+      yay = yay + 1
+    else
+      nay = nay + 1
+    end if
+  end do
+  if((yay/=n).or.(nay/=0)) stop 17
+
+end program main_p
diff --git a/gcc/testsuite/gfortran.dg/PR100136.f90 b/gcc/testsuite/gfortran.dg/PR100136.f90
new file mode 100644
index 00000000000..922af4aecc3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100136.f90
@@ -0,0 +1,39 @@
+! { dg-do run }
+! { dg-options "-fcheck=pointer" }
+! { dg-shouldfail "Argument not allocated" }
+! { dg-output "Fortran runtime error: Allocatable actual argument 'c_init2' is not allocated" }
+!
+! Tests fix for PR100136
+!
+! Test cut down from PR58586
+!
+
+module test_pr58586_mod
+  implicit none
+
+  type :: a
+  end type
+
+  type :: c
+     type(a), allocatable :: a
+  end type
+
+contains
+
+  subroutine add_class_c (d)
+    class(c), value :: d
+  end subroutine
+
+  class(c) function c_init2()
+    allocatable :: c_init2
+  end function
+
+end module test_pr58586_mod
+
+program test_pr58586
+  use test_pr58586_mod
+
+  ! This needs to execute, to see whether the segfault at runtime is resolved
+  call add_class_c(c_init2())
+
+end program
diff --git a/gcc/testsuite/gfortran.dg/PR100245.f90 b/gcc/testsuite/gfortran.dg/PR100245.f90
new file mode 100644
index 00000000000..07c1f7b3a1c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/PR100245.f90
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test the fix for PR100245
+!
+
+program main_p
+
+  implicit none
+
+  type :: foo_t
+    integer :: a
+  end type foo_t
+
+  integer, parameter :: a = 42
+
+  class(foo_t), allocatable :: val
+  class(foo_t), allocatable :: rs1
+  type(foo_t),  allocatable :: rs2
+
+  allocate(val, source=foo_t(42))
+  if (val%a/=a) stop 1
+  rs1 = val
+  if (rs1%a/=a) stop 2
+  rs2 = val
+  if (rs2%a/=a) stop 3
+  deallocate(val, rs1, rs2)
+
+end program main_p
diff --git a/gcc/testsuite/gfortran.dg/associate_26a.f90 b/gcc/testsuite/gfortran.dg/associate_26a.f90
new file mode 100644
index 00000000000..85aebebd4d8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/associate_26a.f90
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+!
+! Test the fix for PR78152 and the followup in PR82868
+!
+! Contributed by <physiker@toast2.net>
+!
+program co_assoc
+  implicit none
+  integer, parameter :: p = 5
+  real, allocatable :: a(:,:)[:,:]
+  allocate (a(p,p)[2,*])
+  associate (i => a(1:p, 1:p))
+  end associate
+end program co_assoc
diff --git a/gcc/testsuite/gfortran.dg/bind_c_usage_34.f90 b/gcc/testsuite/gfortran.dg/bind_c_usage_34.f90
new file mode 100644
index 00000000000..40c8e9363cf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/bind_c_usage_34.f90
@@ -0,0 +1,21 @@
+! { dg-do compile }
+! PR fortran/104332 - ICE with bind(c) in block data
+! Contributed by G. Steinmetz
+
+block data
+  bind(c) :: a ! { dg-error "cannot be BIND\\(C\\)" }
+end
+
+block data aa
+   real, bind(c) :: a ! { dg-error "cannot be BIND\\(C\\)" }
+end
+
+block data bb
+   real    :: a ! { dg-error "cannot be BIND\\(C\\)" }
+   bind(c) :: a
+end
+
+block data cc
+   common /a/ x
+   bind(c) :: /a/
+end
diff --git a/gcc/testsuite/gfortran.dg/class_58.f90 b/gcc/testsuite/gfortran.dg/class_58.f90
index 20b601a2f51..fceb575432d 100644
--- a/gcc/testsuite/gfortran.dg/class_58.f90
+++ b/gcc/testsuite/gfortran.dg/class_58.f90
@@ -9,5 +9,5 @@ subroutine s
   end type
   class(t), parameter :: x = t()  ! { dg-error "cannot have the PARAMETER attribute" }
   class(t), parameter :: y = x    ! { dg-error "cannot have the PARAMETER attribute" }
-  class(t) :: z = x               ! { dg-error "must be dummy, allocatable or pointer" }
+  class(t) :: z = t()             ! { dg-error "must be dummy, allocatable or pointer" }
 end
diff --git a/gcc/testsuite/gfortran.dg/class_73.f90 b/gcc/testsuite/gfortran.dg/class_73.f90
new file mode 100644
index 00000000000..c11ee38c086
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/class_73.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! Error recovery on invalid CLASS(), PARAMETER declarations
+! PR fortran/103137
+! PR fortran/103138
+! PR fortran/103693
+! PR fortran/105243
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     character(3) :: c = '(a)'
+  end type
+  class(t), parameter :: x = 1.  ! { dg-error "PARAMETER attribute" }
+  class(*), parameter :: y = t() ! { dg-error "PARAMETER attribute" }
+  class(*), parameter :: z = 1   ! { dg-error "PARAMETER attribute" }
+  print x%c                      ! { dg-error "Syntax error" }
+end
diff --git a/gcc/testsuite/gfortran.dg/common_27.f90 b/gcc/testsuite/gfortran.dg/common_27.f90
new file mode 100644
index 00000000000..dcde5de2bd2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/common_27.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR fortran/108453 - a use associated variable cannot occur in COMMON
+! Contributed by G.Steinmetz
+
+module m
+  type t
+  end type
+  real :: r
+end
+program p
+  use m, only: t, r
+  common t      ! { dg-error "USE associated from module" }
+  common /cm/ r ! { dg-error "USE associated from module" }
+end
diff --git a/gcc/testsuite/gfortran.dg/dec_union_12.f90 b/gcc/testsuite/gfortran.dg/dec_union_12.f90
new file mode 100755
index 00000000000..26671230b05
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec_union_12.f90
@@ -0,0 +1,43 @@
+! { dg-do compile }
+! { dg-options "-std=legacy -ffree-form -finit-local-zero -finit-derived -fdec-structure" }
+!
+! PR fortran/105310
+!
+! Test that gfc_conv_union_initializer does not cause an ICE when called
+! to build the constructor for a field which triggers a vector resize.
+!
+
+program dec_union_12
+  implicit none
+STRUCTURE /foo8u/
+  ! 8 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo16u/
+  ! 16 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo32u/
+  ! 32 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  INTEGER(4) :: aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+  record /foo8u/ bar8u
+  record /foo16u/ bar16u
+  record /foo32u/ bar32u
+  bar8u.a = 1
+  bar16u.a = 1
+  bar32u.a = 1
+end
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_37.f90 b/gcc/testsuite/gfortran.dg/deferred_character_37.f90
new file mode 100644
index 00000000000..8a5a8c5daf8
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/deferred_character_37.f90
@@ -0,0 +1,88 @@
+! { dg-do run }
+! PR fortran/95947
+! PR fortran/110658
+!
+! Test deferred-length character arguments to selected intrinsics
+! that may return a character result of same length as first argument:
+! CSHIFT, EOSHIFT, MAXVAL, MERGE, MINVAL, PACK, SPREAD, TRANSPOSE, UNPACK
+
+program p
+  implicit none
+  call pr95947 ()
+  call pr110658 ()
+  call s ()
+
+contains
+
+  subroutine pr95947
+    character(len=:), allocatable :: m(:)
+
+    m = [ character(len=10) :: 'ape','bat','cat','dog','eel','fly','gnu']
+    m = pack (m, mask=(m(:)(2:2) == 'a'))
+
+!   print *, "m = '", m,"' ",               "; expected is ['bat','cat']"
+    if (.not. all (m == ['bat','cat'])) stop 1
+   
+!   print *, "size(m) =     ", size(m),     "; expected is 2"
+    if (size (m) /= 2) stop 2
+   
+!   print *, "len(m) =      ", len(m),      "; expected is 10"
+    if (len (m) /= 10) stop 3
+   
+!   print *, "len_trim(m) = ", len_trim(m), "; expected is 3 3"
+    if (.not. all (len_trim(m) == [3,3])) stop 4
+  end
+
+  subroutine pr110658
+    character(len=:), allocatable :: array(:), array2(:,:)
+    character(len=:), allocatable :: res, res1(:), res2(:)
+
+    array = ["bb", "aa", "cc"]
+
+    res = minval (array)
+    if (res /= "aa") stop 11
+
+    res = maxval (array, mask=[.true.,.true.,.false.])
+    if (res /= "bb") stop 12
+
+    res1 = cshift (array, 1)
+    if (any (res1 /= ["aa","cc","bb"])) stop 13
+
+    res2 = eoshift (res1, -1)
+    if (any (res2 /= ["  ", "aa", "cc"])) stop 14
+
+    res2 = pack (array, mask=[.true.,.false.,.true.])
+    if (any (res2 /= ["bb","cc"])) stop 15
+
+    res2 = unpack (res2, mask=[.true.,.false.,.true.], field="aa")
+    if (any (res2 /= array)) stop 16
+
+    res2 = merge (res2, array, [.true.,.false.,.true.])
+    if (any (res2 /= array)) stop 17
+
+    array2 = spread (array, dim=2, ncopies=2)
+    array2 = transpose (array2)
+    if (any (shape (array2) /= [2,3])) stop 18
+    if (any (array2(2,:) /= array))    stop 19
+  end
+
+  subroutine s
+    character(:), allocatable :: array1(:), array2(:)
+    array1 = ["aa","cc","bb"]
+    array2 = copy (array1)
+    if (any (array1 /= array2)) stop 20
+  end
+
+  function copy (arg) result (res)
+    character(:), allocatable :: res(:)
+    character(*), intent(in)  :: arg(:)
+    integer :: i, k, n
+    k = len (arg)
+    n = size (arg)
+    allocate (character(k) :: res(n))
+    do i = 1, n
+       res(i) = arg(i)
+    end do
+  end
+
+end
diff --git a/gcc/testsuite/gfortran.dg/extends_type_of_4.f90 b/gcc/testsuite/gfortran.dg/extends_type_of_4.f90
new file mode 100644
index 00000000000..64373322387
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/extends_type_of_4.f90
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! PR fortran/106121 - ICE in gfc_simplify_extends_type_of
+! Contributed by G.Steinmetz
+
+program p
+   type t
+   end type
+   type(t)  :: x
+   class(t) :: y               ! { dg-error "dummy, allocatable or pointer" }
+   print *, extends_type_of (x, y)
+end
+
+subroutine s
+   type t
+      integer :: i
+   end type
+   type(t)  :: x
+   class(t) :: y               ! { dg-error "dummy, allocatable or pointer" }
+   stop extends_type_of (x, y) ! { dg-error "STOP code" }
+end
diff --git a/gcc/testsuite/gfortran.dg/findloc_10.f90 b/gcc/testsuite/gfortran.dg/findloc_10.f90
new file mode 100644
index 00000000000..4d5ecd2306a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/findloc_10.f90
@@ -0,0 +1,13 @@
+! { dg-do run }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/110288 - FINDLOC and deferred-length character arguments
+
+program test
+  character(len=:), allocatable :: array(:)
+  character(len=:), allocatable :: value
+  array = ["bb", "aa"]
+  value = "aa"
+  if (findloc (array, value, dim=1) /= 2) stop 1
+end program test
+
+! { dg-final { scan-tree-dump "_gfortran_findloc2_s1 \\(.*, \\.array, \\.value\\)" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/findloc_9.f90 b/gcc/testsuite/gfortran.dg/findloc_9.f90
new file mode 100644
index 00000000000..05974476cb3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/findloc_9.f90
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/110585 - simplification of FINDLOC for constant complex arguments
+
+program mvce
+  implicit none
+  integer, parameter :: a(*) = findloc([(1.,0.),(2.,1.)], (2.,0.))
+  integer, parameter :: b(*) = findloc([(1.,0.),(2.,1.)], (2.,0.), back=.true.)
+  integer, parameter :: c(*) = findloc([(1.,0.),(2.,1.)], (2.,1.))
+  integer, parameter :: d(*) = findloc([(1.,0.),(2.,1.)], (2.,1.), back=.true.)
+  integer, parameter :: e    = findloc([(1.,0.),(2.,1.)], (2.,1.), dim=1)
+  if (a(1) /= 0) stop 1
+  if (b(1) /= 0) stop 2
+  if (c(1) /= 2) stop 3
+  if (d(1) /= 2) stop 4
+  if (e    /= 2) stop 5
+end
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/g77/pr105203.f b/gcc/testsuite/gfortran.dg/g77/pr105203.f
new file mode 100644
index 00000000000..3b47210fb40
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/g77/pr105203.f
@@ -0,0 +1,20 @@
+C Test case for PR debug/105203
+C Origin: kmccarty@princeton.edu
+C
+C { dg-do compile }
+C { dg-options "-O2 -fcompare-debug -ftracer -w" }
+C { dg-additional-options "-fPIC" { target fpic } }
+      SUBROUTINE FOO (B)
+
+  10  CALL BAR (A)
+      ASSIGN 20 TO M
+      IF (100.LT.A) GOTO 10
+      GOTO 40
+C
+  20  IF (B.LT.ABS(A)) GOTO 10
+      ASSIGN 30 TO M
+      GOTO 40
+C
+  30  ASSIGN 10 TO M
+  40  GOTO M,(10,20,30)
+      END
diff --git a/gcc/testsuite/gfortran.dg/guality/guality.exp b/gcc/testsuite/gfortran.dg/guality/guality.exp
index 0375edfffe4..86a966a9133 100644
--- a/gcc/testsuite/gfortran.dg/guality/guality.exp
+++ b/gcc/testsuite/gfortran.dg/guality/guality.exp
@@ -8,6 +8,10 @@ if { [istarget *-*-darwin*] } {
   return
 }
 
+if { [istarget hppa*-*-hpux*] } {
+    return
+}
+
 if { [istarget "powerpc-ibm-aix*"] } {
     set torture_execute_xfail "powerpc-ibm-aix*"
     return
diff --git a/gcc/testsuite/gfortran.dg/ibits_2.f90 b/gcc/testsuite/gfortran.dg/ibits_2.f90
new file mode 100644
index 00000000000..2af5542d764
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ibits_2.f90
@@ -0,0 +1,32 @@
+! { dg-do run }
+! { dg-additional-options "-fcheck=bits" }
+! PR fortran/108937 - Intrinsic IBITS(I,POS,LEN) fails when LEN equals
+!                     to BIT_SIZE(I)
+! Contributed by saitofuyuki@jamstec.go.jp
+
+program test_bits
+  implicit none
+  integer, parameter :: KT = kind (1)
+  integer, parameter :: lbits = bit_size (0_KT)
+  integer(kind=KT) :: x, y0, y1
+  integer(kind=KT) :: p, l
+
+  x = -1
+  p = 0
+  do l = 0, lbits
+     y0 = ibits  (x, p, l)
+     y1 = ibits_1(x, p, l)
+     if (y0 /= y1) then
+        print *, l, y0, y1
+        stop 1+l
+     end if
+  end do
+contains
+  elemental integer(kind=KT) function ibits_1(I, POS, LEN) result(n)
+    !! IBITS(I, POS, LEN) = (I >> POS) & ~((~0) << LEN)
+    implicit none
+    integer(kind=KT),intent(in) :: I
+    integer,         intent(in) :: POS, LEN
+    n = IAND (ISHFT(I, - POS), NOT(ISHFT(-1_KT, LEN)))
+  end function ibits_1
+end program test_bits
diff --git a/gcc/testsuite/gfortran.dg/illegal_boz_arg_4.f90 b/gcc/testsuite/gfortran.dg/illegal_boz_arg_4.f90
new file mode 100644
index 00000000000..856cfa9211f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/illegal_boz_arg_4.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! { dg-options "-std=f2018" }
+! PR fortran/103413
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     class(*), allocatable :: a
+  end type
+  type(t) :: x
+  allocate (x%a, source=z'1') ! { dg-error "type incompatible" }
+  allocate (x%a, mold=z'1')   ! { dg-error "type incompatible" }
+end
diff --git a/gcc/testsuite/gfortran.dg/implied_do_io_8.f90 b/gcc/testsuite/gfortran.dg/implied_do_io_8.f90
new file mode 100644
index 00000000000..c66a0f6fde6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/implied_do_io_8.f90
@@ -0,0 +1,18 @@
+! { dg-do run }
+! { dg-additional-options "-fcheck=bounds" }
+! PR fortran/111837 - out of bounds access with front-end optimization
+
+program implied_do_bug
+  implicit none
+  integer :: i,j,k
+  real    :: arr(1,1,1)
+  integer :: ni(1)
+  ni(1) = 1
+  arr = 1
+  write(*,*) (((arr(i,j,k), i=1,ni(k)), k=1,1), j=1,1)
+  write(*,*) (((arr(i,j,k), i=1,ni(k)), j=1,1), k=1,1)
+  write(*,*) (((arr(k,i,j), i=1,ni(k)), k=1,1), j=1,1)
+  write(*,*) (((arr(k,i,j), i=1,ni(k)), j=1,1), k=1,1)
+  write(*,*) (((arr(j,k,i), i=1,ni(k)), k=1,1), j=1,1)
+  write(*,*) (((arr(j,k,i), i=1,ni(k)), j=1,1), k=1,1)
+end
diff --git a/gcc/testsuite/gfortran.dg/index_6.f90 b/gcc/testsuite/gfortran.dg/index_6.f90
new file mode 100644
index 00000000000..61d492985ad
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/index_6.f90
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/105691 - Incorrect calculation of INDEX(str1,str2) at compile time
+
+program main
+  implicit none
+  integer :: i
+  character(*), parameter :: s1 = "fortran.f90"
+  character(*), parameter :: s2 = "fortran"
+  character(*), parameter :: s3 = s2 // "*"
+  integer, parameter :: i0    = index(s1, s2)
+  integer, parameter :: i1    = index(s1, s2, back= .true.)
+  integer, parameter :: i2(*) = index(s1, s2, back=[.true.,.false.])
+  integer, parameter :: i3(*) = index(s1, s2, back=[(i==1, i=1,2)] )
+  integer, parameter :: i4    = index(s1, s3)
+  integer, parameter :: i5    = index(s1, s3, back= .true.)
+  integer, parameter :: i6(*) = index(s1, s3, back=[.true.,.false.])
+  integer, parameter :: i7(*) = index(s1, s3, back=[(i==1, i=1,2)] )
+  integer, parameter :: i8    = index(s1, "f", back= .true.)
+  if (     i0 /= 1 ) stop 1
+  if (     i1 /= 1 ) stop 2
+  if (any (i2 /= 1)) stop 3
+  if (any (i3 /= 1)) stop 4
+  if (     i4 /= 0 ) stop 5
+  if (     i5 /= 0 ) stop 6
+  if (any (i6 /= 0)) stop 7
+  if (any (i7 /= 0)) stop 8
+  if (i8 /= len(s1)-2) stop 9
+end program
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/intent_optimize_4.f90 b/gcc/testsuite/gfortran.dg/intent_optimize_4.f90
new file mode 100644
index 00000000000..effbaa12a2d
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_optimize_4.f90
@@ -0,0 +1,43 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! { dg-final { scan-tree-dump-times "CLOBBER" 2 "original" } }
+!
+! PR fortran/106817
+! Check that for an actual argument whose dummy is INTENT(OUT),
+! the clobber that is emitted in the caller before a procedure call
+! happens after any expression depending on the argument value has been
+! evaluated.
+! 
+
+module m
+  implicit none
+contains
+  subroutine copy1(out, in)
+    integer, intent(in) :: in
+    integer, intent(out) :: out
+    out = in
+  end subroutine copy1
+  subroutine copy2(in, out)
+    integer, intent(in) :: in
+    integer, intent(out) :: out
+    out = in
+  end subroutine copy2
+end module m
+
+program p
+  use m
+  implicit none
+  integer :: a, b
+
+  ! Clobbering of a should happen after a+1 has been evaluated.
+  a = 3
+  call copy1(a, a+1)
+  if (a /= 4) stop 1
+
+  ! Clobbering order does not depend on the order of arguments.
+  ! It should also come last with reversed arguments.
+  b = 12
+  call copy2(b+1, b)
+  if (b /= 13) stop 2
+
+end program p
diff --git a/gcc/testsuite/gfortran.dg/intent_out_15.f90 b/gcc/testsuite/gfortran.dg/intent_out_15.f90
new file mode 100644
index 00000000000..64334e6f038
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/intent_out_15.f90
@@ -0,0 +1,27 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+!
+! PR fortran/105012
+! The following case was triggering an ICE because of a clobber
+! on the DERFC function decl instead of its result.
+
+module error_function
+integer, parameter :: r8 = selected_real_kind(12) ! 8 byte real
+contains
+SUBROUTINE CALERF_r8(ARG, RESULT, JINT)
+   integer, parameter :: rk = r8
+   real(rk), intent(in)  :: arg
+   real(rk), intent(out) :: result
+   IF (Y .LE. THRESH) THEN
+   END IF
+end SUBROUTINE CALERF_r8
+FUNCTION DERFC(X)
+   integer, parameter :: rk = r8 ! 8 byte real
+   real(rk), intent(in) :: X
+   real(rk) :: DERFC
+   CALL CALERF_r8(X, DERFC, JINT)
+END FUNCTION DERFC
+end module error_function
+
+! { dg-final { scan-tree-dump-times "CLOBBER" 1 "original" } }
+! { dg-final { scan-tree-dump "__result_derfc = {CLOBBER};" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/nearest_6.f90 b/gcc/testsuite/gfortran.dg/nearest_6.f90
new file mode 100644
index 00000000000..00d1ebe618c
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/nearest_6.f90
@@ -0,0 +1,26 @@
+! { dg-do run }
+! PR fortran/109186 - Verify that NEAREST produces same results at
+!                     compile-time and run-time for corner cases
+! Reported by John Harper
+
+program p
+  implicit none
+  integer,  parameter :: sp = selected_real_kind (6)
+  integer,  parameter :: dp = selected_real_kind (13)
+  real(sp), parameter :: x1 = huge (1._sp), t1 = tiny (1._sp)
+  real(dp), parameter :: x2 = huge (1._dp), t2 = tiny (1._dp)
+  real(sp), volatile  :: y1, z1
+  real(dp), volatile  :: y2, z2
+  y1 = x1
+  z1 = nearest (y1, -1._sp)
+  if (nearest (x1,  -1._sp) /= z1) stop 1
+  y2 = x2
+  z2 = nearest (y2, -1._dp)
+  if (nearest (x2,  -1._dp) /= z2) stop 2
+  y1 = t1
+  z1 = nearest (y1,  1._sp)
+  if (nearest (t1,   1._sp) /= z1) stop 3
+  y2 = t2
+  z2 = nearest (y2,  1._dp)
+  if (nearest (t2,   1._dp) /= z2) stop 4
+end
diff --git a/gcc/testsuite/gfortran.dg/nint_p7.f90 b/gcc/testsuite/gfortran.dg/nint_p7.f90
index 8f3552293c5..2239824a7fb 100644
--- a/gcc/testsuite/gfortran.dg/nint_p7.f90
+++ b/gcc/testsuite/gfortran.dg/nint_p7.f90
@@ -1,8 +1,7 @@
 ! Fortran
 ! { dg-do compile { target { powerpc*-*-* } } }
 ! { dg-require-effective-target powerpc_vsx_ok } 
-! { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } 
-! { dg-options "-O2 -mcpu=power7 -ffast-math" } 
+! { dg-options "-O2 -mdejagnu-cpu=power7 -ffast-math" } 
 ! { dg-final { scan-assembler-times "xsrdpi" 2 } } 
 
 	subroutine test_nint(x4,x8)
diff --git a/gcc/testsuite/gfortran.dg/null_actual_3.f90 b/gcc/testsuite/gfortran.dg/null_actual_3.f90
new file mode 100644
index 00000000000..ea49f9630c9
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/null_actual_3.f90
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-fallow-argument-mismatch -w" }
+! PR fortran/107576
+! Contributed by G.Steinmetz
+
+program p
+  implicit none
+  interface
+     subroutine r(y)
+       integer, pointer :: y(:)
+     end subroutine r
+  end interface
+  integer, pointer :: z(:) => null()
+  call r(z)
+  call s(z)
+  call r(null(z))
+  call s(null(z)) ! { dg-error "requires an explicit interface" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr102860.f90 b/gcc/testsuite/gfortran.dg/pr102860.f90
index d0a7356c0f5..6b1feaa9d79 100644
--- a/gcc/testsuite/gfortran.dg/pr102860.f90
+++ b/gcc/testsuite/gfortran.dg/pr102860.f90
@@ -1,8 +1,7 @@
 ! PR middle-end/102860
 ! { dg-do compile { target { powerpc*-*-* } } }
 ! { dg-require-effective-target powerpc_vsx_ok } 
-! { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power10" } } 
-! { dg-options "-O2 -mcpu=power10" } 
+! { dg-options "-O2 -mdejagnu-cpu=power10" } 
 
 function foo(a)
   integer(kind=4) :: a(1024)
diff --git a/gcc/testsuite/gfortran.dg/pr103259.f90 b/gcc/testsuite/gfortran.dg/pr103259.f90
new file mode 100644
index 00000000000..f78ff26180e
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103259.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/103259 - ICE in resolve_common_vars
+! Contributed by G.Steinmetz
+
+module m
+  integer :: p
+  common /c/ p
+end
+program p ! { dg-error "cannot appear in a COMMON block" }
+  use m   ! { dg-error "is also the name of the current program unit" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103504.f90 b/gcc/testsuite/gfortran.dg/pr103504.f90
new file mode 100644
index 00000000000..607d1c6c8cc
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103504.f90
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! PR fortran/103504 - ICE in get_sym_storage_size, at fortran/interface.c:2800
+! Contributed by G.Steinmetz
+
+program p
+  implicit none
+  real      :: y(1)
+  character :: b
+  call s(y)
+  call t(y)
+  call u(y)
+  call c(b)
+contains
+  subroutine s(x)
+    real :: x(abs(1.):1)        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine t(x)
+    real :: x(abs(1.):1)        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine u(x)
+    real :: x(1:abs(1.))        ! { dg-error "must be of INTEGER type" }
+  end
+  subroutine c(z)
+    character(len=abs(1.)) :: z ! { dg-error "must be of INTEGER type" }
+  end subroutine c
+end
+
+! { dg-prune-output "must be of INTEGER type" }
diff --git a/gcc/testsuite/gfortran.dg/pr103505.f90 b/gcc/testsuite/gfortran.dg/pr103505.f90
index 522e53efcb2..01308019b2c 100644
--- a/gcc/testsuite/gfortran.dg/pr103505.f90
+++ b/gcc/testsuite/gfortran.dg/pr103505.f90
@@ -3,7 +3,9 @@
 ! Testcase by G.Steinmetz
 
 program p
-  integer, parameter :: a((2.))   = [4,8] ! { dg-error "scalar INTEGER" }
-  integer, parameter :: z(1:(2.)) = [4,8] ! { dg-error "scalar INTEGER" }
-  print *, a(1:1)                         ! { dg-error "Syntax error" }
+  integer, parameter :: a((2.))   = [4,8] ! { dg-error "INTEGER type" }
+  integer, parameter :: z(1:(2.)) = [4,8] ! { dg-error "INTEGER type" }
+  print *, a(1:1)
 end
+
+! { dg-prune-output "Parameter array" }
diff --git a/gcc/testsuite/gfortran.dg/pr103506_1.f90 b/gcc/testsuite/gfortran.dg/pr103506_1.f90
new file mode 100644
index 00000000000..3f57809e099
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103506_1.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR103506 ICE in gfc_free_namespace. ice-on-invalid
+! Test case from the PR.
+module m ! { dg-error "is already being used as a MODULE" }
+stop ! { dg-error "Unexpected STOP statement in MODULE" }
+end
+program p
+call m ! { dg-error "is already being used as a MODULE" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr103694.f90 b/gcc/testsuite/gfortran.dg/pr103694.f90
new file mode 100644
index 00000000000..3ed8b2088da
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr103694.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/103694 - ICE in gfc_conv_expr_op
+! Contributed by G.Steinmetz
+
+subroutine s
+  type t
+     integer :: a(2)
+  end type
+  type(t) :: x((0.)/0)
+  integer :: n = size(x(1)%a) ! { dg-error "does not reduce to a constant expression" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr104313.f b/gcc/testsuite/gfortran.dg/pr104313.f
new file mode 100644
index 00000000000..89c8947cb0a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr104313.f
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-additional-options "-ff2c -fdump-tree-original" }
+!
+! PR fortran/104313 - ICE verify_gimple failed with -ff2c
+! Contributed by G.Steinmetz
+
+      function f(a)
+      return
+      end
+
+! { dg-final { scan-tree-dump-times "return" 1 "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pr104849.f90 b/gcc/testsuite/gfortran.dg/pr104849.f90
new file mode 100644
index 00000000000..ae221b5ba10
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr104849.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/104849 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1, 2] ! { dg-error "deferred shape" }
+  integer :: x(2)
+  data x /a(:)/                       ! { dg-error "Invalid" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr105230.f90 b/gcc/testsuite/gfortran.dg/pr105230.f90
new file mode 100644
index 00000000000..6c6b42ef9bf
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr105230.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/105230 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1, 2] ! { dg-error "deferred shape" }
+  print *, reshape([3, 4], a(1:2))
+end
diff --git a/gcc/testsuite/gfortran.dg/pr105633.f90 b/gcc/testsuite/gfortran.dg/pr105633.f90
new file mode 100644
index 00000000000..f2dbc5e742a
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr105633.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/105633 - ICE in find_array_section
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1,2] ! { dg-error "deferred shape" }
+  print *, [a([1,2])]
+end
diff --git a/gcc/testsuite/gfortran.dg/pr105954.f90 b/gcc/testsuite/gfortran.dg/pr105954.f90
new file mode 100644
index 00000000000..89004bf9aa7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr105954.f90
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! PR fortran/105954 - ICE in gfc_element_size, at fortran/target-memory.cc:132
+! Contributed by G.Steinmetz
+
+program p
+  use iso_c_binding, only: c_float, c_sizeof
+  implicit none
+  integer, parameter :: n = -99
+  type t
+     real :: b(3,7:n)
+  end type
+  type, bind(c) :: u
+     real(c_float) :: b(3,7:n)
+  end type
+  type(t) :: d
+  type(u) :: e
+  integer, parameter :: k = storage_size(d)
+  integer, parameter :: m = sizeof(d)
+  integer, parameter :: l = c_sizeof(e)
+  if (k /= 0) stop 1
+  if (m /= 0) stop 2
+  if (l /= 0) stop 3
+end
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pr106209.f90 b/gcc/testsuite/gfortran.dg/pr106209.f90
new file mode 100644
index 00000000000..44f9233ec2f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106209.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/106209 - ICE in add_init_expr_to_sym
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = 0   ! { dg-error "of deferred shape" }
+  integer, parameter :: b(*) = a   ! { dg-error "Bad shape of initializer" }
+  integer, parameter :: c(*) = [a] ! { dg-error "Cannot determine shape" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106331.f90 b/gcc/testsuite/gfortran.dg/pr106331.f90
new file mode 100644
index 00000000000..3873863be48
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106331.f90
@@ -0,0 +1,7 @@
+! { dg-do run }
+! { dg-options "-Og" }
+
+PROGRAM main
+  CHARACTER(LEN=24) :: a(2)
+  a = ''
+END PROGRAM
diff --git a/gcc/testsuite/gfortran.dg/pr106857.f90 b/gcc/testsuite/gfortran.dg/pr106857.f90
new file mode 100644
index 00000000000..4b0f86a75a6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106857.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/106857 - ICE in gfc_simplify_pack
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     integer :: n
+  end type
+  type(t), parameter :: a(2,2) = t(1)
+  type(t), parameter :: b(4) = reshape(a, [2])                          ! { dg-error "Different shape" }
+  type(t), parameter :: c(2) = pack(b, [.false.,.true.,.false.,.true.]) ! { dg-error "Different shape" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106934.f90 b/gcc/testsuite/gfortran.dg/pr106934.f90
new file mode 100644
index 00000000000..ac58a3e82e3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106934.f90
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! { dg-options "-O" }
+subroutine s
+   logical(1) :: a = .true.
+   logical(2) :: b
+   a = transfer(b, a)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106945.f90 b/gcc/testsuite/gfortran.dg/pr106945.f90
new file mode 100644
index 00000000000..e760ca7d27f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106945.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=single -fcheck=bounds -ftrapv" }
+! PR fortran/106945
+! Contributed by G. Steinmetz
+
+module m
+  implicit none
+  type t
+     class(*), allocatable :: a[:]
+  end type
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106985.f90 b/gcc/testsuite/gfortran.dg/pr106985.f90
new file mode 100644
index 00000000000..f4ed92577a3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106985.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/106985 - ICE in gfc_simplify_expr
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(2) = 1
+  integer, parameter :: b = a(2) + b ! { dg-error "before its definition is complete" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr106986.f90 b/gcc/testsuite/gfortran.dg/pr106986.f90
new file mode 100644
index 00000000000..a309b25d181
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr106986.f90
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/106986 - ICE in simplify_findloc_nodim
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(:) = [1] ! { dg-error "deferred shape" }
+  print *, findloc (a, 1)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr107054.f90 b/gcc/testsuite/gfortran.dg/pr107054.f90
new file mode 100644
index 00000000000..bbfe646beba
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr107054.f90
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR fortran/107054 - ICE in gfc_simplify_unpack
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     integer :: n = 0
+  end type
+  type(t), parameter :: a(4) = t(2)
+  type(t), parameter :: b(4) = reshape(a,[2]) ! { dg-error "Different shape" }
+  type(t), parameter :: c(2) = pack(b,[.false.,.true.,.false.,.true.]) ! { dg-error "Different shape" }
+  type(t), parameter :: d(4) = unpack(c,[.false.,.true.,.false.,.true.],a)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr107397.f90 b/gcc/testsuite/gfortran.dg/pr107397.f90
new file mode 100644
index 00000000000..fd59bf16007
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr107397.f90
@@ -0,0 +1,9 @@
+!{ dg-do compile }
+!
+program p
+  type t
+    real :: a = 1.0
+  end type
+  type(t), parameter :: x = z'1' ! { dg-error "incompatible with a BOZ" }
+  x%a = x%a + 2 ! { dg-error "has no IMPLICIT type" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr107872.f90 b/gcc/testsuite/gfortran.dg/pr107872.f90
new file mode 100644
index 00000000000..09838479e92
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr107872.f90
@@ -0,0 +1,40 @@
+! { dg-do run }
+!
+! Test the fix for PR107872, where an ICE occurred in
+! resolve.cc(derived_inaccessible) because derived types with
+! recursive allocatable components were not catered for.
+!
+module mod1
+  type t
+     integer :: data
+     type(t), allocatable :: next
+   contains
+     procedure, private :: write_t
+     generic :: write(formatted) => write_t
+  end type
+contains
+  recursive subroutine write_t(this, unit, iotype, v_list, iostat, iomsg)
+    class(t), intent(in) :: this
+    integer, intent(in) :: unit
+    character(*), intent(in) :: iotype
+    integer, intent(in) :: v_list(:)
+    integer, intent(out) :: iostat
+    character(*), intent(inout) :: iomsg
+    if (ALLOCATED(this%next)) &
+         write (unit, '(dt)') this%next
+    write (unit, '(i2)') this%data
+  end subroutine
+end module
+
+  use mod1
+  type(t) :: a
+  character (8) :: buffer
+  a%data = 1
+  allocate (a%next)
+  a%next%data = 2
+  allocate (a%next%next)
+  a%next%next%data = 3
+  write (buffer, '(dt)')a
+  deallocate (a%next)
+  if (trim (buffer) .ne. ' 3 2 1') stop 1
+end
diff --git a/gcc/testsuite/gfortran.dg/pr108131.f90 b/gcc/testsuite/gfortran.dg/pr108131.f90
new file mode 100644
index 00000000000..8bf36d361ba
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108131.f90
@@ -0,0 +1,25 @@
+! { dg-do run }
+! { dg-additional-options "-fdump-tree-original" }
+! PR fortran/108131
+!
+! Incorrect array bounds when bound intrinsic used in declaration
+
+program test
+  implicit none
+  integer, parameter :: mg(7:10)                 = 0
+  integer, parameter :: u =   ubound(mg, dim=1)
+  integer, parameter :: cx(-1:ubound(mg, dim=1)) = 1
+  integer, parameter :: dx(lbound(mg, dim=1):ubound(cx, dim=1)) = 2
+
+  write(*,*) ubound(mg, dim=1)
+  write(*,*) ubound(cx, dim=1)
+  if (u /= 10) stop 1
+  if (ubound(mg, dim=1) /= 10) stop 2
+  if (ubound(cx, dim=1) /= 10) stop 3
+  if (ubound(dx, dim=1) /= 10) stop 4
+  if (lbound(mg, dim=1) /=  7) stop 5
+  if (lbound(cx, dim=1) /= -1) stop 6
+  if (lbound(dx, dim=1) /=  7) stop 7
+end program test
+
+! { dg-final { scan-tree-dump-not "_gfortran_stop_numeric" "original" } }
diff --git a/gcc/testsuite/gfortran.dg/pr108193.f90 b/gcc/testsuite/gfortran.dg/pr108193.f90
new file mode 100644
index 00000000000..3a3655f1248
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108193.f90
@@ -0,0 +1,24 @@
+! PR rtl-optimization/108193
+! { dg-do compile { target pthread } }
+! { dg-options "-O2 -fsplit-loops -ftree-parallelize-loops=2 -fno-tree-dominator-opts" }
+
+subroutine foo (n, r)
+  implicit none
+  integer :: i, j, n
+  real :: s, r(*)
+
+  s = 0.0
+
+  do j = 1, 2
+     do i = j, n
+        s = r(i)
+     end do
+  end do
+
+  do i = 1, n
+     do j = i, n
+        s = s + 1
+     end do
+     r(i) = s
+  end do
+end subroutine foo
diff --git a/gcc/testsuite/gfortran.dg/pr108420.f90 b/gcc/testsuite/gfortran.dg/pr108420.f90
new file mode 100644
index 00000000000..985c0b3bf53
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108420.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/108420
+! Contributed by G.Steinmetz
+
+program p
+  character :: c = 'c'
+  logical   :: m = .true.
+  print *, merge(transfer('a', 'b', 0), c, .true.)
+  print *, merge(transfer('a', 'b', 0), c, m)
+end
diff --git a/gcc/testsuite/gfortran.dg/pr108421.f90 b/gcc/testsuite/gfortran.dg/pr108421.f90
new file mode 100644
index 00000000000..89439bc7eec
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108421.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/108421
+! Contributed by G.Steinmetz
+
+program p
+  character(real(3)) :: c ! { dg-error "must be of INTEGER type" }
+  call s(c)
+end
+subroutine s(x)
+  character(*) :: x
+end
diff --git a/gcc/testsuite/gfortran.dg/pr108501.f90 b/gcc/testsuite/gfortran.dg/pr108501.f90
new file mode 100644
index 00000000000..09ab8c9f34f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108501.f90
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR fortran/108501 - ICE in get_expr_storage_size
+! Contributed by G.Steinmetz
+
+program p
+  real, parameter :: n = 2
+  real :: a(1,(n),2) ! { dg-error "must be of INTEGER type" }
+  call s(a(:,:,1))
+end
+subroutine s(x)
+  real :: x(2)
+end
+
+! { dg-prune-output "must have constant shape" }
diff --git a/gcc/testsuite/gfortran.dg/pr108502.f90 b/gcc/testsuite/gfortran.dg/pr108502.f90
new file mode 100644
index 00000000000..45f73849c57
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108502.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-options "-O2 -ffrontend-optimize" }
+! PR fortran/108502 - ICE in gfc_check_dependency
+! Contributed by G.Steinmetz
+
+integer function n()
+  integer :: a(1)
+  a = [1] / 0
+end
+program p
+  integer :: b = n() ! { dg-error "must be an intrinsic function" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr108527.f90 b/gcc/testsuite/gfortran.dg/pr108527.f90
new file mode 100644
index 00000000000..804514810ac
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108527.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/108527 - ICE in compare_bound_int
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a((2.)) = [4,8] ! { dg-error "must be of INTEGER type" }
+  integer(a(1:1)) :: b                  ! { dg-error "Unclassifiable statement" }
+end
+
+! { dg-prune-output "Parameter array" }
diff --git a/gcc/testsuite/gfortran.dg/pr108529.f90 b/gcc/testsuite/gfortran.dg/pr108529.f90
new file mode 100644
index 00000000000..34c9691fae1
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr108529.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/108529 - ICE in transformational_result
+! Contributed by G.Steinmetz
+
+program p
+  integer, parameter :: a(*,*) = reshape([1, 2, 3, 4], [2, 2])
+  logical, parameter :: b(2,*) = a > 2     ! { dg-error "Assumed size" }
+  logical, parameter :: c(*)   = all(b, 1) ! { dg-error "Bad shape" }
+end
diff --git a/gcc/testsuite/gfortran.dg/pr47614.f b/gcc/testsuite/gfortran.dg/pr47614.f
index 500d210a2a4..d772eef257f 100644
--- a/gcc/testsuite/gfortran.dg/pr47614.f
+++ b/gcc/testsuite/gfortran.dg/pr47614.f
@@ -1,6 +1,7 @@
 ! { dg-do run { target { powerpc*-*-* } } }
 ! { dg-skip-if "" { powerpc*-*-darwin* } }
-! { dg-options "-O3 -funroll-loops -ffast-math -mcpu=power4" }
+! { dg-options "-O3 -funroll-loops -ffast-math -mdejagnu-cpu=power4" }
+! { dg-options "-O3 -funroll-loops -ffast-math" { target powerpc64le*-*-linux* } }
 
 
       SUBROUTINE SFCPAR(ZET,NZ,ZMH,TSL,TMES)
diff --git a/gcc/testsuite/gfortran.dg/pr58968.f b/gcc/testsuite/gfortran.dg/pr58968.f
index b6ea17f4ae2..a7f1e1e710b 100644
--- a/gcc/testsuite/gfortran.dg/pr58968.f
+++ b/gcc/testsuite/gfortran.dg/pr58968.f
@@ -1,6 +1,6 @@
 C PR rtl-optimization/58968.f
 C { dg-do compile { target powerpc*-*-* } }
-C { dg-options "-mcpu=power7 -O3 -w -ffast-math  -funroll-loops" }
+C { dg-options "-mdejagnu-cpu=power7 -O3 -w -ffast-math  -funroll-loops" }
       SUBROUTINE MAKTABS(IW,SOME,LBOX1,LBOX2,LBOX3,NSPACE,NA,NB,
      *            LBST,X,
      *            NX,IAMA,IAMI,IBMA,IBMI,MNUM,IDIM,MSTA,IBO,
diff --git a/gcc/testsuite/gfortran.dg/pr85877.f90 b/gcc/testsuite/gfortran.dg/pr85877.f90
new file mode 100644
index 00000000000..d8f08cbd210
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr85877.f90
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! PR fortran/85877
+! A procedure with the bind(c) attribute shall have an explicit interface
+! Contributed by G. Steinmetz
+
+function f() bind(c)
+  f = 42.
+end
+
+subroutine p
+  bind(c) f     ! { dg-error "must be explicit" }
+  x = f()
+end
+
+function g() bind(c)
+  g = 42.
+end
+
+subroutine s
+  interface
+     function g() bind(c)
+     end function g
+  end interface
+  x = g()
+end
diff --git a/gcc/testsuite/gfortran.dg/pr96024.f90 b/gcc/testsuite/gfortran.dg/pr96024.f90
new file mode 100644
index 00000000000..2c914a997f2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr96024.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/96024 - ICE in mio_name_expr_t
+! Contributed by G.Steinmetz
+
+module m
+  implicit none
+  type t
+     character(char(1)) :: a ! { dg-error "must be of INTEGER type" }
+  end type
+  type(t) :: z = t('a')
+end
diff --git a/gcc/testsuite/gfortran.dg/pr96025.f90 b/gcc/testsuite/gfortran.dg/pr96025.f90
new file mode 100644
index 00000000000..ce292bd9664
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr96025.f90
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR fortran/96025 - ICE in expr_check_typed_help
+! Contributed by G.Steinmetz
+
+program p
+  print *, f()
+contains
+  character(char(1)) function f() ! { dg-error "must be of INTEGER type" }
+    f = 'f'
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/pr99036.f90 b/gcc/testsuite/gfortran.dg/pr99036.f90
new file mode 100644
index 00000000000..a6e396f6f71
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr99036.f90
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/99036 - ICE in gfc_current_interface_head
+! Contributed by G. Steinmetz
+
+module m
+contains
+  module procedure s ! { dg-error "must be in a generic module interface" }
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/ptr-func-5.f90 b/gcc/testsuite/gfortran.dg/ptr-func-5.f90
new file mode 100644
index 00000000000..05fd56703ca
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/ptr-func-5.f90
@@ -0,0 +1,39 @@
+! { dg-do compile }
+! PR fortran/109846
+! CLASS pointer function result in variable definition context
+
+module foo
+  implicit none
+  type :: parameter_list
+  contains
+    procedure :: sublist, sublist_nores
+  end type
+contains
+  function sublist (this) result (slist)
+    class(parameter_list), intent(inout) :: this
+    class(parameter_list), pointer       :: slist
+    allocate (slist)
+  end function
+  function sublist_nores (this)
+    class(parameter_list), intent(inout) :: this
+    class(parameter_list), pointer       :: sublist_nores
+    allocate (sublist_nores)
+  end function
+end module
+
+program example
+  use foo
+  implicit none
+  type(parameter_list) :: plist
+  call sub1 (plist%sublist())
+  call sub1 (plist%sublist_nores())
+  call sub2 (plist%sublist())
+  call sub2 (plist%sublist_nores())
+contains
+  subroutine sub1 (plist)
+    type(parameter_list), intent(inout) :: plist
+  end subroutine
+  subroutine sub2 (plist)
+    type(parameter_list) :: plist
+  end subroutine
+end program
diff --git a/gcc/testsuite/gfortran.dg/save_7.f90 b/gcc/testsuite/gfortran.dg/save_7.f90
new file mode 100644
index 00000000000..dfbef12bec0
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/save_7.f90
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-options "-O2 -fno-automatic" }
+!
+! PR fortran/95107 - do not make associate variables TREE_STATIC
+! Contributed by G.Steinmetz
+
+program p
+  type t
+     real, pointer :: a => null()
+  end type
+  type t2
+     type(t) :: b(1)
+  end type
+  type(t2), save :: x
+  associate (y => x%b)
+  end associate
+end
diff --git a/gcc/testsuite/gfortran.dg/select_rank_6.f90 b/gcc/testsuite/gfortran.dg/select_rank_6.f90
new file mode 100644
index 00000000000..d0121777bb5
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/select_rank_6.f90
@@ -0,0 +1,48 @@
+! { dg-do compile }
+! PR fortran/100607 - fix diagnostics for SELECT RANK
+! Contributed by T.Burnus
+
+program p
+  implicit none
+  integer, allocatable :: A(:,:,:)
+
+  allocate(a(5:6,-2:2, 99:100))
+  call foo(a)
+  call bar(a)
+
+contains
+
+  subroutine foo(x)
+    integer, allocatable :: x(..)
+    if (rank(x) /= 3) stop 1
+    if (any (lbound(x) /= [5, -2, 99])) stop 2
+
+    select rank (x)
+    rank(3)
+      if (any (lbound(x) /= [5, -2, 99])) stop 3
+    end select
+
+    select rank (x) ! { dg-error "pointer or allocatable selector at .2." }
+    rank(*)         ! { dg-error "pointer or allocatable selector at .2." }
+      if (rank(x) /= 1) stop 4
+      if (lbound(x, 1) /= 1) stop 5
+    end select
+  end
+
+  subroutine bar(x)
+    integer :: x(..)
+    if (rank(x) /= 3) stop 6
+    if (any (lbound(x) /= 1)) stop 7
+
+    select rank (x)
+    rank(3)
+      if (any (lbound(x) /= 1)) stop 8
+    end select
+
+    select rank (x)
+    rank(*)
+      if (rank(x) /= 1) stop 9
+      if (lbound(x, 1) /= 1) stop 10
+    end select
+  end
+end
diff --git a/gcc/testsuite/gfortran.dg/set_exponent_1.f90 b/gcc/testsuite/gfortran.dg/set_exponent_1.f90
new file mode 100644
index 00000000000..4c063e8330b
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/set_exponent_1.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+! PR fortran/109511
+! Check compile-time simplification of SET_EXPONENT against runtime
+
+program exponent
+  implicit none
+  integer :: i
+  i = 0
+  print *, i, set_exponent(1., 0), set_exponent(1., i)
+  if (set_exponent(1., 0) /= set_exponent(1., i)) stop 1
+  i = 1
+  print *, i, set_exponent(1., 1), set_exponent(1., i)
+  if (set_exponent(1., 1) /= set_exponent(1., i)) stop 2
+  i = 2
+  print *, i, set_exponent(-1.75, 2), set_exponent(-1.75, i)
+  if (set_exponent(-1.75, 2) /= set_exponent(-1.75, i)) stop 3
+  print *, i, set_exponent(0.1875, 2), set_exponent(0.1875, i)
+  if (set_exponent(0.1875, 2) /= set_exponent(0.1875, i)) stop 4
+  i = 3
+  print *, i, set_exponent(0.75, 3), set_exponent(0.75, i)
+  if (set_exponent(0.75, 3) /= set_exponent(0.75, i)) stop 5
+  i = 4
+  print *, i, set_exponent(-2.5, 4), set_exponent(-2.5, i)
+  if (set_exponent(-2.5, 4) /= set_exponent(-2.5, i)) stop 6
+  i = -1
+  print *, i, set_exponent(1., -1), set_exponent(1., i)
+  if (set_exponent(1., -1) /= set_exponent(1., i)) stop 7
+  i = -2
+  print *, i, set_exponent(1.125, -2), set_exponent(1.125, i)
+  if (set_exponent(1.125, -2) /= set_exponent(1.125, i)) stop 8
+  print *, i, set_exponent(-0.25, -2), set_exponent(-0.25, i)
+  if (set_exponent(-0.25, -2) /= set_exponent(-0.25, i)) stop 9
+  i = -3
+  print *, i, set_exponent(0.75, -3), set_exponent(0.75, i)
+  if (set_exponent(0.75, -3) /= set_exponent(0.75, i)) stop 10
+end program exponent
diff --git a/gcc/testsuite/gfortran.dg/unpack_vector_1.f90 b/gcc/testsuite/gfortran.dg/unpack_vector_1.f90
new file mode 100644
index 00000000000..5347c111e8f
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/unpack_vector_1.f90
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR fortran/105813
+! Fix checking of VECTOR argument to UNPACK when MASK is a variable.
+! Contributed by G.Steinmetz
+
+program p
+  logical, parameter :: mask(2,2) = reshape ([.true.,  .true.,  &
+                                              .false., .true.], &
+                                              shape (mask))
+  print *, unpack ([1,2,3], mask, 0) ! OK
+  print *, unpack ([1,2],   mask, 0) ! { dg-error "must provide at least" }
+end
diff --git a/gcc/testsuite/gfortran.dg/vect/pr107254.f90 b/gcc/testsuite/gfortran.dg/vect/pr107254.f90
new file mode 100644
index 00000000000..85bcb5f3fa2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/vect/pr107254.f90
@@ -0,0 +1,49 @@
+! { dg-do run }
+
+subroutine dlartg( f, g, s, r )
+  implicit none
+  double precision :: f, g, r, s
+  double precision :: d, p
+
+  d = sqrt( f*f + g*g )
+  p = 1.d0 / d
+  if( abs( f ) > 1 ) then
+     s = g*sign( p, f )
+     r = sign( d, f )
+  else
+     s = g*sign( p, f )
+     r = sign( d, f )
+  end if
+end subroutine
+
+subroutine dhgeqz( n, h, t )
+  implicit none
+  integer            n
+  double precision   h( n, * ), t( n, * )
+  integer            jc
+  double precision   c, s, temp, temp2, tempr
+  temp2 = 10d0
+  call dlartg( 10d0, temp2, s, tempr )
+  c = 0.9d0
+  s = 1.d0
+  do jc = 1, n
+     temp = c*h( 1, jc ) + s*h( 2, jc )
+     h( 2, jc ) = -s*h( 1, jc ) + c*h( 2, jc )
+     h( 1, jc ) = temp
+     temp2 = c*t( 1, jc ) + s*t( 2, jc )
+     t( 2, jc ) = -s*t( 1, jc ) + c*t( 2, jc )
+     t( 1, jc ) = temp2
+  enddo
+end subroutine dhgeqz
+
+program test
+  implicit none
+  double precision h(2,2), t(2,2)  
+  h = 0
+  t(1,1) = 1
+  t(2,1) = 0
+  t(1,2) = 0
+  t(2,2) = 0
+  call dhgeqz( 2, h, t )
+  if (t(2,2).ne.0) STOP 1
+end program test
diff --git a/gcc/testsuite/gnat.dg/opt100.adb b/gcc/testsuite/gnat.dg/opt100.adb
new file mode 100644
index 00000000000..83270b64339
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt100.adb
@@ -0,0 +1,13 @@
+-- { dg-do run }
+-- { dg-options "-O2 -gnatp" }
+
+with Opt100_Pkg; use Opt100_Pkg;
+
+procedure Opt100 is
+  R : constant Rec := (K => B, N => 1);
+
+begin
+  if Func (R) /= 1 then
+     raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt100_pkg.adb b/gcc/testsuite/gnat.dg/opt100_pkg.adb
new file mode 100644
index 00000000000..42bf8830d53
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt100_pkg.adb
@@ -0,0 +1,17 @@
+package body Opt100_Pkg is
+
+   function Func (R : Rec) return Integer is
+   begin
+      if R in Small_Rec then
+         case R.K is
+            when A => return 0;
+            when B => return 1;
+            when C => return 2;
+            when others => raise Program_Error;
+         end case;
+      else
+         return -1;
+      end if;
+   end;
+
+end Opt100_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt100_pkg.ads b/gcc/testsuite/gnat.dg/opt100_pkg.ads
new file mode 100644
index 00000000000..a45f887d665
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt100_pkg.ads
@@ -0,0 +1,23 @@
+with Interfaces; use Interfaces;
+
+package Opt100_Pkg is
+
+  A : constant Unsigned_8 := 0;
+  B : constant Unsigned_8 := 1;
+  C : constant Unsigned_8 := 2;
+
+  subtype Small_Unsigned_8 is Unsigned_8 range A .. C;
+
+  type Rec is record
+    K : Unsigned_8;
+    N : Natural;
+  end record;
+
+  subtype Small_Rec is Rec
+    with Dynamic_Predicate =>
+      Small_Rec.K in Small_Unsigned_8 and
+        ((Small_Rec.N in Positive) = (Small_Rec.K in B | C));
+
+   function Func (R : Rec) return Integer;
+
+end Opt100_Pkg;
diff --git a/gcc/testsuite/gnat.dg/opt99.adb b/gcc/testsuite/gnat.dg/opt99.adb
new file mode 100644
index 00000000000..8805d47c122
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt99.adb
@@ -0,0 +1,15 @@
+-- { dg-do run }
+-- { dg-options "-O" }
+
+with Opt99_Pkg1; use Opt99_Pkg1;
+
+procedure Opt99 is
+  C : constant My_Character := (D => True, C => ' ');
+  D : Derived;
+
+begin
+  Set (D, C, C);
+  if not D.C2.D then
+    raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/gnat.dg/opt99_pkg1.adb b/gcc/testsuite/gnat.dg/opt99_pkg1.adb
new file mode 100644
index 00000000000..476b09c9524
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt99_pkg1.adb
@@ -0,0 +1,10 @@
+package body Opt99_Pkg1 is
+
+  procedure Set (D: in out Derived; C1, C2 : My_Character) is
+  begin
+    D.I  := 0;
+    D.C1 := C1;
+    D.C2 := C2;
+  end;
+
+end Opt99_Pkg1;
diff --git a/gcc/testsuite/gnat.dg/opt99_pkg1.ads b/gcc/testsuite/gnat.dg/opt99_pkg1.ads
new file mode 100644
index 00000000000..3e265616d14
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt99_pkg1.ads
@@ -0,0 +1,19 @@
+with Opt99_Pkg2;
+
+package Opt99_Pkg1 is
+
+  type My_Character (D : Boolean := False) is record
+    case D is
+      when False => null;
+      when True  => C : Character;
+    end case;
+  end record;
+
+  type Derived is new Opt99_Pkg2.Root with record
+    I : Integer;
+    C1, C2 : My_Character;
+  end record;
+
+  procedure Set (D: in out Derived; C1, C2 : My_Character);
+
+end Opt99_Pkg1;
diff --git a/gcc/testsuite/gnat.dg/opt99_pkg2.ads b/gcc/testsuite/gnat.dg/opt99_pkg2.ads
new file mode 100644
index 00000000000..09aaff14e01
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/opt99_pkg2.ads
@@ -0,0 +1,13 @@
+package Opt99_Pkg2 is
+
+  function Get_Max return Positive is (4);
+
+  C : constant Positive := Get_Max;
+
+  type Arr is array (1 .. C) of Integer;
+
+  type Root is tagged record
+    Data : Arr;
+  end record;
+
+end Opt99_Pkg2;
diff --git a/gcc/testsuite/gnat.dg/sso18.adb b/gcc/testsuite/gnat.dg/sso18.adb
new file mode 100644
index 00000000000..7496e965fd3
--- /dev/null
+++ b/gcc/testsuite/gnat.dg/sso18.adb
@@ -0,0 +1,21 @@
+--  { dg-do run }
+--  { dg-options "-O2" }
+
+with System;
+
+procedure SSO18 is
+
+  type Arr is array (1..32) of Short_Integer;
+  type Rev_Arr is array (1..32) of Short_Integer
+    with Scalar_Storage_Order => System.High_Order_First;
+  C : constant Arr := (others => 16);
+  RA : Rev_Arr;
+  A  : Arr;
+
+begin
+  RA := Rev_Arr(C);
+  A := Arr (RA);
+  if A /= C or else RA(1) /= 16 then
+     raise Program_Error;
+  end if;
+end;
diff --git a/gcc/testsuite/lib/lto.exp b/gcc/testsuite/lib/lto.exp
index 94a81ffabb7..77919e8443b 100644
--- a/gcc/testsuite/lib/lto.exp
+++ b/gcc/testsuite/lib/lto.exp
@@ -159,6 +159,9 @@ proc lto_prune_warns { text } {
     regsub -all "(^|\n)\[ \t\]*\[\(\]file \[^\n\]* value=\[^\n\]*; file \[^\n\]* value=\[^\n\]*\[)\];" $text "" text
     regsub -all "(^|\n)\[ \t\]*\[^\n\]* definition taken" $text "" text
 
+    # Ignore missing jobserver for tests that do more than 1 LTRANS unit
+    regsub -all "(^|\n)\[^\n\]*: warning: using serial compilation of \[^\n\]*" $text "" text
+
     # Ignore informational notes.
     regsub -all "(^|\n)\[^\n\]*: note: \[^\n\]*" $text "" text
 
diff --git a/gcc/testsuite/lib/prune.exp b/gcc/testsuite/lib/prune.exp
index 2809f88b16f..c2ff05c2a37 100644
--- a/gcc/testsuite/lib/prune.exp
+++ b/gcc/testsuite/lib/prune.exp
@@ -76,6 +76,11 @@ proc prune_gcc_output { text } {
     regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $text "" text
     regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $text "" text
 
+    # Ideally the tests would indicate that executable stacks were needed
+    # to the linker.  But the option for that varies and may not even exist
+    # on some targets.  So we're stuck pruning the warning.
+    regsub -all "(^|\n)(\[^\n\]*: warning:\[^\n\]*requires executable stack\[^\n\]*\n?)+" $text "\\1" text
+
     # Ignore harmless warnings from Xcode 3.2.x.
     regsub -all "(^|\n)\[^\n\]*ld: warning: can't add line info to anonymous symbol\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*warning: DWARFDebugInfoEntry::AppendDependants\[^\n\]*AT_\[^\n\]*FORM_ref4\[^\n\]*" $text "" text
@@ -87,6 +92,13 @@ proc prune_gcc_output { text } {
     # Ignore dsymutil warning (tool bug is actually linker)
     regsub -all "(^|\n)\[^\n\]*could not find object file symbol for symbol\[^\n\]*" $text "" text
 
+    # Ignore missing lto jobserver for tests that do more than 1 LTRANS unit
+    regsub -all "(^|\n)\[^\n\]*lto\[^\n\]*: warning: using serial compilation of \[^\n\]*" $text "" text
+    regsub -all "(^|\n)\[^\n\]*lto\[^\n\]*: note: see the \[^\n\]*'-flto' option documentation\[^\n\]* for more information" $text "" text
+
+    # Many tests that use visibility will still pass on platforms that don't support it.
+    regsub -all "(^|\n)\[^\n\]*lto1: warning: visibility attribute not supported in this configuration; ignored\[^\n\]*" $text "" text
+
     # If dg-enable-nn-line-numbers was provided, then obscure source-margin
     # line numbers by converting them to "NN" form.
     set text [maybe-handle-nn-line-numbers $text]
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index 857e57218c1..a09606e4497 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -6087,9 +6087,12 @@ proc check_effective_target_powerpc_sqrt { } {
     }
 
     return [check_no_compiler_messages powerpc_sqrt object {
+	void test (void)
+	{
 	#ifndef _ARCH_PPCSQ
 	#error _ARCH_PPCSQ is not defined
 	#endif
+	}
     } {}]
 }
 
@@ -6196,63 +6199,94 @@ proc check_effective_target_powerpc_p9modulo_ok { } {
 # return 1 if our compiler returns the ARCH_PWR defines with the options
 # as provided by the test.
 proc check_effective_target_has_arch_pwr5 { } {
-	return [check_no_compiler_messages arch_pwr5 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr5 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR5
 		#error does not have power5 support.
 		#else
 		/* "has power5 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr6 { } {
-	return [check_no_compiler_messages arch_pwr6 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr6 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR6
 		#error does not have power6 support.
 		#else
 		/* "has power6 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr7 { } {
-	return [check_no_compiler_messages arch_pwr7 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr7 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR7
 		#error does not have power7 support.
 		#else
 		/* "has power7 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr8 { } {
-	return [check_no_compiler_messages arch_pwr8 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr8 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR8
 		#error does not have power8 support.
 		#else
 		/* "has power8 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr9 { } {
-	return [check_no_compiler_messages arch_pwr9 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr9 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR9
 		#error does not have power9 support.
 		#else
 		/* "has power9 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
 }
 
 proc check_effective_target_has_arch_pwr10 { } {
-	return [check_no_compiler_messages arch_pwr10 assembly {
+	return [check_no_compiler_messages_nocache arch_pwr10 assembly {
+		void test (void)
+		{
 		#ifndef _ARCH_PWR10
 		#error does not have power10 support.
 		#else
 		/* "has power10 support" */
 		#endif
-	}]
+		}
+	} [current_compiler_flags]]
+}
+
+proc check_effective_target_has_arch_ppc64 { } {
+	return [check_no_compiler_messages_nocache arch_ppc64 assembly {
+		void test (void)
+		{
+		#ifndef _ARCH_PPC64
+		#error does not have ppc64 support.
+		#else
+		/* "has ppc64 support" */
+		#endif
+		}
+	} [current_compiler_flags]]
 }
 
 # Return 1 if this is a PowerPC target supporting -mcpu=power10.
@@ -6338,9 +6372,12 @@ proc check_effective_target_powerpc_float128_hw_ok { } {
 
 proc check_effective_target_ppc_float128 { } {
     return [check_no_compiler_messages_nocache ppc_float128 object {
+	void test (void)
+	{
 	#ifndef __FLOAT128__
 	  nope no good
 	#endif
+	}
     }]
 }
 
@@ -6348,9 +6385,12 @@ proc check_effective_target_ppc_float128 { } {
 
 proc check_effective_target_ppc_float128_insns { } {
     return [check_no_compiler_messages_nocache ppc_float128 object {
+	void test (void)
+	{
 	#ifndef __FLOAT128_HARDWARE__
 	  nope no good
 	#endif
+	}
     }]
 }
 
@@ -6358,9 +6398,12 @@ proc check_effective_target_ppc_float128_insns { } {
 
 proc check_effective_target_powerpc_vsx { } {
     return [check_no_compiler_messages_nocache powerpc_vsx object {
+	void test (void)
+	{
 	#ifndef __VSX__
 	  nope no vsx
 	#endif
+	}
     }]
 }
 
diff --git a/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm b/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm
index 07123559d72..27bae630ce8 100644
--- a/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm
+++ b/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm
@@ -2,7 +2,7 @@
 
 // { dg-do run { target *-*-darwin* } }
 // { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } }
-// { dg-skip-if "Headers incompatible with 10.4 APIs" { *-*-darwin1[1-9]* *-*-darwin2[0-9]* } { "-fnext-runtime" } { "" } }
+// { dg-skip-if "Headers incompatible with 10.4 APIs" { *-*-darwin1[1-9]* *-*-darwin2* } { "-fnext-runtime" } { "" } }
 // { dg-additional-options "-fobjc-call-cxx-cdtors -mmacosx-version-min=10.4 -framework Foundation" }
 // This test has no equivalent or meaning for m64/ABI V2
 // { dg-xfail-run-if "No Test Avail" {  *-*-darwin* && lp64 } { "-fnext-runtime" } { "" } }
diff --git a/gcc/testsuite/obj-c++.dg/objc-gc-3.mm b/gcc/testsuite/obj-c++.dg/objc-gc-3.mm
index 45ffbc5553d..18f2cbe8869 100644
--- a/gcc/testsuite/obj-c++.dg/objc-gc-3.mm
+++ b/gcc/testsuite/obj-c++.dg/objc-gc-3.mm
@@ -3,7 +3,7 @@
 /* Contributed by Ziemowit Laski <zlaski@apple.com>  */
 
 /* { dg-do compile } */
-/* { dg-skip-if "GC API is an error from Darwin16." { *-*-darwin1[6-9]* *-*-darwin2[0-9]* } { "-fnext-runtime" } { "" } } */
+/* { dg-skip-if "GC API is an error from Darwin16." { *-*-darwin1[6-9]* *-*-darwin2* } { "-fnext-runtime" } { "" } } */
 /* { dg-options "-fobjc-gc" } */
 /* { dg-prune-output "cc1objplus: warning: '-fobjc-gc' is ignored for '-fgnu-runtime'" } */
 
diff --git a/gcc/testsuite/objc.dg/objc-gc-4.m b/gcc/testsuite/objc.dg/objc-gc-4.m
index 8102a5a532f..1b2d9674969 100644
--- a/gcc/testsuite/objc.dg/objc-gc-4.m
+++ b/gcc/testsuite/objc.dg/objc-gc-4.m
@@ -3,7 +3,7 @@
 /* Contributed by Ziemowit Laski <zlaski@apple.com>  */
 
 /* { dg-do compile } */
-/* { dg-skip-if "GC API is an error from Darwin16." { *-*-darwin1[6-9]* *-*-darwin2[0-9]* } { "-fnext-runtime" } { "" } } */
+/* { dg-skip-if "GC API is an error from Darwin16." { *-*-darwin1[6-9]* *-*-darwin2* } { "-fnext-runtime" } { "" } } */
 /* { dg-options "-fobjc-gc" } */
 /* { dg-prune-output "cc1obj: warning: '-fobjc-gc' is ignored for '-fgnu-runtime'" } */
 
diff --git a/gcc/tree-if-conv.c b/gcc/tree-if-conv.c
index 716eae44a21..6493ccd3f0d 100644
--- a/gcc/tree-if-conv.c
+++ b/gcc/tree-if-conv.c
@@ -1419,10 +1419,20 @@ if_convertible_loop_p_1 (class loop *loop, vec<data_reference_p> *refs)
       basic_block bb = ifc_bbs[i];
       gimple_stmt_iterator gsi;
 
+      bool may_have_nonlocal_labels
+	= bb_with_exit_edge_p (loop, bb) || bb == loop->latch;
       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
 	switch (gimple_code (gsi_stmt (gsi)))
 	  {
 	  case GIMPLE_LABEL:
+	    if (!may_have_nonlocal_labels)
+	      {
+		tree label
+		  = gimple_label_label (as_a <glabel *> (gsi_stmt (gsi)));
+		if (DECL_NONLOCAL (label) || FORCED_LABEL (label))
+		  return false;
+	      }
+	    /* Fallthru.  */
 	  case GIMPLE_ASSIGN:
 	  case GIMPLE_CALL:
 	  case GIMPLE_DEBUG:
@@ -2498,8 +2508,8 @@ remove_conditions_and_labels (loop_p loop)
       basic_block bb = ifc_bbs[i];
 
       if (bb_with_exit_edge_p (loop, bb)
-        || bb == loop->latch)
-      continue;
+	  || bb == loop->latch)
+	continue;
 
       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )
 	switch (gimple_code (gsi_stmt (gsi)))
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
index 48588c41b35..c56c55a683d 100644
--- a/gcc/tree-inline.c
+++ b/gcc/tree-inline.c
@@ -2762,16 +2762,12 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, profile_count count)
 {
   struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);
 
-  if (!DECL_ARGUMENTS (new_fndecl))
-    DECL_ARGUMENTS (new_fndecl) = DECL_ARGUMENTS (callee_fndecl);
-  if (!DECL_RESULT (new_fndecl))
-    DECL_RESULT (new_fndecl) = DECL_RESULT (callee_fndecl);
-
   /* Register specific tree functions.  */
   gimple_register_cfg_hooks ();
 
   /* Get clean struct function.  */
-  push_struct_function (new_fndecl);
+  push_struct_function (new_fndecl, true);
+  targetm.target_option.relayout_function (new_fndecl);
 
   /* We will rebuild these, so just sanity check that they are empty.  */
   gcc_assert (VALUE_HISTOGRAMS (cfun) == NULL);
@@ -6310,8 +6306,7 @@ tree_function_versioning (tree old_decl, tree new_decl,
   id.transform_parameter = false;
   id.transform_lang_insert_block = NULL;
 
-  old_entry_block = ENTRY_BLOCK_PTR_FOR_FN
-    (DECL_STRUCT_FUNCTION (old_decl));
+  old_entry_block = ENTRY_BLOCK_PTR_FOR_FN (DECL_STRUCT_FUNCTION (old_decl));
   DECL_RESULT (new_decl) = DECL_RESULT (old_decl);
   DECL_ARGUMENTS (new_decl) = DECL_ARGUMENTS (old_decl);
   initialize_cfun (new_decl, old_decl,
diff --git a/gcc/tree-into-ssa.c b/gcc/tree-into-ssa.c
index ef990604030..bf6c51654cc 100644
--- a/gcc/tree-into-ssa.c
+++ b/gcc/tree-into-ssa.c
@@ -1927,9 +1927,8 @@ maybe_register_def (def_operand_p def_p, gimple *stmt,
 	  tree tracked_var = target_for_debug_bind (sym);
 	  if (tracked_var)
 	    {
-	      gimple *note = gimple_build_debug_bind (tracked_var, def, stmt);
-	      /* If stmt ends the bb, insert the debug stmt on the single
-		 non-EH edge from the stmt.  */
+	      /* If stmt ends the bb, insert the debug stmt on the non-EH
+		 edge(s) from the stmt.  */
 	      if (gsi_one_before_end_p (gsi) && stmt_ends_bb_p (stmt))
 		{
 		  basic_block bb = gsi_bb (gsi);
@@ -1938,33 +1937,46 @@ maybe_register_def (def_operand_p def_p, gimple *stmt,
 		  FOR_EACH_EDGE (e, ei, bb->succs)
 		    if (!(e->flags & EDGE_EH))
 		      {
-			gcc_checking_assert (!ef);
+			/* asm goto can have multiple non-EH edges from the
+			   stmt.  Insert on all of them where it is
+			   possible.  */
+			gcc_checking_assert (!ef || (gimple_code (stmt)
+						     == GIMPLE_ASM));
 			ef = e;
+			/* If there are other predecessors to ef->dest, then
+			   there must be PHI nodes for the modified
+			   variable, and therefore there will be debug bind
+			   stmts after the PHI nodes.  The debug bind notes
+			   we'd insert would force the creation of a new
+			   block (diverging codegen) and be redundant with
+			   the post-PHI bind stmts, so don't add them.
+
+			   As for the exit edge, there wouldn't be redundant
+			   bind stmts, but there wouldn't be a PC to bind
+			   them to either, so avoid diverging the CFG.  */
+			if (e
+			    && single_pred_p (e->dest)
+			    && gimple_seq_empty_p (phi_nodes (e->dest))
+			    && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))
+			  {
+			    /* If there were PHI nodes in the node, we'd
+			       have to make sure the value we're binding
+			       doesn't need rewriting.  But there shouldn't
+			       be PHI nodes in a single-predecessor block,
+			       so we just add the note.  */
+			    gimple *note
+			      = gimple_build_debug_bind (tracked_var, def,
+							 stmt);
+			    gsi_insert_on_edge_immediate (ef, note);
+			  }
 		      }
-		  /* If there are other predecessors to ef->dest, then
-		     there must be PHI nodes for the modified
-		     variable, and therefore there will be debug bind
-		     stmts after the PHI nodes.  The debug bind notes
-		     we'd insert would force the creation of a new
-		     block (diverging codegen) and be redundant with
-		     the post-PHI bind stmts, so don't add them.
-
-		     As for the exit edge, there wouldn't be redundant
-		     bind stmts, but there wouldn't be a PC to bind
-		     them to either, so avoid diverging the CFG.  */
-		  if (ef && single_pred_p (ef->dest)
-		      && ef->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))
-		    {
-		      /* If there were PHI nodes in the node, we'd
-			 have to make sure the value we're binding
-			 doesn't need rewriting.  But there shouldn't
-			 be PHI nodes in a single-predecessor block,
-			 so we just add the note.  */
-		      gsi_insert_on_edge_immediate (ef, note);
-		    }
 		}
 	      else
-		gsi_insert_after (&gsi, note, GSI_SAME_STMT);
+		{
+		  gimple *note
+		    = gimple_build_debug_bind (tracked_var, def, stmt);
+		  gsi_insert_after (&gsi, note, GSI_SAME_STMT);
+		}
 	    }
 	}
 
diff --git a/gcc/tree-loop-distribution.c b/gcc/tree-loop-distribution.c
index 65aa1df4aba..947326ab1e7 100644
--- a/gcc/tree-loop-distribution.c
+++ b/gcc/tree-loop-distribution.c
@@ -1757,10 +1757,15 @@ loop_distribution::classify_builtin_ldst (loop_p loop, struct graph *rdg,
   if (res != 2)
     return;
 
-  /* They much have the same access size.  */
+  /* They must have the same access size.  */
   if (!operand_equal_p (size, src_size, 0))
     return;
 
+  /* They must have the same storage order.  */
+  if (reverse_storage_order_for_component_p (DR_REF (dst_dr))
+      != reverse_storage_order_for_component_p (DR_REF (src_dr)))
+    return;
+
   /* Load and store in loop nest must access memory in the same way, i.e,
      their must have the same steps in each loop of the nest.  */
   if (dst_steps.length () != src_steps.length ())
@@ -2158,8 +2163,6 @@ struct pg_edge_callback_data
   bitmap sccs_to_merge;
   /* Array constains component information for all vertices.  */
   int *vertices_component;
-  /* Array constains postorder information for all vertices.  */
-  int *vertices_post;
   /* Vector to record all data dependence relations which are needed
      to break strong connected components by runtime alias checks.  */
   vec<ddr_p> *alias_ddrs;
@@ -2409,6 +2412,33 @@ pg_collect_alias_ddrs (struct graph *g, struct graph_edge *e, void *data)
     cbdata->alias_ddrs->safe_splice (edata->alias_ddrs);
 }
 
+/* Callback function for traversing edge E.  DATA is private
+   callback data.  */
+
+static void
+pg_unmark_merged_alias_ddrs (struct graph *, struct graph_edge *e, void *data)
+{
+  int i, j, component;
+  struct pg_edge_callback_data *cbdata;
+  struct pg_edata *edata = (struct pg_edata *) e->data;
+
+  if (edata == NULL || edata->alias_ddrs.length () == 0)
+    return;
+
+  cbdata = (struct pg_edge_callback_data *) data;
+  i = e->src;
+  j = e->dest;
+  component = cbdata->vertices_component[i];
+  /* Make sure to not skip vertices inside SCCs we are going to merge.  */
+  if (component == cbdata->vertices_component[j]
+      && bitmap_bit_p (cbdata->sccs_to_merge, component))
+    {
+      edata->alias_ddrs.release ();
+      delete edata;
+      e->data = NULL;
+    }
+}
+
 /* This is the main function breaking strong conected components in
    PARTITIONS giving reduced depdendence graph RDG.  Store data dependence
    relations for runtime alias check in ALIAS_DDRS.  */
@@ -2468,7 +2498,6 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,
       cbdata.sccs_to_merge = sccs_to_merge;
       cbdata.alias_ddrs = alias_ddrs;
       cbdata.vertices_component = XNEWVEC (int, pg->n_vertices);
-      cbdata.vertices_post = XNEWVEC (int, pg->n_vertices);
       /* Record the component information which will be corrupted by next
 	 graph scc finding call.  */
       for (i = 0; i < pg->n_vertices; ++i)
@@ -2477,17 +2506,18 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,
       /* Collect data dependences for runtime alias checks to break SCCs.  */
       if (bitmap_count_bits (sccs_to_merge) != (unsigned) num_sccs)
 	{
-	  /* Record the postorder information which will be corrupted by next
-	     graph SCC finding call.  */
-	  for (i = 0; i < pg->n_vertices; ++i)
-	    cbdata.vertices_post[i] = pg->vertices[i].post;
+	  /* For SCCs we want to merge clear all alias_ddrs for edges
+	     inside the component.  */
+	  for_each_edge (pg, pg_unmark_merged_alias_ddrs, &cbdata);
 
 	  /* Run SCC finding algorithm again, with alias dependence edges
 	     skipped.  This is to topologically sort partitions according to
 	     compilation time known dependence.  Note the topological order
 	     is stored in the form of pg's post order number.  */
 	  num_sccs_no_alias = graphds_scc (pg, NULL, pg_skip_alias_edge);
-	  gcc_assert (partitions->length () == (unsigned) num_sccs_no_alias);
+	  /* We cannot assert partitions->length () == num_sccs_no_alias
+	     since we are not ignoring alias edges in cycles we are
+	     going to merge.  That's required to compute correct postorder.  */
 	  /* With topological order, we can construct two subgraphs L and R.
 	     L contains edge <x, y> where x < y in terms of post order, while
 	     R contains edge <x, y> where x > y.  Edges for compilation time
@@ -2522,16 +2552,14 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,
 	      first->type = PTYPE_SEQUENTIAL;
 	    }
 	}
-      /* Restore the postorder information if it's corrupted in finding SCC
-	 with alias dependence edges skipped.  If reduction partition's SCC is
-	 broken by runtime alias checks, we force a negative post order to it
-	 making sure it will be scheduled in the last.  */
+      /* If reduction partition's SCC is broken by runtime alias checks,
+	 we force a negative post order to it making sure it will be scheduled
+	 in the last.  */
       if (num_sccs_no_alias > 0)
 	{
 	  j = -1;
 	  for (i = 0; i < pg->n_vertices; ++i)
 	    {
-	      pg->vertices[i].post = cbdata.vertices_post[i];
 	      struct pg_vdata *data = (struct pg_vdata *)pg->vertices[i].data;
 	      if (data->partition && partition_reduction_p (data->partition))
 		{
@@ -2544,7 +2572,6 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,
 	}
 
       free (cbdata.vertices_component);
-      free (cbdata.vertices_post);
     }
 
   sort_partitions_by_post_order (pg, partitions);
diff --git a/gcc/tree-nested.c b/gcc/tree-nested.c
index 968431fa22a..c9b4c30ebdf 100644
--- a/gcc/tree-nested.c
+++ b/gcc/tree-nested.c
@@ -1559,29 +1559,29 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)
 	  break;
 
 	case OMP_CLAUSE_LASTPRIVATE:
-	  {
-	    tree save_local_var_chain = info->new_local_var_chain;
-	    info->new_local_var_chain = NULL;
-	    gimple_seq *seq = &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause);
-	    walk_body (convert_nonlocal_reference_stmt,
-		       convert_nonlocal_reference_op, info, seq);
-	    if (info->new_local_var_chain)
-	      declare_vars (info->new_local_var_chain,
-			    gimple_seq_first_stmt (*seq), false);
-	    info->new_local_var_chain = save_local_var_chain;
-	  }
-	  break;
-
 	case OMP_CLAUSE_LINEAR:
 	  {
 	    tree save_local_var_chain = info->new_local_var_chain;
 	    info->new_local_var_chain = NULL;
-	    gimple_seq *seq = &OMP_CLAUSE_LINEAR_GIMPLE_SEQ (clause);
+	    gimple_seq *seq;
+	    if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LASTPRIVATE)
+	      seq = &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (clause);
+	    else
+	      seq = &OMP_CLAUSE_LINEAR_GIMPLE_SEQ (clause);
 	    walk_body (convert_nonlocal_reference_stmt,
 		       convert_nonlocal_reference_op, info, seq);
 	    if (info->new_local_var_chain)
-	      declare_vars (info->new_local_var_chain,
-			    gimple_seq_first_stmt (*seq), false);
+	      {
+		gimple *g = gimple_seq_first_stmt (*seq);
+		if (gimple_code (g) != GIMPLE_BIND)
+		  {
+		    g = gimple_build_bind (NULL_TREE, *seq, NULL_TREE);
+		    *seq = NULL;
+		    gimple_seq_add_stmt_without_update (seq, g);
+		  }
+		declare_vars (info->new_local_var_chain,
+			      gimple_seq_first_stmt (*seq), false);
+	      }
 	    info->new_local_var_chain = save_local_var_chain;
 	  }
 	  break;
diff --git a/gcc/tree-predcom.c b/gcc/tree-predcom.c
index 0a7c1a936ba..64ab7ad0a80 100644
--- a/gcc/tree-predcom.c
+++ b/gcc/tree-predcom.c
@@ -1651,10 +1651,24 @@ ref_at_iteration (data_reference_p dr, int iter,
 	  ref = TREE_OPERAND (ref, 0);
 	}
     }
-  tree addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);
+  /* We may not associate the constant offset across the pointer plus
+     expression because that might form a pointer to before the object
+     then.  But for some cases we can retain that to allow tree_could_trap_p
+     to return false - see gcc.dg/tree-ssa/predcom-1.c  */
+  tree addr, alias_ptr;
+  if (integer_zerop  (off))
+    {
+      alias_ptr = fold_convert (reference_alias_ptr_type (ref), coff);
+      addr = DR_BASE_ADDRESS (dr);
+    }
+  else
+    {
+      alias_ptr = build_zero_cst (reference_alias_ptr_type (ref));
+      off = size_binop (PLUS_EXPR, off, coff);
+      addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);
+    }
   addr = force_gimple_operand_1 (unshare_expr (addr), stmts,
 				 is_gimple_mem_ref_addr, NULL_TREE);
-  tree alias_ptr = fold_convert (reference_alias_ptr_type (ref), coff);
   tree type = build_aligned_type (TREE_TYPE (ref),
 				  get_object_alignment (ref));
   ref = build2 (MEM_REF, type, addr, alias_ptr);
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 970ad386873..5a1fc81d301 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -1647,7 +1647,18 @@ build_ref_for_offset (location_t loc, tree base, poly_int64 offset,
 static tree
 build_reconstructed_reference (location_t, tree base, struct access *model)
 {
-  tree expr = model->expr, prev_expr = NULL;
+  tree expr = model->expr;
+  /* We have to make sure to start just below the outermost union.  */
+  tree start_expr = expr;
+  while (handled_component_p (expr))
+    {
+      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == UNION_TYPE)
+	start_expr = expr;
+      expr = TREE_OPERAND (expr, 0);
+    }
+
+  expr = start_expr;
+  tree prev_expr = NULL_TREE;
   while (!types_compatible_p (TREE_TYPE (expr), TREE_TYPE (base)))
     {
       if (!handled_component_p (expr))
@@ -3817,7 +3828,23 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)
 	    }
 	}
       else
-	*expr = repl;
+	{
+	  /* If we are going to replace a scalar field in a structure with
+	     reverse storage order by a stand-alone scalar, we are going to
+	     effectively byte-swap the scalar and we also need to byte-swap
+	     the portion of it represented by the bit-field.  */
+	  if (bfr && REF_REVERSE_STORAGE_ORDER (bfr))
+	    {
+	      REF_REVERSE_STORAGE_ORDER (bfr) = 0;
+	      TREE_OPERAND (bfr, 2)
+		= size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (repl)),
+			      size_binop (PLUS_EXPR, TREE_OPERAND (bfr, 1),
+						     TREE_OPERAND (bfr, 2)));
+	    }
+
+	  *expr = repl;
+	}
+
       sra_stats.exprs++;
     }
   else if (write && access->grp_to_be_debug_replaced)
diff --git a/gcc/tree-ssa-alias.c b/gcc/tree-ssa-alias.c
index 3e578e5d05f..c3f43dc8db2 100644
--- a/gcc/tree-ssa-alias.c
+++ b/gcc/tree-ssa-alias.c
@@ -1274,7 +1274,7 @@ aliasing_component_refs_p (tree ref1,
   /* If we didn't find a common base, try the other way around.  */
   if (cmp_outer <= 0 
       || (end_struct_ref1
-	  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type1) <= 0))
+	  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type2) <= 0))
     {
       int res = aliasing_component_refs_walk (ref2, type2, base2,
 					      offset2, max_size2,
diff --git a/gcc/tree-ssa-ccp.c b/gcc/tree-ssa-ccp.c
index aad8526eb21..93b5dbfa57f 100644
--- a/gcc/tree-ssa-ccp.c
+++ b/gcc/tree-ssa-ccp.c
@@ -1412,6 +1412,8 @@ bit_value_binop (enum tree_code code, signop sgn, int width,
 		  *mask = wi::lrotate (r1mask, shift, width);
 		  *val = wi::lrotate (r1val, shift, width);
 		}
+	      *mask = wi::ext (*mask, width, sgn);
+	      *val = wi::ext (*val, width, sgn);
 	    }
 	}
       break;
diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
index 4786dbd3849..735d88c5eb4 100644
--- a/gcc/tree-ssa-dom.c
+++ b/gcc/tree-ssa-dom.c
@@ -540,9 +540,9 @@ record_edge_info (basic_block bb)
             {
               tree cond = build2 (code, boolean_type_node, op0, op1);
               tree inverted = invert_truthvalue_loc (loc, cond);
-              bool can_infer_simple_equiv
-                = !(HONOR_SIGNED_ZEROS (op0)
-                    && real_zerop (op0));
+	      bool can_infer_simple_equiv
+		= !(HONOR_SIGNED_ZEROS (op0) && real_maybe_zerop (op0))
+		  && !DECIMAL_FLOAT_MODE_P (element_mode (TREE_TYPE (op0)));
 	      class edge_info *edge_info;
 
 	      edge_info = new class edge_info (true_edge);
@@ -564,9 +564,9 @@ record_edge_info (basic_block bb)
             {
               tree cond = build2 (code, boolean_type_node, op0, op1);
               tree inverted = invert_truthvalue_loc (loc, cond);
-              bool can_infer_simple_equiv
-                = !(HONOR_SIGNED_ZEROS (op1)
-                    && (TREE_CODE (op1) == SSA_NAME || real_zerop (op1)));
+	      bool can_infer_simple_equiv
+		= !(HONOR_SIGNED_ZEROS (op1) && real_maybe_zerop (op1))
+		  && !DECIMAL_FLOAT_MODE_P (element_mode (TREE_TYPE (op1)));
 	      class edge_info *edge_info;
 
 	      edge_info = new class edge_info (true_edge);
diff --git a/gcc/tree-ssa-loop-im.c b/gcc/tree-ssa-loop-im.c
index 8b1b1b2bede..8ee6c1aca12 100644
--- a/gcc/tree-ssa-loop-im.c
+++ b/gcc/tree-ssa-loop-im.c
@@ -2463,6 +2463,14 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,
       gcc_assert (data);
       if (data->ref == UNANALYZABLE_MEM_ID)
 	return -1;
+      /* Stop at memory references which we can't move.  */
+      else if (TREE_THIS_VOLATILE
+		 (memory_accesses.refs_list[data->ref]->mem.ref))
+	{
+	  /* Mark refs_not_in_seq as unsupported.  */
+	  bitmap_ior_into (refs_not_supported, refs_not_in_seq);
+	  return 1;
+	}
       /* One of the stores we want to apply SM to and we've not yet seen.  */
       else if (bitmap_clear_bit (refs_not_in_seq, data->ref))
 	{
diff --git a/gcc/tree-ssa-loop-ivopts.c b/gcc/tree-ssa-loop-ivopts.c
index 4012ae3f19d..459f0280cdc 100644
--- a/gcc/tree-ssa-loop-ivopts.c
+++ b/gcc/tree-ssa-loop-ivopts.c
@@ -131,6 +131,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "builtins.h"
 #include "tree-vectorizer.h"
 #include "dbgcnt.h"
+#include "cfganal.h"
 
 /* For lang_hooks.types.type_for_mode.  */
 #include "langhooks.h"
@@ -2125,8 +2126,10 @@ idx_record_use (tree base, tree *idx,
   find_interesting_uses_op (data, *idx);
   if (TREE_CODE (base) == ARRAY_REF || TREE_CODE (base) == ARRAY_RANGE_REF)
     {
-      find_interesting_uses_op (data, array_ref_element_size (base));
-      find_interesting_uses_op (data, array_ref_low_bound (base));
+      if (TREE_OPERAND (base, 2))
+	find_interesting_uses_op (data, TREE_OPERAND (base, 2));
+      if (TREE_OPERAND (base, 3))
+	find_interesting_uses_op (data, TREE_OPERAND (base, 3));
     }
   return true;
 }
@@ -7107,6 +7110,12 @@ create_new_iv (struct ivopts_data *data, struct iv_cand *cand)
     case IP_END:
       incr_pos = gsi_last_bb (ip_end_pos (data->current_loop));
       after = true;
+      if (!gsi_end_p (incr_pos) && stmt_ends_bb_p (gsi_stmt (incr_pos)))
+	{
+	  edge e = find_edge (gsi_bb (incr_pos), data->current_loop->header);
+	  incr_pos = gsi_after_labels (split_edge (e));
+	  after = false;
+	}
       break;
 
     case IP_AFTER_USE:
diff --git a/gcc/tree-ssa-math-opts.c b/gcc/tree-ssa-math-opts.c
index 94f9cc4d6b6..adeb70fd635 100644
--- a/gcc/tree-ssa-math-opts.c
+++ b/gcc/tree-ssa-math-opts.c
@@ -1459,7 +1459,7 @@ powi_cost (HOST_WIDE_INT n)
     return 0;
 
   /* Ignore the reciprocal when calculating the cost.  */
-  val = (n < 0) ? -n : n;
+  val = absu_hwi (n);
 
   /* Initialize the exponent cache.  */
   memset (cache, 0, POWI_TABLE_SIZE * sizeof (bool));
@@ -1492,7 +1492,7 @@ powi_cost (HOST_WIDE_INT n)
 
 static tree
 powi_as_mults_1 (gimple_stmt_iterator *gsi, location_t loc, tree type,
-		 HOST_WIDE_INT n, tree *cache)
+		 unsigned HOST_WIDE_INT n, tree *cache)
 {
   tree op0, op1, ssa_target;
   unsigned HOST_WIDE_INT digit;
@@ -1545,7 +1545,7 @@ powi_as_mults (gimple_stmt_iterator *gsi, location_t loc,
   memset (cache, 0, sizeof (cache));
   cache[1] = arg0;
 
-  result = powi_as_mults_1 (gsi, loc, type, (n < 0) ? -n : n, cache);
+  result = powi_as_mults_1 (gsi, loc, type, absu_hwi (n), cache);
   if (n >= 0)
     return result;
 
@@ -1569,11 +1569,9 @@ static tree
 gimple_expand_builtin_powi (gimple_stmt_iterator *gsi, location_t loc, 
 			    tree arg0, HOST_WIDE_INT n)
 {
-  /* Avoid largest negative number.  */
-  if (n != -n
-      && ((n >= -1 && n <= 2)
-	  || (optimize_function_for_speed_p (cfun)
-	      && powi_cost (n) <= POWI_MAX_MULTS)))
+  if ((n >= -1 && n <= 2)
+      || (optimize_function_for_speed_p (cfun)
+	  && powi_cost (n) <= POWI_MAX_MULTS))
     return powi_as_mults (gsi, loc, arg0, n);
 
   return NULL_TREE;
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
index 32e1632705b..1cf577af880 100644
--- a/gcc/tree-ssa-reassoc.c
+++ b/gcc/tree-ssa-reassoc.c
@@ -1520,6 +1520,15 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)
       && (!op2def || gimple_nop_p (op2def)))
     {
       gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));
+      if (!gsi_end_p (gsi)
+	  && is_gimple_call (gsi_stmt (gsi))
+	  && (gimple_call_flags (gsi_stmt (gsi)) & ECF_RETURNS_TWICE))
+	{
+	  /* Don't add statements before a returns_twice call at the start
+	     of a function.  */
+	  split_edge (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));
+	  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));
+	}
       if (gsi_end_p (gsi))
 	{
 	  gimple_stmt_iterator gsi2
@@ -5054,17 +5063,26 @@ swap_ops_for_binary_stmt (vec<operand_entry *> ops,
 }
 
 /* If definition of RHS1 or RHS2 dominates STMT, return the later of those
-   two definitions, otherwise return STMT.  */
+   two definitions, otherwise return STMT.  Sets INSERT_BEFORE to indicate
+   whether RHS1 op RHS2 can be inserted before or needs to be inserted
+   after the returned stmt.  */
 
 static inline gimple *
-find_insert_point (gimple *stmt, tree rhs1, tree rhs2)
+find_insert_point (gimple *stmt, tree rhs1, tree rhs2, bool &insert_before)
 {
+  insert_before = true;
   if (TREE_CODE (rhs1) == SSA_NAME
       && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs1)))
-    stmt = SSA_NAME_DEF_STMT (rhs1);
+    {
+      stmt = SSA_NAME_DEF_STMT (rhs1);
+      insert_before = false;
+    }
   if (TREE_CODE (rhs2) == SSA_NAME
       && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs2)))
-    stmt = SSA_NAME_DEF_STMT (rhs2);
+    {
+      stmt = SSA_NAME_DEF_STMT (rhs2);
+      insert_before = false;
+    }
   return stmt;
 }
 
@@ -5076,7 +5094,8 @@ insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)
   gcc_assert (is_gimple_assign (stmt_to_insert));
   tree rhs1 = gimple_assign_rhs1 (stmt_to_insert);
   tree rhs2 = gimple_assign_rhs2 (stmt_to_insert);
-  gimple *insert_point = find_insert_point (stmt, rhs1, rhs2);
+  bool insert_before;
+  gimple *insert_point = find_insert_point (stmt, rhs1, rhs2, insert_before);
   gimple_stmt_iterator gsi = gsi_for_stmt (insert_point);
   gimple_set_uid (stmt_to_insert, gimple_uid (insert_point));
 
@@ -5084,7 +5103,7 @@ insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)
      the point where operand rhs1 or rhs2 is defined. In this case,
      stmt_to_insert has to be inserted afterwards. This would
      only happen when the stmt insertion point is flexible. */
-  if (stmt == insert_point)
+  if (insert_before)
     gsi_insert_before (&gsi, stmt_to_insert, GSI_NEW_STMT);
   else
     insert_stmt_after (stmt_to_insert, insert_point);
@@ -5143,22 +5162,25 @@ rewrite_expr_tree (gimple *stmt, enum tree_code rhs_code, unsigned int opindex,
 	     return lhs), force creation of a new SSA_NAME.  */
 	  if (changed || ((rhs1 != oe2->op || rhs2 != oe1->op) && opindex))
 	    {
+	      bool insert_before;
 	      gimple *insert_point
-		= find_insert_point (stmt, oe1->op, oe2->op);
+		= find_insert_point (stmt, oe1->op, oe2->op, insert_before);
 	      lhs = make_ssa_name (TREE_TYPE (lhs));
 	      stmt
 		= gimple_build_assign (lhs, rhs_code,
 				       oe1->op, oe2->op);
 	      gimple_set_uid (stmt, uid);
 	      gimple_set_visited (stmt, true);
-	      if (insert_point == gsi_stmt (gsi))
+	      if (insert_before)
 		gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
 	      else
 		insert_stmt_after (stmt, insert_point);
 	    }
 	  else
 	    {
-	      gcc_checking_assert (find_insert_point (stmt, oe1->op, oe2->op)
+	      bool insert_before;
+	      gcc_checking_assert (find_insert_point (stmt, oe1->op, oe2->op,
+						      insert_before)
 				   == stmt);
 	      gimple_assign_set_rhs1 (stmt, oe1->op);
 	      gimple_assign_set_rhs2 (stmt, oe2->op);
@@ -5214,21 +5236,25 @@ rewrite_expr_tree (gimple *stmt, enum tree_code rhs_code, unsigned int opindex,
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);
 	  unsigned int uid = gimple_uid (stmt);
-	  gimple *insert_point = find_insert_point (stmt, new_rhs1, oe->op);
+	  bool insert_before;
+	  gimple *insert_point = find_insert_point (stmt, new_rhs1, oe->op,
+						    insert_before);
 
 	  lhs = make_ssa_name (TREE_TYPE (lhs));
 	  stmt = gimple_build_assign (lhs, rhs_code,
 				      new_rhs1, oe->op);
 	  gimple_set_uid (stmt, uid);
 	  gimple_set_visited (stmt, true);
-	  if (insert_point == gsi_stmt (gsi))
+	  if (insert_before)
 	    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
 	  else
 	    insert_stmt_after (stmt, insert_point);
 	}
       else
 	{
-	  gcc_checking_assert (find_insert_point (stmt, new_rhs1, oe->op)
+	  bool insert_before;
+	  gcc_checking_assert (find_insert_point (stmt, new_rhs1, oe->op,
+						  insert_before)
 			       == stmt);
 	  gimple_assign_set_rhs1 (stmt, new_rhs1);
 	  gimple_assign_set_rhs2 (stmt, oe->op);
@@ -5708,7 +5734,9 @@ try_special_add_to_ops (vec<operand_entry *> *ops,
 	   && gimple_assign_rhs_code (def_stmt) == NEGATE_EXPR
 	   && !HONOR_SNANS (TREE_TYPE (op))
 	   && (!HONOR_SIGNED_ZEROS (TREE_TYPE (op))
-	       || !COMPLEX_FLOAT_TYPE_P (TREE_TYPE (op))))
+	       || !COMPLEX_FLOAT_TYPE_P (TREE_TYPE (op)))
+	   && (!FLOAT_TYPE_P (TREE_TYPE (op))
+	       || !DECIMAL_FLOAT_MODE_P (element_mode (op))))
     {
       tree rhs1 = gimple_assign_rhs1 (def_stmt);
       tree cst = build_minus_one_cst (TREE_TYPE (op));
@@ -5838,10 +5866,14 @@ repropagate_negates (void)
   FOR_EACH_VEC_ELT (plus_negates, i, negate)
     {
       gimple *user = get_single_immediate_use (negate);
-
       if (!user || !is_gimple_assign (user))
 	continue;
 
+      tree negateop = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (negate));
+      if (TREE_CODE (negateop) == SSA_NAME
+	  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (negateop))
+	continue;
+
       /* The negate operand can be either operand of a PLUS_EXPR
 	 (it can be the LHS if the RHS is a constant for example).
 
@@ -5864,9 +5896,9 @@ repropagate_negates (void)
 	  if (gimple_assign_rhs2 (user) == negate)
 	    {
 	      tree rhs1 = gimple_assign_rhs1 (user);
-	      tree rhs2 = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (negate));
 	      gimple_stmt_iterator gsi = gsi_for_stmt (user);
-	      gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, rhs1, rhs2);
+	      gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, rhs1,
+					      negateop);
 	      update_stmt (user);
 	    }
 	}
@@ -5875,21 +5907,20 @@ repropagate_negates (void)
 	  if (gimple_assign_rhs1 (user) == negate)
 	    {
 	      /* We have
-	           x = -a
+		   x = -negateop
 		   y = x - b
 		 which we transform into
-		   x = a + b
+		   x = negateop + b
 		   y = -x .
 		 This pushes down the negate which we possibly can merge
 		 into some other operation, hence insert it into the
 		 plus_negates vector.  */
 	      gimple *feed = SSA_NAME_DEF_STMT (negate);
-	      tree a = gimple_assign_rhs1 (feed);
 	      tree b = gimple_assign_rhs2 (user);
 	      gimple_stmt_iterator gsi = gsi_for_stmt (feed);
 	      gimple_stmt_iterator gsi2 = gsi_for_stmt (user);
 	      tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)));
-	      gimple *g = gimple_build_assign (x, PLUS_EXPR, a, b);
+	      gimple *g = gimple_build_assign (x, PLUS_EXPR, negateop, b);
 	      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);
 	      gimple_assign_set_rhs_with_ops (&gsi2, NEGATE_EXPR, x);
 	      user = gsi_stmt (gsi2);
@@ -5900,13 +5931,11 @@ repropagate_negates (void)
 	    }
 	  else
 	    {
-	      /* Transform "x = -a; y = b - x" into "y = b + a", getting
-	         rid of one operation.  */
-	      gimple *feed = SSA_NAME_DEF_STMT (negate);
-	      tree a = gimple_assign_rhs1 (feed);
+	      /* Transform "x = -negateop; y = b - x" into "y = b + negateop",
+		 getting rid of one operation.  */
 	      tree rhs1 = gimple_assign_rhs1 (user);
 	      gimple_stmt_iterator gsi = gsi_for_stmt (user);
-	      gimple_assign_set_rhs_with_ops (&gsi, PLUS_EXPR, rhs1, a);
+	      gimple_assign_set_rhs_with_ops (&gsi, PLUS_EXPR, rhs1, negateop);
 	      update_stmt (gsi_stmt (gsi));
 	    }
 	}
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
index eaa97566d35..ec5d7cac7f8 100644
--- a/gcc/tree-ssa-sccvn.c
+++ b/gcc/tree-ssa-sccvn.c
@@ -3197,12 +3197,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       poly_int64 extra_off = 0;
       if (j == 0 && i >= 0
 	  && lhs_ops[0].opcode == MEM_REF
-	  && maybe_ne (lhs_ops[0].off, -1))
+	  && known_ne (lhs_ops[0].off, -1))
 	{
 	  if (known_eq (lhs_ops[0].off, vr->operands[i].off))
 	    i--, j--;
 	  else if (vr->operands[i].opcode == MEM_REF
-		   && maybe_ne (vr->operands[i].off, -1))
+		   && known_ne (vr->operands[i].off, -1))
 	    {
 	      extra_off = vr->operands[i].off - lhs_ops[0].off;
 	      i--, j--;
@@ -3229,6 +3229,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       copy_reference_ops_from_ref (rhs1, &rhs);
 
       /* Apply an extra offset to the inner MEM_REF of the RHS.  */
+      bool force_no_tbaa = false;
       if (maybe_ne (extra_off, 0))
 	{
 	  if (rhs.length () < 2)
@@ -3241,6 +3242,10 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
 	  rhs[ix].op0 = int_const_binop (PLUS_EXPR, rhs[ix].op0,
 					 build_int_cst (TREE_TYPE (rhs[ix].op0),
 							extra_off));
+	  /* When we have offsetted the RHS, reading only parts of it,
+	     we can no longer use the original TBAA type, force alias-set
+	     zero.  */
+	  force_no_tbaa = true;
 	}
 
       /* Save the operands since we need to use the original ones for
@@ -3293,8 +3298,11 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
       /* Adjust *ref from the new operands.  */
       ao_ref rhs1_ref;
       ao_ref_init (&rhs1_ref, rhs1);
-      if (!ao_ref_init_from_vn_reference (&r, ao_ref_alias_set (&rhs1_ref),
-					  ao_ref_base_alias_set (&rhs1_ref),
+      if (!ao_ref_init_from_vn_reference (&r,
+					  force_no_tbaa ? 0
+					  : ao_ref_alias_set (&rhs1_ref),
+					  force_no_tbaa ? 0
+					  : ao_ref_base_alias_set (&rhs1_ref),
 					  vr->type, vr->operands))
 	return (void *)-1;
       /* This can happen with bitfields.  */
@@ -4586,41 +4594,44 @@ dominated_by_p_w_unex (basic_block bb1, basic_block bb2, bool allow_back)
     }
 
   /* Iterate to the single executable bb2 successor.  */
-  edge succe = NULL;
-  FOR_EACH_EDGE (e, ei, bb2->succs)
-    if ((e->flags & EDGE_EXECUTABLE)
-	|| (!allow_back && (e->flags & EDGE_DFS_BACK)))
-      {
-	if (succe)
-	  {
-	    succe = NULL;
-	    break;
-	  }
-	succe = e;
-      }
-  if (succe)
+  if (EDGE_COUNT (bb2->succs) > 1)
     {
-      /* Verify the reached block is only reached through succe.
-	 If there is only one edge we can spare us the dominator
-	 check and iterate directly.  */
-      if (EDGE_COUNT (succe->dest->preds) > 1)
-	{
-	  FOR_EACH_EDGE (e, ei, succe->dest->preds)
-	    if (e != succe
-		&& ((e->flags & EDGE_EXECUTABLE)
-		    || (!allow_back && (e->flags & EDGE_DFS_BACK))))
+      edge succe = NULL;
+      FOR_EACH_EDGE (e, ei, bb2->succs)
+	if ((e->flags & EDGE_EXECUTABLE)
+	    || (!allow_back && (e->flags & EDGE_DFS_BACK)))
+	  {
+	    if (succe)
 	      {
 		succe = NULL;
 		break;
 	      }
-	}
+	    succe = e;
+	  }
       if (succe)
 	{
-	  bb2 = succe->dest;
+	  /* Verify the reached block is only reached through succe.
+	     If there is only one edge we can spare us the dominator
+	     check and iterate directly.  */
+	  if (EDGE_COUNT (succe->dest->preds) > 1)
+	    {
+	      FOR_EACH_EDGE (e, ei, succe->dest->preds)
+		if (e != succe
+		    && ((e->flags & EDGE_EXECUTABLE)
+			|| (!allow_back && (e->flags & EDGE_DFS_BACK))))
+		  {
+		    succe = NULL;
+		    break;
+		  }
+	    }
+	  if (succe)
+	    {
+	      bb2 = succe->dest;
 
-	  /* Re-do the dominance check with changed bb2.  */
-	  if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))
-	    return true;
+	      /* Re-do the dominance check with changed bb2.  */
+	      if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))
+		return true;
+	    }
 	}
     }
 
@@ -4843,7 +4854,7 @@ valueized_wider_op (tree wide_type, tree op, bool allow_truncate)
 
   /* For constants simply extend it.  */
   if (TREE_CODE (op) == INTEGER_CST)
-    return wide_int_to_tree (wide_type, wi::to_wide (op));
+    return wide_int_to_tree (wide_type, wi::to_widest (op));
 
   return NULL_TREE;
 }
@@ -5239,19 +5250,6 @@ visit_reference_op_store (tree lhs, tree op, gimple *stmt)
 
   if (!resultsame)
     {
-      /* Only perform the following when being called from PRE
-	 which embeds tail merging.  */
-      if (default_vn_walk_kind == VN_WALK)
-	{
-	  assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);
-	  vn_reference_lookup (assign, vuse, VN_NOWALK, &vnresult, false);
-	  if (vnresult)
-	    {
-	      VN_INFO (vdef)->visited = true;
-	      return set_ssa_val_to (vdef, vnresult->result_vdef);
-	    }
-	}
-
       if (dump_file && (dump_flags & TDF_DETAILS))
 	{
 	  fprintf (dump_file, "No store match\n");
@@ -5276,7 +5274,9 @@ visit_reference_op_store (tree lhs, tree op, gimple *stmt)
       if (default_vn_walk_kind == VN_WALK)
 	{
 	  assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);
-	  vn_reference_insert (assign, lhs, vuse, vdef);
+	  vn_reference_lookup (assign, vuse, VN_NOWALK, &vnresult, false);
+	  if (!vnresult)
+	    vn_reference_insert (assign, lhs, vuse, vdef);
 	}
     }
   else
@@ -5789,6 +5789,13 @@ expressions_equal_p (tree e1, tree e2)
   if (e1 == VN_TOP || e2 == VN_TOP)
     return true;
 
+  /* If only one of them is null, they cannot be equal.  While in general
+     this should not happen for operations like TARGET_MEM_REF some
+     operands are optional and an identity value we could substitute
+     has differing semantics.  */
+  if (!e1 || !e2)
+    return false;
+
   /* SSA_NAME compare pointer equal.  */
   if (TREE_CODE (e1) == SSA_NAME || TREE_CODE (e2) == SSA_NAME)
     return false;
diff --git a/gcc/tree-ssa-sink.c b/gcc/tree-ssa-sink.c
index 3c2ed795f85..b3097531203 100644
--- a/gcc/tree-ssa-sink.c
+++ b/gcc/tree-ssa-sink.c
@@ -390,6 +390,9 @@ statement_sink_location (gimple *stmt, basic_block frombb,
 		 with the use.  */
 	      if (gimple_code (use_stmt) == GIMPLE_PHI)
 		{
+		  /* If the PHI defines the virtual operand, ignore it.  */
+		  if (gimple_phi_result (use_stmt) == gimple_vuse (stmt))
+		    continue;
 		  /* In case the PHI node post-dominates the current insert
 		     location we can disregard it.  But make sure it is not
 		     dominating it as well as can happen in a CFG cycle.  */
diff --git a/gcc/tree-ssa-strlen.c b/gcc/tree-ssa-strlen.c
index cccd4a06771..cfffc220073 100644
--- a/gcc/tree-ssa-strlen.c
+++ b/gcc/tree-ssa-strlen.c
@@ -3231,7 +3231,8 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,
       && !integer_zerop (len))
     {
       maybe_warn_overflow (stmt, len, ptr_qry, olddsi, false, true);
-      adjust_last_stmt (olddsi, stmt, false, ptr_qry);
+      if (tree_fits_uhwi_p (len))
+	adjust_last_stmt (olddsi, stmt, false, ptr_qry);
     }
 
   int idx = get_stridx (src);
@@ -4523,7 +4524,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,
 
   /* Compute the number of leading nonzero bytes in the representation
      and update the minimum and maximum.  */
-  unsigned n = prep ? strnlen (prep, nbytes) : nbytes;
+  unsigned HOST_WIDE_INT n = prep ? strnlen (prep, nbytes) : nbytes;
 
   if (n < lenrange[0])
     lenrange[0] = n;
diff --git a/gcc/tree-ssa.c b/gcc/tree-ssa.c
index 28a7f4f02c9..41959ca03f8 100644
--- a/gcc/tree-ssa.c
+++ b/gcc/tree-ssa.c
@@ -1416,6 +1416,8 @@ maybe_rewrite_mem_ref_base (tree *tp, bitmap suitable_for_renaming)
 	       && (! INTEGRAL_TYPE_P (TREE_TYPE (*tp)) 
 		   || (wi::to_offset (TYPE_SIZE (TREE_TYPE (*tp)))
 		       == TYPE_PRECISION (TREE_TYPE (*tp))))
+	       && (! INTEGRAL_TYPE_P (TREE_TYPE (sym))
+		   || type_has_mode_precision_p (TREE_TYPE (sym)))
 	       && wi::umod_trunc (wi::to_offset (TYPE_SIZE (TREE_TYPE (*tp))),
 				  BITS_PER_UNIT) == 0)
 	{
@@ -1488,6 +1490,10 @@ non_rewritable_mem_ref_base (tree ref)
 	  && (! INTEGRAL_TYPE_P (TREE_TYPE (base))
 	      || (wi::to_offset (TYPE_SIZE (TREE_TYPE (base)))
 		  == TYPE_PRECISION (TREE_TYPE (base))))
+	  /* ???  Likewise for extracts from bitfields, we'd have
+	     to pun the base object to a size precision mode first.  */
+	  && (! INTEGRAL_TYPE_P (TREE_TYPE (decl))
+	      || type_has_mode_precision_p (TREE_TYPE (decl)))
 	  && wi::umod_trunc (wi::to_offset (TYPE_SIZE (TREE_TYPE (base))),
 			     BITS_PER_UNIT) == 0)
 	return NULL_TREE;
diff --git a/gcc/tree-vect-generic.c b/gcc/tree-vect-generic.c
index 0828ff97569..27c09ac38d6 100644
--- a/gcc/tree-vect-generic.c
+++ b/gcc/tree-vect-generic.c
@@ -1007,6 +1007,15 @@ expand_vector_condition (gimple_stmt_iterator *gsi, bitmap dce_ssa_names)
       return true;
     }
 
+  /* If a has vector boolean type and is a comparison, above
+     expand_vec_cond_expr_p might fail, even if both the comparison and
+     VEC_COND_EXPR could be supported individually.  See PR109176.  */
+  if (a_is_comparison
+      && VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (a))
+      && expand_vec_cond_expr_p (type, TREE_TYPE (a), SSA_NAME)
+      && expand_vec_cmp_expr_p (TREE_TYPE (a1), TREE_TYPE (a), code))
+    return true;
+
   /* Handle vector boolean types with bitmasks.  If there is a comparison
      and we can expand the comparison into the vector boolean bitmask,
      or otherwise if it is compatible with type, we can transform
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 968087a9008..2f2346a366e 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -4730,10 +4730,14 @@ get_initial_def_for_reduction (loop_vec_info loop_vinfo,
         else
           def_for_init = build_int_cst (scalar_type, int_init_val);
 
-	if (adjustment_def || operand_equal_p (def_for_init, init_val, 0))
+	bool same_p = operand_equal_p (def_for_init, init_val, 0);
+	init_val = gimple_convert (&stmts, TREE_TYPE (vectype), init_val);
+	def_for_init = gimple_convert (&stmts, TREE_TYPE (vectype), def_for_init);
+
+	if (adjustment_def || same_p)
 	  {
 	    /* Option1: the first element is '0' or '1' as well.  */
-	    if (!operand_equal_p (def_for_init, init_val, 0))
+	    if (!same_p)
 	      *adjustment_def = init_val;
 	    init_def = gimple_build_vector_from_val (&stmts, vectype,
 						     def_for_init);
@@ -5945,9 +5949,12 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,
 	{
           new_temp = scalar_results[0];
 	  gcc_assert (TREE_CODE (TREE_TYPE (adjustment_def)) != VECTOR_TYPE);
-	  adjustment_def = gimple_convert (&stmts, scalar_type, adjustment_def);
-	  new_temp = gimple_build (&stmts, code, scalar_type,
+	  adjustment_def = gimple_convert (&stmts, TREE_TYPE (vectype),
+					   adjustment_def);
+	  new_temp = gimple_convert (&stmts, TREE_TYPE (vectype), new_temp);
+	  new_temp = gimple_build (&stmts, code, TREE_TYPE (vectype),
 				   new_temp, adjustment_def);
+	  new_temp = gimple_convert (&stmts, scalar_type, new_temp);
 	}
 
       epilog_stmt = gimple_seq_last_stmt (stmts);
@@ -6476,6 +6483,7 @@ vectorizable_reduction (loop_vec_info loop_vinfo,
 {
   tree scalar_dest;
   tree vectype_in = NULL_TREE;
+  tree vectype_op[3] = { NULL_TREE, NULL_TREE, NULL_TREE };
   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);
   enum vect_def_type cond_reduc_dt = vect_unknown_def_type;
   stmt_vec_info cond_stmt_vinfo = NULL;
@@ -6486,7 +6494,6 @@ vectorizable_reduction (loop_vec_info loop_vinfo,
   bool nested_cycle = false;
   bool double_reduc = false;
   int vec_num;
-  tree tem;
   tree cr_index_scalar_type = NULL_TREE, cr_index_vector_type = NULL_TREE;
   tree cond_reduc_val = NULL_TREE;
 
@@ -6589,10 +6596,20 @@ vectorizable_reduction (loop_vec_info loop_vinfo,
 	}
       if (!REDUC_GROUP_FIRST_ELEMENT (vdef))
 	only_slp_reduc_chain = false;
-      /* ???  For epilogue generation live members of the chain need
+      /* For epilogue generation live members of the chain need
          to point back to the PHI via their original stmt for
-	 info_for_reduction to work.  */
-      if (STMT_VINFO_LIVE_P (vdef))
+	 info_for_reduction to work.  For SLP we need to look at
+	 all lanes here - even though we only will vectorize from
+	 the SLP node with live lane zero the other live lanes also
+	 need to be identified as part of a reduction to be able
+	 to skip code generation for them.  */
+      if (slp_for_stmt_info)
+	{
+	  for (auto s : SLP_TREE_SCALAR_STMTS (slp_for_stmt_info))
+	    if (STMT_VINFO_LIVE_P (s))
+	      STMT_VINFO_REDUC_DEF (vect_orig_stmt (s)) = phi_info;
+	}
+      else if (STMT_VINFO_LIVE_P (vdef))
 	STMT_VINFO_REDUC_DEF (def) = phi_info;
       gassign *assign = dyn_cast <gassign *> (vdef->stmt);
       if (!assign)
@@ -6723,8 +6740,8 @@ vectorizable_reduction (loop_vec_info loop_vinfo,
       enum vect_def_type dt;
       tree op;
       if (!vect_is_simple_use (loop_vinfo, stmt_info, slp_for_stmt_info,
-			       i + opno_adjust, &op, &slp_op[i], &dt, &tem,
-			       &def_stmt_info))
+			       i + opno_adjust, &op, &slp_op[i], &dt,
+			       &vectype_op[i], &def_stmt_info))
 	{
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
@@ -6739,15 +6756,20 @@ vectorizable_reduction (loop_vec_info loop_vinfo,
       if (VECTORIZABLE_CYCLE_DEF (dt))
 	return false;
 
+      if (!vectype_op[i])
+	vectype_op[i]
+	  = get_vectype_for_scalar_type (loop_vinfo,
+					 TREE_TYPE (op), slp_op[i]);
+
       /* To properly compute ncopies we are interested in the widest
 	 non-reduction input type in case we're looking at a widening
 	 accumulation that we later handle in vect_transform_reduction.  */
       if (lane_reduc_code_p
-	  && tem
+	  && vectype_op[i]
 	  && (!vectype_in
 	      || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))
-		  < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (tem))))))
-	vectype_in = tem;
+		  < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_op[i]))))))
+	vectype_in = vectype_op[i];
 
       if (code == COND_EXPR)
 	{
@@ -7270,7 +7292,7 @@ vectorizable_reduction (loop_vec_info loop_vinfo,
 	   && code != SAD_EXPR
 	   && reduction_type != FOLD_LEFT_REDUCTION))
     for (i = 0; i < op_type; i++)
-      if (!vect_maybe_update_slp_op_vectype (slp_op[i], vectype_in))
+      if (!vect_maybe_update_slp_op_vectype (slp_op[i], vectype_op[i]))
 	{
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
@@ -8578,10 +8600,6 @@ vectorizable_live_operation (vec_info *vinfo,
 	     all involved stmts together.  */
 	  else if (slp_index != 0)
 	    return true;
-	  else
-	    /* For SLP reductions the meta-info is attached to
-	       the representative.  */
-	    stmt_info = SLP_TREE_REPRESENTATIVE (slp_node);
 	}
       stmt_vec_info reduc_info = info_for_reduction (loop_vinfo, stmt_info);
       gcc_assert (reduc_info->is_reduc_info);
@@ -8864,9 +8882,10 @@ vectorizable_live_operation (vec_info *vinfo,
 						use_stmt))
 	      {
 		enum tree_code code = gimple_assign_rhs_code (use_stmt);
-		gcc_assert (code == CONSTRUCTOR
-			    || code == VIEW_CONVERT_EXPR
-			    || CONVERT_EXPR_CODE_P (code));
+		gcc_checking_assert (code == SSA_NAME
+				     || code == CONSTRUCTOR
+				     || code == VIEW_CONVERT_EXPR
+				     || CONVERT_EXPR_CODE_P (code));
 		if (dump_enabled_p ())
 		  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
 				   "Using original scalar computation for "
diff --git a/gcc/tree-vect-patterns.c b/gcc/tree-vect-patterns.c
index f6e8c3c8575..01bcea9dca2 100644
--- a/gcc/tree-vect-patterns.c
+++ b/gcc/tree-vect-patterns.c
@@ -579,7 +579,25 @@ vect_widened_op_tree (vec_info *vinfo, stmt_vec_info stmt_info, tree_code code,
 	  if (shift_p && i == 1)
 	    return 0;
 
-	  if (!vect_look_through_possible_promotion (vinfo, op, this_unprom))
+	  if (rhs_code != code)
+	    {
+	      /* If rhs_code is widened_code, don't look through further
+		 possible promotions, there is a promotion already embedded
+		 in the WIDEN_*_EXPR.  */
+	      if (TREE_CODE (op) != SSA_NAME
+		  || !INTEGRAL_TYPE_P (TREE_TYPE (op)))
+		return 0;
+
+	      stmt_vec_info def_stmt_info;
+	      gimple *def_stmt;
+	      vect_def_type dt;
+	      if (!vect_is_simple_use (op, vinfo, &dt, &def_stmt_info,
+				       &def_stmt))
+		return 0;
+	      this_unprom->set_op (op, dt, NULL);
+	    }
+	  else if (!vect_look_through_possible_promotion (vinfo, op,
+							  this_unprom))
 	    return 0;
 
 	  if (TYPE_PRECISION (this_unprom->type) == TYPE_PRECISION (type))
@@ -1519,7 +1537,9 @@ vect_recog_widen_sum_pattern (vec_info *vinfo,
      of the above pattern.  */
 
   if (!vect_reassociating_reduction_p (vinfo, stmt_vinfo, PLUS_EXPR,
-				       &oprnd0, &oprnd1))
+				       &oprnd0, &oprnd1)
+      || TREE_CODE (oprnd0) != SSA_NAME
+      || !vinfo->lookup_def (oprnd0))
     return NULL;
 
   type = gimple_expr_type (last_stmt);
diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
index 7289656db0f..7c75799f625 100644
--- a/gcc/tree-vect-slp.c
+++ b/gcc/tree-vect-slp.c
@@ -3824,7 +3824,23 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,
 
   /* Handle purely internal nodes.  */
   if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)
-    return vectorizable_slp_permutation (vinfo, NULL, node, cost_vec);
+    {
+      if (!vectorizable_slp_permutation (vinfo, NULL, node, cost_vec))
+	return false;
+
+      stmt_vec_info slp_stmt_info;
+      unsigned int i;
+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, slp_stmt_info)
+	{
+	  if (STMT_VINFO_LIVE_P (slp_stmt_info)
+	      && !vectorizable_live_operation (vinfo,
+					       slp_stmt_info, NULL, node,
+					       node_instance, i,
+					       false, cost_vec))
+	    return false;
+	}
+      return true;
+    }
 
   gcc_assert (STMT_SLP_TYPE (stmt_info) != loop_vect);
   if (is_a <bb_vec_info> (vinfo)
@@ -6319,6 +6335,13 @@ vect_schedule_slp_node (vec_info *vinfo,
 	  gcc_assert (seen_vector_def);
 	  si = gsi_after_labels (as_a <bb_vec_info> (vinfo)->bbs[0]);
 	}
+      else if (is_ctrl_altering_stmt (last_stmt))
+	{
+	  /* We split regions to vectorize at control altering stmts
+	     with a definition so this must be an external which
+	     we can insert at the start of the region.  */
+	  si = gsi_after_labels (as_a <bb_vec_info> (vinfo)->bbs[0]);
+	}
       else if (is_a <bb_vec_info> (vinfo)
 	       && gimple_bb (last_stmt) != gimple_bb (stmt_info->stmt)
 	       && gimple_could_trap_p (stmt_info->stmt))
@@ -6343,8 +6366,6 @@ vect_schedule_slp_node (vec_info *vinfo,
 	}
     }
 
-  bool done_p = false;
-
   /* Handle purely internal nodes.  */
   if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)
     {
@@ -6355,9 +6376,18 @@ vect_schedule_slp_node (vec_info *vinfo,
 	 but open-code it here (partly).  */
       bool done = vectorizable_slp_permutation (vinfo, &si, node, NULL);
       gcc_assert (done);
-      done_p = true;
+      stmt_vec_info slp_stmt_info;
+      unsigned int i;
+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, slp_stmt_info)
+	if (STMT_VINFO_LIVE_P (slp_stmt_info))
+	  {
+	    done = vectorizable_live_operation (vinfo,
+						slp_stmt_info, &si, node,
+						instance, i, true, NULL);
+	    gcc_assert (done);
+	  }
     }
-  if (!done_p)
+  else
     vect_transform_stmt (vinfo, stmt_info, &si, node, instance);
 }
 
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
index 0d61b0f51d0..04f83c1127a 100644
--- a/gcc/tree-vect-stmts.c
+++ b/gcc/tree-vect-stmts.c
@@ -2207,6 +2207,37 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,
 	      gcc_assert (!loop_vinfo || cmp > 0);
 	      *memory_access_type = VMAT_CONTIGUOUS;
 	    }
+
+	  /* When we have a contiguous access across loop iterations
+	     but the access in the loop doesn't cover the full vector
+	     we can end up with no gap recorded but still excess
+	     elements accessed, see PR103116.  Make sure we peel for
+	     gaps if necessary and sufficient and give up if not.  */
+	  if (loop_vinfo
+	      && *memory_access_type == VMAT_CONTIGUOUS
+	      && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ()
+	      && !multiple_p (group_size * LOOP_VINFO_VECT_FACTOR (loop_vinfo),
+			      nunits))
+	    {
+	      unsigned HOST_WIDE_INT cnunits, cvf;
+	      if (!can_overrun_p
+		  || !nunits.is_constant (&cnunits)
+		  || !LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&cvf)
+		  /* Peeling for gaps assumes that a single scalar iteration
+		     is enough to make sure the last vector iteration doesn't
+		     access excess elements.
+		     ???  Enhancements include peeling multiple iterations
+		     or using masked loads with a static mask.  */
+		  || (group_size * cvf) % cnunits + group_size < cnunits)
+		{
+		  if (dump_enabled_p ())
+		    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+				     "peeling for gaps insufficient for "
+				     "access\n");
+		  return false;
+		}
+	      overrun_p = true;
+	    }
 	}
     }
   else
@@ -5232,8 +5263,7 @@ vectorizable_assignment (vec_info *vinfo,
 		       GET_MODE_SIZE (TYPE_MODE (vectype_in)))))
     return false;
 
-  if (VECTOR_BOOLEAN_TYPE_P (vectype)
-      && !VECTOR_BOOLEAN_TYPE_P (vectype_in))
+  if (VECTOR_BOOLEAN_TYPE_P (vectype) != VECTOR_BOOLEAN_TYPE_P (vectype_in))
     {
       if (dump_enabled_p ())
 	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
@@ -8911,6 +8941,7 @@ vectorizable_load (vec_info *vinfo,
       unsigned int group_el = 0;
       unsigned HOST_WIDE_INT
 	elsz = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));
+      unsigned int n_groups = 0;
       for (j = 0; j < ncopies; j++)
 	{
 	  if (nloads > 1)
@@ -8932,12 +8963,19 @@ vectorizable_load (vec_info *vinfo,
 	      if (! slp
 		  || group_el == group_size)
 		{
-		  tree newoff = copy_ssa_name (running_off);
-		  gimple *incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,
-						      running_off, stride_step);
-		  vect_finish_stmt_generation (vinfo, stmt_info, incr, gsi);
-
-		  running_off = newoff;
+		  n_groups++;
+		  /* When doing SLP make sure to not load elements from
+		     the next vector iteration, those will not be accessed
+		     so just use the last element again.  See PR107451.  */
+		  if (!slp || known_lt (n_groups, vf))
+		    {
+		      tree newoff = copy_ssa_name (running_off);
+		      gimple *incr
+			= gimple_build_assign (newoff, POINTER_PLUS_EXPR,
+					       running_off, stride_step);
+		      vect_finish_stmt_generation (vinfo, stmt_info, incr, gsi);
+		      running_off = newoff;
+		    }
 		  group_el = 0;
 		}
 	    }
diff --git a/gcc/tree.c b/gcc/tree.c
index 5f87455c68f..79e03204a6e 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -3025,6 +3025,35 @@ real_minus_onep (const_tree expr)
     }
 }
 
+/* Return true if T could be a floating point zero.  */
+
+bool
+real_maybe_zerop (const_tree expr)
+{
+  switch (TREE_CODE (expr))
+    {
+    case REAL_CST:
+      /* Can't use real_zerop here, as it always returns false for decimal
+	 floats.  And can't use TREE_REAL_CST (expr).cl == rvc_zero
+	 either, as decimal zeros are rvc_normal.  */
+      return real_equal (&TREE_REAL_CST (expr), &dconst0);
+    case COMPLEX_CST:
+      return (real_maybe_zerop (TREE_REALPART (expr))
+	      || real_maybe_zerop (TREE_IMAGPART (expr)));
+    case VECTOR_CST:
+      {
+	unsigned count = vector_cst_encoded_nelts (expr);
+	for (unsigned int i = 0; i < count; ++i)
+	  if (real_maybe_zerop (VECTOR_CST_ENCODED_ELT (expr, i)))
+	    return true;
+	return false;
+      }
+    default:
+      /* Perhaps for SSA_NAMEs we could query frange.  */
+      return true;
+    }
+}
+
 /* Nonzero if EXP is a constant or a cast of a constant.  */
 
 bool
diff --git a/gcc/tree.h b/gcc/tree.h
index 44643c74ad9..32e7024ff23 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -5282,6 +5282,7 @@ extern bool needs_to_live_in_memory (const_tree);
 extern tree reconstruct_complex_type (tree, tree);
 extern bool real_onep (const_tree);
 extern bool real_minus_onep (const_tree);
+extern bool real_maybe_zerop (const_tree);
 extern void init_ttree (void);
 extern void build_common_tree_nodes (bool);
 extern void build_common_builtin_nodes (void);
diff --git a/gcc/value-prof.c b/gcc/value-prof.c
index 42748771192..688089b04d2 100644
--- a/gcc/value-prof.c
+++ b/gcc/value-prof.c
@@ -336,6 +336,10 @@ stream_out_histogram_value (struct output_block *ob, histogram_value hist)
 	/* Note that the IOR counter tracks pointer values and these can have
 	   sign bit set.  */
 	;
+      else if (hist->type == HIST_TYPE_INDIR_CALL && i == 0)
+	/* 'all' counter overflow is stored as a negative value. Individual
+	   counters and values are expected to be non-negative.  */
+	;
       else
 	gcc_assert (value >= 0);
 
diff --git a/gcc/varasm.c b/gcc/varasm.c
index a7ef9b8d9fe..8e456576010 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -2380,7 +2380,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,
   else
     {
       /* Special-case handling of vtv comdat sections.  */
-      if (sect->named.name
+      if (SECTION_STYLE (sect) == SECTION_NAMED
 	  && (strcmp (sect->named.name, ".vtable_map_vars") == 0))
 	handle_vtv_comdat_section (sect, decl);
       else
@@ -4691,7 +4691,10 @@ narrowing_initializer_constant_valid_p (tree value, tree endtype, tree *cache)
     {
       tree inner = TREE_OPERAND (op0, 0);
       if (inner == error_mark_node
-	  || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
+	  || ! INTEGRAL_TYPE_P (TREE_TYPE (op0))
+	  || ! SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (op0)))
+	  || ! INTEGRAL_TYPE_P (TREE_TYPE (inner))
+	  || ! SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
 	  || (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (op0)))
 	      > GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (inner)))))
 	break;
@@ -4703,7 +4706,10 @@ narrowing_initializer_constant_valid_p (tree value, tree endtype, tree *cache)
     {
       tree inner = TREE_OPERAND (op1, 0);
       if (inner == error_mark_node
-	  || ! INTEGRAL_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
+	  || ! INTEGRAL_TYPE_P (TREE_TYPE (op1))
+	  || ! SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (op1)))
+	  || ! INTEGRAL_TYPE_P (TREE_TYPE (inner))
+	  || ! SCALAR_INT_MODE_P (TYPE_MODE (TREE_TYPE (inner)))
 	  || (GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (op1)))
 	      > GET_MODE_SIZE (SCALAR_INT_TYPE_MODE (TREE_TYPE (inner)))))
 	break;
diff --git a/gcc/wide-int.cc b/gcc/wide-int.cc
index 906f4ea9dfc..c90fd99acbc 100644
--- a/gcc/wide-int.cc
+++ b/gcc/wide-int.cc
@@ -842,6 +842,13 @@ wi::shifted_mask (HOST_WIDE_INT *val, unsigned int start, unsigned int width,
 	val[i++] = negate ? block : ~block;
     }
 
+  if (end >= prec)
+    {
+      if (!shift)
+	val[i++] = negate ? 0 : -1;
+      return i;
+    }
+
   while (i < end / HOST_BITS_PER_WIDE_INT)
     /* 1111111 */
     val[i++] = negate ? 0 : -1;
@@ -853,7 +860,7 @@ wi::shifted_mask (HOST_WIDE_INT *val, unsigned int start, unsigned int width,
       HOST_WIDE_INT block = (HOST_WIDE_INT_1U << shift) - 1;
       val[i++] = negate ? ~block : block;
     }
-  else if (end < prec)
+  else
     val[i++] = negate ? -1 : 0;
 
   return i;
@@ -2582,6 +2589,10 @@ wide_int_cc_tests ()
   run_all_wide_int_tests <widest_int> ();
   test_overflow ();
   test_round_for_mask ();
+  ASSERT_EQ (wi::mask (128, false, 128),
+	     wi::shifted_mask (0, 128, false, 128));
+  ASSERT_EQ (wi::mask (128, true, 128),
+	     wi::shifted_mask (0, 128, true, 128));
 }
 
 } // namespace selftest
diff --git a/gcc/wide-int.h b/gcc/wide-int.h
index 19bf65d999c..84c8fa36fb8 100644
--- a/gcc/wide-int.h
+++ b/gcc/wide-int.h
@@ -3169,9 +3169,11 @@ wi::lrotate (const T1 &x, const T2 &y, unsigned int width)
     width = precision;
   WI_UNARY_RESULT (T2) ymod = umod_trunc (y, width);
   WI_UNARY_RESULT (T1) left = wi::lshift (x, ymod);
-  WI_UNARY_RESULT (T1) right = wi::lrshift (x, wi::sub (width, ymod));
+  WI_UNARY_RESULT (T1) right
+    = wi::lrshift (width != precision ? wi::zext (x, width) : x,
+		   wi::sub (width, ymod));
   if (width != precision)
-    return wi::zext (left, width) | wi::zext (right, width);
+    return wi::zext (left, width) | right;
   return left | right;
 }
 
@@ -3186,10 +3188,11 @@ wi::rrotate (const T1 &x, const T2 &y, unsigned int width)
   if (width == 0)
     width = precision;
   WI_UNARY_RESULT (T2) ymod = umod_trunc (y, width);
-  WI_UNARY_RESULT (T1) right = wi::lrshift (x, ymod);
+  WI_UNARY_RESULT (T1) right
+    = wi::lrshift (width != precision ? wi::zext (x, width) : x, ymod);
   WI_UNARY_RESULT (T1) left = wi::lshift (x, wi::sub (width, ymod));
   if (width != precision)
-    return wi::zext (left, width) | wi::zext (right, width);
+    return wi::zext (left, width) | right;
   return left | right;
 }
 
diff --git a/gnattools/ChangeLog b/gnattools/ChangeLog
index b57a967f2e2..d30846dcb67 100644
--- a/gnattools/ChangeLog
+++ b/gnattools/ChangeLog
@@ -1,3 +1,13 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-04-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* configure.ac (TOOLS_TARGET_PAIRS): Remove obsolete settings.
+	(EXTRA_GNATTOOLS): Likewise.
+	* configure: Regenerate.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gnattools/configure b/gnattools/configure
index c2d755b723a..6cdfbe67af2 100755
--- a/gnattools/configure
+++ b/gnattools/configure
@@ -2052,76 +2052,38 @@ fi
 
 # Target-specific stuff (defaults)
 TOOLS_TARGET_PAIRS=
-
 EXTRA_GNATTOOLS=
 
-
 # Per-target case statement
 # -------------------------
 case "${target}" in
   *-*-aix*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-aix.adb \
-    indepsw.adb<indepsw-aix.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-aix.adb"
     ;;
   *-*-darwin*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-darwin.adb \
-    indepsw.adb<indepsw-darwin.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-darwin.adb"
     ;;
   *-*-dragonfly*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-freebsd*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-linux*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
-    ;;
-  *-*-solaris*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-vxworks*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \
-    indepsw.adb<indepsw-gnu.adb"
-    ;;
-  hppa*-hp-hpux10*)
-    ;;
-  hppa*-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-hpux.adb"
-    ;;
-  ia64-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-ia64-hpux.adb"
-    ;;
-  alpha*-*-vms* | alpha*-*-openvms*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vms-alpha.adb \
-    symbols.adb<symbols-vms.adb \
-    symbols-processing.adb<symbols-processing-vms-alpha.adb"
-    EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
-    ;;
-  ia64-*-vms* | ia64-*-openvms*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vms-ia64.adb \
-    symbols.adb<symbols-vms.adb \
-    symbols-processing.adb<symbols-processing-vms-ia64.adb"
-    EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-cygwin32* | *-*-mingw32* | *-*-pe)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-mingw.adb \
-    indepsw.adb<indepsw-mingw.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     EXTRA_GNATTOOLS='../../gnatdll$(exeext)'
     ;;
 esac
 
+
+
+
 # From user or toplevel makefile.
 
 
diff --git a/gnattools/configure.ac b/gnattools/configure.ac
index 40d015ce8b0..38a28b6ee62 100644
--- a/gnattools/configure.ac
+++ b/gnattools/configure.ac
@@ -53,76 +53,38 @@ AC_PROG_LN_S
 
 # Target-specific stuff (defaults)
 TOOLS_TARGET_PAIRS=
-AC_SUBST(TOOLS_TARGET_PAIRS)
 EXTRA_GNATTOOLS=
-AC_SUBST(EXTRA_GNATTOOLS)
 
 # Per-target case statement
 # -------------------------
 case "${target}" in
   *-*-aix*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-aix.adb \
-    indepsw.adb<indepsw-aix.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-aix.adb"
     ;;
   *-*-darwin*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-darwin.adb \
-    indepsw.adb<indepsw-darwin.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-darwin.adb"
     ;;
   *-*-dragonfly*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-freebsd*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-linux*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
-    indepsw.adb<indepsw-gnu.adb"
-    ;;
-  *-*-solaris*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-vxworks*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \
-    indepsw.adb<indepsw-gnu.adb"
-    ;;
-  hppa*-hp-hpux10*)
-    ;;
-  hppa*-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-hpux.adb"
-    ;;
-  ia64-hp-hpux11*)
-    TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-ia64-hpux.adb"
-    ;;
-  alpha*-*-vms* | alpha*-*-openvms*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vms-alpha.adb \
-    symbols.adb<symbols-vms.adb \
-    symbols-processing.adb<symbols-processing-vms-alpha.adb"
-    EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
-    ;;
-  ia64-*-vms* | ia64-*-openvms*)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-vms-ia64.adb \
-    symbols.adb<symbols-vms.adb \
-    symbols-processing.adb<symbols-processing-vms-ia64.adb"
-    EXTRA_GNATTOOLS='../../gnatlbr$(exeext) ../../gnatsym$(exeext)'
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
   *-*-cygwin32* | *-*-mingw32* | *-*-pe)
-    TOOLS_TARGET_PAIRS="\
-    mlib-tgt-specific.adb<mlib-tgt-specific-mingw.adb \
-    indepsw.adb<indepsw-mingw.adb"
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     EXTRA_GNATTOOLS='../../gnatdll$(exeext)'
     ;;
 esac
 
+AC_SUBST(TOOLS_TARGET_PAIRS)
+AC_SUBST(EXTRA_GNATTOOLS)
+
 # From user or toplevel makefile.
 AC_SUBST(ADA_CFLAGS)
 
diff --git a/gotools/ChangeLog b/gotools/ChangeLog
index f1c352d35c7..73ad23c091a 100644
--- a/gotools/ChangeLog
+++ b/gotools/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/include/ChangeLog b/include/ChangeLog
index a3acc4b0ce1..3ca8a3f08de 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/intl/ChangeLog b/intl/ChangeLog
index 5cde4d88d86..e9f9f2498be 100644
--- a/intl/ChangeLog
+++ b/intl/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libada/ChangeLog b/libada/ChangeLog
index 9d825e942b4..59fd3c372eb 100644
--- a/libada/ChangeLog
+++ b/libada/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libatomic/ChangeLog b/libatomic/ChangeLog
index ae629bf4079..d30915d5a95 100644
--- a/libatomic/ChangeLog
+++ b/libatomic/ChangeLog
@@ -1,3 +1,25 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-03-03  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	Backported from master:
+	2023-03-03  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>
+
+	* config/s390/cas_n.c: New file.
+	* config/s390/load_n.c: New file.
+	* config/s390/store_n.c: New file.
+
+2022-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-11-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/104688
+	* config/x86/init.c (__libat_feat1_init): Don't clear
+	bit_AVX on AMD CPUs.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libatomic/config/s390/cas_n.c b/libatomic/config/s390/cas_n.c
new file mode 100644
index 00000000000..44b7152ca5d
--- /dev/null
+++ b/libatomic/config/s390/cas_n.c
@@ -0,0 +1,65 @@
+/* Copyright (C) 2018-2023 Free Software Foundation, Inc.
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <libatomic_i.h>
+
+
+/* Analog to config/s390/exch_n.c.  */
+
+#if !DONE && N == 16
+bool
+SIZE(libat_compare_exchange) (UTYPE *mptr, UTYPE *eptr, UTYPE newval,
+			      int smodel, int fmodel UNUSED)
+{
+  if (!((uintptr_t)mptr & 0xf))
+    {
+      return __atomic_compare_exchange_n (
+	(UTYPE *)__builtin_assume_aligned (mptr, 16), eptr, newval, false,
+	__ATOMIC_SEQ_CST, __ATOMIC_RELAXED);
+    }
+  else
+    {
+      UTYPE oldval;
+      UWORD magic;
+      bool ret;
+
+      pre_seq_barrier (smodel);
+      magic = protect_start (mptr);
+
+      oldval = *mptr;
+      ret = (oldval == *eptr);
+      if (ret)
+	*mptr = newval;
+      else
+	*eptr = oldval;
+
+      protect_end (mptr, magic);
+      post_seq_barrier (smodel);
+
+      return ret;
+    }
+}
+#define DONE 1
+#endif /* N == 16 */
+
+#include "../../cas_n.c"
diff --git a/libatomic/config/s390/load_n.c b/libatomic/config/s390/load_n.c
new file mode 100644
index 00000000000..335d2f8b2c3
--- /dev/null
+++ b/libatomic/config/s390/load_n.c
@@ -0,0 +1,57 @@
+/* Copyright (C) 2018-2023 Free Software Foundation, Inc.
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <libatomic_i.h>
+
+
+/* Analog to config/s390/exch_n.c.  */
+
+#if !DONE && N == 16
+UTYPE
+SIZE(libat_load) (UTYPE *mptr, int smodel)
+{
+  if (!((uintptr_t)mptr & 0xf))
+    {
+      return __atomic_load_n ((UTYPE *)__builtin_assume_aligned (mptr, 16),
+			      __ATOMIC_SEQ_CST);
+    }
+  else
+    {
+      UTYPE ret;
+      UWORD magic;
+
+      pre_seq_barrier (smodel);
+      magic = protect_start (mptr);
+
+      ret = *mptr;
+
+      protect_end (mptr, magic);
+      post_seq_barrier (smodel);
+
+      return ret;
+    }
+}
+#define DONE 1
+#endif /* N == 16 */
+
+#include "../../load_n.c"
diff --git a/libatomic/config/s390/store_n.c b/libatomic/config/s390/store_n.c
new file mode 100644
index 00000000000..9e5b2b8213d
--- /dev/null
+++ b/libatomic/config/s390/store_n.c
@@ -0,0 +1,54 @@
+/* Copyright (C) 2018-2023 Free Software Foundation, Inc.
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <libatomic_i.h>
+
+
+/* Analog to config/s390/exch_n.c.  */
+
+#if !DONE && N == 16
+void
+SIZE(libat_store) (UTYPE *mptr, UTYPE newval, int smodel)
+{
+  if (!((uintptr_t)mptr & 0xf))
+    {
+      __atomic_store_n ((UTYPE *)__builtin_assume_aligned (mptr, 16), newval,
+			__ATOMIC_SEQ_CST);
+    }
+  else
+    {
+      UWORD magic;
+
+      pre_seq_barrier (smodel);
+      magic = protect_start (mptr);
+
+      *mptr = newval;
+
+      protect_end (mptr, magic);
+      post_seq_barrier (smodel);
+    }
+}
+#define DONE 1
+#endif /* N == 16 */
+
+#include "../../store_n.c"
diff --git a/libatomic/config/x86/init.c b/libatomic/config/x86/init.c
index 36e231c68cc..c9b474bda79 100644
--- a/libatomic/config/x86/init.c
+++ b/libatomic/config/x86/init.c
@@ -39,10 +39,12 @@ __libat_feat1_init (void)
       == (bit_AVX | bit_CMPXCHG16B))
     {
       /* Intel SDM guarantees that 16-byte VMOVDQA on 16-byte aligned address
-	 is atomic, but so far we don't have this guarantee from AMD.  */
+	 is atomic, and AMD is going to do something similar soon.
+	 We don't have a guarantee from vendors of other CPUs with AVX,
+	 like Zhaoxin and VIA.  */
       unsigned int ecx2 = 0;
       __get_cpuid (0, &eax, &ebx, &ecx2, &edx);
-      if (ecx2 != signature_INTEL_ecx)
+      if (ecx2 != signature_INTEL_ecx && ecx2 != signature_AMD_ecx)
 	FEAT1_REGISTER &= ~bit_AVX;
     }
 #endif
diff --git a/libbacktrace/ChangeLog b/libbacktrace/ChangeLog
index 25326ce0ef1..7f5c0dd0b79 100644
--- a/libbacktrace/ChangeLog
+++ b/libbacktrace/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libcc1/ChangeLog b/libcc1/ChangeLog
index 56402bc4ca1..a28d9c7223d 100644
--- a/libcc1/ChangeLog
+++ b/libcc1/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libcody/ChangeLog b/libcody/ChangeLog
index 35839598dfa..62eccb3888b 100644
--- a/libcody/ChangeLog
+++ b/libcody/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 3f63896333e..8edf621d50d 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,26 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2022-08-02  Lewis Hyatt  <lhyatt@gmail.com>
+
+	Backported from master:
+	2022-07-10  Lewis Hyatt  <lhyatt@gmail.com>
+
+	PR preprocessor/97498
+	* directives.c (destringize_and_run): Override the location of
+	the CPP_PRAGMA token from a _Pragma directive to the location of
+	the expansion point, as is done for the tokens lexed from it.
+
+2022-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/105732
+	* expr.c (_cpp_parse_expr): Handle CPP_PADDING by just another
+	token.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libcpp/directives.c b/libcpp/directives.c
index 347ddb8b1e1..d764ddfa38e 100644
--- a/libcpp/directives.c
+++ b/libcpp/directives.c
@@ -1905,6 +1905,7 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in,
       maxcount = 50;
       toks = XNEWVEC (cpp_token, maxcount);
       toks[0] = pfile->directive_result;
+      toks[0].src_loc = expansion_loc;
 
       do
 	{
diff --git a/libcpp/expr.c b/libcpp/expr.c
index dd5611dce0e..57db654ed31 100644
--- a/libcpp/expr.c
+++ b/libcpp/expr.c
@@ -1370,6 +1370,10 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)
 	    op.op = CPP_UMINUS;
 	  break;
 
+	case CPP_PADDING:
+	  lex_count--;
+	  continue;
+
 	default:
 	  if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ)
 	    SYNTAX_ERROR2_AT (op.loc,
diff --git a/libcpp/po/ChangeLog b/libcpp/po/ChangeLog
index 61c3a4c5a7c..009d268cab6 100644
--- a/libcpp/po/ChangeLog
+++ b/libcpp/po/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libdecnumber/ChangeLog b/libdecnumber/ChangeLog
index 0768a6ee414..ea72f994e33 100644
--- a/libdecnumber/ChangeLog
+++ b/libdecnumber/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libffi/ChangeLog b/libffi/ChangeLog
index bed6dadc0b1..1ee2653e366 100644
--- a/libffi/ChangeLog
+++ b/libffi/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index ceaa3e21b19..df6eabe6bf7 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,38 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2023-05-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.host: Arrange to set min Darwin OS versions from
+	the configured host version.
+	* config/darwin10-unwind-find-enc-func.c: Do not use current
+	headers, but declare the nexessary structures locally to the
+	versions in use for Mac OSX 10.6.
+	* config/t-darwin: Amend to handle configured min OS
+	versions.
+	* config/t-darwin-min-1: New.
+	* config/t-darwin-min-5: New.
+	* config/t-darwin-min-8: New.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2022-12-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/t-slibgcc-darwin (install-darwin-libgcc-stubs): Skip the
+	install of libgcc_s.1.dylib when the installation is into the build
+	gcc directory.
+
+2022-05-16  Sebastian Pop  <spop@amazon.com>
+
+	PR target/105162
+	* config/aarch64/lse.S: Define BARRIER and handle memory MODEL 5.
+	* config/aarch64/t-lse: Add a 5th memory model for _sync functions.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgcc/config.host b/libgcc/config.host
index f2dc7e266f4..45f8e19ada4 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -225,6 +225,24 @@ case ${host} in
       ;;
   esac
   tmake_file="$tmake_file t-slibgcc-darwin"
+  # newer toolsets produce warnings when building for unsupported versions.
+  case ${host} in
+    *-*-darwin1[89]* | *-*-darwin2* )
+      tmake_file="t-darwin-min-8 $tmake_file"
+      ;;
+    *-*-darwin9* | *-*-darwin1[0-7]*)
+      tmake_file="t-darwin-min-5 $tmake_file"
+      ;;
+    *-*-darwin[4-8]*)
+      tmake_file="t-darwin-min-1 $tmake_file"
+      ;;
+    *)
+      # Fall back to configuring for the oldest system known to work with
+      # all archs and the current sources.
+      tmake_file="t-darwin-min-5 $tmake_file"
+      echo "Warning: libgcc configured to support macOS 10.5" 1>&2
+      ;;
+  esac
   extra_parts="crt3.o libd10-uwfef.a crttms.o crttme.o libemutls_w.a"
   ;;
 *-*-dragonfly*)
diff --git a/libgcc/config/aarch64/lse.S b/libgcc/config/aarch64/lse.S
index df965b5a524..9215873842b 100644
--- a/libgcc/config/aarch64/lse.S
+++ b/libgcc/config/aarch64/lse.S
@@ -87,24 +87,44 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 # define L
 # define M     0x000000
 # define N     0x000000
+# define BARRIER
 #elif MODEL == 2
 # define SUFF  _acq
 # define A     a
 # define L
 # define M     0x400000
 # define N     0x800000
+# define BARRIER
 #elif MODEL == 3
 # define SUFF  _rel
 # define A
 # define L     l
 # define M     0x008000
 # define N     0x400000
+# define BARRIER
 #elif MODEL == 4
 # define SUFF  _acq_rel
 # define A     a
 # define L     l
 # define M     0x408000
 # define N     0xc00000
+# define BARRIER
+#elif MODEL == 5
+# define SUFF  _sync
+#ifdef L_swp
+/* swp has _acq semantics.  */
+#  define A    a
+#  define L
+#  define M    0x400000
+#  define N    0x800000
+#else
+/* All other _sync functions have _seq semantics.  */
+#  define A    a
+#  define L    l
+#  define M    0x408000
+#  define N    0xc00000
+#endif
+# define BARRIER dmb		ish
 #else
 # error
 #endif
@@ -127,7 +147,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #endif
 
 #define NAME(BASE)		glue4(__aarch64_, BASE, SIZE, SUFF)
-#define LDXR			glue4(ld, A, xr, S)
+#if MODEL == 5
+/* Drop A for _sync functions.  */
+# define LDXR			glue3(ld, xr, S)
+#else
+# define LDXR			glue4(ld, A, xr, S)
+#endif
 #define STXR			glue4(st, L, xr, S)
 
 /* Temporary registers used.  Other than these, only the return value
@@ -183,10 +208,16 @@ STARTFN	NAME(cas)
 	bne		1f
 	STXR		w(tmp1), s(1), [x2]
 	cbnz		w(tmp1), 0b
-1:	ret
+1:	BARRIER
+	ret
 
 #else
-#define LDXP	glue3(ld, A, xp)
+#if MODEL == 5
+/* Drop A for _sync functions.  */
+# define LDXP	glue2(ld, xp)
+#else
+# define LDXP	glue3(ld, A, xp)
+#endif
 #define STXP	glue3(st, L, xp)
 #ifdef HAVE_AS_LSE
 # define CASP	glue3(casp, A, L)	x0, x1, x2, x3, [x4]
@@ -205,7 +236,8 @@ STARTFN	NAME(cas)
 	bne		1f
 	STXP		w(tmp2), x2, x3, [x4]
 	cbnz		w(tmp2), 0b
-1:	ret
+1:	BARRIER
+	ret
 
 #endif
 
@@ -229,6 +261,7 @@ STARTFN	NAME(swp)
 0:	LDXR		s(0), [x1]
 	STXR		w(tmp1), s(tmp0), [x1]
 	cbnz		w(tmp1), 0b
+	BARRIER
 	ret
 
 ENDFN	NAME(swp)
@@ -273,6 +306,7 @@ STARTFN	NAME(LDNM)
 	OP		s(tmp1), s(0), s(tmp0)
 	STXR		w(tmp2), s(tmp1), [x1]
 	cbnz		w(tmp2), 0b
+	BARRIER
 	ret
 
 ENDFN	NAME(LDNM)
diff --git a/libgcc/config/aarch64/t-lse b/libgcc/config/aarch64/t-lse
index 88d2d84d100..6ec6df79392 100644
--- a/libgcc/config/aarch64/t-lse
+++ b/libgcc/config/aarch64/t-lse
@@ -18,13 +18,13 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-# Compare-and-swap has 5 sizes and 4 memory models.
+# Compare-and-swap has 5 sizes and 5 memory models.
 S0 := $(foreach s, 1 2 4 8 16, $(addsuffix _$(s), cas))
-O0 := $(foreach m, 1 2 3 4, $(addsuffix _$(m)$(objext), $(S0)))
+O0 := $(foreach m, 1 2 3 4 5, $(addsuffix _$(m)$(objext), $(S0)))
 
-# Swap, Load-and-operate have 4 sizes and 4 memory models
+# Swap, Load-and-operate have 4 sizes and 5 memory models
 S1 := $(foreach s, 1 2 4 8, $(addsuffix _$(s), swp ldadd ldclr ldeor ldset))
-O1 := $(foreach m, 1 2 3 4, $(addsuffix _$(m)$(objext), $(S1)))
+O1 := $(foreach m, 1 2 3 4 5, $(addsuffix _$(m)$(objext), $(S1)))
 
 LSE_OBJS := $(O0) $(O1)
 
diff --git a/libgcc/config/avr/libf7/ChangeLog b/libgcc/config/avr/libf7/ChangeLog
index 7e06f52d415..786c2032ffc 100644
--- a/libgcc/config/avr/libf7/ChangeLog
+++ b/libgcc/config/avr/libf7/ChangeLog
@@ -1,3 +1,16 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2022-09-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backported from master:
+	2022-09-19  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/99184
+	* libf7-asm.sx (to_integer, to_unsigned): Don't round 16-bit
+	and 32-bit integers.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgcc/config/avr/libf7/libf7-asm.sx b/libgcc/config/avr/libf7/libf7-asm.sx
index 7629e23e289..9d701f27582 100644
--- a/libgcc/config/avr/libf7/libf7-asm.sx
+++ b/libgcc/config/avr/libf7/libf7-asm.sx
@@ -601,9 +601,6 @@ DEFUN to_integer
     tst     C6
     brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate
 
-    rcall   .Lround
-    brmi    .Lsaturate.T    ;   > INTxx_MAX  =>  saturate
-
     brtc 9f                 ;   >= 0         =>  return
     sbrc    Mask,   5
     .global __negdi2
@@ -658,30 +655,6 @@ DEFUN to_integer
     .global __clr_8
     XJMP    __clr_8
 
-.Lround:
-    ;; C6.7 is known to be 0 here.
-    ;; Return N = 1 iff we have to saturate.
-    cpi     Mask,   0xf
-    breq .Lround16
-    cpi     Mask,   0x1f
-    breq .Lround32
-
-    ;; For now, no rounding in the 64-bit case.  This rounding
-    ;; would have to be integrated into the right-shift.
-    cln
-    ret
-
-.Lround32:
-    rol     C2
-    adc     C3,     ZERO
-    adc     C4,     ZERO
-    rjmp 2f
-
-.Lround16:
-    rol     C4
-2:  adc     C5,     ZERO
-    adc     C6,     ZERO
-    ret
 ENDF to_integer
 #endif /* F7MOD_to_integer_ */
 
@@ -725,29 +698,6 @@ DEFUN to_unsigned
     clr     CA
     F7call  lshrdi3
     POP     r16
-
-    ;; Rounding
-    ;; ??? C6.7 is known to be 0 here.
-    cpi     Mask,   0xf
-    breq .Lround16
-    cpi     Mask,   0x1f
-    breq .Lround32
-
-    ;; For now, no rounding in the 64-bit case.  This rounding
-    ;; would have to be integrated into the right-shift.
-    ret
-
-.Lround32:
-    rol     C2
-    adc     C3,     ZERO
-    adc     C4,     ZERO
-    rjmp 2f
-
-.Lround16:
-    rol     C4
-2:  adc     C5,     ZERO
-    adc     C6,     ZERO
-    brcs    .Lset_0xffff    ; Rounding overflow  =>  saturate
     ret
 
 .Lset_0xffff:
diff --git a/libgcc/config/darwin10-unwind-find-enc-func.c b/libgcc/config/darwin10-unwind-find-enc-func.c
index 882ec3a2372..b08396c5f1b 100644
--- a/libgcc/config/darwin10-unwind-find-enc-func.c
+++ b/libgcc/config/darwin10-unwind-find-enc-func.c
@@ -1,8 +1,34 @@
-#include "tconfig.h"
-#include "tsystem.h"
-#include "unwind-dw2-fde.h"
 #include "libgcc_tm.h"
 
+/* This shim is special, it needs to be built for Mac OSX 10.6
+   regardless of the current system version.
+   We must also build it to use the unwinder layout that was
+   present for 10.6 (and not update that).
+   So we copy the referenced structures from unwind-dw2-fde.h
+   to avoid pulling in newer system headers and/or changed
+   layouts.  */
+struct dwarf_eh_bases
+{
+  void *tbase;
+  void *dbase;
+  void *func;
+};
+
+typedef          int  sword __attribute__ ((mode (SI)));
+typedef unsigned int  uword __attribute__ ((mode (SI)));
+
+/* The first few fields of an FDE.  */
+struct dwarf_fde
+{
+  uword length;
+  sword CIE_delta;
+  unsigned char pc_begin[];
+} __attribute__ ((packed, aligned (__alignof__ (void *))));
+
+typedef struct dwarf_fde fde;
+
+extern const fde * _Unwind_Find_FDE (void *, struct dwarf_eh_bases *);
+
 void *
 _darwin10_Unwind_FindEnclosingFunction (void *pc)
 {
@@ -10,5 +36,5 @@ _darwin10_Unwind_FindEnclosingFunction (void *pc)
   const struct dwarf_fde *fde = _Unwind_Find_FDE (pc-1, &bases);
   if (fde)
     return bases.func;
-  return NULL;
+  return (void *) 0;
 }
diff --git a/libgcc/config/libbid/ChangeLog b/libgcc/config/libbid/ChangeLog
index 339bb243843..f78b4c72220 100644
--- a/libgcc/config/libbid/ChangeLog
+++ b/libgcc/config/libbid/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgcc/config/t-darwin b/libgcc/config/t-darwin
index 299d26c2c96..a3bb70c6a0a 100644
--- a/libgcc/config/t-darwin
+++ b/libgcc/config/t-darwin
@@ -1,15 +1,15 @@
 # Set this as a minimum (unless overriden by arch t-files) since it's a
 # reasonable lowest common denominator that works for all our archs.
-HOST_LIBGCC2_CFLAGS += -mmacosx-version-min=10.4
+HOST_LIBGCC2_CFLAGS += $(DARWIN_MIN_LIB_VERSION)
 
 crt3.o: $(srcdir)/config/darwin-crt3.c
-	$(crt_compile) -mmacosx-version-min=10.4 -c $<
+	$(crt_compile) $(DARWIN_MIN_CRT_VERSION) -c $<
 
 crttms.o: $(srcdir)/config/darwin-crt-tm.c
-	$(crt_compile) -mmacosx-version-min=10.4 -DSTART -c $<
+	$(crt_compile) $(DARWIN_MIN_CRT_VERSION) -DSTART -c $<
 
 crttme.o: $(srcdir)/config/darwin-crt-tm.c
-	$(crt_compile) -mmacosx-version-min=10.4 -DEND -c $<
+	$(crt_compile) $(DARWIN_MIN_CRT_VERSION) -DEND -c $<
 
 # Make emutls weak so that we can deal with -static-libgcc, override the
 # hidden visibility when this is present in libgcc_eh.
@@ -25,6 +25,8 @@ libemutls_w.a: emutls_s.o
 	$(RANLIB_FOR_TARGET) $@
 
 # Patch to __Unwind_Find_Enclosing_Function for Darwin10.
+# This needs to be built for darwin10, regardless of the current platform
+# version.
 d10-uwfef.o: $(srcdir)/config/darwin10-unwind-find-enc-func.c libgcc_tm.h
 	$(crt_compile) -mmacosx-version-min=10.6 -c $<
 
diff --git a/libgcc/config/t-darwin-min-1 b/libgcc/config/t-darwin-min-1
new file mode 100644
index 00000000000..8c2cf8acd39
--- /dev/null
+++ b/libgcc/config/t-darwin-min-1
@@ -0,0 +1,3 @@
+# Support building with -mmacosx-version-min back to 10.1.
+DARWIN_MIN_LIB_VERSION = -mmacosx-version-min=10.4
+DARWIN_MIN_CRT_VERSION = -mmacosx-version-min=10.1
diff --git a/libgcc/config/t-darwin-min-5 b/libgcc/config/t-darwin-min-5
new file mode 100644
index 00000000000..138193151e7
--- /dev/null
+++ b/libgcc/config/t-darwin-min-5
@@ -0,0 +1,3 @@
+# Support building with -mmacosx-version-min back to 10.5.
+DARWIN_MIN_LIB_VERSION = -mmacosx-version-min=10.5
+DARWIN_MIN_CRT_VERSION = -mmacosx-version-min=10.5
diff --git a/libgcc/config/t-darwin-min-8 b/libgcc/config/t-darwin-min-8
new file mode 100644
index 00000000000..9efc9dc0257
--- /dev/null
+++ b/libgcc/config/t-darwin-min-8
@@ -0,0 +1,3 @@
+# Support building with -mmacosx-version-min back to 10.8.
+DARWIN_MIN_LIB_VERSION = -mmacosx-version-min=10.8
+DARWIN_MIN_CRT_VERSION = -mmacosx-version-min=10.8
diff --git a/libgcc/config/t-slibgcc-darwin b/libgcc/config/t-slibgcc-darwin
index a8f69666a82..cb0cbbdb1c5 100644
--- a/libgcc/config/t-slibgcc-darwin
+++ b/libgcc/config/t-slibgcc-darwin
@@ -72,14 +72,15 @@ all: libgcc_ehs$(SHLIB_EXT)
 LGCC_FILES += libgcc_ehs.$(SHLIB_SOVERSION)$(SHLIB_EXT)
 
 endif
-
-# Provide libgcc_s.1 for backwards compatibility.
-LGCC_FILES += libgcc_s.1.dylib
-
 endif
 
 INSTALL_FILES=$(LGCC_FILES)
 
+ifeq ($(BUILD_LIBGCCS1),YES)
+# Provide libgcc_s.1 for backwards compatibility.
+INSTALL_FILES += libgcc_s.1.dylib
+endif
+
 # For the toplevel multilib, build FAT dylibs including all the multilibs.
 ifeq ($(MULTIBUILDTOP),)
 
@@ -158,9 +159,15 @@ endif
 
 install-darwin-libgcc-stubs :
 	$(mkinstalldirs) $(DESTDIR)$(slibdir)
-	for d in $(INSTALL_FILES) ; do \
-	  $(INSTALL_DATA) $$d $(DESTDIR)$(slibdir)/$$d || exit 1 ; \
-	done
+	if test x$(slibdir) = x; then \
+	  for d in $(LGCC_FILES) ; do \
+	    $(INSTALL_DATA) $$d $(DESTDIR)$(slibdir)/$$d || exit 1 ; \
+	  done; \
+	else \
+	  for d in $(INSTALL_FILES) ; do \
+	    $(INSTALL_DATA) $$d $(DESTDIR)$(slibdir)/$$d || exit 1 ; \
+	  done; \
+	fi
 
 else
 
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index a78ef862c96..cd63aae6c72 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgo/go/syscall/libcall_linux.go b/libgo/go/syscall/libcall_linux.go
index 96974bd3269..a39f408151a 100644
--- a/libgo/go/syscall/libcall_linux.go
+++ b/libgo/go/syscall/libcall_linux.go
@@ -188,6 +188,14 @@ func Gettid() (tid int) {
 //sys	PivotRoot(newroot string, putold string) (err error)
 //pivot_root(newroot *byte, putold *byte) _C_int
 
+// Used by golang.org/x/sys/unix.
+//sys	prlimit(pid int, resource int, newlimit *Rlimit, oldlimit *Rlimit) (err error)
+//prlimit(pid Pid_t, resource _C_int, newlimit *Rlimit, oldlimit *Rlimit) _C_int
+
+func Prlimit(pid int, resource int, newlimit *Rlimit, oldlimit *Rlimit) error {
+	return prlimit(pid, resource, newlimit, oldlimit)
+}
+
 //sys	Removexattr(path string, attr string) (err error)
 //removexattr(path *byte, name *byte) _C_int
 
diff --git a/libgo/sysinfo.c b/libgo/sysinfo.c
index 8ce061e2f5f..336a5983750 100644
--- a/libgo/sysinfo.c
+++ b/libgo/sysinfo.c
@@ -158,9 +158,6 @@
 #if defined(HAVE_LINUX_ETHER_H)
 #include <linux/ether.h>
 #endif
-#if defined(HAVE_LINUX_FS_H)
-#include <linux/fs.h>
-#endif
 #if defined(HAVE_LINUX_REBOOT_H)
 #include <linux/reboot.h>
 #endif
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index 0fa2757d939..1c18a927b15 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,118 @@
+2023-06-28  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2023-06-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR testsuite/66005
+	* testsuite/lib/libgomp.exp: 'flock' through stdout.
+	* testsuite/flock: New.
+	* configure.ac (FLOCK): Point to that if no 'flock' available, but
+	'perl' is.
+	* configure: Regenerate.
+
+2023-06-28  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backported from master:
+	2023-05-15  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR testsuite/66005
+	* configure.ac: Look for 'flock'.
+	* testsuite/Makefile.am (gcc_test_parallel_slots): Enable parallel testing.
+	* testsuite/config/default.exp: Don't 'load_lib "standard.exp"' here...
+	* testsuite/lib/libgomp.exp: ... but here, instead.
+	(libgomp_load): Override for parallel testing.
+	* testsuite/libgomp-site-extra.exp.in (FLOCK): Set.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+	* testsuite/Makefile.in: Regenerate.
+
+2023-06-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backported from master:
+	2023-05-15  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+		    Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR testsuite/66005
+	* testsuite/Makefile.am (PWD_COMMAND): New variable.
+	(%/site.exp): New target.
+	(check_p_numbers0, check_p_numbers1, check_p_numbers2)
+	(check_p_numbers3, check_p_numbers4, check_p_numbers5)
+	(check_p_numbers6, check_p_numbers, gcc_test_parallel_slots)
+	(check_p_subdirs)
+	(check_DEJAGNU_libgomp_targets): New variables.
+	($(check_DEJAGNU_libgomp_targets)): New target.
+	($(check_DEJAGNU_libgomp_targets)): New dependency.
+	(check-DEJAGNU $(check_DEJAGNU_libgomp_targets)): New targets.
+	* testsuite/Makefile.in: Regenerate.
+	* testsuite/lib/libgomp.exp: For parallel testing,
+	'load_file ../libgomp-test-support.exp'.
+
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* libgomp.texi: Fix typos - theads -> threads.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-01-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/108459
+	* testsuite/libgomp.c/pr108459.c: New test.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/108180
+	* testsuite/libgomp.c++/pr108180.C: New test.
+
+2023-03-09  Tobias Burnus  <tobias@codesourcery.com>
+
+	Backported from master:
+	2023-03-01  Tobias Burnus  <tobias@codesourcery.com>
+
+	PR middle-end/108546
+	* testsuite/libgomp.fortran/is_device_ptr-3.f90: New test.
+	* testsuite/libgomp.fortran/use_device_ptr-optional-4.f90: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-10-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* task.c (gomp_create_artificial_team): Fix up handling of invocations
+	from within explicit task.
+	* target.c (GOMP_target_ext): Likewise.
+	* testsuite/libgomp.c/task-7.c: New test.
+	* testsuite/libgomp.c/task-8.c: New test.
+	* testsuite/libgomp.c-c++-common/task-reduction-17.c: New test.
+	* testsuite/libgomp.c-c++-common/task-reduction-18.c: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-09-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/106981
+	* testsuite/libgomp.c-c++-common/pr106981.c: New test.
+
+2022-11-04  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-06-21  Jakub Jelinek  <jakub@redhat.com>
+		    Paul Iannetta  <piannetta@kalrayinc.com>
+
+	PR libgomp/106045
+	* testsuite/libgomp.c/target-31.c: Add private (i) clause.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libgomp/Makefile.in b/libgomp/Makefile.in
index eb868b36704..0fdfb2fe73f 100644
--- a/libgomp/Makefile.in
+++ b/libgomp/Makefile.in
@@ -384,6 +384,7 @@ EXEEXT = @EXEEXT@
 FC = @FC@
 FCFLAGS = @FCFLAGS@
 FGREP = @FGREP@
+FLOCK = @FLOCK@
 GREP = @GREP@
 HSA_RUNTIME_INCLUDE = @HSA_RUNTIME_INCLUDE@
 HSA_RUNTIME_LIB = @HSA_RUNTIME_LIB@
diff --git a/libgomp/configure b/libgomp/configure
index 718a76b4a40..6aee94291ea 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -656,6 +656,7 @@ tmake_file
 XLDFLAGS
 XCFLAGS
 config_path
+FLOCK
 CPU_COUNT
 LIBGOMP_BUILD_VERSIONED_SHLIB_SUN_FALSE
 LIBGOMP_BUILD_VERSIONED_SHLIB_SUN_TRUE
@@ -11421,7 +11422,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11424 "configure"
+#line 11425 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11527,7 +11528,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11530 "configure"
+#line 11531 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -16643,6 +16644,91 @@ $as_echo "unable to detect (assuming 1)" >&6; }
 fi
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for flock implementation" >&5
+$as_echo "$as_me: checking for flock implementation" >&6;}
+for ac_prog in flock
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_FLOCK+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$FLOCK"; then
+  ac_cv_prog_FLOCK="$FLOCK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_FLOCK="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+FLOCK=$ac_cv_prog_FLOCK
+if test -n "$FLOCK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $FLOCK" >&5
+$as_echo "$FLOCK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$FLOCK" && break
+done
+
+# Fallback if 'perl' is available.
+if test -z "$FLOCK"; then
+  # Extract the first word of "perl", so it can be a program name with args.
+set dummy perl; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_FLOCK+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$FLOCK"; then
+  ac_cv_prog_FLOCK="$FLOCK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_FLOCK="$srcdir/testsuite/flock"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+FLOCK=$ac_cv_prog_FLOCK
+if test -n "$FLOCK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $FLOCK" >&5
+$as_echo "$FLOCK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+
 # Get target configury.
 . ${srcdir}/configure.tgt
 CFLAGS="$save_CFLAGS $XCFLAGS"
diff --git a/libgomp/configure.ac b/libgomp/configure.ac
index 0e238b6a559..78a253c0f93 100644
--- a/libgomp/configure.ac
+++ b/libgomp/configure.ac
@@ -331,6 +331,13 @@ fi
 AX_COUNT_CPUS
 AC_SUBST(CPU_COUNT)
 
+AC_MSG_NOTICE([checking for flock implementation])
+AC_CHECK_PROGS(FLOCK, flock)
+# Fallback if 'perl' is available.
+if test -z "$FLOCK"; then
+  AC_CHECK_PROG(FLOCK, perl, $srcdir/testsuite/flock)
+fi
+
 # Get target configury.
 . ${srcdir}/configure.tgt
 CFLAGS="$save_CFLAGS $XCFLAGS"
diff --git a/libgomp/libgomp.texi b/libgomp/libgomp.texi
index 2c1f1b5968b..ec86f44a8ea 100644
--- a/libgomp/libgomp.texi
+++ b/libgomp/libgomp.texi
@@ -176,7 +176,7 @@ linkage, and do not throw exceptions.
 * omp_get_num_procs::           Number of processors online
 * omp_get_num_teams::           Number of teams
 * omp_get_num_threads::         Size of the active team
-* omp_get_proc_bind::           Whether theads may be moved between CPUs
+* omp_get_proc_bind::           Whether threads may be moved between CPUs
 * omp_get_schedule::            Obtain the runtime scheduling method
 * omp_get_supported_active_levels:: Maximum number of active regions supported
 * omp_get_team_num::            Get team number
@@ -626,7 +626,7 @@ one thread per CPU online is used.
 
 
 @node omp_get_proc_bind
-@section @code{omp_get_proc_bind} -- Whether theads may be moved between CPUs
+@section @code{omp_get_proc_bind} -- Whether threads may be moved between CPUs
 @table @asis
 @item @emph{Description}:
 This functions returns the currently active thread affinity policy, which is
@@ -1455,8 +1455,8 @@ beginning with @env{GOMP_} are GNU extensions.
 * OMP_MAX_TASK_PRIORITY::   Set the maximum task priority value
 * OMP_NESTED::              Nested parallel regions
 * OMP_NUM_THREADS::         Specifies the number of threads to use
-* OMP_PROC_BIND::           Whether theads may be moved between CPUs
-* OMP_PLACES::              Specifies on which CPUs the theads should be placed
+* OMP_PROC_BIND::           Whether threads may be moved between CPUs
+* OMP_PLACES::              Specifies on which CPUs the threads should be placed
 * OMP_STACKSIZE::           Set default thread stack size
 * OMP_SCHEDULE::            How threads are scheduled
 * OMP_TARGET_OFFLOAD::      Controls offloading behaviour
@@ -1634,12 +1634,12 @@ nesting by default.  If undefined one thread per CPU is used.
 
 
 @node OMP_PROC_BIND
-@section @env{OMP_PROC_BIND} -- Whether theads may be moved between CPUs
+@section @env{OMP_PROC_BIND} -- Whether threads may be moved between CPUs
 @cindex Environment Variable
 @table @asis
 @item @emph{Description}:
 Specifies whether threads may be moved between processors.  If set to
-@code{TRUE}, OpenMP theads should not be moved; if set to @code{FALSE}
+@code{TRUE}, OpenMP threads should not be moved; if set to @code{FALSE}
 they may be moved.  Alternatively, a comma separated list with the
 values @code{MASTER}, @code{CLOSE} and @code{SPREAD} can be used to specify
 the thread affinity policy for the corresponding nesting level.  With
@@ -1663,7 +1663,7 @@ When undefined, @env{OMP_PROC_BIND} defaults to @code{TRUE} when
 
 
 @node OMP_PLACES
-@section @env{OMP_PLACES} -- Specifies on which CPUs the theads should be placed
+@section @env{OMP_PLACES} -- Specifies on which CPUs the threads should be placed
 @cindex Environment Variable
 @table @asis
 @item @emph{Description}:
diff --git a/libgomp/target.c b/libgomp/target.c
index 4a4e1f80745..98a791770e7 100644
--- a/libgomp/target.c
+++ b/libgomp/target.c
@@ -2192,6 +2192,7 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,
 	{
 	  struct gomp_team *team = gomp_new_team (1);
 	  struct gomp_task *task = thr->task;
+	  struct gomp_task **implicit_task = &task;
 	  struct gomp_task_icv *icv = task ? &task->icv : &gomp_global_icv;
 	  team->prev_ts = thr->ts;
 	  thr->ts.team = team;
@@ -2204,15 +2205,23 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,
 	  thr->ts.static_trip = 0;
 	  thr->task = &team->implicit_task[0];
 	  gomp_init_task (thr->task, NULL, icv);
-	  if (task)
+	  while (*implicit_task
+		 && (*implicit_task)->kind != GOMP_TASK_IMPLICIT)
+	    implicit_task = &(*implicit_task)->parent;
+	  if (*implicit_task)
 	    {
-	      thr->task = task;
+	      thr->task = *implicit_task;
 	      gomp_end_task ();
-	      free (task);
+	      free (*implicit_task);
 	      thr->task = &team->implicit_task[0];
 	    }
 	  else
 	    pthread_setspecific (gomp_thread_destructor, thr);
+	  if (implicit_task != &task)
+	    {
+	      *implicit_task = thr->task;
+	      thr->task = task;
+	    }
 	}
       if (thr->ts.team
 	  && !thr->task->final_task)
diff --git a/libgomp/task.c b/libgomp/task.c
index f5d26873d5b..80274e950be 100644
--- a/libgomp/task.c
+++ b/libgomp/task.c
@@ -2202,6 +2202,7 @@ gomp_create_artificial_team (void)
   struct gomp_task_icv *icv;
   struct gomp_team *team = gomp_new_team (1);
   struct gomp_task *task = thr->task;
+  struct gomp_task **implicit_task = &task;
   icv = task ? &task->icv : &gomp_global_icv;
   team->prev_ts = thr->ts;
   thr->ts.team = team;
@@ -2214,17 +2215,25 @@ gomp_create_artificial_team (void)
   thr->ts.static_trip = 0;
   thr->task = &team->implicit_task[0];
   gomp_init_task (thr->task, NULL, icv);
-  if (task)
+  while (*implicit_task
+	 && (*implicit_task)->kind != GOMP_TASK_IMPLICIT)
+    implicit_task = &(*implicit_task)->parent;
+  if (*implicit_task)
     {
-      thr->task = task;
+      thr->task = *implicit_task;
       gomp_end_task ();
-      free (task);
+      free (*implicit_task);
       thr->task = &team->implicit_task[0];
     }
 #ifdef LIBGOMP_USE_PTHREADS
   else
     pthread_setspecific (gomp_thread_destructor, thr);
 #endif
+  if (implicit_task != &task)
+    {
+      *implicit_task = thr->task;
+      thr->task = task;
+    }
 }
 
 /* The format of data is:
diff --git a/libgomp/testsuite/Makefile.am b/libgomp/testsuite/Makefile.am
index 655a413c160..0cc91ccc4d1 100644
--- a/libgomp/testsuite/Makefile.am
+++ b/libgomp/testsuite/Makefile.am
@@ -12,6 +12,8 @@ _RUNTEST = $(shell if test -f $(top_srcdir)/../dejagnu/runtest; then \
 	     echo $(top_srcdir)/../dejagnu/runtest; else echo runtest; fi)
 RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir
 
+PWD_COMMAND = $${PWDCMD-pwd}
+
 EXTRA_DEJAGNU_SITE_CONFIG = libgomp-site-extra.exp
 
 # Instead of directly in ../testsuite/libgomp-test-support.exp.in, the
@@ -25,17 +27,6 @@ libgomp-test-support.exp: libgomp-test-support.pt.exp Makefile
 	  'set offload_additional_lib_paths "$(offload_additional_lib_paths)"'
 	mv $@.tmp $@
 
-check-DEJAGNU: site.exp
-	srcdir='$(srcdir)'; export srcdir; \
-	EXPECT=$(EXPECT); export EXPECT; \
-	if $(SHELL) -c "$(_RUNTEST) --version" > /dev/null 2>&1; then \
-	  exit_status=0; l='$(PACKAGE)'; for tool in $$l; do \
-	    if $(_RUNTEST) $(AM_RUNTESTFLAGS) $(RUNTESTDEFAULTFLAGS) $(RUNTESTFLAGS); \
-	    then :; else exit_status=1; fi; \
-	  done; \
-	else echo "WARNING: could not find '$(_RUNTEST)'" 1>&2; :;\
-	fi; \
-	exit $$exit_status
 site.exp: Makefile $(EXTRA_DEJAGNU_SITE_CONFIG)
 	@echo 'Making a new site.exp file ...'
 	@echo '## these variables are automatically generated by make ##' >site.tmp
@@ -63,6 +54,72 @@ site.exp: Makefile $(EXTRA_DEJAGNU_SITE_CONFIG)
 	@test ! -f site.exp || mv site.exp site.bak
 	@mv site.tmp site.exp
 
+%/site.exp: site.exp
+	-@test -d $* || mkdir $*
+	@srcdir=`cd $(srcdir); ${PWD_COMMAND}`;
+	@objdir=`${PWD_COMMAND}`/$*; \
+	sed -e "s|^set srcdir .*$$|set srcdir $$srcdir|" \
+	    -e "s|^set objdir .*$$|set objdir $$objdir|" \
+	    site.exp > $*/site.exp.tmp
+	@-rm -f $*/site.bak
+	@test ! -f $*/site.exp || mv $*/site.exp $*/site.bak
+	@mv $*/site.exp.tmp $*/site.exp
+
+check_p_numbers0:=1 2 3 4 5 6 7 8 9
+check_p_numbers1:=0 $(check_p_numbers0)
+check_p_numbers2:=$(foreach i,$(check_p_numbers0),$(addprefix $(i),$(check_p_numbers1)))
+check_p_numbers3:=$(addprefix 0,$(check_p_numbers1)) $(check_p_numbers2)
+check_p_numbers4:=$(foreach i,$(check_p_numbers0),$(addprefix $(i),$(check_p_numbers3)))
+check_p_numbers5:=$(addprefix 0,$(check_p_numbers3)) $(check_p_numbers4)
+check_p_numbers6:=$(foreach i,$(check_p_numbers0),$(addprefix $(i),$(check_p_numbers5)))
+check_p_numbers:=$(check_p_numbers0) $(check_p_numbers2) $(check_p_numbers4) $(check_p_numbers6)
+# If unable to serialize execution testing, use just one parallel slot.
+gcc_test_parallel_slots:=$(if $(FLOCK),$(if $(GCC_TEST_PARALLEL_SLOTS),$(GCC_TEST_PARALLEL_SLOTS),19),1)
+check_p_subdirs=$(wordlist 1,$(gcc_test_parallel_slots),$(check_p_numbers))
+check_DEJAGNU_libgomp_targets = $(addprefix check-DEJAGNUlibgomp,$(check_p_subdirs))
+$(check_DEJAGNU_libgomp_targets): check-DEJAGNUlibgomp%: libgomp%/site.exp
+
+check-DEJAGNU $(check_DEJAGNU_libgomp_targets): check-DEJAGNU%: site.exp
+	$(if $*,@)AR="$(AR)"; export AR; \
+	RANLIB="$(RANLIB)"; export RANLIB; \
+	if [ -z "$*" ] && [ -n "$(filter -j%, $(MFLAGS))" ]; then \
+	  rm -rf libgomp-parallel || true; \
+	  mkdir libgomp-parallel; \
+	  $(MAKE) $(AM_MAKEFLAGS) $(check_DEJAGNU_libgomp_targets); \
+	  rm -rf libgomp-parallel || true; \
+	  for idx in $(check_p_subdirs); do \
+	    if [ -d libgomp$$idx ]; then \
+	      mv -f libgomp$$idx/libgomp.sum libgomp$$idx/libgomp.sum.sep; \
+	      mv -f libgomp$$idx/libgomp.log libgomp$$idx/libgomp.log.sep; \
+	    fi; \
+	  done; \
+	  $(SHELL) $(srcdir)/../../contrib/dg-extract-results.sh \
+	    libgomp[0-9]*/libgomp.sum.sep > libgomp.sum; \
+	  $(SHELL) $(srcdir)/../../contrib/dg-extract-results.sh -L \
+	    libgomp[0-9]*/libgomp.log.sep > libgomp.log; \
+	  exit 0; \
+	fi; \
+	srcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \
+	EXPECT=$(EXPECT); export EXPECT; \
+	runtest=$(_RUNTEST); \
+	if [ -z "$$runtest" ]; then runtest=runtest; fi; \
+	tool=libgomp; \
+	if [ -n "$*" ]; then \
+	  if [ -f libgomp-parallel/finished ]; then rm -rf "$*"; exit 0; fi; \
+	  GCC_RUNTEST_PARALLELIZE_DIR=`${PWD_COMMAND}`/libgomp-parallel; \
+	  export GCC_RUNTEST_PARALLELIZE_DIR; \
+	  cd "$*"; \
+	fi; \
+	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	  $$runtest $(AM_RUNTESTFLAGS) $(RUNTESTDEFAULTFLAGS) \
+		    $(RUNTESTFLAGS); \
+	  if [ -n "$*" ]; then \
+	    touch $$GCC_RUNTEST_PARALLELIZE_DIR/finished; \
+	  fi; \
+	else \
+	  echo "WARNING: could not find \`runtest'" 1>&2; :;\
+	fi
+
 distclean-DEJAGNU:
 	-rm -f site.exp site.bak
 	-l='$(PACKAGE)'; for tool in $$l; do \
diff --git a/libgomp/testsuite/Makefile.in b/libgomp/testsuite/Makefile.in
index e48c3f2f9b0..cd318e3c392 100644
--- a/libgomp/testsuite/Makefile.in
+++ b/libgomp/testsuite/Makefile.in
@@ -162,6 +162,7 @@ EXEEXT = @EXEEXT@
 FC = @FC@
 FCFLAGS = @FCFLAGS@
 FGREP = @FGREP@
+FLOCK = @FLOCK@
 GREP = @GREP@
 HSA_RUNTIME_INCLUDE = @HSA_RUNTIME_INCLUDE@
 HSA_RUNTIME_LIB = @HSA_RUNTIME_LIB@
@@ -310,7 +311,20 @@ _RUNTEST = $(shell if test -f $(top_srcdir)/../dejagnu/runtest; then \
 	     echo $(top_srcdir)/../dejagnu/runtest; else echo runtest; fi)
 
 RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir
+PWD_COMMAND = $${PWDCMD-pwd}
 EXTRA_DEJAGNU_SITE_CONFIG = libgomp-site-extra.exp
+check_p_numbers0 := 1 2 3 4 5 6 7 8 9
+check_p_numbers1 := 0 $(check_p_numbers0)
+check_p_numbers2 := $(foreach i,$(check_p_numbers0),$(addprefix $(i),$(check_p_numbers1)))
+check_p_numbers3 := $(addprefix 0,$(check_p_numbers1)) $(check_p_numbers2)
+check_p_numbers4 := $(foreach i,$(check_p_numbers0),$(addprefix $(i),$(check_p_numbers3)))
+check_p_numbers5 := $(addprefix 0,$(check_p_numbers3)) $(check_p_numbers4)
+check_p_numbers6 := $(foreach i,$(check_p_numbers0),$(addprefix $(i),$(check_p_numbers5)))
+check_p_numbers := $(check_p_numbers0) $(check_p_numbers2) $(check_p_numbers4) $(check_p_numbers6)
+# If unable to serialize execution testing, use just one parallel slot.
+gcc_test_parallel_slots := $(if $(FLOCK),$(if $(GCC_TEST_PARALLEL_SLOTS),$(GCC_TEST_PARALLEL_SLOTS),19),1)
+check_p_subdirs = $(wordlist 1,$(gcc_test_parallel_slots),$(check_p_numbers))
+check_DEJAGNU_libgomp_targets = $(addprefix check-DEJAGNUlibgomp,$(check_p_subdirs))
 all: all-am
 
 .SUFFIXES:
@@ -485,17 +499,6 @@ libgomp-test-support.exp: libgomp-test-support.pt.exp Makefile
 	  'set offload_additional_lib_paths "$(offload_additional_lib_paths)"'
 	mv $@.tmp $@
 
-check-DEJAGNU: site.exp
-	srcdir='$(srcdir)'; export srcdir; \
-	EXPECT=$(EXPECT); export EXPECT; \
-	if $(SHELL) -c "$(_RUNTEST) --version" > /dev/null 2>&1; then \
-	  exit_status=0; l='$(PACKAGE)'; for tool in $$l; do \
-	    if $(_RUNTEST) $(AM_RUNTESTFLAGS) $(RUNTESTDEFAULTFLAGS) $(RUNTESTFLAGS); \
-	    then :; else exit_status=1; fi; \
-	  done; \
-	else echo "WARNING: could not find '$(_RUNTEST)'" 1>&2; :;\
-	fi; \
-	exit $$exit_status
 site.exp: Makefile $(EXTRA_DEJAGNU_SITE_CONFIG)
 	@echo 'Making a new site.exp file ...'
 	@echo '## these variables are automatically generated by make ##' >site.tmp
@@ -523,6 +526,59 @@ site.exp: Makefile $(EXTRA_DEJAGNU_SITE_CONFIG)
 	@test ! -f site.exp || mv site.exp site.bak
 	@mv site.tmp site.exp
 
+%/site.exp: site.exp
+	-@test -d $* || mkdir $*
+	@srcdir=`cd $(srcdir); ${PWD_COMMAND}`;
+	@objdir=`${PWD_COMMAND}`/$*; \
+	sed -e "s|^set srcdir .*$$|set srcdir $$srcdir|" \
+	    -e "s|^set objdir .*$$|set objdir $$objdir|" \
+	    site.exp > $*/site.exp.tmp
+	@-rm -f $*/site.bak
+	@test ! -f $*/site.exp || mv $*/site.exp $*/site.bak
+	@mv $*/site.exp.tmp $*/site.exp
+$(check_DEJAGNU_libgomp_targets): check-DEJAGNUlibgomp%: libgomp%/site.exp
+
+check-DEJAGNU $(check_DEJAGNU_libgomp_targets): check-DEJAGNU%: site.exp
+	$(if $*,@)AR="$(AR)"; export AR; \
+	RANLIB="$(RANLIB)"; export RANLIB; \
+	if [ -z "$*" ] && [ -n "$(filter -j%, $(MFLAGS))" ]; then \
+	  rm -rf libgomp-parallel || true; \
+	  mkdir libgomp-parallel; \
+	  $(MAKE) $(AM_MAKEFLAGS) $(check_DEJAGNU_libgomp_targets); \
+	  rm -rf libgomp-parallel || true; \
+	  for idx in $(check_p_subdirs); do \
+	    if [ -d libgomp$$idx ]; then \
+	      mv -f libgomp$$idx/libgomp.sum libgomp$$idx/libgomp.sum.sep; \
+	      mv -f libgomp$$idx/libgomp.log libgomp$$idx/libgomp.log.sep; \
+	    fi; \
+	  done; \
+	  $(SHELL) $(srcdir)/../../contrib/dg-extract-results.sh \
+	    libgomp[0-9]*/libgomp.sum.sep > libgomp.sum; \
+	  $(SHELL) $(srcdir)/../../contrib/dg-extract-results.sh -L \
+	    libgomp[0-9]*/libgomp.log.sep > libgomp.log; \
+	  exit 0; \
+	fi; \
+	srcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \
+	EXPECT=$(EXPECT); export EXPECT; \
+	runtest=$(_RUNTEST); \
+	if [ -z "$$runtest" ]; then runtest=runtest; fi; \
+	tool=libgomp; \
+	if [ -n "$*" ]; then \
+	  if [ -f libgomp-parallel/finished ]; then rm -rf "$*"; exit 0; fi; \
+	  GCC_RUNTEST_PARALLELIZE_DIR=`${PWD_COMMAND}`/libgomp-parallel; \
+	  export GCC_RUNTEST_PARALLELIZE_DIR; \
+	  cd "$*"; \
+	fi; \
+	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	  $$runtest $(AM_RUNTESTFLAGS) $(RUNTESTDEFAULTFLAGS) \
+		    $(RUNTESTFLAGS); \
+	  if [ -n "$*" ]; then \
+	    touch $$GCC_RUNTEST_PARALLELIZE_DIR/finished; \
+	  fi; \
+	else \
+	  echo "WARNING: could not find \`runtest'" 1>&2; :;\
+	fi
+
 distclean-DEJAGNU:
 	-rm -f site.exp site.bak
 	-l='$(PACKAGE)'; for tool in $$l; do \
diff --git a/libgomp/testsuite/config/default.exp b/libgomp/testsuite/config/default.exp
index 20546e371fd..0b383cc83e1 100644
--- a/libgomp/testsuite/config/default.exp
+++ b/libgomp/testsuite/config/default.exp
@@ -13,5 +13,3 @@
 # You should have received a copy of the GNU General Public License
 # along with this program; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
-
-load_lib "standard.exp"
diff --git a/libgomp/testsuite/flock b/libgomp/testsuite/flock
new file mode 100755
index 00000000000..71878b104f1
--- /dev/null
+++ b/libgomp/testsuite/flock
@@ -0,0 +1,17 @@
+#!/usr/bin/env perl
+
+use strict;
+use warnings;
+
+# Only arguments '--exclusive 1' exactly are supported.
+(@ARGV == 2) or die;
+my $mode = shift;
+($mode eq "--exclusive") or die;
+my $fd = shift;
+($fd eq "1") or die;
+
+use Fcntl ':flock';
+
+open(my $fh, '>&=', 1) or die "open: $!";
+
+flock($fh, LOCK_EX) or die "flock: $!";
diff --git a/libgomp/testsuite/lib/libgomp.exp b/libgomp/testsuite/lib/libgomp.exp
index 46cce9b8445..512a5146ac6 100644
--- a/libgomp/testsuite/lib/libgomp.exp
+++ b/libgomp/testsuite/lib/libgomp.exp
@@ -9,6 +9,7 @@ proc load_gcc_lib { filename } {
 }
 
 load_lib dg.exp
+load_lib standard.exp
 
 # Required to use gcc-dg.exp - however, the latter should NOT be
 # loaded until ${tool}_target_compile is defined since it uses that
@@ -40,7 +41,12 @@ load_gcc_lib torture-options.exp
 load_gcc_lib fortran-modules.exp
 
 # Try to load a test support file, built during libgomp configuration.
-load_file libgomp-test-support.exp
+# Search in '..' vs. '.' to support parallel vs. sequential testing.
+if [info exists ::env(GCC_RUNTEST_PARALLELIZE_DIR)] {
+    load_file ../libgomp-test-support.exp
+} else {
+    load_file libgomp-test-support.exp
+}
 
 set dg-do-what-default run
 
@@ -318,6 +324,36 @@ proc libgomp_option_proc { option } {
     }
 }
 
+if ![info exists ::env(GCC_RUNTEST_PARALLELIZE_DIR)] {
+    # No parallel testing.
+} elseif { $FLOCK == "" } {
+    # Using just one parallel slot.
+} else {
+    # Using several parallel slots.  Override DejaGnu
+    # 'standard.exp:${tool}_load'...
+    rename libgomp_load standard_libgomp_load
+    proc libgomp_load { program args } {
+	# ... in order to serialize execution testing via an exclusive lock.
+	# We use stdout, as per <https://perldoc.perl.org/functions/flock>
+	# "[...] FILEHANDLE [...] be open with write intent to use LOCK_EX".
+	set lock_file ../lock
+	set lock_kind --exclusive
+	set lock_fd [open $lock_file a+]
+	set lock_clock_begin [clock seconds]
+	global FLOCK
+	exec $FLOCK $lock_kind 1 >@ $lock_fd
+	set lock_clock_end [clock seconds]
+	verbose -log "Got ${FLOCK}('$lock_file', '$lock_kind') at [clock format $lock_clock_end] after [expr $lock_clock_end - $lock_clock_begin] s" 2
+
+	set result [standard_libgomp_load $program $args]
+
+	# Unlock (implicit with 'close').
+	close $lock_fd
+
+	return $result
+    }
+}
+
 # Translate offload target to OpenACC device type.  Return the empty string if
 # not supported, and 'host' for offload target 'disable'.
 proc offload_target_to_openacc_device_type { offload_target } {
diff --git a/libgomp/testsuite/libgomp-site-extra.exp.in b/libgomp/testsuite/libgomp-site-extra.exp.in
index c0d26660bad..0a3ba059c21 100644
--- a/libgomp/testsuite/libgomp-site-extra.exp.in
+++ b/libgomp/testsuite/libgomp-site-extra.exp.in
@@ -1 +1,2 @@
+set FLOCK {@FLOCK@}
 set GCC_UNDER_TEST {@CC@}
diff --git a/libgomp/testsuite/libgomp.c++/pr108180.C b/libgomp/testsuite/libgomp.c++/pr108180.C
new file mode 100644
index 00000000000..452910cebeb
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c++/pr108180.C
@@ -0,0 +1,55 @@
+// PR c++/108180
+// { dg-do run }
+
+struct A {
+  A () { ++a; }
+  A (A &&) = delete;
+  A (const A &) { ++a; }
+  A &operator= (const A &) = delete;
+  A &operator= (A &&) = delete;
+  ~A () { --a; }
+  static int a;
+};
+int A::a = 0;
+
+struct B {
+  A a;
+  template <int N>
+  int
+  foo ()
+  {
+    int res = 0;
+    #pragma omp parallel for if(false) firstprivate(a)
+    for (int i = 0; i < 64; ++i)
+      res += i;
+    return res;
+  }
+  int
+  bar ()
+  {
+    int res = 0;
+    #pragma omp parallel for if(false) firstprivate(a)
+    for (int i = 0; i < 64; ++i)
+      res += i;
+    return res;
+  }
+};
+
+int
+main ()
+{
+  {
+    B b;
+    if (b.foo<0> () != 2016)
+      __builtin_abort ();
+  }
+  if (A::a != 0)
+    __builtin_abort ();
+  {
+    B b;
+    if (b.bar () != 2016)
+      __builtin_abort ();
+  }
+  if (A::a != 0)
+    __builtin_abort ();
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/pr106981.c b/libgomp/testsuite/libgomp.c-c++-common/pr106981.c
new file mode 100644
index 00000000000..ed48d2774f2
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/pr106981.c
@@ -0,0 +1,19 @@
+/* PR c/106981 */
+
+int
+main ()
+{
+  int a[0x101];
+  unsigned int b = 0x100;
+  if ((unsigned char) b || (unsigned short) b != 0x100)
+    return 0;
+  a[0] = 0;
+  a[0x100] = 42;
+  #pragma omp atomic update
+  a[(unsigned char) b] = a[(unsigned short) b] + a[(unsigned char) b];
+  #pragma omp atomic update
+  a[(unsigned char) b] = a[(unsigned char) b] + a[(unsigned short) b];
+  if (a[0] != 84 || a[0x100] != 42)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/task-reduction-17.c b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-17.c
new file mode 100644
index 00000000000..4a8d1e8bb73
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-17.c
@@ -0,0 +1,36 @@
+/* { dg-do run } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int a;
+
+int
+main ()
+{
+  #pragma omp task final (1)
+  {
+    if (!omp_in_final ())
+      abort ();
+    #pragma omp task
+    {
+      if (!omp_in_final ())
+	abort ();
+      #pragma omp taskgroup task_reduction (+: a)
+      {
+	if (!omp_in_final ())
+	  abort ();
+	#pragma omp task in_reduction (+: a)
+	{
+	  ++a;
+	  if (!omp_in_final ())
+	    abort ();
+	}
+      }
+      if (!omp_in_final ())
+	abort ();
+      #pragma omp taskwait
+    }
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c-c++-common/task-reduction-18.c b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-18.c
new file mode 100644
index 00000000000..483f4406f6f
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c-c++-common/task-reduction-18.c
@@ -0,0 +1,17 @@
+/* { dg-do run } */
+
+int a;
+
+int
+main ()
+{
+  #pragma omp task
+  {
+    #pragma omp taskgroup task_reduction (+: a)
+    {
+      #pragma omp task in_reduction (+: a)
+      ++a;
+    }
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/pr108459.c b/libgomp/testsuite/libgomp.c/pr108459.c
new file mode 100644
index 00000000000..87ce981e080
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/pr108459.c
@@ -0,0 +1,41 @@
+/* PR middle-end/108459 */
+
+char a[17][17];
+
+__attribute__((noipa)) void
+foo (int x, int y)
+{
+  #pragma omp for collapse(2)
+  for (int i = 1; i <= 16; i++)
+    for (int j = i * x + y; j <= 16; j++)
+      a[i][j] = 1;
+}
+
+int
+main ()
+{
+  #pragma omp parallel
+  foo (1, 1);
+  for (int i = 0; i <= 16; i++)
+    for (int j = 0; j <= 16; j++)
+      if (i >= 1 && j >= i + 1)
+	{
+	  if (a[i][j] != 1)
+	    __builtin_abort ();
+	  a[i][j] = 0;
+	}
+      else if (a[i][j])
+	__builtin_abort ();
+  #pragma omp parallel
+  foo (2, -2);
+  for (int i = 0; i <= 16; i++)
+    for (int j = 0; j <= 16; j++)
+      if (i >= 1 && j >= 2 * i - 2)
+	{
+	  if (a[i][j] != 1)
+	    __builtin_abort ();
+	}
+      else if (a[i][j])
+	__builtin_abort ();
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/target-31.c b/libgomp/testsuite/libgomp.c/target-31.c
index 8e63d286b43..1123b7ea561 100644
--- a/libgomp/testsuite/libgomp.c/target-31.c
+++ b/libgomp/testsuite/libgomp.c/target-31.c
@@ -76,7 +76,7 @@ main ()
       m[1] += 3 * b;
     }
     use (&a, &b, &c, &d, e, f, g, h);
-    #pragma omp parallel firstprivate (u1, u2)
+    #pragma omp parallel firstprivate (u1, u2) private (i)
     {
       int w = omp_get_thread_num ();
       int x = 19;
diff --git a/libgomp/testsuite/libgomp.c/task-7.c b/libgomp/testsuite/libgomp.c/task-7.c
new file mode 100644
index 00000000000..0307575f978
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/task-7.c
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+
+#include <omp.h>
+#include <stdlib.h>
+
+int
+main ()
+{
+  #pragma omp task final (1)
+  {
+    if (!omp_in_final ())
+      abort ();
+    #pragma omp task
+    {
+      if (!omp_in_final ())
+	abort ();
+      #pragma omp target nowait
+      if (omp_in_final ())
+	abort ();
+      if (!omp_in_final ())
+	abort ();
+      #pragma omp taskwait
+    }
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.c/task-8.c b/libgomp/testsuite/libgomp.c/task-8.c
new file mode 100644
index 00000000000..f03aef6a030
--- /dev/null
+++ b/libgomp/testsuite/libgomp.c/task-8.c
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+
+int
+main ()
+{
+  int i = 0;
+  #pragma omp task
+  {
+    #pragma omp target nowait private (i)
+    i = 1;
+    #pragma omp taskwait
+  }
+  return 0;
+}
diff --git a/libgomp/testsuite/libgomp.fortran/is_device_ptr-3.f90 b/libgomp/testsuite/libgomp.fortran/is_device_ptr-3.f90
new file mode 100644
index 00000000000..18d0d38f718
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/is_device_ptr-3.f90
@@ -0,0 +1,47 @@
+module m
+   use iso_c_binding
+   implicit none
+contains
+   subroutine s(x,y,z)
+      type(c_ptr), optional :: x
+      integer, pointer, optional :: y
+      integer, allocatable, optional :: z
+      logical is_present, is_null
+      is_present = present(x)
+      if (is_present) &
+        is_null = .not. c_associated(x)
+
+      !$omp target is_device_ptr(x)
+        if (is_present) then
+          if (is_null) then
+            if (c_associated(x)) stop 1
+!            if (associated(y)) stop 2
+!            if (allocated(z)) stop 3
+          else
+            if (.not. c_associated(x)) stop 4
+!            if (.not. c_associated(x, c_loc(y))) stop 4
+!            if (y /= 7) stop 5
+!            if (z /= 9) stop 6
+          end if
+        end if
+      !$omp end target
+   end
+end
+
+use m
+implicit none
+integer, pointer :: p
+integer, allocatable :: a
+p => null()
+call s()
+!$omp target data map(p,a) use_device_addr(p,a)
+  call s(c_null_ptr, p, a)
+!$omp end target data
+allocate(p,a)
+p = 7
+a = 9
+!$omp target data map(p,a) use_device_addr(p,a)
+  call s(c_loc(p), p, a)
+!$omp end target data
+deallocate(p,a)
+end
diff --git a/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-4.f90 b/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-4.f90
new file mode 100644
index 00000000000..b2a5c314685
--- /dev/null
+++ b/libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-4.f90
@@ -0,0 +1,53 @@
+! PR middle-end/108546
+!
+module m
+   use iso_c_binding
+   implicit none
+   type(c_ptr) :: p2, p3
+contains
+   subroutine s(x,y,z)
+      type(c_ptr), optional :: x
+      integer, pointer, optional :: y
+      integer, allocatable, optional, target :: z
+      logical is_present, is_null
+      is_present = present(x)
+      if (is_present) &
+        is_null = .not. c_associated(x)
+
+      !$omp target data use_device_ptr(x) use_device_addr(y) use_device_addr(z)
+        if (is_present) then
+          if (is_null) then
+            if (c_associated(x)) stop 1
+            if (associated(y)) stop 2
+            if (allocated(z)) stop 3
+          else
+            if (.not. c_associated(x, p2)) stop 4
+            if (.not. c_associated(c_loc(y), p2)) stop 5
+            if (.not. c_associated(c_loc(z), p3)) stop 6
+          end if
+        end if
+      !$omp end target data
+   end
+end
+
+use m
+implicit none
+type(c_ptr) :: cp
+integer, pointer :: p
+integer, allocatable, target :: a
+call s()
+p => null()
+call s(c_null_ptr, p, a)
+allocate(p,a)
+p = 7
+a = 9
+cp = c_loc(p)
+!$omp target enter data map(to: cp, p, a)
+!$omp target map(from: p2, p3)
+  p2 = c_loc(p)
+  p3 = c_loc(a)
+!$omp end target
+call s(cp, p, a)
+!$omp target exit data map(delete: cp, p, a)
+deallocate(p,a)
+end
diff --git a/libhsail-rt/ChangeLog b/libhsail-rt/ChangeLog
index 8bca42d7614..07db466829c 100644
--- a/libhsail-rt/ChangeLog
+++ b/libhsail-rt/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libiberty/ChangeLog b/libiberty/ChangeLog
index e150febed85..4a80d292c07 100644
--- a/libiberty/ChangeLog
+++ b/libiberty/ChangeLog
@@ -1,3 +1,30 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-04-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR other/109306
+	* strstr.c: Revert the 2020-11-13 changes.
+	(strstr): Return s1 if len is 0.
+
+2023-01-04  Florian Weimer  <fweimer@redhat.com>
+
+	Backported from master:
+	2022-10-18  Florian Weimer  <fweimer@redhat.com>
+
+	* acinclude.m4 (ac_cv_func_strncmp_works): Add missing
+	int return type and parameter list to the definition of main.
+	Include <stdlib.h> and <string.h> for prototypes.
+	(ac_cv_c_stack_direction): Add missing
+	int return type and parameter list to the definitions of
+	main, find_stack_direction.  Include <stdlib.h> for exit
+	prototype.
+	* configure: Regenerate.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libiberty/acinclude.m4 b/libiberty/acinclude.m4
index 6db0e508517..8d89619a243 100644
--- a/libiberty/acinclude.m4
+++ b/libiberty/acinclude.m4
@@ -24,6 +24,8 @@ AC_CACHE_CHECK([for working strncmp], ac_cv_func_strncmp_works,
 [AC_TRY_RUN([
 /* Test by Jim Wilson and Kaveh Ghazi.
    Check whether strncmp reads past the end of its string parameters. */
+#include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #ifdef HAVE_FCNTL_H
@@ -51,7 +53,8 @@ AC_CACHE_CHECK([for working strncmp], ac_cv_func_strncmp_works,
 
 #define MAP_LEN 0x10000
 
-main ()
+int
+main (void)
 {
 #if defined(HAVE_MMAP) || defined(HAVE_MMAP_ANYWHERE)
   char *p;
@@ -157,7 +160,10 @@ if test $ac_cv_os_cray = yes; then
 fi
 
 AC_CACHE_CHECK(stack direction for C alloca, ac_cv_c_stack_direction,
-[AC_TRY_RUN([find_stack_direction ()
+[AC_TRY_RUN([#include <stdlib.h>
+
+int
+find_stack_direction (void)
 {
   static char *addr = 0;
   auto char dummy;
@@ -169,7 +175,9 @@ AC_CACHE_CHECK(stack direction for C alloca, ac_cv_c_stack_direction,
   else
     return (&dummy > addr) ? 1 : -1;
 }
-main ()
+
+int
+main (void)
 {
   exit (find_stack_direction() < 0);
 }],
diff --git a/libiberty/configure b/libiberty/configure
index e4d49732a09..26c882e7a97 100755
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -6745,7 +6745,10 @@ else
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-find_stack_direction ()
+#include <stdlib.h>
+
+int
+find_stack_direction (void)
 {
   static char *addr = 0;
   auto char dummy;
@@ -6757,7 +6760,9 @@ find_stack_direction ()
   else
     return (&dummy > addr) ? 1 : -1;
 }
-main ()
+
+int
+main (void)
 {
   exit (find_stack_direction() < 0);
 }
@@ -7582,6 +7587,8 @@ else
 
 /* Test by Jim Wilson and Kaveh Ghazi.
    Check whether strncmp reads past the end of its string parameters. */
+#include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 
 #ifdef HAVE_FCNTL_H
@@ -7609,7 +7616,8 @@ else
 
 #define MAP_LEN 0x10000
 
-main ()
+int
+main (void)
 {
 #if defined(HAVE_MMAP) || defined(HAVE_MMAP_ANYWHERE)
   char *p;
diff --git a/libiberty/strstr.c b/libiberty/strstr.c
index c6f68495a33..49209e8229f 100644
--- a/libiberty/strstr.c
+++ b/libiberty/strstr.c
@@ -18,18 +18,23 @@ length, the function returns @var{string}.
 
 #include <stddef.h>
 
-extern int memcmp (const void *, const void *, size_t);
+extern char *strchr (const char *, int);
+extern int strncmp (const void *, const void *, size_t);
 extern size_t strlen (const char *);
 
 char *
 strstr (const char *s1, const char *s2)
 {
+  const char *p = s1;
   const size_t len = strlen (s2);
-  while (*s1)
+
+  if (!len)
+    return s1;
+
+  for (; (p = strchr (p, *s2)) != 0; p++)
     {
-      if (!memcmp (s1, s2, len))
-	return (char *)s1;
-      ++s1;
+      if (strncmp (p, s2, len) == 0)
+	return (char *)p;
     }
   return (0);
 }
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
index c29f72f1879..f9ba399fbb9 100644
--- a/libitm/ChangeLog
+++ b/libitm/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libobjc/ChangeLog b/libobjc/ChangeLog
index 19816bdde4a..2f5716dc5ae 100644
--- a/libobjc/ChangeLog
+++ b/libobjc/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/liboffloadmic/ChangeLog b/liboffloadmic/ChangeLog
index 5e1f76a461d..36c5bdff4d9 100644
--- a/liboffloadmic/ChangeLog
+++ b/liboffloadmic/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index acd0b312ef2..6682b44d2a8 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,44 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2022-12-13  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/core/stdc/fenv.d: Compile in MIPS uClibc bindings on
+	MIPS_Any targets.
+	* libdruntime/core/stdc/math.d: Likewise.
+	* libdruntime/core/sys/posix/dlfcn.d: Likewise.
+	* libdruntime/core/sys/posix/setjmp.d: Add MIPS64 definitions for
+	CRuntime_UClibc.
+	* libdruntime/core/sys/posix/sys/types.d: Likewise.
+	* src/std/path.d (expandTilde): Handle more errno codes that could be
+	left set by getpwnam_r.
+	* src/std/stdio.d: Set CRuntime_UClibc as GENERIC_IO target.
+
+2022-06-15  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-12-01  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* testsuite/testsuite_flags.in: Add libphobos library directory as
+	search path to --gdcldflags.
+
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-09-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/unwind/generic.d (__aligned__): Define.
+	(_Unwind_Exception): Align struct to __aligned__.
+
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/emutls.d (emutlsDestroyThread): Clear the per-thread
+	TLS array, don't call free().
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libphobos/libdruntime/core/stdc/fenv.d b/libphobos/libdruntime/core/stdc/fenv.d
index 3002c022613..665f383167d 100644
--- a/libphobos/libdruntime/core/stdc/fenv.d
+++ b/libphobos/libdruntime/core/stdc/fenv.d
@@ -481,7 +481,7 @@ else version (CRuntime_UClibc)
 
         alias fexcept_t = ushort;
     }
-    else version (MIPS32)
+    else version (MIPS_Any)
     {
         struct fenv_t
         {
diff --git a/libphobos/libdruntime/core/stdc/math.d b/libphobos/libdruntime/core/stdc/math.d
index 2de6e579575..2a965444f2c 100644
--- a/libphobos/libdruntime/core/stdc/math.d
+++ b/libphobos/libdruntime/core/stdc/math.d
@@ -113,7 +113,7 @@ else version (CRuntime_UClibc)
         ///
         enum int FP_ILOGBNAN      = int.min;
     }
-    else version (MIPS32)
+    else version (MIPS_Any)
     {
         ///
         enum int FP_ILOGB0        = -int.max;
diff --git a/libphobos/libdruntime/core/sys/posix/dlfcn.d b/libphobos/libdruntime/core/sys/posix/dlfcn.d
index f6476ec3106..ff24896cdb6 100644
--- a/libphobos/libdruntime/core/sys/posix/dlfcn.d
+++ b/libphobos/libdruntime/core/sys/posix/dlfcn.d
@@ -316,7 +316,7 @@ else version (CRuntime_UClibc)
         enum RTLD_LOCAL             = 0;
         enum RTLD_NODELETE          = 0x01000;
     }
-    else version (MIPS32)
+    else version (MIPS_Any)
     {
         enum RTLD_LAZY              = 0x0001;
         enum RTLD_NOW               = 0x0002;
diff --git a/libphobos/libdruntime/core/sys/posix/setjmp.d b/libphobos/libdruntime/core/sys/posix/setjmp.d
index b98d321a883..547e52e8edc 100644
--- a/libphobos/libdruntime/core/sys/posix/setjmp.d
+++ b/libphobos/libdruntime/core/sys/posix/setjmp.d
@@ -366,6 +366,22 @@ else version (CRuntime_UClibc)
                 double[6] __fpregs;
         }
     }
+    else version (MIPS64)
+    {
+        struct __jmp_buf
+        {
+            long __pc;
+            long __sp;
+            long[8] __regs;
+            long __fp;
+            long __gp;
+            int __fpc_csr;
+            version (MIPS_N64)
+                double[8] __fpregs;
+            else
+                double[6] __fpregs;
+        }
+    }
     else
         static assert(0, "unimplemented");
 
diff --git a/libphobos/libdruntime/core/sys/posix/sys/types.d b/libphobos/libdruntime/core/sys/posix/sys/types.d
index abcea99019f..529df1bae82 100644
--- a/libphobos/libdruntime/core/sys/posix/sys/types.d
+++ b/libphobos/libdruntime/core/sys/posix/sys/types.d
@@ -1277,6 +1277,18 @@ else version (CRuntime_UClibc)
         enum __SIZEOF_PTHREAD_BARRIER_T     = 20;
         enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
      }
+     else version (MIPS64)
+     {
+        enum __SIZEOF_PTHREAD_ATTR_T        = 56;
+        enum __SIZEOF_PTHREAD_MUTEX_T       = 40;
+        enum __SIZEOF_PTHREAD_MUTEXATTR_T   = 4;
+        enum __SIZEOF_PTHREAD_COND_T        = 48;
+        enum __SIZEOF_PTHREAD_CONDATTR_T    = 4;
+        enum __SIZEOF_PTHREAD_RWLOCK_T      = 56;
+        enum __SIZEOF_PTHREAD_RWLOCKATTR_T  = 8;
+        enum __SIZEOF_PTHREAD_BARRIER_T     = 32;
+        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
+     }
      else version (ARM)
      {
         enum __SIZEOF_PTHREAD_ATTR_T = 36;
diff --git a/libphobos/libdruntime/gcc/emutls.d b/libphobos/libdruntime/gcc/emutls.d
index 462230508ab..ebeeb8deda3 100644
--- a/libphobos/libdruntime/gcc/emutls.d
+++ b/libphobos/libdruntime/gcc/emutls.d
@@ -222,9 +222,9 @@ void** emutlsAlloc(shared __emutls_object* obj) nothrow @nogc
 }
 
 /*
- * When a thread has finished, remove the TLS array from the GC
- * scan list emutlsArrays, free all allocated TLS variables and
- * finally free the array.
+ * When a thread has finished, free all allocated TLS variables and empty the
+ * array.  The pointer is not free'd as it is stil referenced by the GC scan
+ * list emutlsArrays, which gets destroyed when druntime is unloaded.
  */
 extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
 {
@@ -236,7 +236,7 @@ extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
             free(entry[-1]);
     }
 
-    free(arr);
+    arr.length = 0;
 }
 
 /*
diff --git a/libphobos/libdruntime/gcc/unwind/generic.d b/libphobos/libdruntime/gcc/unwind/generic.d
index 592b3afcb71..68ddd1d5410 100644
--- a/libphobos/libdruntime/gcc/unwind/generic.d
+++ b/libphobos/libdruntime/gcc/unwind/generic.d
@@ -123,7 +123,27 @@ enum : _Unwind_Reason_Code
 // @@@ The IA-64 ABI says that this structure must be double-word aligned.
 // Taking that literally does not make much sense generically.  Instead we
 // provide the maximum alignment required by any type for the machine.
-struct _Unwind_Exception
+     version (ARM)      private enum __aligned__ = 8;
+else version (AArch64)  private enum __aligned__ = 16;
+else version (HPPA)     private enum __aligned__ = 8;
+else version (HPPA64)   private enum __aligned__ = 16;
+else version (MIPS_N32) private enum __aligned__ = 16;
+else version (MIPS_N64) private enum __aligned__ = 16;
+else version (MIPS32)   private enum __aligned__ = 8;
+else version (MIPS64)   private enum __aligned__ = 8;
+else version (PPC)      private enum __aligned__ = 16;
+else version (PPC64)    private enum __aligned__ = 16;
+else version (RISCV32)  private enum __aligned__ = 16;
+else version (RISCV64)  private enum __aligned__ = 16;
+else version (S390)     private enum __aligned__ = 8;
+else version (SPARC)    private enum __aligned__ = 8;
+else version (SPARC64)  private enum __aligned__ = 16;
+else version (SystemZ)  private enum __aligned__ = 8;
+else version (X86)      private enum __aligned__ = 16;
+else version (X86_64)   private enum __aligned__ = 16;
+else static assert( false, "Platform not supported.");
+
+align(__aligned__) struct _Unwind_Exception
 {
     _Unwind_Exception_Class exception_class;
     _Unwind_Exception_Cleanup_Fn exception_cleanup;
diff --git a/libphobos/src/std/path.d b/libphobos/src/std/path.d
index 4a435efba6c..d250953ee1c 100644
--- a/libphobos/src/std/path.d
+++ b/libphobos/src/std/path.d
@@ -3850,7 +3850,7 @@ string expandTilde(string inputPath) nothrow
     version (Posix)
     {
         import core.exception : onOutOfMemoryError;
-        import core.stdc.errno : errno, ERANGE;
+        import core.stdc.errno : errno, EBADF, ENOENT, EPERM, ERANGE, ESRCH;
         import core.stdc.stdlib : malloc, free, realloc;
 
         /*  Joins a path from a C string to the remainder of path.
@@ -3950,7 +3950,7 @@ string expandTilde(string inputPath) nothrow
                 scope(exit) free(extra_memory);
 
                 passwd result;
-                while (1)
+                loop: while (1)
                 {
                     extra_memory = cast(char*) realloc(extra_memory, extra_memory_size * char.sizeof);
                     if (extra_memory == null)
@@ -3969,10 +3969,23 @@ string expandTilde(string inputPath) nothrow
                         break;
                     }
 
-                    if (errno != ERANGE &&
+                    switch (errno)
+                    {
+                        case ERANGE:
                         // On BSD and OSX, errno can be left at 0 instead of set to ERANGE
-                        errno != 0)
-                        onOutOfMemoryError();
+                        case 0:
+                            break;
+
+                        case ENOENT:
+                        case ESRCH:
+                        case EBADF:
+                        case EPERM:
+                            // The given name or uid was not found.
+                            break loop;
+
+                        default:
+                            onOutOfMemoryError();
+                    }
 
                     // extra_memory isn't large enough
                     import core.checkedint : mulu;
diff --git a/libphobos/src/std/stdio.d b/libphobos/src/std/stdio.d
index bbf785773d4..1dc91bc2e35 100644
--- a/libphobos/src/std/stdio.d
+++ b/libphobos/src/std/stdio.d
@@ -52,8 +52,7 @@ else version (CRuntime_Musl)
 }
 else version (CRuntime_UClibc)
 {
-    // uClibc supports GCC IO
-    version = GCC_IO;
+    version = GENERIC_IO;
 }
 else version (OSX)
 {
diff --git a/libphobos/testsuite/testsuite_flags.in b/libphobos/testsuite/testsuite_flags.in
index bafd5ad4502..8e2f1eefd5b 100755
--- a/libphobos/testsuite/testsuite_flags.in
+++ b/libphobos/testsuite/testsuite_flags.in
@@ -46,6 +46,7 @@ case ${query} in
     --gdcldflags)
       GDCLDFLAGS="-B${BUILD_DIR}/src
                   -B${BUILD_DIR}/libdruntime/gcc
+                  -B${BUILD_DIR}/src/.libs
                   -L${BUILD_DIR}/src/.libs"
       echo ${GDCLDFLAGS}
       ;;
diff --git a/libquadmath/ChangeLog b/libquadmath/ChangeLog
index 6f7c20c430d..8733d230628 100644
--- a/libquadmath/ChangeLog
+++ b/libquadmath/ChangeLog
@@ -1,3 +1,22 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-02  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2023-03-02  niXman  <i.nixman@autistici.org>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR libquadmath/87204
+	PR libquadmath/94756
+	* strtod/strtod_l.c (round_and_return): Cherry-pick glibc
+	9310c284ae9 BZ #16151, 4406c41c1d6 BZ #16965 and fcd6b5ac36a
+	BZ #23279 fixes.
+	(____STRTOF_INTERNAL): Cherry-pick glibc b0debe14fcf BZ #23007,
+	5556d30caee BZ #18247, 09555b9721d and c6aac3bf366 BZ #26137 and
+	d84f25c7d87 fixes.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libquadmath/strtod/strtod_l.c b/libquadmath/strtod/strtod_l.c
index 0b0e85a3cf7..38602841cd7 100644
--- a/libquadmath/strtod/strtod_l.c
+++ b/libquadmath/strtod/strtod_l.c
@@ -200,7 +200,7 @@ round_and_return (mp_limb_t *retval, intmax_t exponent, int negative,
 
 	  round_limb = retval[RETURN_LIMB_SIZE - 1];
 	  round_bit = (MANT_DIG - 1) % BITS_PER_MP_LIMB;
-	  for (i = 0; i < RETURN_LIMB_SIZE; ++i)
+	  for (i = 0; i < RETURN_LIMB_SIZE - 1; ++i)
 	    more_bits |= retval[i] != 0;
 	  MPN_ZERO (retval, RETURN_LIMB_SIZE);
 	}
@@ -215,9 +215,14 @@ round_and_return (mp_limb_t *retval, intmax_t exponent, int negative,
 	  more_bits |= ((round_limb & ((((mp_limb_t) 1) << round_bit) - 1))
 			!= 0);
 
-	  (void) mpn_rshift (retval, &retval[shift / BITS_PER_MP_LIMB],
-			     RETURN_LIMB_SIZE - (shift / BITS_PER_MP_LIMB),
-			     shift % BITS_PER_MP_LIMB);
+	  /* mpn_rshift requires 0 < shift < BITS_PER_MP_LIMB.  */
+	  if ((shift % BITS_PER_MP_LIMB) != 0)
+	    (void) mpn_rshift (retval, &retval[shift / BITS_PER_MP_LIMB],
+			       RETURN_LIMB_SIZE - (shift / BITS_PER_MP_LIMB),
+			       shift % BITS_PER_MP_LIMB);
+	  else
+	    for (i = 0; i < RETURN_LIMB_SIZE - (shift / BITS_PER_MP_LIMB); i++)
+	      retval[i] = retval[i + (shift / BITS_PER_MP_LIMB)];
 	  MPN_ZERO (&retval[RETURN_LIMB_SIZE - (shift / BITS_PER_MP_LIMB)],
 		    shift / BITS_PER_MP_LIMB);
 	}
@@ -276,7 +281,7 @@ round_and_return (mp_limb_t *retval, intmax_t exponent, int negative,
 	}
     }
 
-  if (exponent > MAX_EXP)
+  if (exponent >= MAX_EXP)
     goto overflow;
 
 #ifdef HAVE_FENV_H
@@ -308,7 +313,7 @@ round_and_return (mp_limb_t *retval, intmax_t exponent, int negative,
     }
 #endif
 
-  if (exponent > MAX_EXP)
+  if (exponent >= MAX_EXP)
   overflow:
     return overflow_value (negative);
 
@@ -688,7 +693,7 @@ ____STRTOF_INTERNAL (nptr, endptr, group)
 	  if (endptr != NULL)
 	    *endptr = (STRING_TYPE *) cp;
 
-	  return retval;
+	  return negative ? -retval : retval;
 	}
 
       /* It is really a text we do not recognize.  */
@@ -1193,7 +1198,16 @@ ____STRTOF_INTERNAL (nptr, endptr, group)
   if (__builtin_expect (exponent > MAX_10_EXP + 1 - (intmax_t) int_no, 0))
     return overflow_value (negative);
 
-  if (__builtin_expect (exponent < MIN_10_EXP - (DIG + 1), 0))
+  /* 10^(MIN_10_EXP-1) is not normal.  Thus, 10^(MIN_10_EXP-1) /
+     2^MANT_DIG is below half the least subnormal, so anything with a
+     base-10 exponent less than the base-10 exponent (which is
+     MIN_10_EXP - 1 - ceil(MANT_DIG*log10(2))) of that value
+     underflows.  DIG is floor((MANT_DIG-1)log10(2)), so an exponent
+     below MIN_10_EXP - (DIG + 3) underflows.  But EXPONENT is
+     actually an exponent multiplied only by a fractional part, not an
+     integer part, so an exponent below MIN_10_EXP - (DIG + 2)
+     underflows.  */
+  if (__builtin_expect (exponent < MIN_10_EXP - (DIG + 2), 0))
     return underflow_value (negative);
 
   if (int_no > 0)
@@ -1360,7 +1374,7 @@ ____STRTOF_INTERNAL (nptr, endptr, group)
 
     assert (dig_no > int_no
 	    && exponent <= 0
-	    && exponent >= MIN_10_EXP - (DIG + 1));
+	    && exponent >= MIN_10_EXP - (DIG + 2));
 
     /* We need to compute MANT_DIG - BITS fractional bits that lie
        within the mantissa of the result, the following bit for
@@ -1651,8 +1665,8 @@ ____STRTOF_INTERNAL (nptr, endptr, group)
 	  d1 = den[densize - 2];
 
 	  /* The division does not work if the upper limb of the two-limb
-	     numerator is greater than the denominator.  */
-	  if (mpn_cmp (num, &den[densize - numsize], numsize) > 0)
+	     numerator is greater than or equal to the denominator.  */
+	  if (mpn_cmp (num, &den[densize - numsize], numsize) >= 0)
 	    num[numsize++] = 0;
 
 	  if (numsize < densize)
@@ -1761,7 +1775,7 @@ ____STRTOF_INTERNAL (nptr, endptr, group)
 	      got_limb;
 	    }
 
-	  for (i = densize; num[i] == 0 && i >= 0; --i)
+	  for (i = densize; i >= 0 && num[i] == 0; --i)
 	    ;
 	  return round_and_return (retval, exponent - 1, negative,
 				   quot, BITS_PER_MP_LIMB - 1 - used,
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
index ded990acbcc..8085bec0af0 100644
--- a/libsanitizer/ChangeLog
+++ b/libsanitizer/ChangeLog
@@ -1,3 +1,24 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from master:
+	2023-04-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* configure.tgt: Unsupport Darwin22+ until a mechanism can be found
+	to locate dyld in the shared cache.
+
+2023-01-04  Florian Weimer  <fweimer@redhat.com>
+
+	Backported from master:
+	2022-10-18  Florian Weimer  <fweimer@redhat.com>
+
+	* configure.ac (sanitizer_supported): Include <unistd.h> for
+	syscall prototype.
+	* configure: Regenerate.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libsanitizer/configure b/libsanitizer/configure
index 1d9ae59be67..8bdde896fe7 100755
--- a/libsanitizer/configure
+++ b/libsanitizer/configure
@@ -16035,6 +16035,7 @@ case "$target" in
     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/syscall.h>
+#include <unistd.h>
 int
 main ()
 {
diff --git a/libsanitizer/configure.ac b/libsanitizer/configure.ac
index 13cd302030d..ac24b4b593b 100644
--- a/libsanitizer/configure.ac
+++ b/libsanitizer/configure.ac
@@ -161,7 +161,8 @@ case "$target" in
   *-*-linux*)
     # Some old Linux distributions miss required syscalls.
     sanitizer_supported=no
-    AC_TRY_COMPILE([#include <sys/syscall.h>],[
+    AC_TRY_COMPILE([#include <sys/syscall.h>
+#include <unistd.h>],[
       syscall (__NR_gettid);
       syscall (__NR_futex);
       syscall (__NR_exit_group);
diff --git a/libsanitizer/configure.tgt b/libsanitizer/configure.tgt
index 0ca5d9fd924..66164822cee 100644
--- a/libsanitizer/configure.tgt
+++ b/libsanitizer/configure.tgt
@@ -63,7 +63,7 @@ case "${target}" in
 		HWASAN_SUPPORTED=yes
 	fi
 	;;
-  x86_64-*-darwin2* | x86_64-*-darwin1[2-9]* | i?86-*-darwin1[2-9]*)
+  x86_64-*-darwin2[01]* | x86_64-*-darwin1[2-9]* | i?86-*-darwin1[2-8]*)
 	TSAN_SUPPORTED=no
 	EXTRA_CXXFLAGS+="-Wl,-undefined,dynamic_lookup"
 	;;
diff --git a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
index 025e575b5bc..5743516c046 100644
--- a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
+++ b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp
@@ -72,7 +72,9 @@
 #include <sys/vt.h>
 #include <linux/cdrom.h>
 #include <linux/fd.h>
+#if SANITIZER_ANDROID
 #include <linux/fs.h>
+#endif
 #include <linux/hdreg.h>
 #include <linux/input.h>
 #include <linux/ioctl.h>
@@ -828,10 +830,10 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);
   unsigned IOCTL_EVIOCGPROP = IOCTL_NOT_PRESENT;
   unsigned IOCTL_EVIOCSKEYCODE_V2 = IOCTL_NOT_PRESENT;
 #endif
-  unsigned IOCTL_FS_IOC_GETFLAGS = FS_IOC_GETFLAGS;
-  unsigned IOCTL_FS_IOC_GETVERSION = FS_IOC_GETVERSION;
-  unsigned IOCTL_FS_IOC_SETFLAGS = FS_IOC_SETFLAGS;
-  unsigned IOCTL_FS_IOC_SETVERSION = FS_IOC_SETVERSION;
+  unsigned IOCTL_FS_IOC_GETFLAGS = _IOR('f', 1, long);
+  unsigned IOCTL_FS_IOC_GETVERSION = _IOR('v', 1, long);
+  unsigned IOCTL_FS_IOC_SETFLAGS = _IOW('f', 2, long);
+  unsigned IOCTL_FS_IOC_SETVERSION = _IOW('v', 2, long);
   unsigned IOCTL_GIO_CMAP = GIO_CMAP;
   unsigned IOCTL_GIO_FONT = GIO_FONT;
   unsigned IOCTL_GIO_UNIMAP = GIO_UNIMAP;
diff --git a/libssp/ChangeLog b/libssp/ChangeLog
index 72119b01c69..2cc64a39649 100644
--- a/libssp/ChangeLog
+++ b/libssp/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 85e04c45288..f47e1753100 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,2057 @@
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/integer_comparisons/greater_equal_neg.cc:
+	Add -O2 to dg-options.
+	* testsuite/20_util/integer_comparisons/greater_neg.cc:
+	Likewise.
+	* testsuite/20_util/integer_comparisons/less_equal_neg.cc:
+	Likewise.
+	* testsuite/lib/prune.exp: Prune 'in constexpr expansion'.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/iterators/97731.cc: New test.
+	* testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc:
+	Check follow_directory_symlink option.
+	* testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc:
+	Likewise.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-06-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/108178
+	* src/filesystem/ops-common.h (do_copy_file): Check for empty
+	files by trying to read a character.
+	* testsuite/27_io/filesystem/operations/copy_file_108178.cc:
+	New test.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-06-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/filesystem/ops-common.h (do_copy_file) [O_CLOEXEC]: Set
+	close-on-exec flag on file descriptors.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-03-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/filesystem/ops-common.h (get_temp_directory_from_env): Fix
+	formatting.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-02-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/filesystem/ops-common.h [AVR] (__unsupported): Always use
+	errc::function_not_supported instead of errc::not_supported.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_dir.cc (_Dir::_Dir) [!_GLIBCXX_HAVE_OPENAT]:
+	Always store pathname if we don't have openat or unlinkat,
+	because the full path is needed to open sub-directories and
+	remove entries.
+
+2023-10-04  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-06-27  Alexandre Oliva  <oliva@adacore.com>
+
+	* src/c++17/fs_dir.cc (dir_and_pathname): Use dirfd if
+	_GLIBCXX_HAVE_OPENAT.
+
+2023-10-04  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-06-24  Alexandre Oliva  <oliva@adacore.com>
+
+	* acinclude.m4 (GLIBCXX_CHECK_FILESYSTEM_DEPS): Check for
+	openat.
+	* configure, config.h.in: Rebuilt.
+	* src/filesystem/dir-common.h (openat): Use ::openat if
+	_GLIBCXX_HAVE_OPENAT.
+	* src/filesystem/dir.cc (dir_and_pathname): Use dirfd if
+	_GLIBCXX_HAVE_OPENAT.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/filesystem/dir-common.h (_GLIBCXX_HAVE_DIRFD): Undefine
+	when <dirent.h> is not available.
+	(_GLIBCXX_HAVE_UNLINKAT):  Likewise.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_dir.cc (_Dir(DIR*, const path&)): Change first
+	parameter to _Dir_base&&.
+	* src/filesystem/dir-common.h (_Dir_base(DIR*)): Remove.
+	* src/filesystem/dir.cc (_Dir(DIR*, const path&)): Change first
+	parameter to _Dir_base&&.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104161
+	* src/c++17/fs_dir.cc (fs::recursive_directory_iterator::__erase):
+	[i_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Refresh entry._M_type member,
+	instead of checking for errno values indicating a directory.
+	* src/c++17/fs_ops.cc (fs::remove_all(const path&)): Use similar
+	logic to non-throwing overload.
+	(fs::remove_all(const path&, error_code&)): Add comments.
+	* src/filesystem/ops-common.h: Likewise.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/filesystem/dir-common.h (_Dir_base::openat): Change return
+	type to use portable posix::DIR alias.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104161
+	* acinclude.m4 (GLIBCXX_CHECK_FILESYSTEM_DEPS): Check for dirfd
+	and unlinkat.
+	* config.h.in: Regenerate.
+	* configure: Regenerate.
+	* include/bits/fs_dir.h (recursive_directory_iterator): Declare
+	remove_all overloads as friends.
+	(recursive_directory_iterator::__erase): Declare new member
+	function.
+	* include/bits/fs_fwd.h (remove, remove_all): Declare.
+	* src/c++17/fs_dir.cc (_Dir): Add filename_only parameter to
+	constructor. Pass file descriptor argument to base constructor.
+	(_Dir::dir_and_pathname, _Dir::open_subdir, _Dir::do_unlink)
+	(_Dir::unlink, _Dir::rmdir): Define new member functions.
+	(directory_iterator): Pass filename_only argument to _Dir
+	constructor.
+	(recursive_directory_iterator::_Dir_stack): Adjust constructor
+	parameters to take a _Dir rvalue instead of creating one.
+	(_Dir_stack::orig): Add data member for storing original path.
+	(_Dir_stack::report_error): Define new member function.
+	(__directory_iterator_nofollow): Move here from dir-common.h and
+	fix value to be a power of two.
+	(__directory_iterator_filename_only): Define new constant.
+	(recursive_directory_iterator): Construct _Dir object and move
+	into _M_dirs stack. Pass skip_permission_denied argument to first
+	advance call.
+	(recursive_directory_iterator::increment): Use _Dir::open_subdir.
+	(recursive_directory_iterator::__erase): Define new member
+	function.
+	* src/c++17/fs_ops.cc (ErrorReporter, do_remove_all): Remove.
+	(fs::remove_all): Use new recursive_directory_iterator::__erase
+	member function.
+	* src/filesystem/dir-common.h (_Dir_base): Add int parameter to
+	constructor and use openat to implement nofollow semantics.
+	(_Dir_base::fdcwd, _Dir_base::set_close_on_exec, _Dir_base::openat):
+	Define new member functions.
+	(__directory_iterator_nofollow): Move to fs_dir.cc.
+	* src/filesystem/dir.cc (_Dir): Pass file descriptor argument to
+	base constructor.
+	(_Dir::dir_and_pathname, _Dir::open_subdir): Define new member
+	functions.
+	(recursive_directory_iterator::_Dir_stack): Adjust constructor
+	parameters to take a _Dir rvalue instead of creating one.
+	(recursive_directory_iterator): Check for new nofollow option.
+	Construct _Dir object and move into _M_dirs stack. Pass
+	skip_permission_denied argument to first advance call.
+	(recursive_directory_iterator::increment): Use _Dir::open_subdir.
+	* src/filesystem/ops.cc (fs::remove_all): Use C++17 remove_all.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104161
+	* acinclude.m4 (GLIBCXX_CHECK_FILESYSTEM_DEPS): Check for
+	fdopendir.
+	* config.h.in: Regenerate.
+	* configure: Regenerate.
+	* src/c++17/fs_dir.cc (_Dir): Add nofollow flag to constructor
+	and pass it to base class constructor.
+	(directory_iterator): Pass nofollow flag to _Dir constructor.
+	(fs::recursive_directory_iterator::increment): Likewise.
+	* src/c++17/fs_ops.cc (do_remove_all): Use nofollow option for
+	directory_iterator constructor. Move error check outside loop.
+	* src/filesystem/dir-common.h (_Dir_base): Add nofollow flag to
+	constructor and when it's set use ::open with O_NOFOLLOW and
+	O_DIRECTORY.
+	* src/filesystem/dir.cc (_Dir): Add nofollow flag to constructor
+	and pass it to base class constructor.
+	(directory_iterator): Pass nofollow flag to _Dir constructor.
+	(fs::recursive_directory_iterator::increment): Likewise.
+	* src/filesystem/ops.cc (remove_all): Use nofollow option for
+	directory_iterator constructor. Move error check outside loop.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_ops.cc (create_directory): Fix typo in enum name.
+	* src/filesystem/ops-common.h (__last_system_error): Add
+	explicit cast to avoid narrowing conversion.
+	(do_space): Fix type in function name.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99327
+	* src/filesystem/ops-common.h (__unsupported): New function to
+	return a suitable error code for missing functionality.
+	(posix::off_t): New typedef.
+	(posix::*): Set errno to ENOSYS instead of ENOTSUP for no-op
+	fallback implementations.
+	(do_copy_file): Replace uses of errc::not_supported.
+	* src/c++17/fs_ops.cc (fs::copy, fs::copy_file, create_dir)
+	(fs::create_directory, fs::create_directory_symlink)
+	(fs::create_hard_link, fs::create_symlink, fs::current_path)
+	(fs::equivalent, do_stat, fs::file_size, fs::hard_link_count)
+	(fs::last_write_time, fs::permissions, fs::read_symlink):
+	Replace uses of errc::not_supported.
+	(fs::resize_file): Qualify off_t.
+	* src/filesystem/ops.cc (fs::copy, fs::copy_file, create_dir)
+	(fs::create_directory, fs::create_directory_symlink)
+	(fs::create_hard_link, fs::create_symlink, fs::current_path)
+	(fs::equivalent, do_stat, fs::file_size, fs::last_write_time)
+	(fs::permissions, fs::read_symlink, fs::system_complete):
+	Replace uses of errc::not_supported.
+	(fs::resize_file): Qualify off_t and enable unconditionally.
+	* testsuite/19_diagnostics/system_error/cons-1.cc: Likewise.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/filesystem/ops-common.h (last_error): New helper function.
+	(filesystem::do_space): Use last_error().
+	* src/c++17/fs_ops.cc (fs::absolute, fs::create_hard_link)
+	(fs::equivalent, fs::remove, fs::temp_directory_path): Use
+	last_error().
+	* src/filesystem/ops.cc (fs::create_hard_link)
+	(fs::remove, fs::temp_directory_path): Likewise.
+
+2023-10-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Revert:
+	2023-03-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_ops.cc [AVR] (not_supported): Define as a macro
+	for function_not_supported.
+	* src/filesystem/ops-common.h [AVR] (ENOTSUP): Define as a macro
+	for ENOSYS.
+
+2023-10-02  Tim Song  <t.canens.cpp@gmail.com>
+
+	Backported from master:
+	2023-09-28  Tim Song  <t.canens.cpp@gmail.com>
+
+	PR libstdc++/111050
+	* include/bits/hashtable_policy.h
+	(_Hash_node_value_base<>::_M_valptr(), _Hash_node_value_base<>::_M_v())
+	Add [[__gnu__::__always_inline__]].
+
+2023-09-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-08-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/bits/fs_path.h (path::string): Use
+	_GLIBCXX17_CONSTEXPR not _GLIBCXX_CONSTEXPR for 'if constexpr'.
+	* include/std/charconv (__to_chars_8): Initialize variable for
+	C++17 constexpr rules.
+
+2023-09-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-09-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/111511
+	PR c++/111512
+	* include/std/array (to_array): Qualify calls to __to_array.
+	* testsuite/23_containers/array/creation/111512.cc: New test.
+
+2023-09-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-09-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/111357
+	* include/std/utility (make_integer_sequence): Add cast.
+	* testsuite/20_util/integer_sequence/pr111357.cc: New test.
+
+2023-07-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-07-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/95048
+	* testsuite/27_io/filesystem/path/construct/95048.cc: Check
+	conversions to wide strings.
+	* testsuite/experimental/filesystem/path/construct/95048.cc:
+	Likewise.
+
+2023-07-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/95048
+	* include/bits/fs_path.h (path::_Codecvt): New class template
+	that selects the kind of code conversion done.
+	(path::_Codecvt<wchar_t>): Select based on sizeof(wchar_t).
+	(_GLIBCXX_CONV_FROM_UTF8): New macro to allow the same code to
+	be used for Windows and POSIX.
+	(path::_S_convert(const EcharT*, const EcharT*)): Simplify by
+	using _Codecvt and _GLIBCXX_CONV_FROM_UTF8 abstractions.
+	(path::_S_str_convert(basic_string_view<value_type>, const A&)):
+	Simplify nested conditions.
+	* include/experimental/bits/fs_path.h (path::_Cvt): Define
+	nested typedef controlling type of code conversion done.
+	(path::_Cvt::_S_wconvert): Use new typedef.
+	(path::string(const A&)): Likewise.
+	* testsuite/27_io/filesystem/path/construct/95048.cc: New test.
+	* testsuite/experimental/filesystem/path/construct/95048.cc: New
+	test.
+
+2023-06-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-06-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/evolution.xml: Document removal of implicit
+	allocator rebinding extensions in strict mode and for C++20.
+	* doc/html/*: Regenerate.
+
+2023-06-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-03-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104242
+	* include/std/any (any(T&&)): Revert change to constraints.
+	* testsuite/20_util/any/cons/104242.cc: New test.
+
+2023-05-30  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-30  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/109822
+	* include/experimental/bits/simd.h (to_native): Use int NTTP
+	as specified in PTS2.
+	(to_compatible): Likewise. Add missing tag to call mask
+	generator ctor.
+	* testsuite/experimental/simd/pr109822_cast_functions.cc: New
+	test.
+
+2023-05-30  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-30  Matthias Kretz  <m.kretz@gsi.de>
+
+	* testsuite/experimental/simd/tests/integer_operators.cc:
+	Compute expected value differently to avoid getting turned into
+	a vector shift.
+
+2023-05-30  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-30  Matthias Kretz  <m.kretz@gsi.de>
+
+	* testsuite/experimental/simd/tests/operator_cvt.cc: Make long
+	double <-> (u)long conversion tests conditional on sizeof(long
+	double) and sizeof(long).
+
+2023-05-30  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-26  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd_ppc.h (_S_bit_shift_left):
+	Negative __y is UB, so prefer signed compare.
+
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/109261
+	* include/experimental/bits/simd.h (_SimdWrapper::_M_set):
+	Avoid vector builtin subscripting in constant expressions.
+	(resizing_simd_cast): Avoid memcpy if constant_evaluated.
+	(const_where_expression, where_expression, where)
+	(__extract_part, simd_mask, _SimdIntOperators, simd): Add either
+	_GLIBCXX_SIMD_CONSTEXPR (on public APIs), or constexpr (on
+	internal APIs).
+	* include/experimental/bits/simd_builtin.h (__vector_permute)
+	(__vector_shuffle, __extract_part, _GnuTraits::_SimdCastType1)
+	(_GnuTraits::_SimdCastType2, _SimdImplBuiltin)
+	(_MaskImplBuiltin::_S_store): Add constexpr.
+	(_CommonImplBuiltin::_S_store_bool_array)
+	(_SimdImplBuiltin::_S_load, _SimdImplBuiltin::_S_store)
+	(_SimdImplBuiltin::_S_reduce, _MaskImplBuiltin::_S_load): Add
+	constant_evaluated case.
+	* include/experimental/bits/simd_fixed_size.h
+	(_S_masked_load): Reword comment.
+	(__tuple_element_meta, __make_meta, _SimdTuple::_M_apply_r)
+	(_SimdTuple::_M_subscript_read, _SimdTuple::_M_subscript_write)
+	(__make_simd_tuple, __optimize_simd_tuple, __extract_part)
+	(__autocvt_to_simd, _Fixed::__traits::_SimdBase)
+	(_Fixed::__traits::_SimdCastType, _SimdImplFixedSize): Add
+	constexpr.
+	(_SimdTuple::operator[], _M_set): Add constexpr and add
+	constant_evaluated case.
+	(_MaskImplFixedSize::_S_load): Add constant_evaluated case.
+	* include/experimental/bits/simd_scalar.h: Add constexpr.
+	* include/experimental/bits/simd_x86.h (_CommonImplX86): Add
+	constexpr and add constant_evaluated case.
+	(_SimdImplX86::_S_equal_to, _S_not_equal_to, _S_less)
+	(_S_less_equal): Value-initialize to satisfy constexpr
+	evaluation.
+	(_MaskImplX86::_S_load): Add constant_evaluated case.
+	(_MaskImplX86::_S_store): Add constexpr and constant_evaluated
+	case. Value-initialize local variables.
+	(_MaskImplX86::_S_logical_and, _S_logical_or, _S_bit_not)
+	(_S_bit_and, _S_bit_or, _S_bit_xor): Add constant_evaluated
+	case.
+	* testsuite/experimental/simd/pr109261_constexpr_simd.cc: New
+	test.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-24  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/109949
+	* include/experimental/bits/simd.h (__intrinsic_type): If
+	__ALTIVEC__ is defined, map gnu::vector_size types to their
+	corresponding __vector T types without losing unsignedness of
+	integer types. Also prefer long long over long.
+	* include/experimental/bits/simd_ppc.h (_S_popcount): Cast mask
+	object to the expected unsigned vector type.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-24  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/109261
+	* include/experimental/bits/simd.h (__intrinsic_type):
+	Specialize __intrinsic_type<double, 8> and
+	__intrinsic_type<double, 16> in any case, but provide the member
+	type only with __aarch64__.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-24  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/109261
+	* include/experimental/bits/simd_neon.h (_S_reduce): Add
+	constexpr and make NEON implementation conditional on
+	not __builtin_is_constant_evaluated.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-05-22  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd_builtin.h (_S_fpclassify): Move
+	__infn into #ifdef'ed block.
+	* testsuite/experimental/simd/tests/fpclassify.cc: Declare
+	constants only when used.
+	* testsuite/experimental/simd/tests/frexp.cc: Likewise.
+	* testsuite/experimental/simd/tests/logarithm.cc: Likewise.
+	* testsuite/experimental/simd/tests/trunc_ceil_floor.cc:
+	Likewise.
+	* testsuite/experimental/simd/tests/ldexp_scalbn_scalbln_modf.cc:
+	Move totest and expect1 into #ifdef'ed block.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-03-28  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd.h (is_simd_flag_type): New.
+	(_IsSimdFlagType): New.
+	(copy_from, copy_to, load ctors): Constrain _Flags using
+	_IsSimdFlagType.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-03-28  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd_x86.h (_SimdImplX86): Use
+	_Base::_S_divides if the optimized _S_divides function is hidden
+	via the preprocessor.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-03-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd_detail.h: Don't declare the
+	simd API as constexpr with Clang.
+	* include/experimental/bits/simd_x86.h (__movm): New.
+	(_S_blend_avx512): Resolve FIXME. Implement blend using __movm
+	and ?:.
+	(_SimdImplX86::_S_masked_unary): Clang does not implement the
+	same builtins. Implement the function using __movm, ?:, and -
+	operators on vector_size types instead.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-24  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd.h: Line breaks and indenting
+	fixed to follow the libstdc++ standard.
+	* include/experimental/bits/simd_builtin.h: Likewise.
+	* include/experimental/bits/simd_fixed_size.h: Likewise.
+	* include/experimental/bits/simd_neon.h: Likewise.
+	* include/experimental/bits/simd_ppc.h: Likewise.
+	* include/experimental/bits/simd_scalar.h: Likewise.
+	* include/experimental/bits/simd_x86.h: Likewise.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-24  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/108030
+	* include/experimental/bits/simd_fixed_size.h
+	(_SimdImplFixedSize::_S_broadcast): Replace inline with
+	_GLIBCXX_SIMD_INTRINSIC.
+	(_SimdImplFixedSize::_S_generate): Likewise.
+	(_SimdImplFixedSize::_S_load): Likewise.
+	(_SimdImplFixedSize::_S_masked_load): Likewise.
+	(_SimdImplFixedSize::_S_store): Likewise.
+	(_SimdImplFixedSize::_S_masked_store): Likewise.
+	(_SimdImplFixedSize::_S_min): Likewise.
+	(_SimdImplFixedSize::_S_max): Likewise.
+	(_SimdImplFixedSize::_S_complement): Likewise.
+	(_SimdImplFixedSize::_S_unary_minus): Likewise.
+	(_SimdImplFixedSize::_S_plus): Likewise.
+	(_SimdImplFixedSize::_S_minus): Likewise.
+	(_SimdImplFixedSize::_S_multiplies): Likewise.
+	(_SimdImplFixedSize::_S_divides): Likewise.
+	(_SimdImplFixedSize::_S_modulus): Likewise.
+	(_SimdImplFixedSize::_S_bit_and): Likewise.
+	(_SimdImplFixedSize::_S_bit_or): Likewise.
+	(_SimdImplFixedSize::_S_bit_xor): Likewise.
+	(_SimdImplFixedSize::_S_bit_shift_left): Likewise.
+	(_SimdImplFixedSize::_S_bit_shift_right): Likewise.
+	(_SimdImplFixedSize::_S_remquo): Add inline keyword (to be
+	explicit about not always-inline, yet).
+	(_SimdImplFixedSize::_S_isinf): Likewise.
+	(_SimdImplFixedSize::_S_isfinite): Likewise.
+	(_SimdImplFixedSize::_S_isnan): Likewise.
+	(_SimdImplFixedSize::_S_isnormal): Likewise.
+	(_SimdImplFixedSize::_S_signbit): Likewise.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-24  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/108856
+	* include/experimental/bits/simd_builtin.h
+	(_SimdImplBuiltin::_S_masked_unary): More efficient
+	implementation of masked inc-/decrement for integers and floats
+	without AVX2.
+	* include/experimental/bits/simd_x86.h
+	(_SimdImplX86::_S_masked_unary): New. Use AVX512 masked subtract
+	builtins for masked inc-/decrement.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	* testsuite/experimental/simd/tests/reductions.cc: Introduce
+	max_distance as the type-dependent max error.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/108030
+	* include/experimental/bits/simd_detail.h
+	(_GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA): Define as empty for
+	__clang__.
+
+2023-05-25  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-16  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/108030
+	* include/experimental/bits/simd_detail.h: Define
+	_GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA.
+	* include/experimental/bits/simd.h: Annotate lambdas with
+	_GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA.
+	* include/experimental/bits/simd_builtin.h: Ditto.
+	* include/experimental/bits/simd_converter.h: Ditto.
+	* include/experimental/bits/simd_fixed_size.h: Ditto.
+	* include/experimental/bits/simd_math.h: Ditto.
+	* include/experimental/bits/simd_neon.h: Ditto.
+	* include/experimental/bits/simd_x86.h: Ditto.
+
+2023-05-22  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2023-03-14  Patrick Palka  <ppalka@redhat.com>
+
+	* include/bits/stl_iterator.h (move_iterator::_S_iter_concept):
+	Define.
+	(__cpp_lib_move_iterator_concept): Define for C++20.
+	(move_iterator::iterator_concept): Strengthen as per P2520R0.
+	* include/std/version (__cpp_lib_move_iterator_concept): Define
+	for C++20.
+	* testsuite/24_iterators/move_iterator/p2520r0.cc: New test.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/107801
+	* src/c++17/memory_resource.cc (chunk::_M_bytes): Change type
+	from uint32_t to bitset::size_type. Adjust static assertion.
+	(__pool_resource::_Pool::replenish): Cast to size_t after
+	multiplication instead of before.
+	(__pool_resource::_M_alloc_pools): Ensure both arguments to
+	std::max have type size_t.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/107801
+	* src/c++17/memory_resource.cc (pool_sizes): Disable large pools
+	for targets with 16-bit int.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91456
+	* include/std/type_traits (__is_nothrow_invocable): Remove.
+	(__is_invocable_impl::__nothrow_type): New member type which
+	checks if the conversion can throw.
+	(__is_nt_invocable_impl): Replace class template with alias
+	template to __is_nt_invocable_impl::__nothrow_type.
+	* testsuite/20_util/is_nothrow_invocable/91456.cc: New test.
+	* testsuite/20_util/is_nothrow_convertible/value.cc: Remove
+	macro used by value_ext.cc test.
+	* testsuite/20_util/is_nothrow_convertible/value_ext.cc: Remove
+	test for non-standard __is_nothrow_invocable trait.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/c_global/cstddef (byte): Add always_inline attribute
+	to all operator overloads.
+	(to_integer): Add always_inline attribute.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_ops.h: Add nodiscard to all pure functions.
+	* include/experimental/bits/fs_ops.h: Likewise.
+	* testsuite/27_io/filesystem/operations/all.cc: Do not discard
+	results of absolute and canonical.
+	* testsuite/27_io/filesystem/operations/absolute.cc: Cast
+	discarded result to void.
+	* testsuite/27_io/filesystem/operations/canonical.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/exists.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/is_empty.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/read_symlink.cc:
+	Likewise.
+	* testsuite/27_io/filesystem/operations/status.cc: Likewise.
+	* testsuite/27_io/filesystem/operations/symlink_status.cc:
+	Likewise.
+	* testsuite/27_io/filesystem/operations/temp_directory_path.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/canonical.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/exists.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/is_empty.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/read_symlink.cc:
+	Likewise.
+	* testsuite/experimental/filesystem/operations/temp_directory_path.cc:
+	Likewise.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-02-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (variant::operator=): Implement resolution
+	of LWG 3585.
+	* testsuite/20_util/variant/lwg3585.cc: New test.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/tuple/swap.cc (MoveOnly::operator==): Add
+	const qualifier.
+	* testsuite/26_numerics/valarray/87641.cc (X::operator==):
+	Likewise.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-03-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104875
+	* src/c++11/codecvt.cc (read_utf8_code_point): Use char32_t to
+	hold octets that will be left-shifted.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/ranges_algobase.h (__detail::__copy_or_move):
+	Move output iterator.
+	* testsuite/25_algorithms/copy/constrained.cc: Check copying to
+	move-only output iterator.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-12-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/108118
+	* include/bits/shared_ptr_base.h (weak_ptr::operator=):
+	Implement as move-and-swap exactly as specified in the standard.
+	* testsuite/20_util/weak_ptr/cons/self_move.cc: New test.
+
+2023-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/108265
+	* include/std/chrono (hh_mm_ss): Do not use chrono::abs if
+	duration rep is unsigned. Remove incorrect noexcept-specifier.
+	* testsuite/std/time/hh_mm_ss/1.cc: Check unsigned rep. Check
+	floating-point representations. Check default construction.
+
+2023-05-12  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2023-04-24  Patrick Palka  <ppalka@redhat.com>
+
+	* include/bits/max_size_type.h (__max_diff_type::operator>>=):
+	Fix propagation of sign bit.
+	* testsuite/std/ranges/iota/max_size_type.cc: Avoid using the
+	non-standard 'signed typedef-name'.  Add some compile-time tests
+	for right-shifting a negative __max_diff_type value by more than
+	one.
+
+2023-05-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105844
+	* include/experimental/numeric (lcm): Use built-in instead of
+	__is_constant_evaluated.
+	* include/std/numeric (__abs_r, lcm): Likewise.
+	* testsuite/26_numerics/gcd/105844.cc: Add dg-prune-output.
+	* testsuite/26_numerics/lcm/105844.cc: Likewise.
+
+2023-05-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105844
+	* include/experimental/numeric (experimental::gcd): Simplify
+	assertions. Use __abs_r instead of __absu.
+	(experimental::lcm): Likewise. Remove use of __detail::__lcm so
+	overflow can be detected.
+	* include/std/numeric (__detail::__absu): Rename to __abs_r and
+	change to allow signed result type, so overflow can be detected.
+	(__detail::__lcm): Remove.
+	(gcd): Simplify assertions. Use __abs_r instead of __absu.
+	(lcm): Likewise. Remove use of __detail::__lcm so overflow can
+	be detected.
+	* testsuite/26_numerics/gcd/gcd_neg.cc: Adjust dg-error lines.
+	* testsuite/26_numerics/lcm/lcm_neg.cc: Likewise.
+	* testsuite/26_numerics/gcd/105844.cc: New test.
+	* testsuite/26_numerics/lcm/105844.cc: New test.
+
+2023-05-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-04-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/doxygen/user.cfg.in (STRIP_FROM_PATH): Remove prefixes
+	from header paths.
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Document LWG 1203.
+	* doc/html/*: Regenerate.
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/barrier: Add missing runtime exception.
+
+2023-04-27  François Dumont  <fdumont@gcc.gnu.org>
+
+	Backported from master:
+	2022-05-26  François Dumont  <fdumont@gcc.gnu.org>
+
+	* python/libstdcxx/v6/printers.py (StdSpanPrinter.__init__):
+	Strip typename from version namespace.
+
+2023-04-27  Philipp Fent  <fent@in.tum.de>
+
+	Backported from master:
+	2022-04-25  Philipp Fent  <fent@in.tum.de>
+
+	* python/libstdcxx/v6/printers.py (StdSpanPrinter._iterator):
+	Rename as iterator.
+	(StdInitializerListPrinter): Define new printer.
+	(build_libstdcxx_dictionary): Register new printer.
+	* testsuite/libstdc++-prettyprinters/cxx11.cc: Check printer for
+	initializer_list.
+
+2023-04-27  Philipp Fent  <fent@in.tum.de>
+
+	Backported from master:
+	2022-04-19  Philipp Fent  <fent@in.tum.de>
+
+	* python/libstdcxx/v6/printers.py (StdSpanPrinter): Define.
+	* testsuite/libstdc++-prettyprinters/cxx20.cc: Test it.
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/atomic: Add missing @endcond doxygen comment.
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-04-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/extensions.xml: Remove std::bad_exception from
+	example program.
+	* doc/html/manual/ext_demangling.html: Regenerate.
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/doxygen/user.cfg.in (SOURCE_BROWSER): Only set to YES for
+	HTML docs.
+	* include/bits/gslice_array.h (_DEFINE_VALARRAY_OPERATOR): Omit
+	from doxygen docs.
+	* include/bits/indirect_array.h (_DEFINE_VALARRAY_OPERATOR):
+	Likewise.
+	* include/bits/mask_array.h (_DEFINE_VALARRAY_OPERATOR):
+	Likewise.
+	* include/bits/slice_array.h (_DEFINE_VALARRAY_OPERATOR):
+	Likewise.
+	* include/std/valarray (_DEFINE_VALARRAY_UNARY_OPERATOR)
+	(_DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT)
+	(_DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT)
+	(_DEFINE_BINARY_OPERATOR): Likewise.
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-10-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (path::filename()): Fix dangling
+	reference.
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/109064
+	* python/libstdcxx/v6/xmethods.py (SharedPtrUseCountWorker):
+	Remove self-recursion in __init__. Add missing _supports.
+	* testsuite/libstdc++-xmethods/shared_ptr.cc: Check use_count()
+	and unique().
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-02-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/108952
+	* include/bits/uses_allocator_args.h
+	(uses_allocator_construction_args): Implement LWG 3527.
+	* testsuite/20_util/pair/astuple/get-2.cc: New test.
+	* testsuite/20_util/scoped_allocator/108952.cc: New test.
+	* testsuite/20_util/uses_allocator/lwg3527.cc: New test.
+
+2023-04-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-02-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/optional: Fix header name in comment.
+
+2023-03-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-03-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd_detail.h: Don't define
+	_GLIBCXX_SIMD_WORKAROUND_PR90993 for Clang.
+	* include/experimental/bits/simd_x86.h (_S_divides): Remove
+	check for __clang__.
+
+2023-03-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-03-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	* testsuite/experimental/simd/tests/operators.cc: Clang doesn't
+	define __GCC_IEC_559. Use __STDC_IEC_559__ instead.
+
+2023-03-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-02-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/108636
+	* include/bits/fs_path.h (path::path(string_view, _Type))
+	(path::_Cmpt::_Cmpt(string_view, _Type, size_t)): Move inline
+	definitions to ...
+	* src/c++17/fs_path.cc: ... here.
+	* testsuite/27_io/filesystem/path/108636.cc: New test.
+
+2023-03-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_ops.cc [AVR] (not_supported): Define as a macro
+	for function_not_supported.
+	* src/filesystem/ops-common.h [AVR] (ENOTSUP): Define as a macro
+	for ENOSYS.
+
+2023-03-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-02-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/random.cc (random_device::_M_fini): Do not try to
+	close the file handle if the target doesn't support the
+	/dev/random and /dev/urandom files.
+
+2023-03-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2023-02-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* config/os/generic/error_constants.h (errc::value_too_large)
+	[__AVR__]: Define.
+	* src/c++11/system_error.cc
+	(system_category::default_error_condition) [__AVR__]: Only match
+	recognize values equal to EDOM, ERANGE, ENOSYS and EINTR.
+	* src/c++17/fs_ops.cc (fs::current_path) [__AVR__]: Do not use
+	getcwd.
+	* src/filesystem/ops-common.h [__AVR__]: Do not use POSIX open,
+	close etc.
+
+2023-03-10  Thomas W Rodgers  <rodgert@twrodgers.com>
+
+	Backported from master:
+	2023-02-14  Thomas W Rodgers  <rodgert@twrodgers.com>
+
+	PR libstdc++/103934
+	* include/std/atomic (atomic_flag_wait): Add.
+	(atomic_flag_wait_explicit): Add.
+	(atomic_flag_notify): Add.
+	(atomic_flag_notify_explicit): Add.
+	* testsuite/29_atomics/atomic_flag/wait_notify/1.cc:
+	Add test case to cover missing atomic_flag free functions.
+
+2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	PR libstdc++/108030
+	* include/experimental/bits/simd.h (__vector_broadcast):
+	Implement via __vector_broadcast_impl instead of
+	__call_with_n_evaluations + 2 lambdas.
+	(__vector_broadcast_impl): New.
+
+2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd_builtin.h (_S_set): Compare as
+	int. The actual range of these indexes is very small.
+
+2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd_x86.h (_S_bit_shift_left)
+	(_S_bit_shift_right): Declare constexpr. The implementation was
+	already expecting constexpr evaluation.
+
+2023-02-23  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-20  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd.h (__extract_part, split):
+	Use reserved name for template parameter.
+
+2023-02-16  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-16  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd_x86.h
+	(_SimdImplX86::_S_not_equal_to, _SimdImplX86::_S_less)
+	(_SimdImplX86::_S_less_equal): Do not call
+	__builtin_is_constant_evaluated in constexpr-if.
+
+2023-02-16  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-16  Matthias Kretz  <m.kretz@gsi.de>
+
+	* testsuite/experimental/simd/tests/bits/verify.h
+	(verify::verify): Use %zx for size_t in format string.
+
+2023-02-16  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2023-02-16  Matthias Kretz  <m.kretz@gsi.de>
+
+	* include/experimental/bits/simd.h
+	(_SimdWrapper::_M_is_constprop_none_of)
+	(_SimdWrapper::_M_is_constprop_all_of): Return false unless the
+	computed result still satisfies __builtin_constant_p.
+
+2023-02-14  Thomas W Rodgers  <rodgert@twrodgers.com>
+
+	Backported from master:
+	2023-02-14  Thomas W Rodgers  <rodgert@twrodgers.com>
+
+	PR libstdc++/103934
+	* include/std/atomic (atomic_flag_test): Add.
+	(atomic_flag_test_explicit): Add.
+	* testsuite/29_atomics/atomic_flag/test/explicit.cc: Add
+	test case to cover missing atomic_flag free functions.
+	* testsuite/29_atomics/atomic_flag/test/implicit.cc:
+	Likewise.
+
+2023-02-02  Detlef Vollmann  <dv@vollmann.ch>
+
+	Backported from master:
+	2022-03-10  Detlef Vollmann  <dv@vollmann.ch>
+
+	PR libstdc++/104866
+	* include/bits/this_thread_sleep.h: Fix order of #endif and
+	closing brace of namespace.
+
+2023-01-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106183
+	* include/bits/atomic_wait.h (__waiter_pool_base::_M_notify):
+	Move increment of _M_ver here.
+	[!_GLIBCXX_HAVE_PLATFORM_WAIT]: Lock mutex around increment.
+	Use relaxed memory order and always notify all waiters.
+	(__waiter_base::_M_do_wait) [!_GLIBCXX_HAVE_PLATFORM_WAIT]:
+	Check value again after locking mutex.
+	(__waiter_base::_M_notify): Remove increment of _M_ver.
+
+2022-12-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/107814
+	* testsuite/experimental/filesystem/iterators/error_reporting.cc:
+	Use a static buffer with space after it.
+
+2022-11-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-11-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/authors.xml: Remove empty author element.
+	* doc/xml/manual/spine.xml: Likewise.
+	* doc/html/*: Regenerate.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/version [!_GLIBCXX_HOSTED]
+	(__cpp_lib_bit_cast): Define for freestanding.
+	(__cpp_lib_string_contains): Do not define for freestanding.
+	(__cpp_lib_to_underlying): Likewise.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106607
+	* include/bits/regex_compiler.tcc (_Compiler::_M_cur_int_value):
+	Use built-ins to check for integer overflow in back-reference
+	number.
+	* testsuite/28_regex/basic_regex/106607.cc: New test.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106695
+	* include/bits/std_thread.h (thread::_State_impl): Forward
+	individual arguments to _Invoker constructor.
+	(thread::_Invoker): Add constructor. Delete copies.
+	* include/std/future (__future_base::_Deferred_state): Forward
+	individual arguments to _Invoker constructor.
+	(__future_base::_Async_state_impl): Likewise.
+	* testsuite/30_threads/async/106695.cc: New test.
+	* testsuite/30_threads/thread/106695.cc: New test.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106248
+	* include/std/istream [C++17] (operator>>(istream&, char*)):
+	Set eofbit if we stopped extracting at EOF.
+	* testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc:
+	New test.
+	* testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc:
+	New test.
+
+2022-09-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104443
+	* include/bits/stl_iterator.h (common_iterator::operator->):
+	Change return type to just auto.
+
+2022-09-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-08-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/string_view (basic_string_view(Range&&)): Add
+	explicit as per P2499R0.
+	* testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc:
+	Adjust implicit conversions. Check implicit conversions fail.
+	* testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc:
+	Likewise.
+
+2022-07-26  Thomas Rodgers  <trodgers@redhat.com>
+
+	Backported from master:
+	2022-07-26  Thomas Rodgers  <trodgers@redhat.com>
+
+	* include/bits/atomic_wait.h (__atomic_spin): Merge spin loops.
+
+2022-07-22  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/106320
+	* include/std/ranges (single_view): Relax constraints on
+	default constructor so as to preserve pre-P2325R3 behavior.
+	(filter_view): Likewise.
+	(transform_view): Likewise.
+	(take_while_view): Likewise.
+	(drop_while_view): Likewise.
+	* testsuite/std/ranges/adaptors/join.cc (test13): New test.
+	* testsuite/std/ranges/p2325.cc: Fix S to be only non default
+	constructible and not also non copy constructible.  XFAIL the
+	tests that verify a non default constructible functor makes a
+	view non default constructible (lines 94, 97 and 98).  XFAIL
+	the test that effectively verifies a non default constructible
+	element type makes single_view non default constructible (line
+	114).
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/100823
+	* include/bits/stl_iterator.h (common_iterator): Define move
+	constructor and move assignment operator.
+	(common_iterator::_M_assign): New function implementing
+	assignment.
+	(common_iterator::operator=): Use _M_assign.
+	(common_iterator::_S_valueless): New constant.
+	* testsuite/24_iterators/common_iterator/100823.cc: New test.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (common_iterator): Fix incorrect
+	uses of is_nothrow_assignable_v. Fix inconsistent constraints on
+	friend declaration. Do not move argument in copy constructor.
+	* testsuite/24_iterators/common_iterator/1.cc: Check for
+	noexcept constructibnle/assignable.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103992
+	* include/bits/stl_iterator.h (common_iterator): Use
+	std::construct_at instead of placement new.
+	* testsuite/24_iterators/common_iterator/1.cc: Check copy
+	construction is usable in constant expressions.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (common_iterator): Add constexpr
+	to all member functions (LWG 3574).
+	* testsuite/24_iterators/common_iterator/1.cc: Evaluate some
+	tests as constant expressions.
+	* testsuite/24_iterators/common_iterator/2.cc: Likewise.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/from_chars/4.cc: Only use log2 if C99 math
+	functions are available.
+
+2022-07-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88881
+	* src/filesystem/ops.cc (has_trailing_slash): New helper
+	function.
+	(fs::status): Strip trailing slashes.
+	(fs::symlink_status): Likewise.
+	* testsuite/experimental/filesystem/operations/temp_directory_path.cc:
+	Clean the environment before each test and use TMP instead of
+	TMPDIR so the test passes on Windows.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-07-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/106162
+	* include/Makefile.am (largefile-config.h): Add
+	stamp-${host_alias} prerequisite.
+	* include/Makefile.in: Regenerate.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/iterators/error_reporting.cc: Use
+	rmdir to remove directories.
+	* testsuite/experimental/filesystem/iterators/error_reporting.cc:
+	Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (counted_iterator::operator++(int)):
+	Add 'constexpr' as per LWG 3643.
+	* testsuite/24_iterators/counted_iterator/lwg3643.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105671
+	* include/std/sstream (basic_stringbuf::_M_high_mark): Add
+	always_inline attribute.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/future (launch): Make operators noexcept.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/ranges_base.h (ranges::size, ranges::empty): Add
+	explicit check for unbounded arrays before using ranges::begin.
+	* testsuite/std/ranges/access/empty.cc: Check handling of unbounded
+	arrays.
+	* testsuite/std/ranges/access/size.cc: Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_automaton.h (_NFA_base::_SizeT): Remove.
+	* include/bits/regex_compiler.h (_Compiler::_IterT): Remove.
+	* include/bits/regex_compiler.tcc: Likewise.
+	* include/bits/regex_scanner.h (_Scanner::_IterT): Remove.
+	* include/bits/regex_scanner.tcc: Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (basic_regex, swap): Add noexcept to
+	non-throwing functions.
+	* include/bits/regex_automaton.h (_State_base, _State)
+	(_NFA_base): Likewise.
+	* include/bits/regex_compiler.h (_Compiler): Likewise.
+	* include/bits/regex_error.h (regex_error::code()): Likewise.
+	* include/bits/regex_scanner.h (_Scanner): Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/102447
+	* include/bits/regex_compiler.h (_Compiler::_BracketState): New
+	class.
+	(_Compiler::_BrackeyMatcher): New alias template.
+	(_Compiler::_M_expression_term): Change pair<bool, CharT>
+	parameter to _BracketState. Process first character for
+	ECMAScript syntax as well as POSIX.
+	* include/bits/regex_compiler.tcc
+	(_Compiler::_M_insert_bracket_matcher): Pass _BracketState.
+	(_Compiler::_M_expression_term): Use _BracketState to store
+	state between calls. Improve handling of dashes in ranges.
+	* testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc:
+	Add more tests for ranges containing dashes. Check invalid
+	ranges with character class at the beginning.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_compiler.h (_Compiler::_S_validate): New
+	function.
+	* include/bits/regex_compiler.tcc (_Compiler::_Compiler): Use
+	_S_validate to check flags.
+	* include/bits/regex_error.h (_S_grammar): New error code for
+	internal use.
+	* testsuite/28_regex/basic_regex/ctors/grammar.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_compiler.tcc: Add line break in empty while
+	statement.
+	* include/bits/regex_executor.tcc: Avoid unused parameter
+	warning.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/28_regex/algorithms/regex_replace/char/103664.cc:
+	Add dg-timeout-factor directive.
+	* testsuite/28_regex/basic_regex/84110.cc: Likewise.
+	* testsuite/28_regex/basic_regex/ctors/char/other.cc: Likewise.
+	* testsuite/28_regex/match_results/102667.cc: Likewise.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (__detail::__is_contiguous_iter): Move
+	here from <bits/regex_compiler.h>.
+	(basic_regex::_M_compile): New function to compile an NFA from
+	a regular expression string.
+	(basic_regex::basic_regex): Use _M_compile instead of delegating
+	to other constructors.
+	(basic_regex::operator=(const basic_regex&)): Define as
+	defaulted.
+	(basic_regex::operator=(initializer_list<C>)): Use _M_compile.
+	(basic_regex::assign(const basic_regex&)): Use copy assignment.
+	(basic_regex::assign(basic_regex&&)): Use move assignment.
+	(basic_regex::assign(const C*, flag_type)): Use _M_compile
+	instead of constructing a temporary string.
+	(basic_regex::assign(const C*, size_t, flag_type)): Likewise.
+	(basic_regex::assign(const basic_string<C,T,A>&, flag_type)):
+	Use _M_compile instead of constructing a temporary basic_regex.
+	(basic_regex::assign(InputIter, InputIter, flag_type)): Avoid
+	constructing a temporary string for contiguous iterators of the
+	right value type.
+	* include/bits/regex_compiler.h (__is_contiguous_iter): Move to
+	<bits/regex.h>.
+	(__enable_if_contiguous_iter, __disable_if_contiguous_iter)
+	(__compile_nfa): Remove.
+	* testsuite/28_regex/basic_regex/assign/exception_safety.cc: New
+	test.
+	* testsuite/28_regex/basic_regex/ctors/char/other.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103664
+	* include/bits/regex.h (__regex_replace): Declare.
+	(regex_replace): Use it.
+	* include/bits/regex.tcc (__regex_replace): Replace regex_replace
+	definition with __regex_replace.
+	* testsuite/28_regex/algorithms/regex_replace/char/103664.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__detail::__variant::__get_storage):
+	Remove unused function.
+	(__variant_construct_by_index): Set index after construction is
+	complete. Rename to ...
+	(__detail::__variant::__construct_by_index): ... this.
+	(variant): Use new name for __variant_construct_by_index friend
+	declaration. Remove __get_storage friend declaration.
+	(variant::emplace): Use new name and remove try-blocks.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/list.tcc (list::merge): Remove call to size() and
+	try-catch block. Use _Finalize_merge instead.
+	* include/bits/stl_list.h (list::_Finalize_merge): New
+	scope guard type to update _M_size members after a merge.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (basic_regex::multiline): Define for
+	non-strict C++11 and C++14 modes.
+	* include/bits/regex_constants.h (regex_constants::multiline):
+	Add _GLIBCXX_RESOLVE_LIB_DEFECTS comment.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (basic_regex::multiline): Fix #if
+	condition.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex.h (basic_regex::multiline): Define constant
+	for C++17.
+	* include/bits/regex_constants.h (regex_constants::multiline):
+	Define constant for C++17.
+	(regex_constants::__multiline): Define duplicate constant for
+	internal use in C++11 and C++14.
+	* include/bits/regex_executor.h (_Executor::_M_match_multiline()):
+	New member function.
+	(_Executor::_M_is_line_terminator(_CharT)): New member function.
+	(_Executor::_M_at_begin(), _Executor::_M_at_end()): Use new
+	member functions to support multiline matches.
+	* testsuite/28_regex/algorithms/regex_match/multiline.cc: New test.
+
+2022-07-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backported from master:
+	2021-10-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/28_regex/basic_regex/84110.cc (test01)
+	[__cpp_exceptions]: Disambiguate extended.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84110
+	* include/bits/regex_error.h (regex_constants::_S_null): New
+	error code for internal use.
+	* include/bits/regex_scanner.tcc (_Scanner::_M_scan_normal()):
+	Check for null character.
+	* testsuite/28_regex/basic_regex/84110.cc: New test.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-10-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (_Variant_storage::_M_storage()): Remove.
+	(__detail::__variant::__get_storage): Remove.
+	(variant): Remove friend declaration of __get_storage.
+
+2022-07-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libstdc++/105128
+	* include/std/source_location (std::source_location::__impl): Move
+	definition before using __builtin_ret_type.
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104602
+	* include/std/source_location (source_location::current): Use
+	deduced type of __builtin_source_location().
+
+2022-07-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (hash<filesystem::path>): Define.
+	* testsuite/27_io/filesystem/path/nonmember/hash_value.cc:
+	Check std::hash specialization.
+
+2022-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-06-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/atomic (__atomic_val_t): Use __type_identity_t
+	instead of atomic<T>::value_type, as per LWG 3220.
+	* testsuite/29_atomics/atomic/lwg3220.cc: New test.
+
+2022-06-15  Mark Mentovai  <mark@mentovai.com>
+
+	Backported from master:
+	2022-06-13  Mark Mentovai  <mark@mentovai.com>
+
+	* include/experimental/bits/fs_path.h (__detail::__null_terminated):
+	Rename to __nul_terminated to avoid colliding with a macro in
+	Apple's SDK.
+
+2022-06-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105915
+	* include/experimental/bits/fs_path.h (path::begin, path::end):
+	Remove noexcept from declarations.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2023.xml: Update status.
+	* doc/html/manual/status.html: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/prerequisites.xml: Fix attributes for external
+	hyperlink.
+	* doc/html/manual/setup.html: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Include new chapter.
+	* doc/xml/manual/status_cxx2020.xml: Tweak release numbers.
+	* doc/xml/manual/status_cxx2023.xml: New file.
+	* doc/html/*: Regenerate.
+
+2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/html/manual/status.html: Regenerate.
+	* doc/xml/manual/status_cxx2020.xml: Fix supported version for
+	C++20 bit operations.
+
+2022-05-13  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-06  Alexandre Oliva  <oliva@adacore.com>
+
+	* include/experimental/bits/simd.h [__ALTIVEC__]: Require VSX
+	for double, long long, and 64-bit long intrinsic types.
+	[__ALTIVEC__] (__intrinsic_type): Mention 128-bit in
+	preexisting long double diagnostic, adjust no-VSX double
+	diagnostic to cover 64-bit long double as well.
+
+2022-05-11  Patrick Palka  <ppalka@redhat.com>
+
+	Backported from master:
+	2022-05-02  Patrick Palka  <ppalka@redhat.com>
+
+	PR libstdc++/103911
+	* src/c++17/floating_from_chars.cc (find_end_of_float): Accept
+	two delimeters for the exponent part in the form of a possibly
+	NULL string of length two.  Don't use std::tolower.
+	(pattern): Adjust calls to find_end_of_float accordingly.
+
+2022-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105284
+	* include/std/iosfwd: Add declarations for <synstream> class
+	templates and typedefs.
+	* include/std/syncstream (basic_syncbuf, basic_osyncstream):
+	Remove default template arguments.
+	* testsuite/27_io/headers/iosfwd/synopsis.cc: New test.
+	* testsuite/27_io/headers/iosfwd/types.cc: New test.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104217
+	* src/c++17/fs_ops.cc (_GNU_SOURCE): Define.
+	* src/filesystem/dir.cc (_GNU_SOURCE): Define.
+	* src/filesystem/ops.cc (_GNU_SOURCE): Define.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105502
+	* include/bits/random.tcc
+	(operator>>(basic_istream<C,T>&, normal_distribution<R>&)):
+	Update state when __state_avail is false.
+	* testsuite/26_numerics/random/normal_distribution/operators/serialize.cc:
+	Check that deserialized object equals serialized one.
+
+2022-05-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-05-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/104731
+	* testsuite/27_io/filesystem/iterators/error_reporting.cc:
+	Use a trailing char array as storage for dirent::d_name.
+
+2022-05-06  Alexandre Oliva  <oliva@adacore.com>
+
+	Backported from master:
+	2022-05-03  Alexandre Oliva  <oliva@adacore.com>
+
+	PR c++/105324
+	* testsuite/20_util/from_chars/pr105324.cc: Guard test body
+	with conditional for floating-point overloads of from_char.
+
+2022-04-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/99290
+	* src/c++17/fs_ops.cc (fs::copy): Pass error_code to
+	directory_iterator constructor, and check on each iteration.
+	* src/filesystem/ops.cc (fs::copy): Likewise.
+	* testsuite/27_io/filesystem/operations/copy.cc: Check for
+	errors during recursion.
+	* testsuite/experimental/filesystem/operations/copy.cc:
+	Likewise.
+
+2022-04-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105375
+	* include/std/future (packaged_task): Add deduction guides.
+	* testsuite/30_threads/packaged_task/cons/deduction.cc: New test.
+
+2022-04-22  Thomas W Rodgers  <trodgers@redhat.com>
+
+	Backported from master:
+	2022-04-22  Thomas W Rodgers  <trodgers@redhat.com>
+
+	PR libstdc++/102994
+	* include/bits/atomic_base.h (atomic_flag::notify_one,
+	notify_all): Remove const qualification.
+	(__atomic_base::notify_one, notify_all): Likewise.
+	* include/std/atomic (atomic<bool>::notify_one, notify_all):
+	Likewise.
+	(atomic::notify_one, notify_all): Likewise.
+	(atomic<T*>::notify_one, notify_all): Likewise.
+	(atomic_notify_one, atomic_notify_all): Likewise.
+	* testsuite/29_atomics/atomic/wait_notify/102994.cc: Adjust test
+	to account for change in notify_one/notify_all signature.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96592
+	* include/std/tuple (tuple::is_constructible): Remove.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/102177
+	* include/bits/atomic_base.h (__is_valid_cmpexch_failure_order):
+	New function to check if a memory order is valid for the failure
+	case of compare exchange operations.
+	(__atomic_base<I>::compare_exchange_weak): Simplify assertions
+	by using __is_valid_cmpexch_failure_order.
+	(__atomic_base<I>::compare_exchange_strong): Likewise.
+	(__atomic_base<P*>::compare_exchange_weak): Likewise.
+	(__atomic_base<P*>::compare_exchange_strong): Likewise.
+	(__atomic_impl::compare_exchange_weak): Add assertion.
+	(__atomic_impl::compare_exchange_strong): Likewise.
+	* include/std/atomic (atomic::compare_exchange_weak): Likewise.
+	(atomic::compare_exchange_strong): Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/monotonic_buffer_resource/allocate.cc:
+	Ignore -Walloc-larger-than warning.
+	* testsuite/20_util/unsynchronized_pool_resource/allocate.cc:
+	Likewise.
+	* testsuite/29_atomics/atomic/cons/user_pod.cc: Compile with -O1
+	to avoid linker error for __atomic_is_lock_free.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (operator==, operator<=>): Define
+	overloads for homogeneous specializations of reverse_iterator,
+	__normal_iterator and move_iterator.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/24_iterators/move_iterator/dr3265.cc: Fix test to
+	account for LWG 3435 resolution.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101709
+	* src/filesystem/ops-common.h (get_temp_directory_from_env):
+	Add error_code parameter.
+	* src/c++17/fs_ops.cc (fs::temp_directory_path): Pass error_code
+	argument to get_temp_directory_from_env and check it.
+	* src/filesystem/ops.cc (fs::temp_directory_path): Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105324
+	* src/c++17/floating_from_chars.cc (buffer_resource::do_allocate):
+	Remove assertion.
+	* testsuite/20_util/from_chars/pr105324.cc: New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/65018
+	* configure.ac: Check for secure_getenv.
+	* config.h.in: Regenerate.
+	* configure: Regenerate.
+	* src/filesystem/ops-common.h (get_temp_directory_from_env): New
+	helper function to obtain path from the environment.
+	* src/c++17/fs_ops.cc (fs::temp_directory_path): Use new helper.
+	* src/filesystem/ops.cc (fs::temp_directory_path): Likewise.
+	* testsuite/27_io/filesystem/operations/temp_directory_path.cc:
+	Print messages if test cannot be run.
+	* testsuite/experimental/filesystem/operations/temp_directory_path.cc:
+	Likewise. Fix incorrect condition. Use "TMP" to work with
+	Windows as well as POSIX.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++20/sstream-inst.cc (_GLIBCXX_USE_CXX11_ABI): Define to
+	select new ABI.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string/cons/char/moveable.cc: Allow
+	moved-from string to be non-empty.
+	* testsuite/21_strings/basic_string/cons/char/moveable2.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc:
+	Construct empty string before setting oom flag.
+	* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc:
+	Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_compiler.tcc (_Compiler::_M_match_token):
+	Use reserved name for parameter.
+	* testsuite/17_intro/names.cc: Check "token".
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/17_intro/names.cc: Check 'sz'.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/ranges (ranges::lazy_split_view::_InnerIter::end()):
+	Add neoxcept (LWG 3593).
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/internet (address): Use std::_Construct
+	to initialize union members.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/cxx11-ios_failure.cc (io_error_category): Define
+	class and virtual functions as 'final'.
+	(io_category_instance): Use constinit union to make the object
+	immortal.
+	* src/c++11/future.cc (future_error_category): Define class and
+	virtual functions as 'final'.
+	(future_category_instance): Use constinit union.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/span (span(Range&&)): Reorder constraints.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_path.cc (path::_M_split_cmpts()): Remove
+	micro-optimization for "/" path.
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Only access
+	the contents of _M_pathname using const member functions.
+
+2022-04-21  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+
+	Backported from master:
+	2022-01-06  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103853
+	* include/bits/forward_list.tcc (forward_list::merge): Check for
+	self-merge.
+	* testsuite/23_containers/forward_list/operations/merge.cc: New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_construct.h (_Construct, _Construct_novalue):
+	Also cast away cv-qualifiers when converting pointer to void.
+	* testsuite/20_util/allocator/void.cc: Test construct function
+	with cv-qualified types.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103911
+	* include/std/charconv (__from_chars_alpha_to_num): Return
+	char instead of unsigned char. Change invalid return value to
+	127 instead of using numeric trait.
+	(__from_chars_alnum): Fix comment. Do not use std::isdigit.
+	Change type of variable to char.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/ranges_base.h (ranges::advance): Avoid signed
+	overflow. Do nothing if already equal to desired result.
+	* testsuite/24_iterators/range_operations/advance_overflow.cc:
+	New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/ext/rope/pthread7-rope.cc: Add dg-timeout-factor.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-03-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/17_intro/names.cc (func): Undef on AIX.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93602
+	* doc/xml/manual/prerequisites.xml: Document libiconv
+	workarounds.
+	* doc/html/manual/setup.html: Regenerate.
+	* src/Makefile.am (CXXLINK): Add $(LTLIBICONV).
+	* src/Makefile.in: Regenerate.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Fix comment.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc:
+	Check correct feature test macro.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR middle-end/104966
+	* include/bits/locale_facets_nonio.tcc
+	(__moneypunct_cache::_M_cache): Store string sizes in local
+	variable that doesn't escape.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103848
+	* include/bits/stl_deque.h (operator-): Do not use 0 as null
+	pointer constant.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 15c975ff86e..696756a6df6 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -4825,6 +4825,55 @@ dnl
     AC_DEFINE(HAVE_TRUNCATE, 1, [Define if truncate is available in <unistd.h>.])
   fi
   AC_MSG_RESULT($glibcxx_cv_truncate)
+dnl
+  AC_CACHE_CHECK([for fdopendir],
+    glibcxx_cv_fdopendir, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <dirent.h>],
+      [::DIR* dir = ::fdopendir(1);],
+      [glibcxx_cv_fdopendir=yes],
+      [glibcxx_cv_fdopendir=no])
+  ])
+  if test $glibcxx_cv_truncate = yes; then
+    AC_DEFINE(HAVE_FDOPENDIR, 1, [Define if fdopendir is available in <dirent.h>.])
+  fi
+dnl
+  AC_CACHE_CHECK([for dirfd],
+    glibcxx_cv_dirfd, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <dirent.h>],
+      [int fd = ::dirfd((::DIR*)0);],
+      [glibcxx_cv_dirfd=yes],
+      [glibcxx_cv_dirfd=no])
+  ])
+  if test $glibcxx_cv_dirfd = yes; then
+    AC_DEFINE(HAVE_DIRFD, 1, [Define if dirfd is available in <dirent.h>.])
+  fi
+dnl
+  AC_CACHE_CHECK([for openat],
+    glibcxx_cv_openat, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <fcntl.h>],
+      [int fd = ::openat(AT_FDCWD, "", 0);],
+      [glibcxx_cv_openat=yes],
+      [glibcxx_cv_openat=no])
+  ])
+  if test $glibcxx_cv_openat = yes; then
+    AC_DEFINE(HAVE_OPENAT, 1, [Define if openat is available in <fcntl.h>.])
+  fi
+dnl
+  AC_CACHE_CHECK([for unlinkat],
+    glibcxx_cv_unlinkat, [dnl
+    GCC_TRY_COMPILE_OR_LINK(
+      [#include <fcntl.h>
+       #include <unistd.h>],
+      [::unlinkat(AT_FDCWD, "", AT_REMOVEDIR);],
+      [glibcxx_cv_unlinkat=yes],
+      [glibcxx_cv_unlinkat=no])
+  ])
+  if test $glibcxx_cv_unlinkat = yes; then
+    AC_DEFINE(HAVE_UNLINKAT, 1, [Define if unlinkat is available in <fcntl.h>.])
+  fi
 dnl
   CXXFLAGS="$ac_save_CXXFLAGS"
   AC_LANG_RESTORE
diff --git a/libstdc++-v3/config.h.in b/libstdc++-v3/config.h.in
index 61c342681d4..f8f8e6bd557 100644
--- a/libstdc++-v3/config.h.in
+++ b/libstdc++-v3/config.h.in
@@ -66,6 +66,9 @@
 /* Define to 1 if you have the <dirent.h> header file. */
 #undef HAVE_DIRENT_H
 
+/* Define if dirfd is available in <dirent.h>. */
+#undef HAVE_DIRFD
+
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #undef HAVE_DLFCN_H
 
@@ -93,6 +96,9 @@
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
+/* Define if fdopendir is available in <dirent.h>. */
+#undef HAVE_FDOPENDIR
+
 /* Define to 1 if you have the <fenv.h> header file. */
 #undef HAVE_FENV_H
 
@@ -282,6 +288,9 @@
 /* Define if <math.h> defines obsolete isnan function. */
 #undef HAVE_OBSOLETE_ISNAN
 
+/* Define if openat is available in <fcntl.h>. */
+#undef HAVE_OPENAT
+
 /* Define if poll is available in <poll.h>. */
 #undef HAVE_POLL
 
@@ -310,6 +319,9 @@
 /* Define if readlink is available in <unistd.h>. */
 #undef HAVE_READLINK
 
+/* Define to 1 if you have the `secure_getenv' function. */
+#undef HAVE_SECURE_GETENV
+
 /* Define to 1 if you have the `setenv' function. */
 #undef HAVE_SETENV
 
@@ -473,6 +485,9 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
+/* Define if unlinkat is available in <fcntl.h>. */
+#undef HAVE_UNLINKAT
+
 /* Define to 1 if you have the `uselocale' function. */
 #undef HAVE_USELOCALE
 
diff --git a/libstdc++-v3/config/os/generic/error_constants.h b/libstdc++-v3/config/os/generic/error_constants.h
index 9d01c16ee27..1d37454ba2e 100644
--- a/libstdc++-v3/config/os/generic/error_constants.h
+++ b/libstdc++-v3/config/os/generic/error_constants.h
@@ -167,6 +167,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #ifdef EOVERFLOW
       value_too_large = 			EOVERFLOW,
+#elif defined __AVR__
+      value_too_large = 			999,
 #endif
 
       wrong_protocol_type = 			EPROTOTYPE
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 3120d5855f6..8633b8a6dab 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -28419,6 +28419,17 @@ if test "x$ac_cv_func__wfopen" = xyes; then :
 #define HAVE__WFOPEN 1
 _ACEOF
 
+fi
+done
+
+  for ac_func in secure_getenv
+do :
+  ac_fn_c_check_func "$LINENO" "secure_getenv" "ac_cv_func_secure_getenv"
+if test "x$ac_cv_func_secure_getenv" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SECURE_GETENV 1
+_ACEOF
+
 fi
 done
 
@@ -76774,6 +76785,228 @@ $as_echo "#define HAVE_TRUNCATE 1" >>confdefs.h
   fi
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_truncate" >&5
 $as_echo "$glibcxx_cv_truncate" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fdopendir" >&5
+$as_echo_n "checking for fdopendir... " >&6; }
+if ${glibcxx_cv_fdopendir+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <dirent.h>
+int
+main ()
+{
+::DIR* dir = ::fdopendir(1);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_fdopendir=yes
+else
+  glibcxx_cv_fdopendir=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error $? "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <dirent.h>
+int
+main ()
+{
+::DIR* dir = ::fdopendir(1);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_fdopendir=yes
+else
+  glibcxx_cv_fdopendir=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_fdopendir" >&5
+$as_echo "$glibcxx_cv_fdopendir" >&6; }
+  if test $glibcxx_cv_truncate = yes; then
+
+$as_echo "#define HAVE_FDOPENDIR 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dirfd" >&5
+$as_echo_n "checking for dirfd... " >&6; }
+if ${glibcxx_cv_dirfd+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <dirent.h>
+int
+main ()
+{
+int fd = ::dirfd((::DIR*)0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_dirfd=yes
+else
+  glibcxx_cv_dirfd=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error $? "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <dirent.h>
+int
+main ()
+{
+int fd = ::dirfd((::DIR*)0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_dirfd=yes
+else
+  glibcxx_cv_dirfd=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_dirfd" >&5
+$as_echo "$glibcxx_cv_dirfd" >&6; }
+  if test $glibcxx_cv_dirfd = yes; then
+
+$as_echo "#define HAVE_DIRFD 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for openat" >&5
+$as_echo_n "checking for openat... " >&6; }
+if ${glibcxx_cv_openat+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <fcntl.h>
+int
+main ()
+{
+int fd = ::openat(AT_FDCWD, "", 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_openat=yes
+else
+  glibcxx_cv_openat=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error $? "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <fcntl.h>
+int
+main ()
+{
+int fd = ::openat(AT_FDCWD, "", 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_openat=yes
+else
+  glibcxx_cv_openat=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_openat" >&5
+$as_echo "$glibcxx_cv_openat" >&6; }
+  if test $glibcxx_cv_openat = yes; then
+
+$as_echo "#define HAVE_OPENAT 1" >>confdefs.h
+
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for unlinkat" >&5
+$as_echo_n "checking for unlinkat... " >&6; }
+if ${glibcxx_cv_unlinkat+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+      if test x$gcc_no_link = xyes; then
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <fcntl.h>
+       #include <unistd.h>
+int
+main ()
+{
+::unlinkat(AT_FDCWD, "", AT_REMOVEDIR);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  glibcxx_cv_unlinkat=yes
+else
+  glibcxx_cv_unlinkat=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  if test x$gcc_no_link = xyes; then
+  as_fn_error $? "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <fcntl.h>
+       #include <unistd.h>
+int
+main ()
+{
+::unlinkat(AT_FDCWD, "", AT_REMOVEDIR);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  glibcxx_cv_unlinkat=yes
+else
+  glibcxx_cv_unlinkat=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_unlinkat" >&5
+$as_echo "$glibcxx_cv_unlinkat" >&6; }
+  if test $glibcxx_cv_unlinkat = yes; then
+
+$as_echo "#define HAVE_UNLINKAT 1" >>confdefs.h
+
+  fi
   CXXFLAGS="$ac_save_CXXFLAGS"
   ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index fb256bb0287..4d16b094d7f 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -276,6 +276,7 @@ if $GLIBCXX_IS_NATIVE; then
   AC_CHECK_FUNCS(__cxa_thread_atexit_impl __cxa_thread_atexit)
   AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
   AC_CHECK_FUNCS(_wfopen)
+  AC_CHECK_FUNCS(secure_getenv)
 
   # C11 functions for C++17 library
   AC_CHECK_FUNCS(timespec_get)
diff --git a/libstdc++-v3/doc/doxygen/user.cfg.in b/libstdc++-v3/doc/doxygen/user.cfg.in
index eb05c975213..c690b515113 100644
--- a/libstdc++-v3/doc/doxygen/user.cfg.in
+++ b/libstdc++-v3/doc/doxygen/user.cfg.in
@@ -152,7 +152,7 @@ FULL_PATH_NAMES        = NO
 # will be relative from the directory where doxygen is started.
 # This tag requires that the tag FULL_PATH_NAMES is set to YES.
 
-STRIP_FROM_PATH        =
+STRIP_FROM_PATH        = @srcdir@/doc/ @srcdir@/libsupc++/ include/
 
 # The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
 # path mentioned in the documentation of a class, which tells the reader which
@@ -837,6 +837,7 @@ WARN_LOGFILE           =
 # spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
 # Note: If this tag is empty the current directory is searched.
 
+# N.B. update STRIP_FROM_PATH to sanitize paths outside the build tree.
 INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \
                          @srcdir@/libsupc++/compare \
                          @srcdir@/libsupc++/cxxabi.h \
@@ -1216,7 +1217,7 @@ USE_MDFILE_AS_MAINPAGE =
 # also VERBATIM_HEADERS is set to NO.
 # The default value is: NO.
 
-SOURCE_BROWSER         = YES
+SOURCE_BROWSER         = @do_html@
 
 # Setting the INLINE_SOURCES tag to YES will include the body of functions,
 # classes and enums directly into the documentation.
diff --git a/libstdc++-v3/doc/html/bk02.html b/libstdc++-v3/doc/html/bk02.html
index 7c47759f223..182c94b59a6 100644
--- a/libstdc++-v3/doc/html/bk02.html
+++ b/libstdc++-v3/doc/html/bk02.html
@@ -1,2 +1,2 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library" /><link rel="prev" href="manual/backwards.html" title="Backwards Compatibility" /><link rel="next" href="api.html" title="The GNU C++ Library API Reference" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="manual/backwards.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="api.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="article"><a href="api.html">The GNU C++ Library API Reference</a></span></dt></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="manual/backwards.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="api.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Backwards Compatibility </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> The GNU C++ Library API Reference</td></tr></table></div></body></html>
\ No newline at end of file
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library" /><link rel="prev" href="manual/appendix_gfdl.html" title="Appendix E. GNU Free Documentation License" /><link rel="next" href="api.html" title="The GNU C++ Library API Reference" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="manual/appendix_gfdl.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="api.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="article"><a href="api.html">The GNU C++ Library API Reference</a></span></dt></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="manual/appendix_gfdl.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="api.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Appendix E. GNU Free Documentation License </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> The GNU C++ Library API Reference</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/index.html b/libstdc++-v3/doc/html/index.html
index ed1a05f36f7..b118c214b47 100644
--- a/libstdc++-v3/doc/html/index.html
+++ b/libstdc++-v3/doc/html/index.html
@@ -23,7 +23,7 @@
     </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="book"><a href="manual/index.html">The GNU C++ Library Manual</a></span></dt><dd><dl><dt><span class="part"><a href="manual/intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/support.html">4. 
   Support
diff --git a/libstdc++-v3/doc/html/manual/api.html b/libstdc++-v3/doc/html/manual/api.html
index 70889a583f9..617c457e155 100644
--- a/libstdc++-v3/doc/html/manual/api.html
+++ b/libstdc++-v3/doc/html/manual/api.html
@@ -368,6 +368,11 @@ now defaults to zero.
   For the non-default <code class="option">--enable-symvers=gnu-versioned-namespace</code>
   configuration, the shared library SONAME has been changed to
   <code class="filename">libstdc++.so.8</code>.
+</p><p>
+  The extension allowing containers to be instantiated with an allocator
+  that doesn't match the container's value type is no longer allowed in
+  strict (<code class="option">-std=c++NN</code>) modes, only in
+  <code class="option">-std=gnu++NN</code> modes.
 </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="api.rel_91"></a><code class="constant">9</code></h3></div></div></div><p>
   C++17 header
   <code class="filename">&lt;memory_resource&gt;</code>
@@ -423,6 +428,10 @@ now defaults to zero.
   and
   <code class="filename">&lt;stop_token&gt;</code>
   added.
+</p><p>
+  The extension allowing containers to be instantiated with an allocator
+  that doesn't match the container's value type is no longer allowed in
+  C++20 mode, even in non-strict <code class="option">-std=gnu++20</code> mode.
 </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="api.rel_111"></a><code class="constant">11</code></h3></div></div></div><p>
   The <code class="option">--enable-cheaders=c_std</code> configuration
   was deprecated.
diff --git a/libstdc++-v3/doc/html/manual/bugs.html b/libstdc++-v3/doc/html/manual/bugs.html
index 7e0837322e5..280aa77d311 100644
--- a/libstdc++-v3/doc/html/manual/bugs.html
+++ b/libstdc++-v3/doc/html/manual/bugs.html
@@ -350,6 +350,9 @@
 	<span class="emphasis"><em>More algorithms that throw away information</em></span>
     </span></dt><dd><p>The traditional HP / SGI return type and value is blessed
 		    by the resolution of the DR.
+    </p></dd><dt><a id="manual.bugs.dr1203"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1203" target="_top">1203</a>:
+       <span class="emphasis"><em>More useful rvalue stream insertion</em></span>
+    </span></dt><dd><p>Return the stream as its original type, not the base class.
     </p></dd><dt><a id="manual.bugs.dr1339"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339" target="_top">1339</a>:
        <span class="emphasis"><em>uninitialized_fill_n should return the end of its range</em></span>
     </span></dt><dd><p>Return the end of the filled range.
diff --git a/libstdc++-v3/doc/html/manual/ext_demangling.html b/libstdc++-v3/doc/html/manual/ext_demangling.html
index 879497f7d08..028ec71d8c8 100644
--- a/libstdc++-v3/doc/html/manual/ext_demangling.html
+++ b/libstdc++-v3/doc/html/manual/ext_demangling.html
@@ -39,14 +39,6 @@ int main()
   int     status;
   char   *realname;
 
-  // exception classes not in &lt;stdexcept&gt;, thrown by the implementation
-  // instead of the user
-  std::bad_exception  e;
-  realname = abi::__cxa_demangle(e.what(), 0, 0, &amp;status);
-  std::cout &lt;&lt; e.what() &lt;&lt; "\t=&gt; " &lt;&lt; realname &lt;&lt; "\t: " &lt;&lt; status &lt;&lt; '\n';
-  free(realname);
-
-
   // typeid
   bar&lt;empty,17&gt;          u;
   const std::type_info  &amp;ti = typeid(u);
@@ -61,13 +53,12 @@ int main()
      This prints
    </p><pre class="screen">
    <code class="computeroutput">
-      St13bad_exception       =&gt; std::bad_exception   : 0
       3barI5emptyLi17EE       =&gt; bar&lt;empty, 17&gt;       : 0
    </code>
    </pre><p>
      The demangler interface is described in the source documentation
      linked to above.  It is actually written in C, so you don't need to
      be writing C++ in order to demangle C++.  (That also means we have to
-     use crummy memory management facilities, so don't forget to free()
-     the returned char array.)
+     use crummy memory management facilities, so don't forget to
+     <code class="code">free()</code> the returned char array.)
    </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ext_io.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="extensions.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ext_concurrency.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 27. Input and Output </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 29. Concurrency</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/extensions.html b/libstdc++-v3/doc/html/manual/extensions.html
index 82bf42e54b0..1b13d711714 100644
--- a/libstdc++-v3/doc/html/manual/extensions.html
+++ b/libstdc++-v3/doc/html/manual/extensions.html
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Part III.  Extensions</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library Manual" /><link rel="prev" href="io_and_c.html" title="Interacting with C" /><link rel="next" href="ext_preface.html" title="" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Part III. 
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Part III.  Extensions</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="index.html" title="The GNU C++ Library Manual" /><link rel="prev" href="concurrency.html" title="Chapter 15.  Concurrency" /><link rel="next" href="ext_preface.html" title="" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Part III. 
   Extensions
   
-</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="io_and_c.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="ext_preface.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.ext"></a>Part III. 
+</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="concurrency.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="ext_preface.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.ext"></a>Part III. 
   Extensions
   <a id="id-1.3.5.1.1.1" class="indexterm"></a>
 </h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="preface"><a href="ext_preface.html"></a></span></dt><dt><span class="chapter"><a href="ext_compile_checks.html">16. Compile Time Checks</a></span></dt><dt><span class="chapter"><a href="debug_mode.html">17. Debug Mode</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode.html#manual.ext.debug_mode.intro">Intro</a></span></dt><dt><span class="section"><a href="debug_mode_semantics.html">Semantics</a></span></dt><dt><span class="section"><a href="debug_mode_using.html">Using</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_using.html#debug_mode.using.mode">Using the Debug Mode</a></span></dt><dt><span class="section"><a href="debug_mode_using.html#debug_mode.using.specific">Using a Specific Debug Container</a></span></dt></dl></dd><dt><span class="section"><a href="debug_mode_design.html">Design</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.goals">Goals</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods">Methods</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.wrappers">The Wrapper Model</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.safe_iter">Safe Iterators</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.safe_seq">Safe Sequences (Containers)</a></span></dt></dl></dd><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.precond">Precondition Checking</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#debug_mode.design.methods.coexistence">Release- and debug-mode coexistence</a></span></dt><dd><dl><dt><span class="section"><a href="debug_mode_design.html#methods.coexistence.compile">Compile-time coexistence of release- and debug-mode components</a></span></dt><dt><span class="section"><a href="debug_mode_design.html#methods.coexistence.link">Link- and run-time coexistence of release- and
@@ -68,4 +68,7 @@
 	  Text <code class="function">modify</code> Up
 	</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#performance.priority_queue.text_modify_down">
 	  Text <code class="function">modify</code> Down
-	</a></span></dt></dl></dd><dt><span class="section"><a href="policy_based_data_structures_test.html#pbds.test.performance.observations">Observations</a></span></dt><dd><dl><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.associative">Associative</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.priority_queue">Priority_Queue</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="policy_data_structures_ack.html">Acknowledgments</a></span></dt><dt><span class="bibliography"><a href="policy_data_structures.html#pbds.biblio">Bibliography</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_containers.html">22. HP/SGI Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="ext_containers.html#manual.ext.containers.sgi">Backwards Compatibility</a></span></dt><dt><span class="section"><a href="ext_sgi.html">Deprecated</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_utilities.html">23. Utilities</a></span></dt><dt><span class="chapter"><a href="ext_algorithms.html">24. Algorithms</a></span></dt><dt><span class="chapter"><a href="ext_numerics.html">25. Numerics</a></span></dt><dt><span class="chapter"><a href="ext_iterators.html">26. Iterators</a></span></dt><dt><span class="chapter"><a href="ext_io.html">27. Input and Output</a></span></dt><dd><dl><dt><span class="section"><a href="ext_io.html#manual.ext.io.filebuf_derived">Derived filebufs</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_demangling.html">28. Demangling</a></span></dt><dt><span class="chapter"><a href="ext_concurrency.html">29. Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.threads">Interface to Locks and Mutexes</a></span></dt><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.atomics">Interface to Atomic Functions</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_impl.html">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.atomic_fallbacks">Using Built-in Atomic Functions</a></span></dt><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.thread">Thread Abstraction</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_use.html">Use</a></span></dt></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="io_and_c.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ext_preface.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Interacting with C </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
\ No newline at end of file
+	</a></span></dt></dl></dd><dt><span class="section"><a href="policy_based_data_structures_test.html#pbds.test.performance.observations">Observations</a></span></dt><dd><dl><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.associative">Associative</a></span></dt><dt><span class="section"><a href="policy_based_data_structures_test.html#observations.priority_queue">Priority_Queue</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="section"><a href="policy_data_structures_ack.html">Acknowledgments</a></span></dt><dt><span class="bibliography"><a href="policy_data_structures.html#pbds.biblio">Bibliography</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_containers.html">22. HP/SGI Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="ext_containers.html#manual.ext.containers.sgi">Backwards Compatibility</a></span></dt><dt><span class="section"><a href="ext_sgi.html">Deprecated</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_utilities.html">23. Utilities</a></span></dt><dt><span class="chapter"><a href="ext_algorithms.html">24. Algorithms</a></span></dt><dt><span class="chapter"><a href="ext_numerics.html">25. Numerics</a></span></dt><dt><span class="chapter"><a href="ext_iterators.html">26. Iterators</a></span></dt><dt><span class="chapter"><a href="ext_io.html">27. Input and Output</a></span></dt><dd><dl><dt><span class="section"><a href="ext_io.html#manual.ext.io.filebuf_derived">Derived filebufs</a></span></dt></dl></dd><dt><span class="chapter"><a href="ext_demangling.html">28. Demangling</a></span></dt><dt><span class="chapter"><a href="ext_concurrency.html">29. Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design">Design</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.threads">Interface to Locks and Mutexes</a></span></dt><dt><span class="section"><a href="ext_concurrency.html#manual.ext.concurrency.design.atomics">Interface to Atomic Functions</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_impl.html">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.atomic_fallbacks">Using Built-in Atomic Functions</a></span></dt><dt><span class="section"><a href="ext_concurrency_impl.html#manual.ext.concurrency.impl.thread">Thread Abstraction</a></span></dt></dl></dd><dt><span class="section"><a href="ext_concurrency_use.html">Use</a></span></dt></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="concurrency.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ext_preface.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 15. 
+  Concurrency
+  
+ </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/index.html b/libstdc++-v3/doc/html/manual/index.html
index e34210ee5d9..e62de964384 100644
--- a/libstdc++-v3/doc/html/manual/index.html
+++ b/libstdc++-v3/doc/html/manual/index.html
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The GNU C++ Library Manual</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="../index.html" title="The GNU C++ Library" /><link rel="prev" href="../index.html" title="The GNU C++ Library" /><link rel="next" href="intro.html" title="Part I.  Introduction" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The GNU C++ Library Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="intro.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="manual"></a>The GNU C++ Library Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname"></span> <span class="surname"></span></h3></div><div class="author"><h3 class="author"><span class="firstname">Paolo</span> <span class="surname">Carlini</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Edwards</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Doug</span> <span class="surname">Gregor</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Kosnik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dhruv</span> <span class="surname">Matani</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jason</span> <span class="surname">Merrill</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Mitchell</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nathan</span> <span class="surname">Myers</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Felix</span> <span class="surname">Natter</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Stefan</span> <span class="surname">Olsson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Singler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ami</span> <span class="surname">Tavory</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Wakely</span></h3></div></div></div><div><p class="copyright">Copyright © 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The GNU C++ Library Manual</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="../index.html" title="The GNU C++ Library" /><link rel="prev" href="../index.html" title="The GNU C++ Library" /><link rel="next" href="intro.html" title="Part I.  Introduction" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The GNU C++ Library Manual</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="intro.html">Next</a></td></tr></table><hr /></div><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="manual"></a>The GNU C++ Library Manual</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Paolo</span> <span class="surname">Carlini</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Phil</span> <span class="surname">Edwards</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Doug</span> <span class="surname">Gregor</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Benjamin</span> <span class="surname">Kosnik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dhruv</span> <span class="surname">Matani</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jason</span> <span class="surname">Merrill</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Mitchell</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nathan</span> <span class="surname">Myers</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Felix</span> <span class="surname">Natter</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Stefan</span> <span class="surname">Olsson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Johannes</span> <span class="surname">Singler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ami</span> <span class="surname">Tavory</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Wakely</span></h3></div></div></div><div><p class="copyright">Copyright © 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020 
       <a class="link" href="https://www.fsf.org" target="_top">FSF</a>
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="support.html">4. 
   Support
@@ -145,7 +145,7 @@ Support for C++11 dialect.
 	  </a></dt><dt>21.10. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.3.3.23">Non-unique Mapping Containers</a></dt><dt>21.11. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.4.3.5">Point Iterator Hierarchy</a></dt><dt>21.12. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.4.4.5">Invalidation Guarantee Tags Hierarchy</a></dt><dt>21.13. <a href="policy_data_structures_design.html#id-1.3.5.8.4.3.5.7.4">Container Tag Hierarchy</a></dt><dt>21.14. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.3">Hash functions, ranged-hash functions, and
 	      range-hashing functions</a></dt><dt>21.15. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.3.4">Insert hash sequence diagram</a></dt><dt>21.16. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.3.6">Insert hash sequence diagram with a null policy</a></dt><dt>21.17. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.5.5.5">Hash policy class diagram</a></dt><dt>21.18. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.4.7">Balls and bins</a></dt><dt>21.19. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.6">Insert resize sequence diagram</a></dt><dt>21.20. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.9">Standard resize policy trigger sequence
 		diagram</a></dt><dt>21.21. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.3.5.3.10">Standard resize policy size sequence
-		diagram</a></dt><dt>21.22. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.5">Tree node invariants</a></dt><dt>21.23. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>21.24. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>21.25. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>21.26. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>21.27. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.20">Useless update path</a></dt><dt>21.28. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>21.29. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>21.30. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.3">A simple list</a></dt><dt>21.31. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.6">The counter algorithm</a></dt><dt>21.32. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>21.33. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_features">C++ 2017 Library Features</a></dt><dt>1.6. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.7. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.8. <a href="status.html#table.par2ts_simd_support">Support for Extended ABI Tags</a></dt><dt>1.9. <a href="status.html#table.cxx20_features">C++ 2020 Library Features</a></dt><dt>1.10. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.11. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.12. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx98_deprheaders">C++ 1998 Deprecated Library Header</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.6. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.7. <a href="using_headers.html#table.cxx14_headers">C++ 2014 Library Header</a></dt><dt>3.8. <a href="using_headers.html#table.cxx17_headers">C++ 2017 Library Headers</a></dt><dt>3.9. <a href="using_headers.html#table.cxx20_headers">C++ 2020 Library Headers</a></dt><dt>3.10. <a href="using_headers.html#table.cxx20_deprheaders">C++ 2020 Obsolete Headers</a></dt><dt>3.11. <a href="using_headers.html#table.filesystemts_headers">File System TS Header</a></dt><dt>3.12. <a href="using_headers.html#table.libfundts_headers">Library Fundamentals TS Headers</a></dt><dt>3.13. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.14. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.15. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.16. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.17. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.18. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.19. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>20.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>21.1. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>21.2. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>21.3. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>21.4. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>21.5. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.7">
+		diagram</a></dt><dt>21.22. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.5">Tree node invariants</a></dt><dt>21.23. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>21.24. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>21.25. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>21.26. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>21.27. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.3.3.2.11.20">Useless update path</a></dt><dt>21.28. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>21.29. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>21.30. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.3">A simple list</a></dt><dt>21.31. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.5.3.3.6">The counter algorithm</a></dt><dt>21.32. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>21.33. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_features">C++ 2017 Library Features</a></dt><dt>1.6. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.7. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.8. <a href="status.html#table.par2ts_simd_support">Support for Extended ABI Tags</a></dt><dt>1.9. <a href="status.html#table.cxx20_features">C++ 2020 Library Features</a></dt><dt>1.10. <a href="status.html#table.cxx23_features">C++ 2023 Library Features</a></dt><dt>1.11. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.12. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.13. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx98_deprheaders">C++ 1998 Deprecated Library Header</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.6. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.7. <a href="using_headers.html#table.cxx14_headers">C++ 2014 Library Header</a></dt><dt>3.8. <a href="using_headers.html#table.cxx17_headers">C++ 2017 Library Headers</a></dt><dt>3.9. <a href="using_headers.html#table.cxx20_headers">C++ 2020 Library Headers</a></dt><dt>3.10. <a href="using_headers.html#table.cxx20_deprheaders">C++ 2020 Obsolete Headers</a></dt><dt>3.11. <a href="using_headers.html#table.filesystemts_headers">File System TS Header</a></dt><dt>3.12. <a href="using_headers.html#table.libfundts_headers">Library Fundamentals TS Headers</a></dt><dt>3.13. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.14. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.15. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.16. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.17. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.18. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.19. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>20.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>21.1. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>21.2. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>21.3. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>21.4. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>21.5. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.7">
 		A Standard String Hash Function
 	      </a></dt><dt>21.6. <a href="policy_data_structures_design.html#id-1.3.5.8.4.4.2.3.2.4.12">
 		Only k String DNA Hash
diff --git a/libstdc++-v3/doc/html/manual/intro.html b/libstdc++-v3/doc/html/manual/intro.html
index 3604e0a1d45..1a8234437d9 100644
--- a/libstdc++-v3/doc/html/manual/intro.html
+++ b/libstdc++-v3/doc/html/manual/intro.html
@@ -5,4 +5,4 @@
 </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.intro"></a>Part I. 
   Introduction
   <a id="id-1.3.3.1.1.1" class="indexterm"></a>
-</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
+</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
diff --git a/libstdc++-v3/doc/html/manual/setup.html b/libstdc++-v3/doc/html/manual/setup.html
index 636a4401602..f27b8d806df 100644
--- a/libstdc++-v3/doc/html/manual/setup.html
+++ b/libstdc++-v3/doc/html/manual/setup.html
@@ -42,6 +42,39 @@
    </p><p>
    Finally, a few system-specific requirements:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">linux</span></dt><dd><p>
+	  The 'gnu' locale model makes use of <code class="function">iconv</code>
+	  for character set conversions. The relevant functions are provided
+	  by Glibc and so are always available, however they can also be
+	  provided by the separate GNU libiconv library. If GNU libiconv is
+	  found when GCC is built (e.g., because its headers are installed
+	  in <code class="filename">/usr/local/include</code>)
+	  then the <code class="filename">libstdc++.so.6</code> library will have a
+	  run-time dependency on <code class="filename">libiconv.so.2</code>.
+	  If you do not want that run-time dependency then you should do
+	  one of the following:
+	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
+	      Uninstall the libiconv headers before building GCC.
+	      Glibc already provides <code class="function">iconv</code> so you should
+	      not need libiconv anyway.
+	    </p></li><li class="listitem"><p>
+	    <a class="link" href="https://www.gnu.org/software/libiconv/#downloading" target="_top">
+	    Download</a> the libiconv sources and extract them into the
+	    top level of the GCC source tree, e.g.,
+	    </p><pre class="programlisting">
+wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz
+tar xf libiconv-1.16.tar.gz
+ln -s libiconv-1.16 libiconv
+</pre><p>
+	      This will build libiconv as part of building GCC and link to
+	      it statically, so there is no <code class="filename">libiconv.so.2</code>
+	      dependency.
+	    </p></li><li class="listitem"><p>
+	      Configure GCC with <code class="option">--with-libiconv-type=static</code>.
+	      This requires the static <code class="filename">libiconv.a</code> library,
+	      which is not installed by default. You might need to reinstall
+	      libiconv using the <code class="option">--enable-static</code> configure
+	      option to get the static library.
+	    </p></li></ul></div><p>
 	  If GCC 3.1.0 or later on is being used on GNU/Linux, an attempt
 	  will be made to use "C" library functionality necessary for
 	  C++ named locale support.  For GCC 4.6.0 and later, this
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
index 25c676d2892..3805e9e24f0 100644
--- a/libstdc++-v3/doc/html/manual/status.html
+++ b/libstdc++-v3/doc/html/manual/status.html
@@ -2,7 +2,7 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 1. Status</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="intro.html" title="Part I.  Introduction" /><link rel="prev" href="intro.html" title="Part I.  Introduction" /><link rel="next" href="license.html" title="License" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 1. Status</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="intro.html">Prev</a> </td><th width="60%" align="center">Part I. 
   Introduction
   
-</th><td width="20%" align="right"> <a accesskey="n" href="license.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.status"></a>Chapter 1. Status</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.iso"></a>Implementation Status</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.1998"></a>C++ 1998/2003</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.1998.status"></a>Implementation Status</h4></div></div></div><p>
+</th><td width="20%" align="right"> <a accesskey="n" href="license.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.status"></a>Chapter 1. Status</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2014.filesystemts">Filesystem TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.par2ts">Parallelism 2 TS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="status.html#status.iso.2020">C++ 2020</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2023">C++ 2023</a></span></dt><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.status.iso"></a>Implementation Status</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.1998"></a>C++ 1998/2003</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.1998.status"></a>Implementation Status</h4></div></div></div><p>
 This status table is based on the table of contents of ISO/IEC 14882:2003.
 </p><p>
 This section describes the C++ support in the GCC 11 release series.
@@ -1242,8 +1242,8 @@ presence of the required flag.
 This section describes the C++20 and library TS support in the GCC 11
 release series.
 </p><p>
-The following table lists new library features that have been accepted into
-the C++20 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++20 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -1344,10 +1344,10 @@ or any notes about the implementation.
       </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_atomic_float &gt;= 201711L</code> </td></tr><tr><td align="left">  C++ Synchronized Buffered Ostream </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0053r7.pdf" target="_top">
         P0053R7 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201711L</code> </td></tr><tr><td align="left">  Manipulators for C++ Synchronized Buffered Ostream </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201711L</code> </td></tr><tr><td align="left">  Manipulators for C++ Synchronized Buffered Ostream </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0753r2.pdf" target="_top">
         P0753R2 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201803L</code> </td></tr><tr><td align="left">  Make <code class="code">std::memory_order</code> a scoped enumeration </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_syncbuf &gt;= 201803L</code> </td></tr><tr><td align="left">  Make <code class="code">std::memory_order</code> a scoped enumeration </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0439r0.html" target="_top">
         P0439R0 </a>
       </td><td align="center"> 9.1 </td><td align="left"> </td></tr><tr bgcolor="#C8B0B0"><td align="left">  The Curious Case of Padding Bits, Featuring Atomic Compare-and-Exchange </td><td align="left">
@@ -1428,7 +1428,7 @@ or any notes about the implementation.
       </td></tr><tr><td align="left">  <code class="code">string::reserve</code> Should Not Shrink </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0966r1.html" target="_top">
         P0966R1 </a>
-      </td><td align="center"> 11 </td><td align="left"> </td></tr><tr><td align="left">  <code class="code">char8_t</code>: A type for UTF-8 characters and strings </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left">  <code class="code">char8_t</code>: A type for UTF-8 characters and strings </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0482r6.html" target="_top">
         P0482R6 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_char8_t &gt;= 201811L</code> </td></tr><tr><td align="left">  <code class="code">char8_t</code> backward compatibility remediation </td><td align="left">
@@ -1555,7 +1555,7 @@ or any notes about the implementation.
       </td><td align="center"> </td><td align="left"> </td></tr><tr><td align="left">  Bit-casting object representations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0476r2.html" target="_top">
         P0476R2 </a>
-      </td><td align="center"> 11 </td><td align="left"> <code class="code">__cpp_lib_bit_cast &gt;= 201806L</code> </td></tr><tr><td align="left">  Integral power-of-2 operations </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_bit_cast &gt;= 201806L</code> </td></tr><tr><td align="left">  Integral power-of-2 operations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0556r3.html" target="_top">
         P0556R3 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_int_pow2 &gt;= 201806L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left"> On the names of low-level bit manipulation functions </td><td align="left">
@@ -1675,7 +1675,7 @@ or any notes about the implementation.
       </td><td align="center"> 8.1 </td><td align="left"> <code class="code">__cpp_lib_endian &gt;= 201907L</code> </td></tr><tr><td align="left"> Bit operations </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html" target="_top">
         P0553R4 </a>
-      </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left">  Well-behaved interpolation for numbers and pointers </td><td align="left">
+      </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </td></tr><tr><td align="left">  Well-behaved interpolation for numbers and pointers </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0811r3.html" target="_top">
         P0811R3 </a>
       </td><td align="center"> 9.1 </td><td align="left"> <code class="code">__cpp_lib_interpolate &gt;= 201902L</code> </td></tr><tr><td align="left"> Mathematical constants </td><td align="left">
@@ -1684,16 +1684,105 @@ or any notes about the implementation.
       </td><td align="center"> 10.1 </td><td align="left"> <code class="code">__cpp_lib_math_constants &gt;= 201907L</code> </td></tr><tr><td align="left"> std::source_location </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1208r6.pdf" target="_top">
         P1208R6 </a>
-      </td><td align="center"> 11 </td><td align="left">
+      </td><td align="center"> 11.1 </td><td align="left">
         <code class="code">__cpp_lib_source_location &gt;= 201907L</code>
       </td></tr><tr><td align="left"> Efficient access to std::basic_stringbuf's Buffer </td><td align="left">
         <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf" target="_top">
         P0408R7 </a>
-      </td><td align="center"> 11 </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
 Note 1: This feature is supported in older releases but the
 <code class="code">__cpp_lib</code> macro is not defined to the right value
 (or not defined at all) until the version shown in parentheses.
-</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.tr1"></a>C++ TR1</h3></div></div></div><p>
+</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.2023"></a>C++ 2023</h3></div></div></div><p>
+In this implementation the <code class="literal">-std=gnu++23</code> or
+<code class="literal">-std=c++23</code> flag must be used to enable language
+and library
+features. See <a class="link" href="using.html#manual.intro.using.flags" title="Command Options">dialect</a>
+options. The pre-defined symbol
+<code class="constant">__cplusplus</code> is used to check for the
+presence of the required flag.
+</p><p>
+This section describes the C++23 and library TS support in mainline GCC,
+not in any particular release.
+</p><p>
+The following table lists new library features that have been accepted into
+the C++23 working draft. The "Proposal" column provides a link to the
+ISO C++ committee proposal that describes the feature, while the "Status"
+column indicates the first version of GCC that contains an implementation of
+this feature (if it has been implemented).
+A dash (—) in the status column indicates that the changes in the proposal
+either do not affect the code in libstdc++, or the changes are not required for conformance.
+The "SD-6 Feature Test / Notes" column shows the corresponding macro or header from
+<a class="link" href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations" target="_top">SD-6:
+Feature-testing recommendations for C++</a> (where applicable)
+or any notes about the implementation.
+</p><div class="table"><a id="table.cxx23_features"></a><p class="title"><strong>Table 1.10. C++ 2023 Library Features</strong></p><div class="table-contents"><table class="table" summary="C++ 2023 Library Features" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Library Feature</th><th align="left">Proposal</th><th align="left">Status</th><th align="left">SD-6 Feature Test / Notes</th></tr></thead><tbody><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Ranges and Views</strong></span>
+      </td></tr><tr><td align="left"> Range constructor for std::string_view </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf" target="_top">
+        P1989R2
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> <code class="code">join_view</code> should join all views of ranges </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r1.html" target="_top">
+        P2328R1
+        </a>
+      </td><td align="center"> 11.2 </td><td align="left"> </td></tr><tr><td align="left"> Clarifying range adaptor objects </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2281r1.html" target="_top">
+        P2281R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> Views should not be required to be default constructible </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html" target="_top">
+        P2325R3
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> <code class="code">__cpp_lib_ranges &gt;= 202106L</code> </td></tr><tr><td align="left"> Conditionally borrowed ranges </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2017r1.html" target="_top">
+        P2017R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> </td></tr><tr><td align="left"> Require <code class="code">span</code> &amp; <code class="code">basic_string_view</code> to be Trivially Copyable </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf" target="_top">
+        P2251R1
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Compile-time programming</strong></span>
+      </td></tr><tr><td align="left"> A proposal for a type trait to detect scoped enumerations </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1048r1.pdf" target="_top">
+        P1048R1
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_is_scoped_enum &gt;= 202011L</code> </td></tr><tr><td align="left"> std::to_underlying for enumerations </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r3.html" target="_top">
+        P1682R3
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_to_underlying &gt;= 202102L</code> </td></tr><tr bgcolor="#B0B0B0"><td align="left"> Missing constexpr in std::optional and std::variant </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html" target="_top">
+        P2231R1
+        </a>
+      </td><td align="center"> 11.3 (<code class="code">optional</code> only) </td><td align="left">
+	<div class="informaltable"><table class="informaltable" border="0"><colgroup><col /></colgroup><tbody><tr><td> <code class="code">__cpp_lib_constexpr_optional &gt;= 202106L</code> </td></tr><tr><td> <code class="code">__cpp_lib_variant &gt;= 202106L</code> </td></tr></tbody></table></div>
+      </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Strings and text</strong></span>
+      </td></tr><tr><td align="left"> string contains function </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r3.html" target="_top">
+        P1679R3
+        </a>
+      </td><td align="center"> 11.1 </td><td align="left"> <code class="code">__cpp_lib_string_contains &gt;= 202011L</code> </td></tr><tr><td colspan="4" align="left">
+        <span class="bold"><strong>Miscellaneous</strong></span>
+      </td></tr><tr><td align="left"> Inheriting from <code class="code">std::variant</code> </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2162r2.html" target="_top">
+        P2162R2
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> <code class="code">__cpp_lib_variant &gt;= 202102L</code> </td></tr><tr><td align="left"> Printing <code class="code">volatile</code> Pointers </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1147r1.html" target="_top">
+        P1147R1
+        </a>
+      </td><td align="center"> 11.3 </td><td align="left"> </td></tr><tr><td align="left"> Clarifying the status of the "C headers" </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r1.html" target="_top">
+        P2340R1
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr><tr><td align="left"> Relax Requirements for time_point::clock </td><td align="left">
+        <a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html" target="_top">
+        P2212R2
+        </a>
+      </td><td align="center"> Yes </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="status.iso.tr1"></a>C++ TR1</h3></div></div></div><p>
 This table is based on the table of contents of ISO/IEC DTR 19768
 Doc No: N1836=05-0096 Date: 2005-06-24
 Draft Technical Report on C++ Library Extensions
@@ -1703,7 +1792,7 @@ In this implementation the header names are prefixed by
 <code class="code">&lt;tr1/memory&gt;</code>, and so on.
 </p><p>
 This page describes the TR1 support in the GCC 11 release series.
-</p><div class="table"><a id="table.tr1_status"></a><p class="title"><strong>Table 1.10. C++ TR1 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR1 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left"><span class="emphasis"><em>2</em></span></td><td colspan="3" align="left"><span class="emphasis"><em>General Utilities</em></span></td></tr><tr><td align="left">2.1</td><td align="left">Reference wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.1</td><td align="left">Additions to header <code class="code">&lt;functional&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.2.1</td><td align="left"><code class="code">reference_wrapper</code> construct/copy/destroy</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.2</td><td align="left"><code class="code">reference_wrapper</code> assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.3</td><td align="left"><code class="code">reference_wrapper</code> access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.4</td><td align="left"><code class="code">reference_wrapper</code> invocation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.5</td><td align="left"><code class="code">reference_wrapper</code> helper functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.2.1</td><td align="left">Additions to header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.2</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.3</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left"> </td><td align="left">
+</p><div class="table"><a id="table.tr1_status"></a><p class="title"><strong>Table 1.11. C++ TR1 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR1 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left"><span class="emphasis"><em>2</em></span></td><td colspan="3" align="left"><span class="emphasis"><em>General Utilities</em></span></td></tr><tr><td align="left">2.1</td><td align="left">Reference wrappers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.1</td><td align="left">Additions to header <code class="code">&lt;functional&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2</td><td align="left">Class template <code class="code">reference_wrapper</code></td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.1.2.1</td><td align="left"><code class="code">reference_wrapper</code> construct/copy/destroy</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.2</td><td align="left"><code class="code">reference_wrapper</code> assignment</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.3</td><td align="left"><code class="code">reference_wrapper</code> access</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.4</td><td align="left"><code class="code">reference_wrapper</code> invocation</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.1.2.5</td><td align="left"><code class="code">reference_wrapper</code> helper functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2</td><td align="left">Smart pointers</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">2.2.1</td><td align="left">Additions to header <code class="code">&lt;memory&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.2</td><td align="left">Class <code class="code">bad_weak_ptr</code></td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">2.2.3</td><td align="left">Class template <code class="code">shared_ptr</code></td><td align="left"> </td><td align="left">
 	<p>
 	  Uses code from
 	  <a class="link" href="http://www.boost.org/libs/smart_ptr/shared_ptr.htm" target="_top">boost::shared_ptr</a>.
@@ -1723,7 +1812,7 @@ Extension for the programming language C++ to support
 decimal floating-point arithmetic
 </p><p>
 This page describes the TR 24733 support in the GCC 11 release series.
-</p><div class="table"><a id="table.decfp_status"></a><p class="title"><strong>Table 1.11. C++ TR 24733 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
+</p><div class="table"><a id="table.decfp_status"></a><p class="title"><strong>Table 1.12. C++ TR 24733 Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">
 	<span class="emphasis"><em>0</em></span>
       </td><td colspan="3" align="left">
 	<span class="emphasis"><em>Introduction</em></span>
@@ -1763,7 +1852,7 @@ non-strict modes (i.e. <code class="code">-std=gnu++NN</code> modes) the
 hypergeometric functions and confluent hypergeometric functions
 from TR1 are also provided, defined in namespace
 <code class="code">__gnu_cxx</code>.
-</p><div class="table"><a id="table.specfun_status"></a><p class="title"><strong>Table 1.12. C++ Special Functions Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ Special Functions Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr bgcolor="#B0B0B0"><td align="left">7</td><td align="left">Macro names</td><td align="left">Partial</td><td align="left">No diagnostic for inconsistent definitions of
+</p><div class="table"><a id="table.specfun_status"></a><p class="title"><strong>Table 1.13. C++ Special Functions Implementation Status</strong></p><div class="table-contents"><table class="table" summary="C++ Special Functions Implementation Status" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Section</th><th align="left">Description</th><th align="left">Status</th><th align="left">Comments</th></tr></thead><tbody><tr bgcolor="#B0B0B0"><td align="left">7</td><td align="left">Macro names</td><td align="left">Partial</td><td align="left">No diagnostic for inconsistent definitions of
              <code class="code">__STDCPP_WANT_MATH_SPEC_FUNCS__</code></td></tr><tr><td align="left">8</td><td align="left">Mathematical special functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1</td><td align="left">Additions to header <code class="code">&lt;cmath&gt;</code> synopsis</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.1</td><td align="left">associated Laguerre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.2</td><td align="left">associated Legendre functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.3</td><td align="left">beta function</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.4</td><td align="left">(complete) elliptic integral of the first kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.5</td><td align="left">(complete) elliptic integral of the second kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.6</td><td align="left">(complete) elliptic integral of the third kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.7</td><td align="left">regular modified cylindrical Bessel functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.8</td><td align="left">cylindrical Bessel functions (of the first kind)</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.9</td><td align="left">irregular modified cylindrical Bessel functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.10</td><td align="left">cylindrical Neumann functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.11</td><td align="left">(incomplete) elliptic integral of the first kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.12</td><td align="left">(incomplete) elliptic integral of the second kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.13</td><td align="left">(incomplete) elliptic integral of the third kind</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.14</td><td align="left">exponential integral</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.15</td><td align="left">Hermite polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.16</td><td align="left">Laguerre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.17</td><td align="left">Legendre polynomials</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.18</td><td align="left">Riemann zeta function</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.19</td><td align="left">spherical Bessel functions (of the first kind)</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.20</td><td align="left">spherical associated Legendre functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.1.21</td><td align="left">spherical Neumann functions</td><td align="left">Y</td><td align="left"> </td></tr><tr><td align="left">8.2</td><td align="left">Additions to header <code class="code">&lt;math.h&gt;</code></td><td align="left">Y</td><td align="left"> </td></tr><tr bgcolor="#B0B0B0"><td align="left">8.3</td><td align="left">The header <code class="code">&lt;ctgmath&gt;</code></td><td align="left">Partial</td><td align="left">Conflicts with C++ 2011 requirements.</td></tr><tr bgcolor="#C8B0B0"><td align="left">8.4</td><td align="left">The header <code class="code">&lt;tgmath.h&gt;</code></td><td align="left">N</td><td align="left">Conflicts with C++ 2011 requirements.</td></tr></tbody></table></div></div><br class="table-break" /><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="iso.specfun.specific"></a>Implementation Specific Behavior</h4></div></div></div><p>For behaviour which is specified by the 2011 standard,
       see <a class="link" href="status.html#iso.2011.specific" title="Implementation Specific Behavior">C++ 2011 Implementation
       Specific Behavior</a>. This section documents behaviour which
diff --git a/libstdc++-v3/doc/xml/authors.xml b/libstdc++-v3/doc/xml/authors.xml
index 0a120b508e9..95626d46cba 100644
--- a/libstdc++-v3/doc/xml/authors.xml
+++ b/libstdc++-v3/doc/xml/authors.xml
@@ -13,18 +13,13 @@
       </address>
     </affiliation>
 
-    <authorblurb>
+    <personblurb>
       <para>
       </para>
-    </authorblurb>
+    </personblurb>
   </author>
 -->
 
-  <author><personname><firstname/><surname/></personname><personblurb>
-      <para>
-      </para>
-    </personblurb></author>
-
   <author><personname><firstname>Paolo</firstname><surname>Carlini</surname></personname><personblurb>
       <para>
 	TR1, LWG Active, Closed, Defects lists.
diff --git a/libstdc++-v3/doc/xml/manual/evolution.xml b/libstdc++-v3/doc/xml/manual/evolution.xml
index 55b8903baff..6ae6b5aec19 100644
--- a/libstdc++-v3/doc/xml/manual/evolution.xml
+++ b/libstdc++-v3/doc/xml/manual/evolution.xml
@@ -911,6 +911,13 @@ now defaults to zero.
   <filename>libstdc++.so.8</filename>.
 </para>
 
+<para>
+  The extension allowing containers to be instantiated with an allocator
+  that doesn't match the container's value type is no longer allowed in
+  strict (<option>-std=c++NN</option>) modes, only in
+  <option>-std=gnu++NN</option> modes.
+</para>
+
 </section>
 
 <section xml:id="api.rel_91"><info><title><constant>9</constant></title></info>
@@ -994,6 +1001,12 @@ now defaults to zero.
   added.
 </para>
 
+<para>
+  The extension allowing containers to be instantiated with an allocator
+  that doesn't match the container's value type is no longer allowed in
+  C++20 mode, even in non-strict <option>-std=gnu++20</option> mode.
+</para>
+
 </section>
 
 <section xml:id="api.rel_111"><info><title><constant>11</constant></title></info>
diff --git a/libstdc++-v3/doc/xml/manual/extensions.xml b/libstdc++-v3/doc/xml/manual/extensions.xml
index 86e92beffd3..196b55d8347 100644
--- a/libstdc++-v3/doc/xml/manual/extensions.xml
+++ b/libstdc++-v3/doc/xml/manual/extensions.xml
@@ -534,14 +534,6 @@ int main()
   int     status;
   char   *realname;
 
-  // exception classes not in &lt;stdexcept&gt;, thrown by the implementation
-  // instead of the user
-  std::bad_exception  e;
-  realname = abi::__cxa_demangle(e.what(), 0, 0, &amp;status);
-  std::cout &lt;&lt; e.what() &lt;&lt; "\t=&gt; " &lt;&lt; realname &lt;&lt; "\t: " &lt;&lt; status &lt;&lt; '\n';
-  free(realname);
-
-
   // typeid
   bar&lt;empty,17&gt;          u;
   const std::type_info  &amp;ti = typeid(u);
@@ -559,7 +551,6 @@ int main()
 
    <screen>
    <computeroutput>
-      St13bad_exception       =&gt; std::bad_exception   : 0
       3barI5emptyLi17EE       =&gt; bar&lt;empty, 17&gt;       : 0
    </computeroutput>
    </screen>
@@ -568,8 +559,8 @@ int main()
      The demangler interface is described in the source documentation
      linked to above.  It is actually written in C, so you don't need to
      be writing C++ in order to demangle C++.  (That also means we have to
-     use crummy memory management facilities, so don't forget to free()
-     the returned char array.)
+     use crummy memory management facilities, so don't forget to
+     <code>free()</code> the returned char array.)
    </para>
 </chapter>
 
diff --git a/libstdc++-v3/doc/xml/manual/intro.xml b/libstdc++-v3/doc/xml/manual/intro.xml
index 3e7843f58c1..98dbf596866 100644
--- a/libstdc++-v3/doc/xml/manual/intro.xml
+++ b/libstdc++-v3/doc/xml/manual/intro.xml
@@ -47,15 +47,19 @@
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxx2020.xml">
     </xi:include>
 
-    <!-- Section 01.5 : Status C++ TR1 -->
+    <!-- Section 01.5 : Status C++ 2023 -->
+    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxx2023.xml">
+    </xi:include>
+
+    <!-- Section 01.6 : Status C++ TR1 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxtr1.xml">
     </xi:include>
 
-    <!-- Section 01.6 : Status C++ TR24733 -->
+    <!-- Section 01.7 : Status C++ TR24733 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxtr24733.xml">
     </xi:include>
 
-    <!-- Section 01.7 : Status C++ IS 24733 -->
+    <!-- Section 01.8 : Status C++ IS 29124 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxis29124.xml">
     </xi:include>
   </section>
@@ -835,6 +839,12 @@ requirements of the license of GCC.
 		    by the resolution of the DR.
     </para></listitem></varlistentry>
 
+    <varlistentry xml:id="manual.bugs.dr1203"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#1203">1203</link>:
+       <emphasis>More useful rvalue stream insertion</emphasis>
+    </term>
+    <listitem><para>Return the stream as its original type, not the base class.
+    </para></listitem></varlistentry>
+
     <varlistentry xml:id="manual.bugs.dr1339"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#1339">1339</link>:
        <emphasis>uninitialized_fill_n should return the end of its range</emphasis>
     </term>
diff --git a/libstdc++-v3/doc/xml/manual/prerequisites.xml b/libstdc++-v3/doc/xml/manual/prerequisites.xml
index 22e90a7e79d..f00979a1afa 100644
--- a/libstdc++-v3/doc/xml/manual/prerequisites.xml
+++ b/libstdc++-v3/doc/xml/manual/prerequisites.xml
@@ -48,6 +48,57 @@
       <varlistentry>
 	<term>linux</term>
 
+	<listitem>
+	<para>
+	  The 'gnu' locale model makes use of <function>iconv</function>
+	  for character set conversions. The relevant functions are provided
+	  by Glibc and so are always available, however they can also be
+	  provided by the separate GNU libiconv library. If GNU libiconv is
+	  found when GCC is built (e.g., because its headers are installed
+	  in <filename class="directory">/usr/local/include</filename>)
+	  then the <filename>libstdc++.so.6</filename> library will have a
+	  run-time dependency on <filename>libiconv.so.2</filename>.
+	  If you do not want that run-time dependency then you should do
+	  one of the following:
+	</para>
+	<itemizedlist>
+	  <listitem>
+	    <para>
+	      Uninstall the libiconv headers before building GCC.
+	      Glibc already provides <function>iconv</function> so you should
+	      not need libiconv anyway.
+	    </para>
+	  </listitem>
+	  <listitem>
+	    <para>
+	    <link xmlns:xlink="http://www.w3.org/1999/xlink"
+	      xlink:href="https://www.gnu.org/software/libiconv/#downloading">
+	    Download</link> the libiconv sources and extract them into the
+	    top level of the GCC source tree, e.g.,
+	    </para>
+<programlisting>
+wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz
+tar xf libiconv-1.16.tar.gz
+ln -s libiconv-1.16 libiconv
+</programlisting>
+	    <para>
+	      This will build libiconv as part of building GCC and link to
+	      it statically, so there is no <filename>libiconv.so.2</filename>
+	      dependency.
+	    </para>
+	  </listitem>
+	  <listitem>
+	    <para>
+	      Configure GCC with <option>--with-libiconv-type=static</option>.
+	      This requires the static <filename>libiconv.a</filename> library,
+	      which is not installed by default. You might need to reinstall
+	      libiconv using the <option>--enable-static</option> configure
+	      option to get the static library.
+	    </para>
+	  </listitem>
+	</itemizedlist>
+	</listitem>
+
 	<listitem>
 	<para>
 	  If GCC 3.1.0 or later on is being used on GNU/Linux, an attempt
diff --git a/libstdc++-v3/doc/xml/manual/spine.xml b/libstdc++-v3/doc/xml/manual/spine.xml
index 34daa33344c..eff72bc13d7 100644
--- a/libstdc++-v3/doc/xml/manual/spine.xml
+++ b/libstdc++-v3/doc/xml/manual/spine.xml
@@ -48,18 +48,13 @@
       </address>
     </affiliation>
 
-    <authorblurb>
+    <personblurb>
       <para>
       </para>
-    </authorblurb>
+    </personblurb>
   </author>
 -->
 
-  <author><personname><firstname/><surname/></personname><personblurb>
-      <para>
-      </para>
-    </personblurb></author>
-
   <author><personname><firstname>Paolo</firstname><surname>Carlini</surname></personname><personblurb>
       <para>
 	TR1, LWG Active, Closed, Defects lists.
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
index 411a337c534..67aac7d64b8 100644
--- a/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2020.xml
@@ -25,8 +25,8 @@ release series.
 </para>
 
 <para>
-The following table lists new library features that have been accepted into
-the C++20 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++20 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -362,7 +362,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0053r7.pdf">
         P0053R7 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_syncbuf &gt;= 201711L</code> </entry>
     </row>
 
@@ -372,7 +372,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0753r2.pdf">
         P0753R2 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_syncbuf &gt;= 201803L</code> </entry>
     </row>
 
@@ -647,7 +647,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0966r1.html">
         P0966R1 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry />
     </row>
 
@@ -1045,7 +1045,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0476r2.html">
         P0476R2 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry> <code>__cpp_lib_bit_cast &gt;= 201806L</code> </entry>
     </row>
 
@@ -1401,7 +1401,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0553r4.html">
         P0553R4 </link>
       </entry>
-      <entry align="center"> 10.1 </entry>
+      <entry align="center"> 9.1 </entry>
       <entry> <code>__cpp_lib_bitops &gt;= 201907L</code> (since 9.4, see Note 1) </entry>
     </row>
 
@@ -1431,7 +1431,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1208r6.pdf">
         P1208R6 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry>
         <code>__cpp_lib_source_location &gt;= 201907L</code>
       </entry>
@@ -1443,7 +1443,7 @@ or any notes about the implementation.
         <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">
         P0408R7 </link>
       </entry>
-      <entry align="center"> 11 </entry>
+      <entry align="center"> 11.1 </entry>
       <entry />
     </row>
 
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2023.xml b/libstdc++-v3/doc/xml/manual/status_cxx2023.xml
new file mode 100644
index 00000000000..75f31f55aa9
--- /dev/null
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2023.xml
@@ -0,0 +1,249 @@
+<section xmlns="http://docbook.org/ns/docbook" version="5.0"
+   xml:id="status.iso.2023" xreflabel="Status C++ 2023">
+<?dbhtml filename="status_iso_cxx2023.html"?>
+
+<info><title>C++ 2023</title>
+  <keywordset>
+    <keyword>ISO C++</keyword>
+    <keyword>2023</keyword>
+  </keywordset>
+</info>
+
+<para>
+In this implementation the <literal>-std=gnu++23</literal> or
+<literal>-std=c++23</literal> flag must be used to enable language
+and library
+features. See <link linkend="manual.intro.using.flags">dialect</link>
+options. The pre-defined symbol
+<constant>__cplusplus</constant> is used to check for the
+presence of the required flag.
+</para>
+
+<para>
+This section describes the C++23 and library TS support in mainline GCC,
+not in any particular release.
+</para>
+
+<para>
+The following table lists new library features that have been accepted into
+the C++23 working draft. The "Proposal" column provides a link to the
+ISO C++ committee proposal that describes the feature, while the "Status"
+column indicates the first version of GCC that contains an implementation of
+this feature (if it has been implemented).
+A dash (&#x2014;) in the status column indicates that the changes in the proposal
+either do not affect the code in libstdc++, or the changes are not required for conformance.
+The "SD-6 Feature Test / Notes" column shows the corresponding macro or header from
+<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">SD-6:
+Feature-testing recommendations for C++</link> (where applicable)
+or any notes about the implementation.
+</para>
+
+<table frame="all" xml:id="table.cxx23_features">
+<title>C++ 2023 Library Features</title>
+
+<tgroup cols="4" align="left" colsep="0" rowsep="1">
+<colspec colname="c1"/>
+<colspec colname="c2"/>
+<colspec colname="c3"/>
+<colspec colname="c4"/>
+  <thead>
+    <row>
+      <entry>Library Feature</entry>
+      <entry>Proposal</entry>
+      <entry>Status</entry>
+      <entry>SD-6 Feature Test / Notes</entry>
+    </row>
+  </thead>
+
+  <tbody>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Ranges and Views</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> Range constructor for std::string_view </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf">
+        P1989R2
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> <code>join_view</code> should join all views of ranges </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2328r1.html">
+        P2328R1
+        </link>
+      </entry>
+      <entry align="center"> 11.2 </entry>
+      <entry />
+    </row>
+
+
+    <row>
+      <entry> Clarifying range adaptor objects </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2281r1.html">
+        P2281R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Views should not be required to be default constructible </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r3.html">
+        P2325R3
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry> <code>__cpp_lib_ranges &gt;= 202106L</code> </entry>
+    </row>
+
+    <row>
+      <entry> Conditionally borrowed ranges </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2017r1.html">
+        P2017R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Require <code>span</code> &amp; <code>basic_string_view</code> to be Trivially Copyable </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf">
+        P2251R1
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Compile-time programming</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> A proposal for a type trait to detect scoped enumerations </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1048r1.pdf">
+        P1048R1
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_is_scoped_enum &gt;= 202011L</code> </entry>
+    </row>
+
+    <row>
+      <entry> std::to_underlying for enumerations </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1682r3.html">
+        P1682R3
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_to_underlying &gt;= 202102L</code> </entry>
+    </row>
+
+    <row>
+      <?dbhtml bgcolor="#B0B0B0" ?>
+      <entry> Missing constexpr in std::optional and std::variant </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html">
+        P2231R1
+        </link>
+      </entry>
+      <entry align="center"> 11.3 (<code>optional</code> only) </entry>
+      <entry>
+	<informaltable colsep="0" rowsep="0" rowheader="norowheader" frame="none"><tgroup cols="1"><tbody>
+        <row><entry> <code>__cpp_lib_constexpr_optional &gt;= 202106L</code> </entry></row>
+        <row><entry> <code>__cpp_lib_variant &gt;= 202106L</code> </entry></row>
+        </tbody></tgroup></informaltable>
+      </entry>
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Strings and text</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> string contains function </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1679r3.html">
+        P1679R3
+        </link>
+      </entry>
+      <entry align="center"> 11.1 </entry>
+      <entry> <code>__cpp_lib_string_contains &gt;= 202011L</code> </entry>
+    </row>
+
+    <row>
+      <entry namest="c1" nameend="c4" align="left">
+        <emphasis role="bold">Miscellaneous</emphasis>
+      </entry>
+    </row>
+
+    <row>
+      <entry> Inheriting from <code>std::variant</code> </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2162r2.html">
+        P2162R2
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry> <code>__cpp_lib_variant &gt;= 202102L</code> </entry>
+    </row>
+
+    <row>
+      <entry> Printing <code>volatile</code> Pointers </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1147r1.html">
+        P1147R1
+        </link>
+      </entry>
+      <entry align="center"> 11.3 </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Clarifying the status of the "C headers" </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r1.html">
+        P2340R1
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+    <row>
+      <entry> Relax Requirements for time_point::clock </entry>
+      <entry>
+        <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html">
+        P2212R2
+        </link>
+      </entry>
+      <entry align="center"> Yes </entry>
+      <entry />
+    </row>
+
+  </tbody>
+</tgroup>
+</table>
+
+</section>
diff --git a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
index 174fafeee5e..16ea5ffef52 100644
--- a/libstdc++-v3/include/Makefile.am
+++ b/libstdc++-v3/include/Makefile.am
@@ -1275,7 +1275,7 @@ stamp-float128:
 endif
 
 # This header is not installed, it's only used to build libstdc++ itself.
-${host_builddir}/largefile-config.h: ${CONFIG_HEADER}
+${host_builddir}/largefile-config.h: ${CONFIG_HEADER} stamp-${host_alias}
 	@rm -f $@.tmp
 	@-grep 'define _DARWIN_USE_64_BIT_INODE' ${CONFIG_HEADER} >> $@.tmp
 	@-grep 'define _FILE_OFFSET_BITS' ${CONFIG_HEADER} >> $@.tmp
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index 814b0a43b3d..877133d8165 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -1761,7 +1761,7 @@ stamp-host: ${host_headers} ${bits_host_headers} ${ext_host_headers} ${host_head
 @ENABLE_FLOAT128_FALSE@	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
 
 # This header is not installed, it's only used to build libstdc++ itself.
-${host_builddir}/largefile-config.h: ${CONFIG_HEADER}
+${host_builddir}/largefile-config.h: ${CONFIG_HEADER} stamp-${host_alias}
 	@rm -f $@.tmp
 	@-grep 'define _DARWIN_USE_64_BIT_INODE' ${CONFIG_HEADER} >> $@.tmp
 	@-grep 'define _FILE_OFFSET_BITS' ${CONFIG_HEADER} >> $@.tmp
diff --git a/libstdc++-v3/include/bits/atomic_base.h b/libstdc++-v3/include/bits/atomic_base.h
index 60b976bf8d1..2abdc400260 100644
--- a/libstdc++-v3/include/bits/atomic_base.h
+++ b/libstdc++-v3/include/bits/atomic_base.h
@@ -121,6 +121,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       | __memory_order_modifier(__m & __memory_order_modifier_mask));
   }
 
+  constexpr bool
+  __is_valid_cmpexch_failure_order(memory_order __m) noexcept
+  {
+    return (__m & __memory_order_mask) != memory_order_release
+	&& (__m & __memory_order_mask) != memory_order_acq_rel;
+  }
+
   _GLIBCXX_ALWAYS_INLINE void
   atomic_thread_fence(memory_order __m) noexcept
   { __atomic_thread_fence(int(__m)); }
@@ -245,13 +252,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     _GLIBCXX_ALWAYS_INLINE void
-    notify_one() const noexcept
+    notify_one() noexcept
     { std::__atomic_notify_address(&_M_i, false); }
 
     // TODO add const volatile overload
 
     _GLIBCXX_ALWAYS_INLINE void
-    notify_all() const noexcept
+    notify_all() noexcept
     { std::__atomic_notify_address(&_M_i, true); }
 
     // TODO add const volatile overload
@@ -511,13 +518,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(__int_type& __i1, __int_type __i2,
 			    memory_order __m1, memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
 					   int(__m1), int(__m2));
@@ -528,13 +529,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			    memory_order __m1,
 			    memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
 					   int(__m1), int(__m2));
@@ -560,13 +555,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(__int_type& __i1, __int_type __i2,
 			      memory_order __m1, memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
 					   int(__m1), int(__m2));
@@ -577,14 +566,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
 					   int(__m1), int(__m2));
@@ -618,13 +600,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // TODO add const volatile overload
 
       _GLIBCXX_ALWAYS_INLINE void
-      notify_one() const noexcept
+      notify_one() noexcept
       { std::__atomic_notify_address(&_M_i, false); }
 
       // TODO add const volatile overload
 
       _GLIBCXX_ALWAYS_INLINE void
-      notify_all() const noexcept
+      notify_all() noexcept
       { std::__atomic_notify_address(&_M_i, true); }
 
       // TODO add const volatile overload
@@ -869,13 +851,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
 					   int(__m1), int(__m2));
@@ -886,14 +862,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
 					   int(__m1), int(__m2));
@@ -996,6 +965,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			    _Val<_Tp> __desired, memory_order __success,
 			    memory_order __failure) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));
+
 	return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
 					 std::__addressof(__desired), true,
 					 int(__success), int(__failure));
@@ -1007,6 +978,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      _Val<_Tp> __desired, memory_order __success,
 			      memory_order __failure) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));
+
 	return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
 					 std::__addressof(__desired), false,
 					 int(__success), int(__failure));
diff --git a/libstdc++-v3/include/bits/atomic_wait.h b/libstdc++-v3/include/bits/atomic_wait.h
index 394f666d02e..d6231808ec7 100644
--- a/libstdc++-v3/include/bits/atomic_wait.h
+++ b/libstdc++-v3/include/bits/atomic_wait.h
@@ -142,8 +142,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
     }
 
-    constexpr auto __atomic_spin_count_1 = 12;
-    constexpr auto __atomic_spin_count_2 = 4;
+    constexpr auto __atomic_spin_count_relax = 12;
+    constexpr auto __atomic_spin_count = 16;
 
     struct __default_spin_policy
     {
@@ -157,18 +157,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool
       __atomic_spin(_Pred& __pred, _Spin __spin = _Spin{ }) noexcept
       {
-	for (auto __i = 0; __i < __atomic_spin_count_1; ++__i)
+	for (auto __i = 0; __i < __atomic_spin_count; ++__i)
 	  {
 	    if (__pred())
 	      return true;
-	    __detail::__thread_relax();
-	  }
 
-	for (auto __i = 0; __i < __atomic_spin_count_2; ++__i)
-	  {
-	    if (__pred())
-	      return true;
-	    __detail::__thread_yield();
+	    if (__i < __atomic_spin_count_relax)
+	      __detail::__thread_relax();
+	    else
+	      __detail::__thread_yield();
 	  }
 
 	while (__spin())
@@ -226,18 +223,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
 
       void
-      _M_notify(const __platform_wait_t* __addr, bool __all, bool __bare) noexcept
+      _M_notify(__platform_wait_t* __addr, [[maybe_unused]] bool __all,
+		bool __bare) noexcept
       {
-	if (!(__bare || _M_waiting()))
-	  return;
-
 #ifdef _GLIBCXX_HAVE_PLATFORM_WAIT
-	__platform_notify(__addr, __all);
+	if (__addr == &_M_ver)
+	  {
+	    __atomic_fetch_add(__addr, 1, __ATOMIC_SEQ_CST);
+	    __all = true;
+	  }
+
+	if (__bare || _M_waiting())
+	  __platform_notify(__addr, __all);
 #else
-	if (__all)
+	{
+	  lock_guard<mutex> __l(_M_mtx);
+	  __atomic_fetch_add(__addr, 1, __ATOMIC_RELAXED);
+	}
+	if (__bare || _M_waiting())
 	  _M_cv.notify_all();
-	else
-	  _M_cv.notify_one();
 #endif
       }
 
@@ -264,7 +268,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	if (__val == __old)
 	  {
 	    lock_guard<mutex> __l(_M_mtx);
-	    _M_cv.wait(_M_mtx);
+	    __atomic_load(__addr, &__val, __ATOMIC_RELAXED);
+	    if (__val == __old)
+	      _M_cv.wait(_M_mtx);
 	  }
 #endif // __GLIBCXX_HAVE_PLATFORM_WAIT
       }
@@ -302,20 +308,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    , _M_addr(_S_wait_addr(__addr, &_M_w._M_ver))
 	  { }
 
-	bool
-	_M_laundered() const
-	{ return _M_addr == &_M_w._M_ver; }
-
 	void
-	_M_notify(bool __all, bool __bare = false)
-	{
-	  if (_M_laundered())
-	    {
-	      __atomic_fetch_add(_M_addr, 1, __ATOMIC_SEQ_CST);
-	      __all = true;
-	    }
-	  _M_w._M_notify(_M_addr, __all, __bare);
-	}
+	_M_notify(bool __all, bool __bare = false) noexcept
+	{ _M_w._M_notify(_M_addr, __all, __bare); }
 
 	template<typename _Up, typename _ValFn,
 		 typename _Spin = __default_spin_policy>
diff --git a/libstdc++-v3/include/bits/forward_list.tcc b/libstdc++-v3/include/bits/forward_list.tcc
index bd7a859091f..1145230b910 100644
--- a/libstdc++-v3/include/bits/forward_list.tcc
+++ b/libstdc++-v3/include/bits/forward_list.tcc
@@ -367,6 +367,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       forward_list<_Tp, _Alloc>::
       merge(forward_list&& __list, _Comp __comp)
       {
+	// _GLIBCXX_RESOLVE_LIB_DEFECTS
+	// 3088. forward_list::merge behavior unclear when passed *this
+	if (std::__addressof(__list) == this)
+	  return;
+
 	_Node_base* __node = &this->_M_impl._M_head;
 	while (__node->_M_next && __list._M_impl._M_head._M_next)
 	  {
diff --git a/libstdc++-v3/include/bits/fs_dir.h b/libstdc++-v3/include/bits/fs_dir.h
index 2674ca6b115..e9a2d1de250 100644
--- a/libstdc++-v3/include/bits/fs_dir.h
+++ b/libstdc++-v3/include/bits/fs_dir.h
@@ -537,6 +537,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
     struct _Dir_stack;
     std::__shared_ptr<_Dir_stack> _M_dirs;
+
+    recursive_directory_iterator&
+    __erase(error_code* = nullptr);
+
+    friend uintmax_t
+    filesystem::remove_all(const path&, error_code&);
+    friend uintmax_t
+    filesystem::remove_all(const path&);
   };
 
   /// @relates std::filesystem::recursive_directory_iterator @{
diff --git a/libstdc++-v3/include/bits/fs_fwd.h b/libstdc++-v3/include/bits/fs_fwd.h
index fbf687ca310..c2292977dbc 100644
--- a/libstdc++-v3/include/bits/fs_fwd.h
+++ b/libstdc++-v3/include/bits/fs_fwd.h
@@ -354,6 +354,10 @@ _GLIBCXX_END_NAMESPACE_CXX11
   bool is_regular_file(file_status) noexcept;
   bool is_symlink(file_status) noexcept;
 
+  bool remove(const path&, error_code&) noexcept;
+  uintmax_t remove_all(const path&);
+  uintmax_t remove_all(const path&, error_code&);
+
 /// @}
 } // namespace filesystem
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/bits/fs_ops.h b/libstdc++-v3/include/bits/fs_ops.h
index 5d7dfe155b5..ef01c1b824f 100644
--- a/libstdc++-v3/include/bits/fs_ops.h
+++ b/libstdc++-v3/include/bits/fs_ops.h
@@ -44,10 +44,16 @@ namespace filesystem
    *  @{
    */
 
+  [[nodiscard]]
   path absolute(const path& __p);
+
+  [[nodiscard]]
   path absolute(const path& __p, error_code& __ec);
 
+  [[nodiscard]]
   path canonical(const path& __p);
+
+  [[nodiscard]]
   path canonical(const path& __p, error_code& __ec);
 
   inline void
@@ -100,25 +106,34 @@ namespace filesystem
   void create_symlink(const path& __to, const path& __new_symlink,
 		      error_code& __ec) noexcept;
 
+  [[nodiscard]]
   path current_path();
+
+  [[nodiscard]]
   path current_path(error_code& __ec);
+
   void current_path(const path& __p);
   void current_path(const path& __p, error_code& __ec) noexcept;
 
+  [[nodiscard]]
   bool
   equivalent(const path& __p1, const path& __p2);
 
+  [[nodiscard]]
   bool
   equivalent(const path& __p1, const path& __p2, error_code& __ec) noexcept;
 
+  [[nodiscard]]
   inline bool
   exists(file_status __s) noexcept
   { return status_known(__s) && __s.type() != file_type::not_found; }
 
+  [[nodiscard]]
   inline bool
   exists(const path& __p)
   { return exists(status(__p)); }
 
+  [[nodiscard]]
   inline bool
   exists(const path& __p, error_code& __ec) noexcept
   {
@@ -131,63 +146,85 @@ namespace filesystem
     return false;
   }
 
+  [[nodiscard]]
   uintmax_t file_size(const path& __p);
+
+  [[nodiscard]]
   uintmax_t file_size(const path& __p, error_code& __ec) noexcept;
 
+  [[nodiscard]]
   uintmax_t hard_link_count(const path& __p);
+
+  [[nodiscard]]
   uintmax_t hard_link_count(const path& __p, error_code& __ec) noexcept;
 
+  [[nodiscard]]
   inline bool
   is_block_file(file_status __s) noexcept
   { return __s.type() == file_type::block; }
 
+  [[nodiscard]]
   inline bool
   is_block_file(const path& __p)
   { return is_block_file(status(__p)); }
 
+  [[nodiscard]]
   inline bool
   is_block_file(const path& __p, error_code& __ec) noexcept
   { return is_block_file(status(__p, __ec)); }
 
+  [[nodiscard]]
   inline bool
   is_character_file(file_status __s) noexcept
   { return __s.type() == file_type::character; }
 
+  [[nodiscard]]
   inline bool
   is_character_file(const path& __p)
   { return is_character_file(status(__p)); }
 
+  [[nodiscard]]
   inline bool
   is_character_file(const path& __p, error_code& __ec) noexcept
   { return is_character_file(status(__p, __ec)); }
 
+  [[nodiscard]]
   inline bool
   is_directory(file_status __s) noexcept
   { return __s.type() == file_type::directory; }
 
+  [[nodiscard]]
   inline bool
   is_directory(const path& __p)
   { return is_directory(status(__p)); }
 
+  [[nodiscard]]
   inline bool
   is_directory(const path& __p, error_code& __ec) noexcept
   { return is_directory(status(__p, __ec)); }
 
+  [[nodiscard]]
   bool is_empty(const path& __p);
+
+  [[nodiscard]]
   bool is_empty(const path& __p, error_code& __ec);
 
+  [[nodiscard]]
   inline bool
   is_fifo(file_status __s) noexcept
   { return __s.type() == file_type::fifo; }
 
+  [[nodiscard]]
   inline bool
   is_fifo(const path& __p)
   { return is_fifo(status(__p)); }
 
+  [[nodiscard]]
   inline bool
   is_fifo(const path& __p, error_code& __ec) noexcept
   { return is_fifo(status(__p, __ec)); }
 
+  [[nodiscard]]
   inline bool
   is_other(file_status __s) noexcept
   {
@@ -195,52 +232,67 @@ namespace filesystem
       && !is_symlink(__s);
   }
 
+  [[nodiscard]]
   inline bool
   is_other(const path& __p)
   { return is_other(status(__p)); }
 
+  [[nodiscard]]
   inline bool
   is_other(const path& __p, error_code& __ec) noexcept
   { return is_other(status(__p, __ec)); }
 
+  [[nodiscard]]
   inline bool
   is_regular_file(file_status __s) noexcept
   { return __s.type() == file_type::regular; }
 
+  [[nodiscard]]
   inline bool
   is_regular_file(const path& __p)
   { return is_regular_file(status(__p)); }
 
+  [[nodiscard]]
   inline bool
   is_regular_file(const path& __p, error_code& __ec) noexcept
   { return is_regular_file(status(__p, __ec)); }
 
+  [[nodiscard]]
   inline bool
   is_socket(file_status __s) noexcept
   { return __s.type() == file_type::socket; }
 
+  [[nodiscard]]
   inline bool
   is_socket(const path& __p)
   { return is_socket(status(__p)); }
 
+  [[nodiscard]]
   inline bool
   is_socket(const path& __p, error_code& __ec) noexcept
   { return is_socket(status(__p, __ec)); }
 
+  [[nodiscard]]
   inline bool
   is_symlink(file_status __s) noexcept
   { return __s.type() == file_type::symlink; }
 
+  [[nodiscard]]
   inline bool
   is_symlink(const path& __p)
   { return is_symlink(symlink_status(__p)); }
 
+  [[nodiscard]]
   inline bool
   is_symlink(const path& __p, error_code& __ec) noexcept
   { return is_symlink(symlink_status(__p, __ec)); }
 
+  [[nodiscard]]
   file_time_type  last_write_time(const path& __p);
+
+  [[nodiscard]]
   file_time_type  last_write_time(const path& __p, error_code& __ec) noexcept;
+
   void last_write_time(const path& __p, file_time_type __new_time);
   void last_write_time(const path& __p, file_time_type __new_time,
 		       error_code& __ec) noexcept;
@@ -257,19 +309,30 @@ namespace filesystem
   permissions(const path& __p, perms __prms, perm_options __opts,
 	      error_code& __ec) noexcept;
 
+  [[nodiscard]]
   inline path proximate(const path& __p, error_code& __ec)
   { return proximate(__p, current_path(), __ec); }
 
+  [[nodiscard]]
   path proximate(const path& __p, const path& __base = current_path());
+
+  [[nodiscard]]
   path proximate(const path& __p, const path& __base, error_code& __ec);
 
+  [[nodiscard]]
   path read_symlink(const path& __p);
+
+  [[nodiscard]]
   path read_symlink(const path& __p, error_code& __ec);
 
+  [[nodiscard]]
   inline path relative(const path& __p, error_code& __ec)
   { return relative(__p, current_path(), __ec); }
 
+  [[nodiscard]]
   path relative(const path& __p, const path& __base = current_path());
+
+  [[nodiscard]]
   path relative(const path& __p, const path& __base, error_code& __ec);
 
   bool remove(const path& __p);
@@ -284,22 +347,38 @@ namespace filesystem
   void resize_file(const path& __p, uintmax_t __size);
   void resize_file(const path& __p, uintmax_t __size, error_code& __ec) noexcept;
 
+  [[nodiscard]]
   space_info space(const path& __p);
+
+  [[nodiscard]]
   space_info space(const path& __p, error_code& __ec) noexcept;
 
+  [[nodiscard]]
   file_status status(const path& __p);
+
+  [[nodiscard]]
   file_status status(const path& __p, error_code& __ec) noexcept;
 
+  [[nodiscard]]
   inline bool status_known(file_status __s) noexcept
   { return __s.type() != file_type::none; }
 
+  [[nodiscard]]
   file_status symlink_status(const path& __p);
+
+  [[nodiscard]]
   file_status symlink_status(const path& __p, error_code& __ec) noexcept;
 
+  [[nodiscard]]
   path temp_directory_path();
+
+  [[nodiscard]]
   path temp_directory_path(error_code& __ec);
 
+  [[nodiscard]]
   path weakly_canonical(const path& __p);
+
+  [[nodiscard]]
   path weakly_canonical(const path& __p, error_code& __ec);
 
   /// @} group filesystem
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index a1f780a9c9b..029a6f365b3 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -558,12 +558,7 @@ namespace __detail
       _Multi = 0, _Root_name, _Root_dir, _Filename
     };
 
-    path(basic_string_view<value_type> __str, _Type __type)
-    : _M_pathname(__str)
-    {
-      __glibcxx_assert(__type != _Type::_Multi);
-      _M_cmpts.type(__type);
-    }
+    path(basic_string_view<value_type> __str, _Type __type);
 
     enum class _Split { _Stem, _Extension };
 
@@ -689,6 +684,8 @@ namespace __detail
     _List _M_cmpts;
 
     struct _Parser;
+
+    template<typename _EcharT> struct _Codecvt;
   };
 
   /// @{
@@ -809,63 +806,79 @@ namespace __detail
 
   struct path::_Cmpt : path
   {
-    _Cmpt(basic_string_view<value_type> __s, _Type __t, size_t __pos)
-      : path(__s, __t), _M_pos(__pos) { }
+    _Cmpt(basic_string_view<value_type> __s, _Type __t, size_t __pos);
 
     _Cmpt() : _M_pos(-1) { }
 
     size_t _M_pos;
   };
 
+  // path::_Codecvt<C> Performs conversions between C and path::string_type.
+  // The native encoding of char strings is the OS-dependent current
+  // encoding for pathnames. FIXME: We assume this is UTF-8 everywhere,
+  // but should use a Windows API to query it.
+
+  // Converts between native pathname encoding and char16_t or char32_t.
+  template<typename _EcharT>
+    struct path::_Codecvt
+    // Need derived class here because std::codecvt has protected destructor.
+    : std::codecvt<_EcharT, char, mbstate_t>
+    { };
+
+  // Converts between native pathname encoding and native wide encoding.
+  // The native encoding for wide strings is the execution wide-character
+  // set encoding. FIXME: We assume that this is either UTF-32 or UTF-16
+  // (depending on the width of wchar_t). That matches GCC's default,
+  // but can be changed with -fwide-exec-charset.
+  // We need a custom codecvt converting the native pathname encoding
+  // to/from the native wide encoding.
+  template<>
+    struct path::_Codecvt<wchar_t>
+    : conditional_t<sizeof(wchar_t) == sizeof(char32_t),
+		    std::codecvt_utf8<wchar_t>,       // UTF-8 <-> UTF-32
+		    std::codecvt_utf8_utf16<wchar_t>> // UTF-8 <-> UTF-16
+    { };
+
   template<typename _EcharT>
     auto
     path::_S_convert(const _EcharT* __f, const _EcharT* __l)
     {
       static_assert(__detail::__is_encoded_char<_EcharT>);
 
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+# define _GLIBCXX_CONV_FROM_UTF8(S) __detail::__wstr_from_utf8(S)
+#else
+# define _GLIBCXX_CONV_FROM_UTF8(S) S
+#endif
+
       if constexpr (is_same_v<_EcharT, value_type>)
 	return basic_string_view<value_type>(__f, __l - __f);
-#if !defined _GLIBCXX_FILESYSTEM_IS_WINDOWS && defined _GLIBCXX_USE_CHAR8_T
+#ifdef _GLIBCXX_USE_CHAR8_T
       else if constexpr (is_same_v<_EcharT, char8_t>)
-	// For POSIX converting from char8_t to char is also 'noconv'
-	return string_view(reinterpret_cast<const char*>(__f), __l - __f);
+	{
+	  string_view __str(reinterpret_cast<const char*>(__f), __l - __f);
+	  return _GLIBCXX_CONV_FROM_UTF8(__str);
+	}
 #endif
-      else
-	{
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      else if constexpr (is_same_v<_EcharT, char>)
+	{
 	  std::wstring __wstr;
-	  if constexpr (is_same_v<_EcharT, char>)
-	    {
-	      struct _UCvt : std::codecvt<wchar_t, char, std::mbstate_t>
-	      { } __cvt;
-	      if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))
-		return __wstr;
-	    }
-#ifdef _GLIBCXX_USE_CHAR8_T
-	  else if constexpr (is_same_v<_EcharT, char8_t>)
-	    {
-	      const auto __f2 = reinterpret_cast<const char*>(__f);
-	      return __detail::__wstr_from_utf8(string_view(__f2, __l - __f));
-	    }
+	  path::_Codecvt<wchar_t> __cvt;
+	  if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))
+	    return __wstr;
+	}
 #endif
-	  else // char16_t or char32_t
-	    {
-	      struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>
-	      { } __cvt;
-	      std::string __str;
-	      if (__str_codecvt_out_all(__f, __l, __str, __cvt))
-		return __detail::__wstr_from_utf8(__str);
-	    }
-#else // ! windows
-	  struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>
-	  { } __cvt;
+      else
+	{
+	  path::_Codecvt<_EcharT> __cvt;
 	  std::string __str;
 	  if (__str_codecvt_out_all(__f, __l, __str, __cvt))
-	    return __str;
-#endif
-	  __detail::__throw_conversion_error();
+	    return _GLIBCXX_CONV_FROM_UTF8(__str);
 	}
+      __detail::__throw_conversion_error();
     }
+#undef _GLIBCXX_CONV_FROM_UTF8
 
   /// @endcond
 
@@ -1034,7 +1047,9 @@ namespace __detail
       if (__str.size() == 0)
 	return _WString(__a);
 
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      string_view __u8str = __str;
+#else
       // First convert native string from UTF-16 to to UTF-8.
       // XXX This assumes that the execution wide-character set is UTF-16.
       std::codecvt_utf8_utf16<value_type> __cvt;
@@ -1044,35 +1059,30 @@ namespace __detail
       _String __u8str{_CharAlloc{__a}};
       const value_type* __wfirst = __str.data();
       const value_type* __wlast = __wfirst + __str.size();
-      if (__str_codecvt_out_all(__wfirst, __wlast, __u8str, __cvt)) {
+      if (!__str_codecvt_out_all(__wfirst, __wlast, __u8str, __cvt))
+	__detail::__throw_conversion_error();
       if constexpr (is_same_v<_CharT, char>)
 	return __u8str; // XXX assumes native ordinary encoding is UTF-8.
-      else {
-
-      const char* __first = __u8str.data();
-      const char* __last = __first + __u8str.size();
-#else
-      const value_type* __first = __str.data();
-      const value_type* __last = __first + __str.size();
-#endif
-
-      // Convert UTF-8 string to requested format.
-#ifdef _GLIBCXX_USE_CHAR8_T
-      if constexpr (is_same_v<_CharT, char8_t>)
-	return _WString(__first, __last, __a);
       else
 #endif
 	{
-	  // Convert UTF-8 to wide string.
-	  _WString __wstr(__a);
-	  struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t> { } __cvt;
-	  if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))
-	    return __wstr;
+	  const char* __first = __u8str.data();
+	  const char* __last = __first + __u8str.size();
+
+	  // Convert UTF-8 string to requested format.
+#ifdef _GLIBCXX_USE_CHAR8_T
+	  if constexpr (is_same_v<_CharT, char8_t>)
+	    return _WString(__first, __last, __a);
+	  else
+#endif
+	    {
+	      // Convert UTF-8 to wide string.
+	      _WString __wstr(__a);
+	      path::_Codecvt<_CharT> __cvt;
+	      if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))
+		return __wstr;
+	    }
 	}
-
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-      } }
-#endif
       __detail::__throw_conversion_error();
     }
   /// @endcond
@@ -1211,9 +1221,9 @@ namespace __detail
       {
 	if (_M_pathname.back() == preferred_separator)
 	  return {};
-	auto& __last = *--end();
-	if (__last._M_type() == _Type::_Filename)
-	  return __last;
+	auto __last = --end();
+	if (__last->_M_type() == _Type::_Filename)
+	  return *__last;
       }
     return {};
   }
@@ -1361,6 +1371,16 @@ extern template class __shared_ptr<const filesystem::filesystem_error::_Impl>;
 
 /// @endcond
 
+// _GLIBCXX_RESOLVE_LIB_DEFECTS
+// 3657. std::hash<std::filesystem::path> is not enabled
+template<>
+  struct hash<filesystem::path>
+  {
+    size_t
+    operator()(const filesystem::path& __p) const noexcept
+    { return filesystem::hash_value(__p); }
+  };
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 
diff --git a/libstdc++-v3/include/bits/gslice_array.h b/libstdc++-v3/include/bits/gslice_array.h
index 4f3309d842e..f8d11855699 100644
--- a/libstdc++-v3/include/bits/gslice_array.h
+++ b/libstdc++-v3/include/bits/gslice_array.h
@@ -183,6 +183,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      _Array<size_t>(_M_index));
       }
 
+  /// @cond undocumented
 #undef _DEFINE_VALARRAY_OPERATOR
 #define _DEFINE_VALARRAY_OPERATOR(_Op, _Name)				\
   template<typename _Tp>						\
@@ -214,6 +215,7 @@ _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)
 _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
+  /// @endcond
 
   /// @} group numeric_arrays
 
diff --git a/libstdc++-v3/include/bits/hashtable_policy.h b/libstdc++-v3/include/bits/hashtable_policy.h
index b97c07cb42e..1fdd351cb56 100644
--- a/libstdc++-v3/include/bits/hashtable_policy.h
+++ b/libstdc++-v3/include/bits/hashtable_policy.h
@@ -233,18 +233,22 @@ namespace __detail
 
       __gnu_cxx::__aligned_buffer<_Value> _M_storage;
 
+      [[__gnu__::__always_inline__]]
       _Value*
       _M_valptr() noexcept
       { return _M_storage._M_ptr(); }
 
+      [[__gnu__::__always_inline__]]
       const _Value*
       _M_valptr() const noexcept
       { return _M_storage._M_ptr(); }
 
+      [[__gnu__::__always_inline__]]
       _Value&
       _M_v() noexcept
       { return *_M_valptr(); }
 
+      [[__gnu__::__always_inline__]]
       const _Value&
       _M_v() const noexcept
       { return *_M_valptr(); }
diff --git a/libstdc++-v3/include/bits/indirect_array.h b/libstdc++-v3/include/bits/indirect_array.h
index a3dc6059988..bb47855ecea 100644
--- a/libstdc++-v3/include/bits/indirect_array.h
+++ b/libstdc++-v3/include/bits/indirect_array.h
@@ -174,6 +174,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       indirect_array<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e) const
       { std::__valarray_copy(__e, _M_sz, _M_array, _M_index); }
 
+  /// @cond undocumented
 #undef _DEFINE_VALARRAY_OPERATOR
 #define _DEFINE_VALARRAY_OPERATOR(_Op, _Name)				\
   template<typename _Tp>						\
@@ -203,6 +204,7 @@ _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)
 _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
+  /// @endcond
 
   /// @} group numeric_arrays
 
diff --git a/libstdc++-v3/include/bits/list.tcc b/libstdc++-v3/include/bits/list.tcc
index 0ce4c47a90e..62b0ba1063a 100644
--- a/libstdc++-v3/include/bits/list.tcc
+++ b/libstdc++-v3/include/bits/list.tcc
@@ -416,29 +416,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	  iterator __last1 = end();
 	  iterator __first2 = __x.begin();
 	  iterator __last2 = __x.end();
-	  const size_t __orig_size = __x.size();
-	  __try {
-	    while (__first1 != __last1 && __first2 != __last2)
-	      if (*__first2 < *__first1)
-		{
-		  iterator __next = __first2;
-		  _M_transfer(__first1, __first2, ++__next);
-		  __first2 = __next;
-		}
-	      else
-		++__first1;
-	    if (__first2 != __last2)
+
+	  const _Finalize_merge __fin(*this, __x, __first2);
+
+	  while (__first1 != __last1 && __first2 != __last2)
+	    if (*__first2 < *__first1)
+	      {
+		iterator __next = __first2;
+		_M_transfer(__first1, __first2, ++__next);
+		__first2 = __next;
+	      }
+	    else
+	      ++__first1;
+	  if (__first2 != __last2)
+	    {
 	      _M_transfer(__last1, __first2, __last2);
-
-	    this->_M_inc_size(__x._M_get_size());
-	    __x._M_set_size(0);
-	  }
-	  __catch(...)
-	    {
-	      const size_t __dist = std::distance(__first2, __last2);
-	      this->_M_inc_size(__orig_size - __dist);
-	      __x._M_set_size(__dist);
-	      __throw_exception_again;
+	      __first2 = __last2;
 	    }
 	}
     }
@@ -463,30 +456,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 	    iterator __last1 = end();
 	    iterator __first2 = __x.begin();
 	    iterator __last2 = __x.end();
-	    const size_t __orig_size = __x.size();
-	    __try
-	      {
-		while (__first1 != __last1 && __first2 != __last2)
-		  if (__comp(*__first2, *__first1))
-		    {
-		      iterator __next = __first2;
-		      _M_transfer(__first1, __first2, ++__next);
-		      __first2 = __next;
-		    }
-		  else
-		    ++__first1;
-		if (__first2 != __last2)
-		  _M_transfer(__last1, __first2, __last2);
 
-		this->_M_inc_size(__x._M_get_size());
-		__x._M_set_size(0);
-	      }
-	    __catch(...)
+	    const _Finalize_merge __fin(*this, __x, __first2);
+
+	    while (__first1 != __last1 && __first2 != __last2)
+	      if (__comp(*__first2, *__first1))
+		{
+		  iterator __next = __first2;
+		  _M_transfer(__first1, __first2, ++__next);
+		  __first2 = __next;
+		}
+	      else
+		++__first1;
+	    if (__first2 != __last2)
 	      {
-		const size_t __dist = std::distance(__first2, __last2);
-		this->_M_inc_size(__orig_size - __dist);
-		__x._M_set_size(__dist);
-		__throw_exception_again;
+		_M_transfer(__last1, __first2, __last2);
+		__first2 = __last2;
 	      }
 	  }
       }
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.tcc b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
index 51c23d8003a..4aef5502032 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.tcc
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
@@ -78,32 +78,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       char* __grouping = 0;
       _CharT* __curr_symbol = 0;
       _CharT* __positive_sign = 0;
-      _CharT* __negative_sign = 0;     
+      _CharT* __negative_sign = 0;
+      size_t __sz;
       __try
 	{
 	  const string& __g = __mp.grouping();
-	  _M_grouping_size = __g.size();
-	  __grouping = new char[_M_grouping_size];
-	  __g.copy(__grouping, _M_grouping_size);
+	  __sz = _M_grouping_size = __g.size();
+	  __grouping = new char[__sz];
+	  __g.copy(__grouping, __sz);
 	  _M_use_grouping = (_M_grouping_size
 			     && static_cast<signed char>(__grouping[0]) > 0
 			     && (__grouping[0]
 				 != __gnu_cxx::__numeric_traits<char>::__max));
 
 	  const basic_string<_CharT>& __cs = __mp.curr_symbol();
-	  _M_curr_symbol_size = __cs.size();
-	  __curr_symbol = new _CharT[_M_curr_symbol_size];
-	  __cs.copy(__curr_symbol, _M_curr_symbol_size);
+	  __sz = _M_curr_symbol_size = __cs.size();
+	  __curr_symbol = new _CharT[__sz];
+	  __cs.copy(__curr_symbol, __sz);
 
 	  const basic_string<_CharT>& __ps = __mp.positive_sign();
-	  _M_positive_sign_size = __ps.size();
-	  __positive_sign = new _CharT[_M_positive_sign_size];
-	  __ps.copy(__positive_sign, _M_positive_sign_size);
+	  __sz = _M_positive_sign_size = __ps.size();
+	  __positive_sign = new _CharT[__sz];
+	  __ps.copy(__positive_sign, __sz);
 
 	  const basic_string<_CharT>& __ns = __mp.negative_sign();
-	  _M_negative_sign_size = __ns.size();
-	  __negative_sign = new _CharT[_M_negative_sign_size];
-	  __ns.copy(__negative_sign, _M_negative_sign_size);
+	  __sz = _M_negative_sign_size = __ns.size();
+	  __negative_sign = new _CharT[__sz];
+	  __ns.copy(__negative_sign, __sz);
 
 	  _M_pos_format = __mp.pos_format();
 	  _M_neg_format = __mp.neg_format();
diff --git a/libstdc++-v3/include/bits/mask_array.h b/libstdc++-v3/include/bits/mask_array.h
index 3889bd151a6..fb861dac95b 100644
--- a/libstdc++-v3/include/bits/mask_array.h
+++ b/libstdc++-v3/include/bits/mask_array.h
@@ -174,6 +174,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       mask_array<_Tp>::operator=(const _Expr<_Ex, _Tp>& __e) const
       { std::__valarray_copy(__e, __e.size(), _M_array, _M_mask); }
 
+  /// @cond undocumented
 #undef _DEFINE_VALARRAY_OPERATOR
 #define _DEFINE_VALARRAY_OPERATOR(_Op, _Name)				\
   template<typename _Tp>						\
@@ -204,6 +205,7 @@ _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)
 _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
+  /// @endcond
 
   /// @} group numeric_arrays
 
diff --git a/libstdc++-v3/include/bits/max_size_type.h b/libstdc++-v3/include/bits/max_size_type.h
index 153b1bff5f4..d6cdb72662e 100644
--- a/libstdc++-v3/include/bits/max_size_type.h
+++ b/libstdc++-v3/include/bits/max_size_type.h
@@ -559,7 +559,8 @@ namespace ranges
 	// Arithmetic right shift.
 	const auto __msb = _M_rep._M_msb;
 	_M_rep >>= __r._M_rep;
-	_M_rep._M_msb |= __msb;
+	if (__msb)
+	  _M_rep |= ~(__max_size_type(-1) >> __r._M_rep);
 	return *this;
       }
 
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
index 22ae1f38ebb..2898f7f17e6 100644
--- a/libstdc++-v3/include/bits/random.tcc
+++ b/libstdc++-v3/include/bits/random.tcc
@@ -1955,7 +1955,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       bool __saved_avail;
       if (__is >> __mean >> __stddev >> __saved_avail)
 	{
-	  if (__saved_avail && (__is >> __x._M_saved))
+	  if (!__saved_avail || (__is >> __x._M_saved))
 	    {
 	      __x._M_saved_available = __saved_avail;
 	      __x.param(param_type(__mean, __stddev));
diff --git a/libstdc++-v3/include/bits/ranges_algobase.h b/libstdc++-v3/include/bits/ranges_algobase.h
index de8afd16582..08f536f4fce 100644
--- a/libstdc++-v3/include/bits/ranges_algobase.h
+++ b/libstdc++-v3/include/bits/ranges_algobase.h
@@ -238,7 +238,7 @@ namespace ranges
 	{
 	  auto [__in,__out]
 	    = ranges::__copy_or_move<_IsMove>(__first.base(), __last.base(),
-					      __result);
+					      std::move(__result));
 	  return {decltype(__first){__in}, std::move(__out)};
 	}
       else if constexpr (__is_normal_iterator<_Out>)
diff --git a/libstdc++-v3/include/bits/ranges_base.h b/libstdc++-v3/include/bits/ranges_base.h
index 87283b84028..2a525e421b9 100644
--- a/libstdc++-v3/include/bits/ranges_base.h
+++ b/libstdc++-v3/include/bits/ranges_base.h
@@ -379,6 +379,8 @@ namespace ranges
     template<typename _Tp>
       concept __sentinel_size = requires(_Tp& __t)
 	{
+	  requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);
+
 	  { _Begin{}(__t) } -> forward_iterator;
 
 	  { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>;
@@ -462,6 +464,8 @@ namespace ranges
     template<typename _Tp>
       concept __eq_iter_empty = requires(_Tp& __t)
 	{
+	  requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);
+
 	  { _Begin{}(__t) } -> forward_iterator;
 
 	  bool(_Begin{}(__t) == _End{}(__t));
@@ -728,20 +732,23 @@ namespace ranges
 	  {
 	    const auto __diff = __bound - __it;
 
-	    // n and bound must not lead in opposite directions:
-	    __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));
-	    const auto __absdiff = __diff < 0 ? -__diff : __diff;
-	    const auto __absn = __n < 0 ? -__n : __n;;
-	    if (__absn >= __absdiff)
+	    if (__diff == 0)
+	      return __n;
+	    else if (__diff > 0 ? __n >= __diff : __n <= __diff)
 	      {
 		(*this)(__it, __bound);
 		return __n - __diff;
 	      }
-	    else
+	    else if (__n != 0) [[likely]]
 	      {
+		// n and bound must not lead in opposite directions:
+		__glibcxx_assert(__n < 0 == __diff < 0);
+
 		(*this)(__it, __n);
 		return 0;
 	      }
+	    else
+	      return 0;
 	  }
 	else if (__it == __bound || __n == 0)
 	  return __n;
diff --git a/libstdc++-v3/include/bits/regex.h b/libstdc++-v3/include/bits/regex.h
index a9a035e04d1..314849a6bff 100644
--- a/libstdc++-v3/include/bits/regex.h
+++ b/libstdc++-v3/include/bits/regex.h
@@ -57,6 +57,16 @@ namespace __detail
 
   template<typename, typename, typename, bool>
     class _Executor;
+
+  template<typename _Tp>
+    struct __is_contiguous_iter : false_type { };
+
+  template<typename _Tp>
+    struct __is_contiguous_iter<_Tp*> : true_type { };
+
+  template<typename _Tp, typename _Cont>
+    struct __is_contiguous_iter<__gnu_cxx::__normal_iterator<_Tp*, _Cont>>
+    : true_type { };
 }
 
 _GLIBCXX_BEGIN_NAMESPACE_CXX11
@@ -414,6 +424,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       static constexpr flag_type awk = regex_constants::awk;
       static constexpr flag_type grep = regex_constants::grep;
       static constexpr flag_type egrep = regex_constants::egrep;
+#if __cplusplus >= 201703L || !defined __STRICT_ANSI__
+      static constexpr flag_type multiline = regex_constants::multiline;
+#endif
       ///@}
 
       // [7.8.2] construct/copy/destroy
@@ -421,7 +434,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * Constructs a basic regular expression that does not match any
        * character sequence.
        */
-      basic_regex()
+      basic_regex() noexcept
       : _M_flags(ECMAScript), _M_loc(), _M_automaton(nullptr)
       { }
 
@@ -438,8 +451,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       explicit
       basic_regex(const _Ch_type* __p, flag_type __f = ECMAScript)
-      : basic_regex(__p, __p + char_traits<_Ch_type>::length(__p), __f)
-      { }
+      { _M_compile(__p, __p + _Rx_traits::length(__p), __f); }
 
       /**
        * @brief Constructs a basic regular expression from the sequence
@@ -455,8 +467,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       basic_regex(const _Ch_type* __p, std::size_t __len,
 		  flag_type __f = ECMAScript)
-      : basic_regex(__p, __p + __len, __f)
-      { }
+      { _M_compile(__p, __p + __len, __f); }
 
       /**
        * @brief Copy-constructs a basic regular expression.
@@ -486,8 +497,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	basic_regex(const std::basic_string<_Ch_type, _Ch_traits,
 					    _Ch_alloc>& __s,
 		    flag_type __f = ECMAScript)
-	: basic_regex(__s.data(), __s.data() + __s.size(), __f)
-	{ }
+	{ _M_compile(__s.data(), __s.data() + __s.size(), __f); }
 
       /**
        * @brief Constructs a basic regular expression from the range
@@ -505,8 +515,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       template<typename _FwdIter>
 	basic_regex(_FwdIter __first, _FwdIter __last,
 		    flag_type __f = ECMAScript)
-	: basic_regex(std::move(__first), std::move(__last), locale_type(), __f)
-	{ }
+	{ this->assign(__first, __last, __f); }
 
       /**
        * @brief Constructs a basic regular expression from an initializer list.
@@ -517,8 +526,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @throws regex_error if @p __l is not a valid regular expression.
        */
       basic_regex(initializer_list<_Ch_type> __l, flag_type __f = ECMAScript)
-      : basic_regex(__l.begin(), __l.end(), __f)
-      { }
+      { _M_compile(__l.begin(), __l.end(), __f); }
 
       /**
        * @brief Destroys a basic regular expression.
@@ -530,15 +538,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @brief Assigns one regular expression to another.
        */
       basic_regex&
-      operator=(const basic_regex& __rhs)
-      { return this->assign(__rhs); }
+      operator=(const basic_regex&) = default;
 
       /**
        * @brief Move-assigns one regular expression to another.
        */
       basic_regex&
-      operator=(basic_regex&& __rhs) noexcept
-      { return this->assign(std::move(__rhs)); }
+      operator=(basic_regex&&) = default;
 
       /**
        * @brief Replaces a regular expression with a new one constructed from
@@ -561,7 +567,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       basic_regex&
       operator=(initializer_list<_Ch_type> __l)
-      { return this->assign(__l.begin(), __l.end()); }
+      { return this->assign(__l); }
 
       /**
        * @brief Replaces a regular expression with a new one constructed from
@@ -576,30 +582,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 
       // [7.8.3] assign
       /**
-       * @brief the real assignment operator.
+       * @brief Assigns one regular expression to another.
        *
        * @param __rhs Another regular expression object.
        */
       basic_regex&
-      assign(const basic_regex& __rhs)
-      {
-	basic_regex __tmp(__rhs);
-	this->swap(__tmp);
-	return *this;
-      }
+      assign(const basic_regex& __rhs) noexcept
+      { return *this = __rhs; }
 
       /**
-       * @brief The move-assignment operator.
+       * @brief Move-assigns one regular expression to another.
        *
        * @param __rhs Another regular expression object.
        */
       basic_regex&
       assign(basic_regex&& __rhs) noexcept
-      {
-	basic_regex __tmp(std::move(__rhs));
-	this->swap(__tmp);
-	return *this;
-      }
+      { return *this = std::move(__rhs); }
 
       /**
        * @brief Assigns a new regular expression to a regex object from a
@@ -616,7 +614,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       basic_regex&
       assign(const _Ch_type* __p, flag_type __flags = ECMAScript)
-      { return this->assign(string_type(__p), __flags); }
+      {
+	_M_compile(__p, __p + _Rx_traits::length(__p), __flags);
+	return *this;
+      }
 
       /**
        * @brief Assigns a new regular expression to a regex object from a
@@ -635,7 +636,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       // 3296. Inconsistent default argument for basic_regex<>::assign
       basic_regex&
       assign(const _Ch_type* __p, size_t __len, flag_type __flags = ECMAScript)
-      { return this->assign(string_type(__p, __len), __flags); }
+      {
+	_M_compile(__p, __p + __len, __flags);
+	return *this;
+      }
 
       /**
        * @brief Assigns a new regular expression to a regex object from a
@@ -653,8 +657,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	assign(const basic_string<_Ch_type, _Ch_traits, _Alloc>& __s,
 	       flag_type __flags = ECMAScript)
 	{
-	  return this->assign(basic_regex(__s.data(), __s.data() + __s.size(),
-					  _M_loc, __flags));
+	  _M_compile(__s.data(), __s.data() + __s.size(), __flags);
+	  return *this;
 	}
 
       /**
@@ -674,7 +678,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	basic_regex&
 	assign(_InputIterator __first, _InputIterator __last,
 	       flag_type __flags = ECMAScript)
-	{ return this->assign(string_type(__first, __last), __flags); }
+	{
+#if __cplusplus >= 201703L
+	  using _ValT = typename iterator_traits<_InputIterator>::value_type;
+	  if constexpr (__detail::__is_contiguous_iter<_InputIterator>::value
+			&& is_same_v<_ValT, value_type>)
+	    {
+	      const auto __len = __last - __first;
+	      const _Ch_type* __p = std::__to_address(__first);
+	      _M_compile(__p, __p + __len, __flags);
+	    }
+	  else
+#endif
+	  this->assign(string_type(__first, __last), __flags);
+	  return *this;
+	}
 
       /**
        * @brief Assigns a new regular expression to a regex object.
@@ -689,7 +707,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        */
       basic_regex&
       assign(initializer_list<_Ch_type> __l, flag_type __flags = ECMAScript)
-      { return this->assign(__l.begin(), __l.end(), __flags); }
+      {
+	_M_compile(__l.begin(), __l.end(), __flags);
+	return *this;
+      }
 
       // [7.8.4] const operations
       /**
@@ -697,7 +718,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * expression.
        */
       unsigned int
-      mark_count() const
+      mark_count() const noexcept
       {
 	if (_M_automaton)
 	  return _M_automaton->_M_sub_count() - 1;
@@ -709,7 +730,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * or in the last call to assign().
        */
       flag_type
-      flags() const
+      flags() const noexcept
       { return _M_flags; }
 
       // [7.8.5] locale
@@ -731,7 +752,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        *        object.
        */
       locale_type
-      getloc() const
+      getloc() const noexcept
       { return _M_loc; }
 
       // [7.8.6] swap
@@ -741,7 +762,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
        * @param __rhs Another regular expression object.
        */
       void
-      swap(basic_regex& __rhs)
+      swap(basic_regex& __rhs) noexcept
       {
 	std::swap(_M_flags, __rhs._M_flags);
 	std::swap(_M_loc, __rhs._M_loc);
@@ -757,13 +778,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
     private:
       typedef std::shared_ptr<const __detail::_NFA<_Rx_traits>> _AutomatonPtr;
 
-      template<typename _FwdIter>
-	basic_regex(_FwdIter __first, _FwdIter __last, locale_type __loc,
-		    flag_type __f)
-	: _M_flags(__f), _M_loc(std::move(__loc)),
-	_M_automaton(__detail::__compile_nfa<_Rx_traits>(
-	  std::move(__first), std::move(__last), _M_loc, _M_flags))
-	{ }
+      void
+      _M_compile(const _Ch_type* __first, const _Ch_type* __last,
+		 flag_type __f)
+      {
+	__detail::_Compiler<_Rx_traits> __c(__first, __last, _M_loc, __f);
+	_M_automaton = __c._M_get_nfa();
+	_M_flags = __f;
+      }
 
       template<typename _Bp, typename _Ap, typename _Cp, typename _Rp,
 	__detail::_RegexExecutorPolicy, bool>
@@ -848,7 +870,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
   template<typename _Ch_type, typename _Rx_traits>
     inline void
     swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,
-	 basic_regex<_Ch_type, _Rx_traits>& __rhs)
+	 basic_regex<_Ch_type, _Rx_traits>& __rhs) noexcept
     { __lhs.swap(__rhs); }
 
 
@@ -2459,6 +2481,15 @@ _GLIBCXX_END_NAMESPACE_CXX11
 		 = regex_constants::match_default) = delete;
 
   // std [28.11.4] Function template regex_replace
+
+  template<typename _Out_iter, typename _Bi_iter,
+	   typename _Rx_traits, typename _Ch_type>
+    _Out_iter
+    __regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+		    const basic_regex<_Ch_type, _Rx_traits>& __e,
+		    const _Ch_type* __fmt, size_t __len,
+		    regex_constants::match_flag_type __flags);
+
   /**
    * @brief Search for a regular expression within a range for multiple times,
    and replace the matched parts through filling a format string.
@@ -2482,7 +2513,8 @@ _GLIBCXX_END_NAMESPACE_CXX11
 		  regex_constants::match_flag_type __flags
 		  = regex_constants::match_default)
     {
-      return regex_replace(__out, __first, __last, __e, __fmt.c_str(), __flags);
+      return std::__regex_replace(__out, __first, __last, __e, __fmt.c_str(),
+				  __fmt.length(), __flags);
     }
 
   /**
@@ -2505,7 +2537,13 @@ _GLIBCXX_END_NAMESPACE_CXX11
 		  const basic_regex<_Ch_type, _Rx_traits>& __e,
 		  const _Ch_type* __fmt,
 		  regex_constants::match_flag_type __flags
-		  = regex_constants::match_default);
+		  = regex_constants::match_default)
+    {
+      return std::__regex_replace(__out, __first, __last, __e, __fmt,
+				  char_traits<_Ch_type>::length(__fmt),
+				  __flags);
+    }
+
 
   /**
    * @brief Search for a regular expression within a string for multiple times,
diff --git a/libstdc++-v3/include/bits/regex.tcc b/libstdc++-v3/include/bits/regex.tcc
index 39ad3f0a4cc..ef152851e55 100644
--- a/libstdc++-v3/include/bits/regex.tcc
+++ b/libstdc++-v3/include/bits/regex.tcc
@@ -461,10 +461,10 @@ namespace __detail
   template<typename _Out_iter, typename _Bi_iter,
 	   typename _Rx_traits, typename _Ch_type>
     _Out_iter
-    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
-		  const basic_regex<_Ch_type, _Rx_traits>& __e,
-		  const _Ch_type* __fmt,
-		  regex_constants::match_flag_type __flags)
+    __regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,
+		    const basic_regex<_Ch_type, _Rx_traits>& __e,
+		    const _Ch_type* __fmt, size_t __len,
+		    regex_constants::match_flag_type __flags)
     {
       typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> _IterT;
       _IterT __i(__first, __last, __e, __flags);
@@ -477,7 +477,6 @@ namespace __detail
       else
 	{
 	  sub_match<_Bi_iter> __last;
-	  auto __len = char_traits<_Ch_type>::length(__fmt);
 	  for (; __i != __end; ++__i)
 	    {
 	      if (!(__flags & regex_constants::format_no_copy))
diff --git a/libstdc++-v3/include/bits/regex_automaton.h b/libstdc++-v3/include/bits/regex_automaton.h
index 872a17fe8cb..f108675f35e 100644
--- a/libstdc++-v3/include/bits/regex_automaton.h
+++ b/libstdc++-v3/include/bits/regex_automaton.h
@@ -95,13 +95,13 @@ namespace __detail
     };
 
   protected:
-    explicit _State_base(_Opcode __opcode)
+    explicit _State_base(_Opcode __opcode) noexcept
     : _M_opcode(__opcode), _M_next(_S_invalid_state_id)
     { }
 
   public:
     bool
-    _M_has_alt()
+    _M_has_alt() const noexcept
     {
       return _M_opcode == _S_opcode_alternative
 	|| _M_opcode == _S_opcode_repeat
@@ -130,7 +130,7 @@ namespace __detail
 		    "std::function<bool(char)>");
 
       explicit
-      _State(_Opcode __opcode) : _State_base(__opcode)
+      _State(_Opcode __opcode) noexcept : _State_base(__opcode)
       {
 	if (_M_opcode() == _S_opcode_match)
 	  new (this->_M_matcher_storage._M_addr()) _MatcherT();
@@ -143,7 +143,7 @@ namespace __detail
 	    _MatcherT(__rhs._M_get_matcher());
       }
 
-      _State(_State&& __rhs) : _State_base(__rhs)
+      _State(_State&& __rhs) noexcept : _State_base(__rhs)
       {
 	if (__rhs._M_opcode() == _S_opcode_match)
 	  new (this->_M_matcher_storage._M_addr())
@@ -162,7 +162,7 @@ namespace __detail
       // Since correct ctor and dtor rely on _M_opcode, it's better not to
       // change it over time.
       _Opcode
-      _M_opcode() const
+      _M_opcode() const noexcept
       { return _State_base::_M_opcode; }
 
       bool
@@ -170,11 +170,11 @@ namespace __detail
       { return _M_get_matcher()(__char); }
 
       _MatcherT&
-      _M_get_matcher()
+      _M_get_matcher() noexcept
       { return *static_cast<_MatcherT*>(this->_M_matcher_storage._M_addr()); }
 
       const _MatcherT&
-      _M_get_matcher() const
+      _M_get_matcher() const noexcept
       {
 	return *static_cast<const _MatcherT*>(
 	    this->_M_matcher_storage._M_addr());
@@ -183,11 +183,10 @@ namespace __detail
 
   struct _NFA_base
   {
-    typedef size_t                              _SizeT;
     typedef regex_constants::syntax_option_type _FlagT;
 
     explicit
-    _NFA_base(_FlagT __f)
+    _NFA_base(_FlagT __f) noexcept
     : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),
     _M_has_backref(false)
     { }
@@ -199,21 +198,21 @@ namespace __detail
 
   public:
     _FlagT
-    _M_options() const
+    _M_options() const noexcept
     { return _M_flags; }
 
     _StateIdT
-    _M_start() const
+    _M_start() const noexcept
     { return _M_start_state; }
 
-    _SizeT
-    _M_sub_count() const
+    size_t
+    _M_sub_count() const noexcept
     { return _M_subexpr_count; }
 
     _GLIBCXX_STD_C::vector<size_t> _M_paren_stack;
     _FlagT                    _M_flags;
     _StateIdT                 _M_start_state;
-    _SizeT                    _M_subexpr_count;
+    size_t                    _M_subexpr_count;
     bool                      _M_has_backref;
   };
 
diff --git a/libstdc++-v3/include/bits/regex_compiler.h b/libstdc++-v3/include/bits/regex_compiler.h
index bf7dcc54dba..bae2138e309 100644
--- a/libstdc++-v3/include/bits/regex_compiler.h
+++ b/libstdc++-v3/include/bits/regex_compiler.h
@@ -58,15 +58,14 @@ namespace __detail
     {
     public:
       typedef typename _TraitsT::char_type        _CharT;
-      typedef const _CharT*                       _IterT;
       typedef _NFA<_TraitsT>              	  _RegexT;
       typedef regex_constants::syntax_option_type _FlagT;
 
-      _Compiler(_IterT __b, _IterT __e,
+      _Compiler(const _CharT* __b, const _CharT* __e,
 		const typename _TraitsT::locale_type& __traits, _FlagT __flags);
 
       shared_ptr<const _RegexT>
-      _M_get_nfa()
+      _M_get_nfa() noexcept
       { return std::move(_M_nfa); }
 
     private:
@@ -122,13 +121,45 @@ namespace __detail
 	void
 	_M_insert_bracket_matcher(bool __neg);
 
-      // Returns true if successfully matched one term and should continue.
+      // Cache of the last atom seen in a bracketed range expression.
+      struct _BracketState
+      {
+	enum class _Type : char { _None, _Char, _Class } _M_type = _Type::_None;
+	_CharT _M_char;
+
+	void
+	set(_CharT __c) noexcept { _M_type = _Type::_Char; _M_char = __c; }
+
+	_GLIBCXX_NODISCARD _CharT
+	get() const noexcept { return _M_char; }
+
+	void
+	reset(_Type __t = _Type::_None) noexcept { _M_type = __t; }
+
+	explicit operator bool() const noexcept
+	{ return _M_type != _Type::_None; }
+
+	// Previous token was a single character.
+	_GLIBCXX_NODISCARD bool
+	_M_is_char() const noexcept { return _M_type == _Type::_Char; }
+
+	// Previous token was a character class, equivalent class,
+	// collating symbol etc.
+	_GLIBCXX_NODISCARD bool
+	_M_is_class() const noexcept { return _M_type == _Type::_Class; }
+      };
+
+      template<bool __icase, bool __collate>
+	using _BracketMatcher
+	  = std::__detail::_BracketMatcher<_TraitsT, __icase, __collate>;
+
+      // Returns true if successfully parsed one term and should continue
+      // compiling a bracket expression.
       // Returns false if the compiler should move on.
       template<bool __icase, bool __collate>
 	bool
-	_M_expression_term(pair<bool, _CharT>& __last_char,
-			   _BracketMatcher<_TraitsT, __icase, __collate>&
-			   __matcher);
+	_M_expression_term(_BracketState& __last_char,
+			   _BracketMatcher<__icase, __collate>& __matcher);
 
       int
       _M_cur_int_value(int __radix);
@@ -144,6 +175,26 @@ namespace __detail
 	return ret;
       }
 
+      static _FlagT
+      _S_validate(_FlagT __f)
+      {
+	using namespace regex_constants;
+	switch (__f & (ECMAScript|basic|extended|awk|grep|egrep))
+	  {
+	  case ECMAScript:
+	  case basic:
+	  case extended:
+	  case awk:
+	  case grep:
+	  case egrep:
+	    return __f;
+	  case _FlagT(0):
+	    return __f | ECMAScript;
+	  default:
+	    std::__throw_regex_error(_S_grammar, "conflicting grammar options");
+	  }
+      }
+
       _FlagT              _M_flags;
       _ScannerT           _M_scanner;
       shared_ptr<_RegexT> _M_nfa;
@@ -153,47 +204,6 @@ namespace __detail
       const _CtypeT&      _M_ctype;
     };
 
-  template<typename _Tp>
-    struct __is_contiguous_iter : is_pointer<_Tp>::type { };
-
-  template<typename _Tp, typename _Cont>
-    struct
-    __is_contiguous_iter<__gnu_cxx::__normal_iterator<_Tp*, _Cont>>
-    : true_type { };
-
-  template<typename _Iter, typename _TraitsT>
-    using __enable_if_contiguous_iter
-      = __enable_if_t< __is_contiguous_iter<_Iter>::value,
-                       std::shared_ptr<const _NFA<_TraitsT>> >;
-
-  template<typename _Iter, typename _TraitsT>
-    using __disable_if_contiguous_iter
-      = __enable_if_t< !__is_contiguous_iter<_Iter>::value,
-                       std::shared_ptr<const _NFA<_TraitsT>> >;
-
-  template<typename _TraitsT, typename _FwdIter>
-    inline __enable_if_contiguous_iter<_FwdIter, _TraitsT>
-    __compile_nfa(_FwdIter __first, _FwdIter __last,
-		  const typename _TraitsT::locale_type& __loc,
-		  regex_constants::syntax_option_type __flags)
-    {
-      size_t __len = __last - __first;
-      const auto* __cfirst = __len ? std::__addressof(*__first) : nullptr;
-      using _Cmplr = _Compiler<_TraitsT>;
-      return _Cmplr(__cfirst, __cfirst + __len, __loc, __flags)._M_get_nfa();
-    }
-
-  template<typename _TraitsT, typename _FwdIter>
-    inline __disable_if_contiguous_iter<_FwdIter, _TraitsT>
-    __compile_nfa(_FwdIter __first, _FwdIter __last,
-		  const typename _TraitsT::locale_type& __loc,
-		  regex_constants::syntax_option_type __flags)
-    {
-      const basic_string<typename _TraitsT::char_type> __str(__first, __last);
-      return __compile_nfa<_TraitsT>(__str.data(), __str.data() + __str.size(),
-				     __loc, __flags);
-    }
-
   // [28.13.14]
   template<typename _TraitsT, bool __icase, bool __collate>
     class _RegexTranslatorBase
diff --git a/libstdc++-v3/include/bits/regex_compiler.tcc b/libstdc++-v3/include/bits/regex_compiler.tcc
index 440669debe0..6f42f2aed65 100644
--- a/libstdc++-v3/include/bits/regex_compiler.tcc
+++ b/libstdc++-v3/include/bits/regex_compiler.tcc
@@ -63,17 +63,9 @@ namespace __detail
 {
   template<typename _TraitsT>
     _Compiler<_TraitsT>::
-    _Compiler(_IterT __b, _IterT __e,
+    _Compiler(const _CharT* __b, const _CharT* __e,
 	      const typename _TraitsT::locale_type& __loc, _FlagT __flags)
-    : _M_flags((__flags
-		& (regex_constants::ECMAScript
-		   | regex_constants::basic
-		   | regex_constants::extended
-		   | regex_constants::grep
-		   | regex_constants::egrep
-		   | regex_constants::awk))
-	       ? __flags
-	       : __flags | regex_constants::ECMAScript),
+    : _M_flags(_S_validate(__flags)),
       _M_scanner(__b, __e, _M_flags, __loc),
       _M_nfa(make_shared<_RegexT>(__loc, _M_flags)),
       _M_traits(_M_nfa->_M_traits),
@@ -140,7 +132,8 @@ namespace __detail
 	return true;
       if (this->_M_atom())
 	{
-	  while (this->_M_quantifier());
+	  while (this->_M_quantifier())
+	    ;
 	  return true;
 	}
       return false;
@@ -410,7 +403,7 @@ namespace __detail
     _M_insert_character_class_matcher()
     {
       __glibcxx_assert(_M_value.size() == 1);
-      _BracketMatcher<_TraitsT, __icase, __collate> __matcher
+      _BracketMatcher<__icase, __collate> __matcher
 	(_M_ctype.is(_CtypeT::upper, _M_value[0]), _M_traits);
       __matcher._M_add_character_class(_M_value, false);
       __matcher._M_ready();
@@ -424,25 +417,17 @@ namespace __detail
     _Compiler<_TraitsT>::
     _M_insert_bracket_matcher(bool __neg)
     {
-      _BracketMatcher<_TraitsT, __icase, __collate> __matcher(__neg, _M_traits);
-      pair<bool, _CharT> __last_char; // Optional<_CharT>
-      __last_char.first = false;
-      if (!(_M_flags & regex_constants::ECMAScript))
-	{
-	  if (_M_try_char())
-	    {
-	      __last_char.first = true;
-	      __last_char.second = _M_value[0];
-	    }
-	  else if (_M_match_token(_ScannerT::_S_token_bracket_dash))
-	    {
-	      __last_char.first = true;
-	      __last_char.second = '-';
-	    }
-	}
-      while (_M_expression_term(__last_char, __matcher));
-      if (__last_char.first)
-	__matcher._M_add_char(__last_char.second);
+      _BracketMatcher<__icase, __collate> __matcher(__neg, _M_traits);
+      _BracketState __last_char;
+      if (_M_try_char())
+	__last_char.set(_M_value[0]);
+      else if (_M_match_token(_ScannerT::_S_token_bracket_dash))
+	// Dash as first character is a normal character.
+	__last_char.set('-');
+      while (_M_expression_term(__last_char, __matcher))
+	;
+      if (__last_char._M_is_char())
+	__matcher._M_add_char(__last_char.get());
       __matcher._M_ready();
       _M_stack.push(_StateSeqT(
 		      *_M_nfa,
@@ -453,27 +438,27 @@ namespace __detail
   template<bool __icase, bool __collate>
     bool
     _Compiler<_TraitsT>::
-    _M_expression_term(pair<bool, _CharT>& __last_char,
-		       _BracketMatcher<_TraitsT, __icase, __collate>& __matcher)
+    _M_expression_term(_BracketState& __last_char,
+		       _BracketMatcher<__icase, __collate>& __matcher)
     {
       if (_M_match_token(_ScannerT::_S_token_bracket_end))
 	return false;
 
+      // Add any previously cached char into the matcher and update cache.
       const auto __push_char = [&](_CharT __ch)
       {
-	if (__last_char.first)
-	  __matcher._M_add_char(__last_char.second);
-	else
-	  __last_char.first = true;
-	__last_char.second = __ch;
+	if (__last_char._M_is_char())
+	  __matcher._M_add_char(__last_char.get());
+	__last_char.set(__ch);
       };
-      const auto __flush = [&]
+      // Add any previously cached char into the matcher and update cache.
+      const auto __push_class = [&]
       {
-	if (__last_char.first)
-	  {
-	    __matcher._M_add_char(__last_char.second);
-	    __last_char.first = false;
-	  }
+        if (__last_char._M_is_char())
+	  __matcher._M_add_char(__last_char.get());
+	// We don't cache anything here, just record that the last thing
+	// processed was a character class (or similar).
+	__last_char.reset(_BracketState::_Type::_Class);
       };
 
       if (_M_match_token(_ScannerT::_S_token_collsymbol))
@@ -482,16 +467,16 @@ namespace __detail
 	  if (__symbol.size() == 1)
 	    __push_char(__symbol[0]);
 	  else
-	    __flush();
+	    __push_class();
 	}
       else if (_M_match_token(_ScannerT::_S_token_equiv_class_name))
 	{
-	  __flush();
+	  __push_class();
 	  __matcher._M_add_equivalence_class(_M_value);
 	}
       else if (_M_match_token(_ScannerT::_S_token_char_class_name))
 	{
-	  __flush();
+	  __push_class();
 	  __matcher._M_add_character_class(_M_value, false);
 	}
       else if (_M_try_char())
@@ -508,49 +493,50 @@ namespace __detail
       // It turns out that no one reads BNFs ;)
       else if (_M_match_token(_ScannerT::_S_token_bracket_dash))
 	{
-	  if (!__last_char.first)
+	  if (_M_match_token(_ScannerT::_S_token_bracket_end))
 	    {
-	      if (!(_M_flags & regex_constants::ECMAScript))
-		{
-		  if (_M_match_token(_ScannerT::_S_token_bracket_end))
-		    {
-		      __push_char('-');
-		      return false;
-		    }
-		  __throw_regex_error(
-		    regex_constants::error_range,
-		    "Unexpected dash in bracket expression. For POSIX syntax, "
-		    "a dash is not treated literally only when it is at "
-		    "beginning or end.");
-		}
+	      // For "-]" the dash is a literal character.
 	      __push_char('-');
+	      return false;
 	    }
-	  else
+	  else if (__last_char._M_is_class())
+	    {
+	      // "\\w-" is invalid, start of range must be a single char.
+	      __throw_regex_error(regex_constants::error_range,
+		    "Invalid start of range in bracket expression.");
+	    }
+	  else if (__last_char._M_is_char())
 	    {
 	      if (_M_try_char())
 		{
-		  __matcher._M_make_range(__last_char.second, _M_value[0]);
-		  __last_char.first = false;
+		  // "x-y"
+		  __matcher._M_make_range(__last_char.get(), _M_value[0]);
+		  __last_char.reset();
 		}
 	      else if (_M_match_token(_ScannerT::_S_token_bracket_dash))
 		{
-		  __matcher._M_make_range(__last_char.second, '-');
-		  __last_char.first = false;
+		  // "x--"
+		  __matcher._M_make_range(__last_char.get(), '-');
+		  __last_char.reset();
 		}
 	      else
-		{
-		  if (_M_scanner._M_get_token()
-		      != _ScannerT::_S_token_bracket_end)
-		    __throw_regex_error(
-		      regex_constants::error_range,
-		      "Character is expected after a dash.");
-		  __push_char('-');
-		}
+		__throw_regex_error(regex_constants::error_range,
+		      "Invalid end of range in bracket expression.");
 	    }
+	  else if (_M_flags & regex_constants::ECMAScript)
+	    {
+	      // A dash that is not part of an existing range. Might be the
+	      // start of a new range, or might just be a literal '-' char.
+	      // Only ECMAScript allows that in the middle of a bracket expr.
+	      __push_char('-');
+	    }
+	  else
+	    __throw_regex_error(regex_constants::error_range,
+				"Invalid dash in bracket expression.");
 	}
       else if (_M_match_token(_ScannerT::_S_token_quoted_class))
 	{
-	  __flush();
+	  __push_class();
 	  __matcher._M_add_character_class(_M_value,
 					   _M_ctype.is(_CtypeT::upper,
 						       _M_value[0]));
@@ -586,9 +572,9 @@ namespace __detail
   template<typename _TraitsT>
     bool
     _Compiler<_TraitsT>::
-    _M_match_token(_TokenT token)
+    _M_match_token(_TokenT __token)
     {
-      if (token == _M_scanner._M_get_token())
+      if (__token == _M_scanner._M_get_token())
 	{
 	  _M_value = _M_scanner._M_get_value();
 	  _M_scanner._M_advance();
@@ -602,10 +588,12 @@ namespace __detail
     _Compiler<_TraitsT>::
     _M_cur_int_value(int __radix)
     {
-      long __v = 0;
-      for (typename _StringT::size_type __i = 0;
-	   __i < _M_value.length(); ++__i)
-	__v =__v * __radix + _M_traits.value(_M_value[__i], __radix);
+      int __v = 0;
+      for (_CharT __c : _M_value)
+	if (__builtin_mul_overflow(__v, __radix, &__v)
+	    || __builtin_add_overflow(__v, _M_traits.value(__c, __radix), &__v))
+	    std::__throw_regex_error(regex_constants::error_backref,
+				     "invalid back reference");
       return __v;
     }
 
diff --git a/libstdc++-v3/include/bits/regex_constants.h b/libstdc++-v3/include/bits/regex_constants.h
index 1c3dd36d57c..0fd2879c817 100644
--- a/libstdc++-v3/include/bits/regex_constants.h
+++ b/libstdc++-v3/include/bits/regex_constants.h
@@ -64,7 +64,7 @@ namespace regex_constants
     _S_grep,
     _S_egrep,
     _S_polynomial,
-    _S_syntax_last
+    _S_multiline
   };
 
   /**
@@ -170,6 +170,24 @@ namespace regex_constants
   _GLIBCXX17_INLINE constexpr syntax_option_type egrep =
     static_cast<syntax_option_type>(1 << _S_egrep);
 
+#if __cplusplus >= 201703L || !defined __STRICT_ANSI__
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 2503. multiline option should be added to syntax_option_type
+  /**
+   * Specifies that the `^` anchor matches at the beginning of a line,
+   * and the `$` anchor matches at the end of a line, not only at the
+   * beginning/end of the input.
+   * Valid for the ECMAScript syntax, ignored otherwise.
+   * @since C++17
+   */
+  _GLIBCXX17_INLINE constexpr syntax_option_type multiline =
+    static_cast<syntax_option_type>(1 << _S_multiline);
+#endif
+
+  /// Extension: Equivalent to regex_constants::multiline for C++11 and C++14.
+  _GLIBCXX17_INLINE constexpr syntax_option_type __multiline =
+    static_cast<syntax_option_type>(1 << _S_multiline);
+
   /**
    * Extension: Ensure both space complexity of compiled regex and
    * time complexity execution are not exponential.
@@ -310,9 +328,10 @@ namespace regex_constants
     static_cast<match_flag_type>(1 << _S_continuous);
 
   /**
-   * --first is a valid iterator position.  When this flag is set then the
-   * flags match_not_bol and match_not_bow are ignored by the regular
-   * expression algorithms 28.11 and iterators 28.12.
+   * `--first` is a valid iterator position.  When this flag is set then the
+   * flags `match_not_bol` and `match_not_bow` are ignored by the algorithms
+   * `regex_match`, `regex_search`, and `regex_replace`, and by the iterators
+   * `regex_iterator` and `regex_token_iterator`.
    */
   _GLIBCXX17_INLINE constexpr match_flag_type match_prev_avail =
     static_cast<match_flag_type>(1 << _S_prev_avail);
diff --git a/libstdc++-v3/include/bits/regex_error.h b/libstdc++-v3/include/bits/regex_error.h
index 27593833544..e7b7b420ec4 100644
--- a/libstdc++-v3/include/bits/regex_error.h
+++ b/libstdc++-v3/include/bits/regex_error.h
@@ -61,6 +61,8 @@ namespace regex_constants
       _S_error_badrepeat,
       _S_error_complexity,
       _S_error_stack,
+      _S_null,
+      _S_grammar
     };
 
   /** The expression contained an invalid collating element name. */
@@ -150,7 +152,7 @@ namespace regex_constants
      * @returns the regex error code.
      */
     regex_constants::error_type
-    code() const
+    code() const noexcept
     { return _M_code; }
 
   private:
diff --git a/libstdc++-v3/include/bits/regex_executor.h b/libstdc++-v3/include/bits/regex_executor.h
index 4a641eeee6c..ebaad88b75f 100644
--- a/libstdc++-v3/include/bits/regex_executor.h
+++ b/libstdc++-v3/include/bits/regex_executor.h
@@ -78,12 +78,12 @@ namespace __detail
       _M_results(__results),
       _M_rep_count(_M_nfa.size()),
       _M_states(_M_nfa._M_start(), _M_nfa.size()),
-      _M_flags((__flags & regex_constants::match_prev_avail)
-	       ? (__flags
-		  & ~regex_constants::match_not_bol
-		  & ~regex_constants::match_not_bow)
-	       : __flags)
-      { }
+      _M_flags(__flags)
+      {
+	using namespace regex_constants;
+	if (__flags & match_prev_avail) // ignore not_bol and not_bow
+	  _M_flags &= ~(match_not_bol | match_not_bow);
+      }
 
       // Set matched when string exactly matches the pattern.
       bool
@@ -165,16 +165,39 @@ namespace __detail
       bool
       _M_at_begin() const
       {
-	return _M_current == _M_begin
-	  && !(_M_flags & (regex_constants::match_not_bol
-			   | regex_constants::match_prev_avail));
+	if (_M_current == _M_begin)
+	  {
+	    // match_not_bol means ^ does not match [_M_begin,_M_begin)
+	    if (_M_flags & regex_constants::match_not_bol)
+	      return false;
+	    // match_prev_avail means _M_begin is not the start of the input.
+	    if (_M_flags & regex_constants::match_prev_avail)
+	      {
+		// For ECMAScript multiline matches, check if the previous
+		// character is a line terminator.
+		if (_M_match_multiline())
+		  return _M_is_line_terminator(*std::prev(_M_current));
+		else
+		  return false;
+	      }
+	    else // ^ matches at _M_begin
+	      return true;
+	  }
+	else if (_M_match_multiline())
+	  return _M_is_line_terminator(*std::prev(_M_current));
+	else
+	  return false;
       }
 
       bool
       _M_at_end() const
       {
-	return _M_current == _M_end
-	  && !(_M_flags & regex_constants::match_not_eol);
+	if (_M_current == _M_end)
+	  return !(_M_flags & regex_constants::match_not_eol);
+	else if (_M_match_multiline())
+	  return _M_is_line_terminator(*_M_current);
+	else
+	  return false;
       }
 
       bool
@@ -183,6 +206,31 @@ namespace __detail
       bool
       _M_lookahead(_StateIdT __next);
 
+      bool
+      _M_is_line_terminator(_CharT __c) const
+      {
+	const auto& __traits = _M_re._M_automaton->_M_traits;
+	const auto& __ct = use_facet<ctype<_CharT>>(__traits.getloc());
+	const char __n{ __ct.narrow(__c, ' ') };
+	if (__n == '\n')
+	  return true;
+	if (_M_re._M_automaton->_M_options() & regex_constants::ECMAScript)
+	  {
+	    if (__n == '\r')
+	      return true;
+	    // FIXME: U+2028 (line separator) and U+2029 (paragraph separator)
+	  }
+	return false;
+      }
+
+      bool
+      _M_match_multiline() const noexcept
+      {
+	constexpr auto __m
+	  = regex_constants::ECMAScript | regex_constants::__multiline;
+	return (_M_re._M_automaton->_M_options() & __m) == __m;
+      }
+
        // Holds additional information used in BFS-mode.
       template<typename _SearchMode, typename _ResultsVec>
 	struct _State_info;
diff --git a/libstdc++-v3/include/bits/regex_executor.tcc b/libstdc++-v3/include/bits/regex_executor.tcc
index 405d1c4d0d1..88bbbf42f78 100644
--- a/libstdc++-v3/include/bits/regex_executor.tcc
+++ b/libstdc++-v3/include/bits/regex_executor.tcc
@@ -423,7 +423,7 @@ namespace __detail
   template<typename _BiIter, typename _Alloc, typename _TraitsT,
 	   bool __dfs_mode>
     void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
-    _M_handle_accept(_Match_mode __match_mode, _StateIdT __i)
+    _M_handle_accept(_Match_mode __match_mode, _StateIdT)
     {
       if (__dfs_mode)
 	{
diff --git a/libstdc++-v3/include/bits/regex_scanner.h b/libstdc++-v3/include/bits/regex_scanner.h
index e810fa7dd31..4e7d5efb34b 100644
--- a/libstdc++-v3/include/bits/regex_scanner.h
+++ b/libstdc++-v3/include/bits/regex_scanner.h
@@ -211,23 +211,22 @@ namespace __detail
     : public _ScannerBase
     {
     public:
-      typedef const _CharT*                                       _IterT;
       typedef std::basic_string<_CharT>                           _StringT;
       typedef regex_constants::syntax_option_type                 _FlagT;
       typedef const std::ctype<_CharT>                            _CtypeT;
 
-      _Scanner(_IterT __begin, _IterT __end,
+      _Scanner(const _CharT* __begin, const _CharT* __end,
 	       _FlagT __flags, std::locale __loc);
 
       void
       _M_advance();
 
       _TokenT
-      _M_get_token() const
+      _M_get_token() const noexcept
       { return _M_token; }
 
       const _StringT&
-      _M_get_value() const
+      _M_get_value() const noexcept
       { return _M_value; }
 
 #ifdef _GLIBCXX_DEBUG
@@ -257,8 +256,8 @@ namespace __detail
       void
       _M_eat_class(char);
 
-      _IterT                        _M_current;
-      _IterT                        _M_end;
+      const _CharT*                 _M_current;
+      const _CharT*                 _M_end;
       _CtypeT&                      _M_ctype;
       _StringT                      _M_value;
       void (_Scanner::* _M_eat_escape)();
diff --git a/libstdc++-v3/include/bits/regex_scanner.tcc b/libstdc++-v3/include/bits/regex_scanner.tcc
index a3512083f0e..473dc888a20 100644
--- a/libstdc++-v3/include/bits/regex_scanner.tcc
+++ b/libstdc++-v3/include/bits/regex_scanner.tcc
@@ -54,8 +54,7 @@ namespace __detail
 {
   template<typename _CharT>
     _Scanner<_CharT>::
-    _Scanner(typename _Scanner::_IterT __begin,
-	     typename _Scanner::_IterT __end,
+    _Scanner(const _CharT* __begin, const _CharT* __end,
 	     _FlagT __flags, std::locale __loc)
     : _ScannerBase(__flags),
       _M_current(__begin), _M_end(__end),
@@ -176,6 +175,16 @@ namespace __detail
 	  _M_state = _S_state_in_brace;
 	  _M_token = _S_token_interval_begin;
 	}
+      else if (__builtin_expect(__c == _CharT(0), false))
+	{
+	  if (!_M_is_ecma())
+	    {
+	      __throw_regex_error(regex_constants::_S_null,
+		  "Unexpected null character in regular expression");
+	    }
+	  _M_token = _S_token_ord_char;
+	  _M_value.assign(1, __c);
+	}
       else if (__c != ']' && __c != '}')
 	{
 	  auto __it = _M_token_tbl;
diff --git a/libstdc++-v3/include/bits/shared_ptr_base.h b/libstdc++-v3/include/bits/shared_ptr_base.h
index eb9ad23ba1e..611680692fd 100644
--- a/libstdc++-v3/include/bits/shared_ptr_base.h
+++ b/libstdc++-v3/include/bits/shared_ptr_base.h
@@ -1666,9 +1666,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __weak_ptr&
       operator=(__weak_ptr&& __r) noexcept
       {
-	_M_ptr = __r._M_ptr;
-	_M_refcount = std::move(__r._M_refcount);
-	__r._M_ptr = nullptr;
+	__weak_ptr(std::move(__r)).swap(*this);
 	return *this;
       }
 
diff --git a/libstdc++-v3/include/bits/slice_array.h b/libstdc++-v3/include/bits/slice_array.h
index bdced19e789..1990a1cddb4 100644
--- a/libstdc++-v3/include/bits/slice_array.h
+++ b/libstdc++-v3/include/bits/slice_array.h
@@ -245,6 +245,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     slice_array<_Tp>::operator=(const _Expr<_Dom,_Tp>& __e) const
     { std::__valarray_copy(__e, _M_sz, _M_array, _M_stride); }
 
+  /// @cond undocumented
 #undef _DEFINE_VALARRAY_OPERATOR
 #define _DEFINE_VALARRAY_OPERATOR(_Op,_Name)				\
   template<typename _Tp>						\
@@ -275,6 +276,7 @@ _DEFINE_VALARRAY_OPERATOR(<<, __shift_left)
 _DEFINE_VALARRAY_OPERATOR(>>, __shift_right)
 
 #undef _DEFINE_VALARRAY_OPERATOR
+  /// @endcond
 
   /// @} group numeric_arrays
 
diff --git a/libstdc++-v3/include/bits/std_thread.h b/libstdc++-v3/include/bits/std_thread.h
index 2a500bf1777..976526001c5 100644
--- a/libstdc++-v3/include/bits/std_thread.h
+++ b/libstdc++-v3/include/bits/std_thread.h
@@ -204,7 +204,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 	template<typename... _Args>
 	  _State_impl(_Args&&... __args)
-	  : _M_func{{std::forward<_Args>(__args)...}}
+	  : _M_func(std::forward<_Args>(__args)...)
 	  { }
 
 	void
@@ -238,6 +238,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     template<typename _Tuple>
       struct _Invoker
       {
+	template<typename... _Args>
+	  explicit
+	  _Invoker(_Args&&... __args)
+	  : _M_t(std::forward<_Args>(__args)...)
+	  { }
+
 	_Tuple _M_t;
 
 	template<typename>
diff --git a/libstdc++-v3/include/bits/stl_construct.h b/libstdc++-v3/include/bits/stl_construct.h
index e53ed0d9f91..f14fba0cfb1 100644
--- a/libstdc++-v3/include/bits/stl_construct.h
+++ b/libstdc++-v3/include/bits/stl_construct.h
@@ -116,7 +116,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return;
 	}
 #endif
-      ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...);
+      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
     }
 #else
   template<typename _T1, typename _T2>
@@ -132,7 +132,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _T1>
     inline void
     _Construct_novalue(_T1* __p)
-    { ::new(static_cast<void*>(__p)) _T1; }
+    { ::new((void*)__p) _T1; }
 
   template<typename _ForwardIterator>
     _GLIBCXX20_CONSTEXPR void
diff --git a/libstdc++-v3/include/bits/stl_deque.h b/libstdc++-v3/include/bits/stl_deque.h
index 20c73b4fc3c..8236fe35ce7 100644
--- a/libstdc++-v3/include/bits/stl_deque.h
+++ b/libstdc++-v3/include/bits/stl_deque.h
@@ -353,7 +353,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
       {
 	return difference_type(_S_buffer_size())
-	  * (__x._M_node - __y._M_node - int(__x._M_node != 0))
+	  * (__x._M_node - __y._M_node - bool(__x._M_node))
 	  + (__x._M_cur - __x._M_first)
 	  + (__y._M_last - __y._M_cur);
       }
@@ -365,10 +365,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       template<typename _RefR, typename _PtrR>
 	friend difference_type
 	operator-(const _Self& __x,
-		  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
+		  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
+	_GLIBCXX_NOEXCEPT
 	{
 	  return difference_type(_S_buffer_size())
-	    * (__x._M_node - __y._M_node - int(__x._M_node != 0))
+	    * (__x._M_node - __y._M_node - bool(__x._M_node))
 	    + (__x._M_cur - __x._M_first)
 	    + (__y._M_last - __y._M_cur);
 	}
diff --git a/libstdc++-v3/include/bits/stl_iterator.h b/libstdc++-v3/include/bits/stl_iterator.h
index beeb4ef4c8a..33e7535ac31 100644
--- a/libstdc++-v3/include/bits/stl_iterator.h
+++ b/libstdc++-v3/include/bits/stl_iterator.h
@@ -77,11 +77,12 @@
 # define __cpp_lib_array_constexpr 201803L
 #endif
 
-#if __cplusplus > 201703L
+#if __cplusplus >= 202002L
 # include <compare>
 # include <new>
 # include <bits/exception_defines.h>
 # include <bits/iterator_concepts.h>
+# include <bits/stl_construct.h>
 #endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -537,6 +538,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<=>(const reverse_iterator<_IteratorL>& __x,
 		const reverse_iterator<_IteratorR>& __y)
     { return __y.base() <=> __x.base(); }
+
+  // Additional, non-standard overloads to avoid ambiguities with greedy,
+  // unconstrained overloads in associated namespaces.
+
+  template<typename _Iterator>
+    constexpr bool
+    operator==(const reverse_iterator<_Iterator>& __x,
+	       const reverse_iterator<_Iterator>& __y)
+    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
+    { return __x.base() == __y.base(); }
+
+  template<three_way_comparable _Iterator>
+    constexpr compare_three_way_result_t<_Iterator, _Iterator>
+    operator<=>(const reverse_iterator<_Iterator>& __x,
+		const reverse_iterator<_Iterator>& __y)
+    { return __y.base() <=> __x.base(); }
 #endif // C++20
   ///@}
 
@@ -1113,6 +1130,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		const __normal_iterator<_IteratorR, _Container>& __rhs)
     noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
     { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
+
+  template<typename _Iterator, typename _Container>
+    constexpr bool
+    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
+	       const __normal_iterator<_Iterator, _Container>& __rhs)
+    noexcept(noexcept(__lhs.base() == __rhs.base()))
+    requires requires {
+      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
+    }
+    { return __lhs.base() == __rhs.base(); }
+
+  template<typename _Iterator, typename _Container>
+    constexpr std::__detail::__synth3way_t<_Iterator>
+    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
+		const __normal_iterator<_Iterator, _Container>& __rhs)
+    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
+    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
 #else
    // Forward iterator requirements
   template<typename _IteratorL, typename _IteratorR, typename _Container>
@@ -1356,11 +1390,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    && convertible_to<const _Iter2&, _Iterator>;
 #endif
 
+#if __cplusplus > 201703L && __cpp_lib_concepts
+      static auto
+      _S_iter_concept()
+      {
+	if constexpr (random_access_iterator<_Iterator>)
+	  return random_access_iterator_tag{};
+	else if constexpr (bidirectional_iterator<_Iterator>)
+	  return bidirectional_iterator_tag{};
+	else if constexpr (forward_iterator<_Iterator>)
+	  return forward_iterator_tag{};
+	else
+	  return input_iterator_tag{};
+      }
+#endif
+
     public:
       using iterator_type = _Iterator;
 
 #if __cplusplus > 201703L && __cpp_lib_concepts
-      using iterator_concept = input_iterator_tag;
+      // This is P2520R0, a C++23 change, but we treat it as a DR against C++20.
+# define __cpp_lib_move_iterator_concept 202207L
+      using iterator_concept = decltype(_S_iter_concept());
+
       // iterator_category defined in __move_iter_cat
       using value_type = iter_value_t<_Iterator>;
       using difference_type = iter_difference_t<_Iterator>;
@@ -1588,20 +1640,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
     { return !(__x < __y); }
 
-#if ! (__cplusplus > 201703L && __cpp_lib_concepts)
   // Note: See __normal_iterator operators note from Gaby to understand
   // why we have these extra overloads for some move_iterator operators.
 
-  // These extra overloads are not needed in C++20, because the ones above
-  // are constrained with a requires-clause and so overload resolution will
-  // prefer them to greedy unconstrained function templates.
-
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR bool
     operator==(const move_iterator<_Iterator>& __x,
 	       const move_iterator<_Iterator>& __y)
     { return __x.base() == __y.base(); }
 
+#if __cpp_lib_three_way_comparison
+  template<three_way_comparable _Iterator>
+    constexpr compare_three_way_result_t<_Iterator>
+    operator<=>(const move_iterator<_Iterator>& __x,
+		const move_iterator<_Iterator>& __y)
+    { return __x.base() <=> __y.base(); }
+#else
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR bool
     operator!=(const move_iterator<_Iterator>& __x,
@@ -1697,7 +1751,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _S_noexcept1()
       {
 	if constexpr (is_trivially_default_constructible_v<_Tp>)
-	  return is_nothrow_assignable_v<_Tp, _Up>;
+	  return is_nothrow_assignable_v<_Tp&, _Up>;
 	else
 	  return is_nothrow_constructible_v<_Tp, _Up>;
       }
@@ -1767,19 +1821,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       noexcept(_S_noexcept<const _It2&, const _Sent2&>())
       : _M_valueless(), _M_index(__x._M_index)
       {
+	__glibcxx_assert(__x._M_has_value());
 	if (_M_index == 0)
 	  {
 	    if constexpr (is_trivially_default_constructible_v<_It>)
 	      _M_it = std::move(__x._M_it);
 	    else
-	      ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
+	      std::construct_at(std::__addressof(_M_it), __x._M_it);
 	  }
 	else if (_M_index == 1)
 	  {
 	    if constexpr (is_trivially_default_constructible_v<_Sent>)
 	      _M_sent = std::move(__x._M_sent);
 	    else
-	      ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
+	      std::construct_at(std::__addressof(_M_sent), __x._M_sent);
 	  }
       }
 
@@ -1787,31 +1842,75 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     common_iterator(const common_iterator& __x)
     noexcept(_S_noexcept<const _It&, const _Sent&>())
     : _M_valueless(), _M_index(__x._M_index)
+    {
+      if (_M_index == 0)
+	{
+	  if constexpr (is_trivially_default_constructible_v<_It>)
+	    _M_it = __x._M_it;
+	  else
+	    std::construct_at(std::__addressof(_M_it), __x._M_it);
+	}
+      else if (_M_index == 1)
+	{
+	  if constexpr (is_trivially_default_constructible_v<_Sent>)
+	    _M_sent = __x._M_sent;
+	  else
+	    std::construct_at(std::__addressof(_M_sent), __x._M_sent);
+	}
+    }
+
+    constexpr
+    common_iterator(common_iterator&& __x)
+    noexcept(_S_noexcept<_It, _Sent>())
+    : _M_valueless(), _M_index(__x._M_index)
     {
       if (_M_index == 0)
 	{
 	  if constexpr (is_trivially_default_constructible_v<_It>)
 	    _M_it = std::move(__x._M_it);
 	  else
-	    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
+	    std::construct_at(std::__addressof(_M_it), std::move(__x._M_it));
 	}
       else if (_M_index == 1)
 	{
 	  if constexpr (is_trivially_default_constructible_v<_Sent>)
 	    _M_sent = std::move(__x._M_sent);
 	  else
-	    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
+	    std::construct_at(std::__addressof(_M_sent),
+			      std::move(__x._M_sent));
 	}
     }
 
-    common_iterator&
+    constexpr common_iterator&
+    operator=(const common_iterator&) = default;
+
+    constexpr common_iterator&
     operator=(const common_iterator& __x)
     noexcept(is_nothrow_copy_assignable_v<_It>
 	     && is_nothrow_copy_assignable_v<_Sent>
 	     && is_nothrow_copy_constructible_v<_It>
 	     && is_nothrow_copy_constructible_v<_Sent>)
+    requires (!is_trivially_copy_assignable_v<_It>
+		|| !is_trivially_copy_assignable_v<_Sent>)
     {
-      return this->operator=<_It, _Sent>(__x);
+      _M_assign(__x);
+      return *this;
+    }
+
+    constexpr common_iterator&
+    operator=(common_iterator&&) = default;
+
+    constexpr common_iterator&
+    operator=(common_iterator&& __x)
+    noexcept(is_nothrow_move_assignable_v<_It>
+	     && is_nothrow_move_assignable_v<_Sent>
+	     && is_nothrow_move_constructible_v<_It>
+	     && is_nothrow_move_constructible_v<_Sent>)
+    requires (!is_trivially_move_assignable_v<_It>
+		|| !is_trivially_move_assignable_v<_Sent>)
+    {
+      _M_assign(std::move(__x));
+      return *this;
     }
 
     template<typename _It2, typename _Sent2>
@@ -1819,72 +1918,45 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	&& convertible_to<const _Sent2&, _Sent>
 	&& assignable_from<_It&, const _It2&>
 	&& assignable_from<_Sent&, const _Sent2&>
-      common_iterator&
+      constexpr common_iterator&
       operator=(const common_iterator<_It2, _Sent2>& __x)
       noexcept(is_nothrow_constructible_v<_It, const _It2&>
 	       && is_nothrow_constructible_v<_Sent, const _Sent2&>
-	       && is_nothrow_assignable_v<_It, const _It2&>
-	       && is_nothrow_assignable_v<_Sent, const _Sent2&>)
+	       && is_nothrow_assignable_v<_It&, const _It2&>
+	       && is_nothrow_assignable_v<_Sent&, const _Sent2&>)
       {
-	switch(_M_index << 2 | __x._M_index)
-	  {
-	  case 0b0000:
-	    _M_it = __x._M_it;
-	    break;
-	  case 0b0101:
-	    _M_sent = __x._M_sent;
-	    break;
-	  case 0b0001:
-	    _M_it.~_It();
-	    _M_index = -1;
-	    [[fallthrough]];
-	  case 0b1001:
-	    ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
-	    _M_index = 1;
-	    break;
-	  case 0b0100:
-	    _M_sent.~_Sent();
-	    _M_index = -1;
-	    [[fallthrough]];
-	  case 0b1000:
-	    ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
-	    _M_index = 0;
-	    break;
-	  default:
-	    __glibcxx_assert(__x._M_has_value());
-	    __builtin_unreachable();
-	  }
+	__glibcxx_assert(__x._M_has_value());
+	_M_assign(__x);
 	return *this;
       }
 
+    constexpr
     ~common_iterator()
     {
-      switch (_M_index)
-	{
-	case 0:
-	  _M_it.~_It();
-	  break;
-	case 1:
-	  _M_sent.~_Sent();
-	  break;
-	}
+      if (_M_index == 0)
+	_M_it.~_It();
+      else if (_M_index == 1)
+	_M_sent.~_Sent();
     }
 
-    decltype(auto)
+    [[nodiscard]]
+    constexpr decltype(auto)
     operator*()
     {
       __glibcxx_assert(_M_index == 0);
       return *_M_it;
     }
 
-    decltype(auto)
+    [[nodiscard]]
+    constexpr decltype(auto)
     operator*() const requires __detail::__dereferenceable<const _It>
     {
       __glibcxx_assert(_M_index == 0);
       return *_M_it;
     }
 
-    decltype(auto)
+    [[nodiscard]]
+    constexpr auto
     operator->() const requires __detail::__common_iter_has_arrow<_It>
     {
       __glibcxx_assert(_M_index == 0);
@@ -1899,7 +1971,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return __arrow_proxy{*_M_it};
     }
 
-    common_iterator&
+    constexpr common_iterator&
     operator++()
     {
       __glibcxx_assert(_M_index == 0);
@@ -1907,7 +1979,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return *this;
     }
 
-    decltype(auto)
+    constexpr decltype(auto)
     operator++(int)
     {
       __glibcxx_assert(_M_index == 0);
@@ -1929,9 +2001,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     template<typename _It2, sentinel_for<_It> _Sent2>
       requires sentinel_for<_Sent, _It2>
-      friend bool
-      operator==(const common_iterator& __x,
-		 const common_iterator<_It2, _Sent2>& __y)
+      friend constexpr bool
+      operator== [[nodiscard]] (const common_iterator& __x,
+				const common_iterator<_It2, _Sent2>& __y)
       {
 	switch(__x._M_index << 2 | __y._M_index)
 	  {
@@ -1951,9 +2023,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     template<typename _It2, sentinel_for<_It> _Sent2>
       requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
-      friend bool
-      operator==(const common_iterator& __x,
-		 const common_iterator<_It2, _Sent2>& __y)
+      friend constexpr bool
+      operator== [[nodiscard]] (const common_iterator& __x,
+				const common_iterator<_It2, _Sent2>& __y)
       {
 	switch(__x._M_index << 2 | __y._M_index)
 	  {
@@ -1974,9 +2046,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
       requires sized_sentinel_for<_Sent, _It2>
-      friend iter_difference_t<_It2>
-      operator-(const common_iterator& __x,
-		const common_iterator<_It2, _Sent2>& __y)
+      friend constexpr iter_difference_t<_It2>
+      operator- [[nodiscard]] (const common_iterator& __x,
+			       const common_iterator<_It2, _Sent2>& __y)
       {
 	switch(__x._M_index << 2 | __y._M_index)
 	  {
@@ -1995,7 +2067,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  }
       }
 
-    friend iter_rvalue_reference_t<_It>
+    [[nodiscard]]
+    friend constexpr iter_rvalue_reference_t<_It>
     iter_move(const common_iterator& __i)
     noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
     requires input_iterator<_It>
@@ -2005,7 +2078,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     }
 
     template<indirectly_swappable<_It> _It2, typename _Sent2>
-      friend void
+      friend constexpr void
       iter_swap(const common_iterator& __x,
 		const common_iterator<_It2, _Sent2>& __y)
       noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
@@ -2018,9 +2091,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   private:
     template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
+      requires (!same_as<_It2, _Sent2>) && copyable<_It2>
       friend class common_iterator;
 
-    bool _M_has_value() const noexcept { return _M_index < 2; }
+    constexpr bool
+    _M_has_value() const noexcept { return _M_index != _S_valueless; }
+
+    template<typename _CIt>
+      constexpr void
+      _M_assign(_CIt&& __x)
+      {
+	if (_M_index == __x._M_index)
+	  {
+	    if (_M_index == 0)
+	      _M_it = std::forward<_CIt>(__x)._M_it;
+	    else if (_M_index == 1)
+	      _M_sent = std::forward<_CIt>(__x)._M_sent;
+	  }
+	else
+	  {
+	    if (_M_index == 0)
+	      _M_it.~_It();
+	    else if (_M_index == 1)
+	      _M_sent.~_Sent();
+	    _M_index = _S_valueless;
+
+	    if (__x._M_index == 0)
+	      std::construct_at(std::__addressof(_M_it),
+				std::forward<_CIt>(__x)._M_it);
+	    else if (__x._M_index == 1)
+	      std::construct_at(std::__addressof(_M_sent),
+				std::forward<_CIt>(__x)._M_sent);
+	    _M_index = __x._M_index;
+	  }
+      }
 
     union
     {
@@ -2028,7 +2132,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _Sent _M_sent;
       unsigned char _M_valueless;
     };
-    unsigned char _M_index; // 0==_M_it, 1==_M_sent, 2==valueless
+    unsigned char _M_index; // 0 == _M_it, 1 == _M_sent, 2 == valueless
+
+    static constexpr unsigned char _S_valueless{2};
   };
 
   template<typename _It, typename _Sent>
@@ -2188,7 +2294,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return *this;
       }
 
-      decltype(auto)
+      constexpr decltype(auto)
       operator++(int)
       {
 	__glibcxx_assert(_M_length > 0);
@@ -2200,7 +2306,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    ++_M_length;
 	    __throw_exception_again;
 	  }
-
       }
 
       constexpr counted_iterator
diff --git a/libstdc++-v3/include/bits/stl_list.h b/libstdc++-v3/include/bits/stl_list.h
index dbe05a9834b..2c70adf2b93 100644
--- a/libstdc++-v3/include/bits/stl_list.h
+++ b/libstdc++-v3/include/bits/stl_list.h
@@ -1,6 +1,7 @@
 // List implementation -*- C++ -*-
 
 // Copyright (C) 2001-2021 Free Software Foundation, Inc.
+// Copyright The GNU Toolchain Authors.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -1966,6 +1967,40 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 			     __false_type{});
       }
 #endif
+
+#if _GLIBCXX_USE_CXX11_ABI
+      // Update _M_size members after merging (some of) __src into __dest.
+      struct _Finalize_merge
+      {
+	explicit
+	_Finalize_merge(list& __dest, list& __src, const iterator& __src_next)
+	: _M_dest(__dest), _M_src(__src), _M_next(__src_next)
+	{ }
+
+	~_Finalize_merge()
+	{
+	  // For the common case, _M_next == _M_sec.end() and the std::distance
+	  // call is fast. But if any *iter1 < *iter2 comparison throws then we
+	  // have to count how many elements remain in _M_src.
+	  const size_t __num_unmerged = std::distance(_M_next, _M_src.end());
+	  const size_t __orig_size = _M_src._M_get_size();
+	  _M_dest._M_inc_size(__orig_size - __num_unmerged);
+	  _M_src._M_set_size(__num_unmerged);
+	}
+
+	list& _M_dest;
+	list& _M_src;
+	const iterator& _M_next;
+
+#if __cplusplus >= 201103L
+	_Finalize_merge(const _Finalize_merge&) = delete;
+#endif
+      };
+#else
+      struct _Finalize_merge
+      { explicit _Finalize_merge(list&, list&, const iterator&) { } };
+#endif
+
     };
 
 #if __cpp_deduction_guides >= 201606
diff --git a/libstdc++-v3/include/bits/this_thread_sleep.h b/libstdc++-v3/include/bits/this_thread_sleep.h
index bdcd0cdeb77..b7e956f9119 100644
--- a/libstdc++-v3/include/bits/this_thread_sleep.h
+++ b/libstdc++-v3/include/bits/this_thread_sleep.h
@@ -107,8 +107,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    __now = _Clock::now();
 	  }
       }
-  } // namespace this_thread
 #endif // ! NO_SLEEP
+  } // namespace this_thread
 
   /// @}
 
diff --git a/libstdc++-v3/include/bits/uses_allocator_args.h b/libstdc++-v3/include/bits/uses_allocator_args.h
index 044494aab05..40ef6843945 100644
--- a/libstdc++-v3/include/bits/uses_allocator_args.h
+++ b/libstdc++-v3/include/bits/uses_allocator_args.h
@@ -180,11 +180,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       using _Tp1 = typename _Tp::first_type;
       using _Tp2 = typename _Tp::second_type;
 
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 3527. uses_allocator_construction_args handles rvalue pairs
+      // of rvalue references incorrectly
       return std::make_tuple(piecewise_construct,
 	  std::uses_allocator_construction_args<_Tp1>(__a,
-	    std::move(__pr).first),
+	    std::get<0>(std::move(__pr))),
 	  std::uses_allocator_construction_args<_Tp2>(__a,
-	    std::move(__pr).second));
+	    std::get<1>(std::move(__pr))));
     }
 
   template<typename _Tp, typename _Alloc, typename... _Args>
diff --git a/libstdc++-v3/include/c_global/cstddef b/libstdc++-v3/include/c_global/cstddef
index 13ef7f03c12..58bbdf66be9 100644
--- a/libstdc++-v3/include/c_global/cstddef
+++ b/libstdc++-v3/include/c_global/cstddef
@@ -121,55 +121,66 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     using __byte_op_t = typename __byte_operand<_IntegerType>::__type;
 
   template<typename _IntegerType>
+    [[__gnu__::__always_inline__]]
     constexpr __byte_op_t<_IntegerType>
     operator<<(byte __b, _IntegerType __shift) noexcept
     { return (byte)(unsigned char)((unsigned)__b << __shift); }
 
   template<typename _IntegerType>
+    [[__gnu__::__always_inline__]]
     constexpr __byte_op_t<_IntegerType>
     operator>>(byte __b, _IntegerType __shift) noexcept
     { return (byte)(unsigned char)((unsigned)__b >> __shift); }
 
+  [[__gnu__::__always_inline__]]
   constexpr byte
   operator|(byte __l, byte __r) noexcept
   { return (byte)(unsigned char)((unsigned)__l | (unsigned)__r); }
 
+  [[__gnu__::__always_inline__]]
   constexpr byte
   operator&(byte __l, byte __r) noexcept
   { return (byte)(unsigned char)((unsigned)__l & (unsigned)__r); }
 
+  [[__gnu__::__always_inline__]]
   constexpr byte
   operator^(byte __l, byte __r) noexcept
   { return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r); }
 
+  [[__gnu__::__always_inline__]]
   constexpr byte
   operator~(byte __b) noexcept
   { return (byte)(unsigned char)~(unsigned)__b; }
 
   template<typename _IntegerType>
+    [[__gnu__::__always_inline__]]
     constexpr __byte_op_t<_IntegerType>&
     operator<<=(byte& __b, _IntegerType __shift) noexcept
     { return __b = __b << __shift; }
 
   template<typename _IntegerType>
+    [[__gnu__::__always_inline__]]
     constexpr __byte_op_t<_IntegerType>&
     operator>>=(byte& __b, _IntegerType __shift) noexcept
     { return __b = __b >> __shift; }
 
+  [[__gnu__::__always_inline__]]
   constexpr byte&
   operator|=(byte& __l, byte __r) noexcept
   { return __l = __l | __r; }
 
+  [[__gnu__::__always_inline__]]
   constexpr byte&
   operator&=(byte& __l, byte __r) noexcept
   { return __l = __l & __r; }
 
+  [[__gnu__::__always_inline__]]
   constexpr byte&
   operator^=(byte& __l, byte __r) noexcept
   { return __l = __l ^ __r; }
 
   template<typename _IntegerType>
-    [[nodiscard]]
+    [[nodiscard,__gnu__::__always_inline__]]
     constexpr _IntegerType
     to_integer(__byte_op_t<_IntegerType> __b) noexcept
     { return _IntegerType(__b); }
diff --git a/libstdc++-v3/include/experimental/bits/fs_ops.h b/libstdc++-v3/include/experimental/bits/fs_ops.h
index 3231f50adac..e8278dd00c6 100644
--- a/libstdc++-v3/include/experimental/bits/fs_ops.h
+++ b/libstdc++-v3/include/experimental/bits/fs_ops.h
@@ -51,10 +51,16 @@ inline namespace v1
    * @{
    */
 
+  [[__nodiscard__]]
   path absolute(const path& __p, const path& __base = current_path());
 
+  [[__nodiscard__]]
   path canonical(const path& __p, const path& __base = current_path());
+
+  [[__nodiscard__]]
   path canonical(const path& __p, error_code& __ec);
+
+  [[__nodiscard__]]
   path canonical(const path& __p, const path& __base, error_code& __ec);
 
   inline void
@@ -66,6 +72,7 @@ inline namespace v1
   { copy(__from, __to, copy_options::none, __ec); }
 
   void copy(const path& __from, const path& __to, copy_options __options);
+
   void copy(const path& __from, const path& __to, copy_options __options,
 	    error_code& __ec) noexcept;
 
@@ -107,25 +114,34 @@ inline namespace v1
   void create_symlink(const path& __to, const path& __new_symlink,
 		      error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   path current_path();
+
+  [[__nodiscard__]]
   path current_path(error_code& __ec);
+
   void current_path(const path& __p);
   void current_path(const path& __p, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   bool
   equivalent(const path& __p1, const path& __p2);
 
+  [[__nodiscard__]]
   bool
   equivalent(const path& __p1, const path& __p2, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   inline bool
   exists(file_status __s) noexcept
   { return status_known(__s) && __s.type() != file_type::not_found; }
 
+  [[__nodiscard__]]
   inline bool
   exists(const path& __p)
   { return exists(status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   exists(const path& __p, error_code& __ec) noexcept
   {
@@ -138,63 +154,84 @@ inline namespace v1
     return false;
   }
 
+  [[__nodiscard__]]
   uintmax_t file_size(const path& __p);
+
+  [[__nodiscard__]]
   uintmax_t file_size(const path& __p, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   uintmax_t hard_link_count(const path& __p);
+
+  [[__nodiscard__]]
   uintmax_t hard_link_count(const path& __p, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   inline bool
   is_block_file(file_status __s) noexcept
   { return __s.type() == file_type::block; }
 
+  [[__nodiscard__]]
   inline bool
   is_block_file(const path& __p)
   { return is_block_file(status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   is_block_file(const path& __p, error_code& __ec) noexcept
   { return is_block_file(status(__p, __ec)); }
 
+  [[__nodiscard__]]
   inline bool
   is_character_file(file_status __s) noexcept
   { return __s.type() == file_type::character; }
 
+  [[__nodiscard__]]
   inline bool
   is_character_file(const path& __p)
   { return is_character_file(status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   is_character_file(const path& __p, error_code& __ec) noexcept
   { return is_character_file(status(__p, __ec)); }
 
+  [[__nodiscard__]]
   inline bool
   is_directory(file_status __s) noexcept
   { return __s.type() == file_type::directory; }
 
+  [[__nodiscard__]]
   inline bool
   is_directory(const path& __p)
   { return is_directory(status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   is_directory(const path& __p, error_code& __ec) noexcept
   { return is_directory(status(__p, __ec)); }
 
+  [[__nodiscard__]]
   bool is_empty(const path& __p);
+  [[__nodiscard__]]
   bool is_empty(const path& __p, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   inline bool
   is_fifo(file_status __s) noexcept
   { return __s.type() == file_type::fifo; }
 
+  [[__nodiscard__]]
   inline bool
   is_fifo(const path& __p)
   { return is_fifo(status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   is_fifo(const path& __p, error_code& __ec) noexcept
   { return is_fifo(status(__p, __ec)); }
 
+  [[__nodiscard__]]
   inline bool
   is_other(file_status __s) noexcept
   {
@@ -202,52 +239,67 @@ inline namespace v1
       && !is_symlink(__s);
   }
 
+  [[__nodiscard__]]
   inline bool
   is_other(const path& __p)
   { return is_other(status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   is_other(const path& __p, error_code& __ec) noexcept
   { return is_other(status(__p, __ec)); }
 
+  [[__nodiscard__]]
   inline bool
   is_regular_file(file_status __s) noexcept
   { return __s.type() == file_type::regular; }
 
+  [[__nodiscard__]]
   inline bool
   is_regular_file(const path& __p)
   { return is_regular_file(status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   is_regular_file(const path& __p, error_code& __ec) noexcept
   { return is_regular_file(status(__p, __ec)); }
 
+  [[__nodiscard__]]
   inline bool
   is_socket(file_status __s) noexcept
   { return __s.type() == file_type::socket; }
 
+  [[__nodiscard__]]
   inline bool
   is_socket(const path& __p)
   { return is_socket(status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   is_socket(const path& __p, error_code& __ec) noexcept
   { return is_socket(status(__p, __ec)); }
 
+  [[__nodiscard__]]
   inline bool
   is_symlink(file_status __s) noexcept
   { return __s.type() == file_type::symlink; }
 
+  [[__nodiscard__]]
   inline bool
   is_symlink(const path& __p)
   { return is_symlink(symlink_status(__p)); }
 
+  [[__nodiscard__]]
   inline bool
   is_symlink(const path& __p, error_code& __ec) noexcept
   { return is_symlink(symlink_status(__p, __ec)); }
 
+  [[__nodiscard__]]
   file_time_type  last_write_time(const path& __p);
+
+  [[__nodiscard__]]
   file_time_type  last_write_time(const path& __p, error_code& __ec) noexcept;
+
   void last_write_time(const path& __p, file_time_type __new_time);
   void last_write_time(const path& __p, file_time_type __new_time,
 		       error_code& __ec) noexcept;
@@ -255,7 +307,10 @@ inline namespace v1
   void permissions(const path& __p, perms __prms);
   void permissions(const path& __p, perms __prms, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   path read_symlink(const path& __p);
+
+  [[__nodiscard__]]
   path read_symlink(const path& __p, error_code& __ec);
 
   bool remove(const path& __p);
@@ -270,22 +325,38 @@ inline namespace v1
   void resize_file(const path& __p, uintmax_t __size);
   void resize_file(const path& __p, uintmax_t __size, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   space_info space(const path& __p);
+
+  [[__nodiscard__]]
   space_info space(const path& __p, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   file_status status(const path& __p);
+
+  [[__nodiscard__]]
   file_status status(const path& __p, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   inline bool status_known(file_status __s) noexcept
   { return __s.type() != file_type::none; }
 
+  [[__nodiscard__]]
   file_status symlink_status(const path& __p);
+
+  [[__nodiscard__]]
   file_status symlink_status(const path& __p, error_code& __ec) noexcept;
 
+  [[__nodiscard__]]
   path system_complete(const path& __p);
+
+  [[__nodiscard__]]
   path system_complete(const path& __p, error_code& __ec);
 
+  [[__nodiscard__]]
   path temp_directory_path();
+
+  [[__nodiscard__]]
   path temp_directory_path(error_code& __ec);
 
   /// @} group filesystem-ts
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
index 1cc1b3bf686..50e47082714 100644
--- a/libstdc++-v3/include/experimental/bits/fs_path.h
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h
@@ -140,10 +140,10 @@ namespace __detail
     inline _Source
     _S_range_begin(_Source __begin) { return __begin; }
 
-  struct __null_terminated { };
+  struct __nul_terminated { };
 
   template<typename _Source>
-    inline __null_terminated
+    inline __nul_terminated
     _S_range_end(_Source) { return {}; }
 
   template<typename _CharT, typename _Traits, typename _Alloc>
@@ -425,8 +425,8 @@ namespace __detail
     class iterator;
     typedef iterator const_iterator;
 
-    iterator begin() const noexcept;
-    iterator end() const noexcept;
+    iterator begin() const;
+    iterator end() const;
 
     /// @cond undocumented
     // Create a basic_string by reading until a null character.
@@ -473,11 +473,11 @@ namespace __detail
       struct _Cvt;
 
     static string_type
-    _S_convert(value_type* __src, __detail::__null_terminated)
+    _S_convert(value_type* __src, __detail::__nul_terminated)
     { return string_type(__src); }
 
     static string_type
-    _S_convert(const value_type* __src, __detail::__null_terminated)
+    _S_convert(const value_type* __src, __detail::__nul_terminated)
     { return string_type(__src); }
 
     template<typename _Iter>
@@ -491,7 +491,7 @@ namespace __detail
 
     template<typename _InputIterator>
       static string_type
-      _S_convert(_InputIterator __src, __detail::__null_terminated)
+      _S_convert(_InputIterator __src, __detail::__nul_terminated)
       {
 	auto __s = _S_string_from_iter(__src);
 	return _S_convert(__s.c_str(), __s.c_str() + __s.size());
@@ -518,7 +518,7 @@ namespace __detail
 
     template<typename _InputIterator>
       static string_type
-      _S_convert_loc(_InputIterator __src, __detail::__null_terminated,
+      _S_convert_loc(_InputIterator __src, __detail::__nul_terminated,
 		     const std::locale& __loc)
       {
 	const std::string __s = _S_string_from_iter(__src);
@@ -748,15 +748,48 @@ namespace __detail
   template<>
     struct path::_Cvt<path::value_type>
     {
+      // We need this type to be defined because we don't have `if constexpr`
+      // in C++11 and so path::string<C,T,A>(const A&) needs to be able to
+      // declare a variable of this type and pass it to __str_codecvt_in_all.
+      using __codecvt_utf8_to_wide = _Cvt;
+      // Dummy overload used for unreachable calls in path::string<C,T,A>.
+      template<typename _WStr>
+	friend bool
+	__str_codecvt_in_all(const char*, const char*,
+			     _WStr&, __codecvt_utf8_to_wide&) noexcept
+	{ return true; }
+
       template<typename _Iter>
 	static string_type
 	_S_convert(_Iter __first, _Iter __last)
 	{ return string_type{__first, __last}; }
     };
 
+  // Performs conversions from _CharT to path::string_type.
   template<typename _CharT>
     struct path::_Cvt
     {
+      // FIXME: We currently assume that the native wide encoding for wchar_t
+      // is either UTF-32 or UTF-16 (depending on the width of wchar_t).
+      // See comments in <bits/fs_path.h> for further details.
+      using __codecvt_utf8_to_wchar
+	= typename conditional<sizeof(wchar_t) == sizeof(char32_t),
+			       std::codecvt_utf8<wchar_t>,      // from UTF-32
+			       std::codecvt_utf8_utf16<wchar_t> // from UTF-16
+			      >::type;
+
+      // Converts from char16_t or char32_t using std::codecvt<charNN_t, char>.
+      // Need derived class here because std::codecvt has protected destructor.
+      struct __codecvt_utf8_to_utfNN : std::codecvt<_CharT, char, mbstate_t>
+      { };
+
+      // Convert from native pathname format (assumed to be UTF-8 everywhere)
+      // to the encoding implied by the wide character type _CharT.
+      using __codecvt_utf8_to_wide
+	= typename conditional<is_same<_CharT, wchar_t>::value,
+			       __codecvt_utf8_to_wchar,
+			       __codecvt_utf8_to_utfNN>::type;
+
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
 #ifdef _GLIBCXX_USE_CHAR8_T
       static string_type
@@ -774,8 +807,7 @@ namespace __detail
       static string_type
       _S_wconvert(const char* __f, const char* __l, const char*)
       {
-	using _Cvt = std::codecvt<wchar_t, char, mbstate_t>;
-	const auto& __cvt = std::use_facet<_Cvt>(std::locale{});
+	std::codecvt_utf8_utf16<wchar_t> __cvt;
 	std::wstring __wstr;
 	if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))
 	    return __wstr;
@@ -787,8 +819,7 @@ namespace __detail
       static string_type
       _S_wconvert(const _CharT* __f, const _CharT* __l, const void*)
       {
-	struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>
-	{ } __cvt;
+	__codecvt_utf8_to_wide __cvt;
 	std::string __str;
 	if (__str_codecvt_out_all(__f, __l, __str, __cvt))
 	  {
@@ -819,8 +850,7 @@ namespace __detail
 	else
 #endif
 	  {
-	    struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>
-	    { } __cvt;
+	    __codecvt_utf8_to_wide __cvt;
 	    std::string __str;
 	    if (__str_codecvt_out_all(__f, __l, __str, __cvt))
 	      return __str;
@@ -990,7 +1020,7 @@ namespace __detail
     inline std::basic_string<_CharT, _Traits, _Allocator>
     path::string(const _Allocator& __a) const
     {
-      if (is_same<_CharT, value_type>::value)
+      if _GLIBCXX17_CONSTEXPR (is_same<_CharT, value_type>::value)
 	return { _M_pathname.begin(), _M_pathname.end(), __a };
 
       using _WString = basic_string<_CharT, _Traits, _Allocator>;
@@ -1026,9 +1056,8 @@ namespace __detail
 	      else
 #endif
 	        {
-	          // Convert UTF-8 to wide string.
-	          struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>
-		  { } __cvt;
+		  // Convert UTF-8 to char16_t or char32_t string.
+		  typename path::_Cvt<_CharT>::__codecvt_utf8_to_wide __cvt;
 	          const char* __f = __from.data();
 	          const char* __l = __f + __from.size();
 	          if (__str_codecvt_in_all(__f, __l, __to, __cvt))
@@ -1041,14 +1070,14 @@ namespace __detail
 	  if (auto* __p = __dispatch(__u8str, __wstr, is_same<_CharT, char>{}))
 	    return *__p;
 	}
-#else
+#else // ! Windows
 #ifdef _GLIBCXX_USE_CHAR8_T
       if constexpr (is_same<_CharT, char8_t>::value)
           return _WString(__first, __last, __a);
       else
 #endif
         {
-          struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t> { } __cvt;
+	  typename path::_Cvt<_CharT>::__codecvt_utf8_to_wide __cvt;
           _WString __wstr(__a);
           if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))
 	    return __wstr;
diff --git a/libstdc++-v3/include/experimental/bits/simd.h b/libstdc++-v3/include/experimental/bits/simd.h
index 421c923e7b0..d5683bfcacb 100644
--- a/libstdc++-v3/include/experimental/bits/simd.h
+++ b/libstdc++-v3/include/experimental/bits/simd.h
@@ -179,10 +179,7 @@ struct vector_aligned_tag
   template <typename _Tp, typename _Up>
     _GLIBCXX_SIMD_INTRINSIC static constexpr _Up*
     _S_apply(_Up* __ptr)
-    {
-      return static_cast<_Up*>(
-	__builtin_assume_aligned(__ptr, _S_alignment<_Tp, _Up>));
-    }
+    { return static_cast<_Up*>(__builtin_assume_aligned(__ptr, _S_alignment<_Tp, _Up>)); }
 };
 
 template <size_t _Np> struct overaligned_tag
@@ -420,28 +417,34 @@ template <size_t _Bytes>
 	  operator&(_Ip __rhs) const
 	  {
 	    return __generate_from_n_evaluations<_Np, _Ip>(
-	      [&](auto __i) { return __rhs._M_data[__i] & _M_data[__i]; });
+	      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		return __rhs._M_data[__i] & _M_data[__i];
+	      });
 	  }
 
 	  _GLIBCXX_SIMD_INTRINSIC constexpr _Ip
 	  operator|(_Ip __rhs) const
 	  {
 	    return __generate_from_n_evaluations<_Np, _Ip>(
-	      [&](auto __i) { return __rhs._M_data[__i] | _M_data[__i]; });
+	      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		return __rhs._M_data[__i] | _M_data[__i];
+	      });
 	  }
 
 	  _GLIBCXX_SIMD_INTRINSIC constexpr _Ip
 	  operator^(_Ip __rhs) const
 	  {
 	    return __generate_from_n_evaluations<_Np, _Ip>(
-	      [&](auto __i) { return __rhs._M_data[__i] ^ _M_data[__i]; });
+	      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		return __rhs._M_data[__i] ^ _M_data[__i];
+	      });
 	  }
 
 	  _GLIBCXX_SIMD_INTRINSIC constexpr _Ip
 	  operator~() const
 	  {
 	    return __generate_from_n_evaluations<_Np, _Ip>(
-	      [&](auto __i) { return ~_M_data[__i]; });
+	      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { return ~_M_data[__i]; });
 	  }
 	};
 	return _Ip{};
@@ -619,8 +622,7 @@ template <typename _Tp, typename _Up>
 // __invoke_ub{{{
 template <typename... _Args>
   [[noreturn]] _GLIBCXX_SIMD_ALWAYS_INLINE void
-  __invoke_ub([[maybe_unused]] const char* __msg,
-	      [[maybe_unused]] const _Args&... __args)
+  __invoke_ub([[maybe_unused]] const char* __msg, [[maybe_unused]] const _Args&... __args)
   {
 #ifdef _GLIBCXX_DEBUG_UB
     __builtin_fprintf(stderr, __msg, __args...);
@@ -665,11 +667,14 @@ class _ExactBool
   const bool _M_data;
 
 public:
-  _GLIBCXX_SIMD_INTRINSIC constexpr _ExactBool(bool __b) : _M_data(__b) {}
+  _GLIBCXX_SIMD_INTRINSIC constexpr
+  _ExactBool(bool __b) : _M_data(__b) {}
 
   _ExactBool(int) = delete;
 
-  _GLIBCXX_SIMD_INTRINSIC constexpr operator bool() const { return _M_data; }
+  _GLIBCXX_SIMD_INTRINSIC constexpr
+  operator bool() const
+  { return _M_data; }
 };
 
 // }}}
@@ -1267,7 +1272,7 @@ template <size_t _Np, bool _Sanitized>
     operator^=(const _BitMask& __b) & noexcept
     {
       __execute_n_times<_S_array_size>(
-	[&](auto __i) { _M_bits[__i] ^= __b._M_bits[__i]; });
+	[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { _M_bits[__i] ^= __b._M_bits[__i]; });
       return *this;
     }
 
@@ -1275,7 +1280,7 @@ template <size_t _Np, bool _Sanitized>
     operator|=(const _BitMask& __b) & noexcept
     {
       __execute_n_times<_S_array_size>(
-	[&](auto __i) { _M_bits[__i] |= __b._M_bits[__i]; });
+	[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { _M_bits[__i] |= __b._M_bits[__i]; });
       return *this;
     }
 
@@ -1283,7 +1288,7 @@ template <size_t _Np, bool _Sanitized>
     operator&=(const _BitMask& __b) & noexcept
     {
       __execute_n_times<_S_array_size>(
-	[&](auto __i) { _M_bits[__i] &= __b._M_bits[__i]; });
+	[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { _M_bits[__i] &= __b._M_bits[__i]; });
       return *this;
     }
 
@@ -1358,8 +1363,7 @@ template <typename _Tp>
 
 // else, use GNU-style builtin vector types
 template <typename _Tp, size_t _Np>
-  struct __vector_type_n<_Tp, _Np,
-			 enable_if_t<__is_vectorizable_v<_Tp> && _Np >= 2>>
+  struct __vector_type_n<_Tp, _Np, enable_if_t<__is_vectorizable_v<_Tp> && _Np >= 2>>
   {
     static constexpr size_t _S_Np2 = std::__bit_ceil(_Np * sizeof(_Tp));
 
@@ -1637,8 +1641,7 @@ template <typename _To, typename _From>
 // }}}
 // __to_intrin {{{
 template <typename _Tp, typename _TVT = _VectorTraits<_Tp>,
-	  typename _R
-	  = __intrinsic_type_t<typename _TVT::value_type, _TVT::_S_full_size>>
+	  typename _R = __intrinsic_type_t<typename _TVT::value_type, _TVT::_S_full_size>>
   _GLIBCXX_SIMD_INTRINSIC constexpr _R
   __to_intrin(_Tp __x)
   {
@@ -1659,30 +1662,26 @@ template <typename _Tp, typename _TVT = _VectorTraits<_Tp>,
 template <typename _Tp, typename... _Args>
   _GLIBCXX_SIMD_INTRINSIC constexpr __vector_type_t<_Tp, sizeof...(_Args)>
   __make_vector(const _Args&... __args)
-  {
-    return __vector_type_t<_Tp, sizeof...(_Args)>{static_cast<_Tp>(__args)...};
-  }
+  { return __vector_type_t<_Tp, sizeof...(_Args)>{static_cast<_Tp>(__args)...}; }
 
 // }}}
 // __vector_broadcast{{{
+template <size_t _Np, typename _Tp, size_t... _I>
+  _GLIBCXX_SIMD_INTRINSIC constexpr __vector_type_t<_Tp, _Np>
+  __vector_broadcast_impl(_Tp __x, index_sequence<_I...>)
+  { return __vector_type_t<_Tp, _Np>{((void)_I, __x)...}; }
+
 template <size_t _Np, typename _Tp>
   _GLIBCXX_SIMD_INTRINSIC constexpr __vector_type_t<_Tp, _Np>
   __vector_broadcast(_Tp __x)
-  {
-    return __call_with_n_evaluations<_Np>(
-      [](auto... __xx) { return __vector_type_t<_Tp, _Np>{__xx...}; },
-      [&__x](int) { return __x; });
-  }
+  { return __vector_broadcast_impl<_Np, _Tp>(__x, make_index_sequence<_Np>()); }
 
 // }}}
 // __generate_vector{{{
   template <typename _Tp, size_t _Np, typename _Gp, size_t... _I>
   _GLIBCXX_SIMD_INTRINSIC constexpr __vector_type_t<_Tp, _Np>
   __generate_vector_impl(_Gp&& __gen, index_sequence<_I...>)
-  {
-    return __vector_type_t<_Tp, _Np>{
-      static_cast<_Tp>(__gen(_SizeConstant<_I>()))...};
-  }
+  { return __vector_type_t<_Tp, _Np>{ static_cast<_Tp>(__gen(_SizeConstant<_I>()))...}; }
 
 template <typename _V, typename _VVT = _VectorTraits<_V>, typename _Gp>
   _GLIBCXX_SIMD_INTRINSIC constexpr _V
@@ -1895,8 +1894,7 @@ template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
 // }}}
 // __concat{{{
 template <typename _Tp, typename _TVT = _VectorTraits<_Tp>,
-	  typename _R = __vector_type_t<typename _TVT::value_type,
-					_TVT::_S_full_size * 2>>
+	  typename _R = __vector_type_t<typename _TVT::value_type, _TVT::_S_full_size * 2>>
   constexpr _R
   __concat(_Tp a_, _Tp b_)
   {
@@ -2040,8 +2038,7 @@ template <int _Offset,
 	  int _SplitBy,
 	  typename _Tp,
 	  typename _TVT = _VectorTraits<_Tp>,
-	  typename _R = __vector_type_t<typename _TVT::value_type,
-			  _TVT::_S_full_size / _SplitBy>>
+	  typename _R = __vector_type_t<typename _TVT::value_type, _TVT::_S_full_size / _SplitBy>>
   _GLIBCXX_SIMD_INTRINSIC constexpr _R
   __extract(_Tp __in)
   {
@@ -2078,7 +2075,7 @@ template <int _Offset,
 #endif
 	constexpr int _O = _Offset * __return_width;
 	return __call_with_subscripts<__return_width, _O>(
-	  __x, [](auto... __entries) {
+	  __x, [](auto... __entries) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    return reinterpret_cast<_R>(_Up{__entries...});
 	  });
       }
@@ -2087,8 +2084,7 @@ template <int _Offset,
 // }}}
 // __lo/__hi64[z]{{{
 template <typename _Tp,
-	  typename _R
-	  = __vector_type8_t<typename _VectorTraits<_Tp>::value_type>>
+	  typename _R = __vector_type8_t<typename _VectorTraits<_Tp>::value_type>>
   _GLIBCXX_SIMD_INTRINSIC constexpr _R
   __lo64(_Tp __x)
   {
@@ -2098,8 +2094,7 @@ template <typename _Tp,
   }
 
 template <typename _Tp,
-	  typename _R
-	  = __vector_type8_t<typename _VectorTraits<_Tp>::value_type>>
+	  typename _R = __vector_type8_t<typename _VectorTraits<_Tp>::value_type>>
   _GLIBCXX_SIMD_INTRINSIC constexpr _R
   __hi64(_Tp __x)
   {
@@ -2110,8 +2105,7 @@ template <typename _Tp,
   }
 
 template <typename _Tp,
-	  typename _R
-	  = __vector_type8_t<typename _VectorTraits<_Tp>::value_type>>
+	  typename _R = __vector_type8_t<typename _VectorTraits<_Tp>::value_type>>
   _GLIBCXX_SIMD_INTRINSIC constexpr _R
   __hi64z([[maybe_unused]] _Tp __x)
   {
@@ -2222,18 +2216,15 @@ template <>
 // the following excludes bool via __is_vectorizable
 #if _GLIBCXX_SIMD_HAVE_SSE
 template <typename _Tp, size_t _Bytes>
-  struct __intrinsic_type<_Tp, _Bytes,
-			  enable_if_t<__is_vectorizable_v<_Tp> && _Bytes <= 64>>
+  struct __intrinsic_type<_Tp, _Bytes, enable_if_t<__is_vectorizable_v<_Tp> && _Bytes <= 64>>
   {
     static_assert(!is_same_v<_Tp, long double>,
 		  "no __intrinsic_type support for long double on x86");
 
-    static constexpr size_t _S_VBytes = _Bytes <= 16   ? 16
-					: _Bytes <= 32 ? 32
-						       : 64;
+    static constexpr size_t _S_VBytes = _Bytes <= 16 ? 16 : _Bytes <= 32 ? 32 : 64;
 
     using type [[__gnu__::__vector_size__(_S_VBytes)]]
-    = conditional_t<is_integral_v<_Tp>, long long int, _Tp>;
+      = conditional_t<is_integral_v<_Tp>, long long int, _Tp>;
   };
 #endif // _GLIBCXX_SIMD_HAVE_SSE
 
@@ -2249,15 +2240,21 @@ template <>
   struct __intrinsic_type<float, 16, void>
   { using type = float32x4_t; };
 
-#if _GLIBCXX_SIMD_HAVE_NEON_A64
 template <>
   struct __intrinsic_type<double, 8, void>
-  { using type = float64x1_t; };
+  {
+#if _GLIBCXX_SIMD_HAVE_NEON_A64
+   using type = float64x1_t;
+#endif
+  };
 
 template <>
   struct __intrinsic_type<double, 16, void>
-  { using type = float64x2_t; };
+  {
+#if _GLIBCXX_SIMD_HAVE_NEON_A64
+    using type = float64x2_t;
 #endif
+  };
 
 #define _GLIBCXX_SIMD_ARM_INTRIN(_Bits, _Np)                                   \
 template <>                                                                    \
@@ -2279,16 +2276,19 @@ _GLIBCXX_SIMD_ARM_INTRIN(64, 2);
 #undef _GLIBCXX_SIMD_ARM_INTRIN
 
 template <typename _Tp, size_t _Bytes>
-  struct __intrinsic_type<_Tp, _Bytes,
-			  enable_if_t<__is_vectorizable_v<_Tp> && _Bytes <= 16>>
+  struct __intrinsic_type<_Tp, _Bytes, enable_if_t<__is_vectorizable_v<_Tp> && _Bytes <= 16>>
   {
     static constexpr int _SVecBytes = _Bytes <= 8 ? 8 : 16;
+
     using _Ip = __int_for_sizeof_t<_Tp>;
+
     using _Up = conditional_t<
       is_floating_point_v<_Tp>, _Tp,
       conditional_t<is_unsigned_v<_Tp>, make_unsigned_t<_Ip>, _Ip>>;
+
     static_assert(!is_same_v<_Tp, _Up> || _SVecBytes != _Bytes,
 		  "should use explicit specialization above");
+
     using type = typename __intrinsic_type<_Up, _SVecBytes>::type;
   };
 #endif // _GLIBCXX_SIMD_HAVE_NEON
@@ -2303,36 +2303,74 @@ template <typename _Tp>
   template <>                                                                  \
     struct __intrinsic_type_impl<_Tp> { using type = __vector _Tp; }
 _GLIBCXX_SIMD_PPC_INTRIN(float);
+#ifdef __VSX__
 _GLIBCXX_SIMD_PPC_INTRIN(double);
+#endif
 _GLIBCXX_SIMD_PPC_INTRIN(signed char);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned char);
 _GLIBCXX_SIMD_PPC_INTRIN(signed short);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned short);
 _GLIBCXX_SIMD_PPC_INTRIN(signed int);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned int);
+#if defined __VSX__ || __SIZEOF_LONG__ == 4
 _GLIBCXX_SIMD_PPC_INTRIN(signed long);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned long);
+#endif
+#ifdef __VSX__
 _GLIBCXX_SIMD_PPC_INTRIN(signed long long);
 _GLIBCXX_SIMD_PPC_INTRIN(unsigned long long);
+#endif
 #undef _GLIBCXX_SIMD_PPC_INTRIN
 
 template <typename _Tp, size_t _Bytes>
-  struct __intrinsic_type<_Tp, _Bytes,
-			  enable_if_t<__is_vectorizable_v<_Tp> && _Bytes <= 16>>
+  struct __intrinsic_type<_Tp, _Bytes, enable_if_t<__is_vectorizable_v<_Tp> && _Bytes <= 16>>
   {
     static constexpr bool _S_is_ldouble = is_same_v<_Tp, long double>;
+
     // allow _Tp == long double with -mlong-double-64
     static_assert(!(_S_is_ldouble && sizeof(long double) > sizeof(double)),
-		  "no __intrinsic_type support for long double on PPC");
+		  "no __intrinsic_type support for 128-bit floating point on PowerPC");
+
 #ifndef __VSX__
-    static_assert(!is_same_v<_Tp, double>,
-		  "no __intrinsic_type support for double on PPC w/o VSX");
+    static_assert(!(is_same_v<_Tp, double>
+		    || (_S_is_ldouble && sizeof(long double) == sizeof(double))),
+		  "no __intrinsic_type support for 64-bit floating point on PowerPC w/o VSX");
 #endif
-    using type =
-      typename __intrinsic_type_impl<
-		 conditional_t<is_floating_point_v<_Tp>,
-			       conditional_t<_S_is_ldouble, double, _Tp>,
-			       __int_for_sizeof_t<_Tp>>>::type;
+
+    static constexpr auto __element_type()
+    {
+      if constexpr (is_floating_point_v<_Tp>)
+	{
+	  if constexpr (_S_is_ldouble)
+	    return double {};
+	  else
+	    return _Tp {};
+	}
+      else if constexpr (is_signed_v<_Tp>)
+	{
+	  if constexpr (sizeof(_Tp) == sizeof(_SChar))
+	    return _SChar {};
+	  else if constexpr (sizeof(_Tp) == sizeof(short))
+	    return short {};
+	  else if constexpr (sizeof(_Tp) == sizeof(int))
+	    return int {};
+	  else if constexpr (sizeof(_Tp) == sizeof(_LLong))
+	    return _LLong {};
+	}
+      else
+	{
+	  if constexpr (sizeof(_Tp) == sizeof(_UChar))
+	    return _UChar {};
+	  else if constexpr (sizeof(_Tp) == sizeof(_UShort))
+	    return _UShort {};
+	  else if constexpr (sizeof(_Tp) == sizeof(_UInt))
+	    return _UInt {};
+	  else if constexpr (sizeof(_Tp) == sizeof(_ULLong))
+	    return _ULLong {};
+	}
+    }
+
+    using type = typename __intrinsic_type_impl<decltype(__element_type())>::type;
   };
 #endif // __ALTIVEC__
 
@@ -2348,22 +2386,29 @@ template <size_t _Width>
     static constexpr size_t _S_full_size = sizeof(_BuiltinType) * __CHAR_BIT__;
 
     _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper<bool, _S_full_size>
-    __as_full_vector() const { return _M_data; }
+    __as_full_vector() const
+    { return _M_data; }
+
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapper() = default;
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper() = default;
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper(_BuiltinType __k)
-      : _M_data(__k) {};
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapper(_BuiltinType __k) : _M_data(__k) {};
 
-    _GLIBCXX_SIMD_INTRINSIC operator const _BuiltinType&() const
+    _GLIBCXX_SIMD_INTRINSIC
+    operator const _BuiltinType&() const
     { return _M_data; }
 
-    _GLIBCXX_SIMD_INTRINSIC operator _BuiltinType&()
+    _GLIBCXX_SIMD_INTRINSIC
+    operator _BuiltinType&()
     { return _M_data; }
 
-    _GLIBCXX_SIMD_INTRINSIC _BuiltinType __intrin() const
+    _GLIBCXX_SIMD_INTRINSIC _BuiltinType
+    __intrin() const
     { return _M_data; }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr value_type operator[](size_t __i) const
+    _GLIBCXX_SIMD_INTRINSIC constexpr value_type
+    operator[](size_t __i) const
     { return _M_data & (_BuiltinType(1) << __i); }
 
     template <size_t __i>
@@ -2371,7 +2416,8 @@ template <size_t _Width>
       operator[](_SizeConstant<__i>) const
       { return _M_data & (_BuiltinType(1) << __i); }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr void _M_set(size_t __i, value_type __x)
+    _GLIBCXX_SIMD_INTRINSIC constexpr void
+    _M_set(size_t __i, value_type __x)
     {
       if (__x)
 	_M_data |= (_BuiltinType(1) << __i);
@@ -2379,11 +2425,12 @@ template <size_t _Width>
 	_M_data &= ~(_BuiltinType(1) << __i);
     }
 
-    _GLIBCXX_SIMD_INTRINSIC
-    constexpr bool _M_is_constprop() const
+    _GLIBCXX_SIMD_INTRINSIC constexpr bool
+    _M_is_constprop() const
     { return __builtin_constant_p(_M_data); }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr bool _M_is_constprop_none_of() const
+    _GLIBCXX_SIMD_INTRINSIC constexpr bool
+    _M_is_constprop_none_of() const
     {
       if (__builtin_constant_p(_M_data))
 	{
@@ -2395,7 +2442,8 @@ template <size_t _Width>
       return false;
     }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr bool _M_is_constprop_all_of() const
+    _GLIBCXX_SIMD_INTRINSIC constexpr bool
+    _M_is_constprop_all_of() const
     {
       if (__builtin_constant_p(_M_data))
 	{
@@ -2417,10 +2465,11 @@ template <bool _MustZeroInitPadding, typename _BuiltinType>
 template <typename _BuiltinType>
   struct _SimdWrapperBase<false, _BuiltinType> // no padding or no SNaNs
   {
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapperBase() = default;
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapperBase(_BuiltinType __init)
-      : _M_data(__init)
-    {}
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapperBase() = default;
+
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapperBase(_BuiltinType __init) : _M_data(__init) {}
 
     _BuiltinType _M_data;
   };
@@ -2429,10 +2478,11 @@ template <typename _BuiltinType>
   struct _SimdWrapperBase<true, _BuiltinType> // with padding that needs to
 					      // never become SNaN
   {
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapperBase() : _M_data() {}
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapperBase(_BuiltinType __init)
-      : _M_data(__init)
-    {}
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapperBase() : _M_data() {}
+
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapperBase(_BuiltinType __init) : _M_data(__init) {}
 
     _BuiltinType _M_data;
   };
@@ -2471,24 +2521,33 @@ template <typename _Tp, size_t _Width>
     __as_full_vector() const
     { return _M_data; }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper(initializer_list<_Tp> __init)
-      : _Base(__generate_from_n_evaluations<_Width, _BuiltinType>(
-	[&](auto __i) { return __init.begin()[__i.value]; })) {}
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapper(initializer_list<_Tp> __init)
+    : _Base(__generate_from_n_evaluations<_Width, _BuiltinType>(
+	      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		return __init.begin()[__i.value];
+	      })) {}
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper() = default;
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper(const _SimdWrapper&)
-      = default;
-    _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper(_SimdWrapper&&) = default;
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapper() = default;
+
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapper(const _SimdWrapper&) = default;
+
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    _SimdWrapper(_SimdWrapper&&) = default;
 
     _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper&
     operator=(const _SimdWrapper&) = default;
+
     _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper&
     operator=(_SimdWrapper&&) = default;
 
     template <typename _V, typename = enable_if_t<disjunction_v<
 			     is_same<_V, __vector_type_t<_Tp, _Width>>,
 			     is_same<_V, __intrinsic_type_t<_Tp, _Width>>>>>
-      _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper(_V __x)
+      _GLIBCXX_SIMD_INTRINSIC constexpr
+      _SimdWrapper(_V __x)
       // __vector_bitcast can convert e.g. __m128 to __vector(2) float
       : _Base(__vector_bitcast<_Tp, _Width>(__x)) {}
 
@@ -2498,33 +2557,46 @@ template <typename _Tp, size_t _Width>
       _GLIBCXX_SIMD_INTRINSIC constexpr
       operator _SimdTuple<_Tp, _As...>() const
       {
-	const auto& dd = _M_data; // workaround for GCC7 ICE
-	return __generate_from_n_evaluations<sizeof...(_As),
-					     _SimdTuple<_Tp, _As...>>([&](
-	  auto __i) constexpr { return dd[int(__i)]; });
+	return __generate_from_n_evaluations<sizeof...(_As), _SimdTuple<_Tp, _As...>>(
+		 [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+		 { return _M_data[int(__i)]; });
       }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr operator const _BuiltinType&() const
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    operator const _BuiltinType&() const
     { return _M_data; }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr operator _BuiltinType&()
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    operator _BuiltinType&()
     { return _M_data; }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr _Tp operator[](size_t __i) const
+    _GLIBCXX_SIMD_INTRINSIC constexpr _Tp
+    operator[](size_t __i) const
     { return _M_data[__i]; }
 
     template <size_t __i>
-      _GLIBCXX_SIMD_INTRINSIC constexpr _Tp operator[](_SizeConstant<__i>) const
+      _GLIBCXX_SIMD_INTRINSIC constexpr _Tp
+      operator[](_SizeConstant<__i>) const
       { return _M_data[__i]; }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr void _M_set(size_t __i, _Tp __x)
-    { _M_data[__i] = __x; }
+    _GLIBCXX_SIMD_INTRINSIC constexpr void
+    _M_set(size_t __i, _Tp __x)
+    {
+      if (__builtin_is_constant_evaluated())
+	_M_data = __generate_from_n_evaluations<_Width, _BuiltinType>([&](auto __j) {
+		    return __j == __i ? __x : _M_data[__j()];
+		  });
+      else
+	_M_data[__i] = __x;
+    }
 
     _GLIBCXX_SIMD_INTRINSIC
-    constexpr bool _M_is_constprop() const
+    constexpr bool
+    _M_is_constprop() const
     { return __builtin_constant_p(_M_data); }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr bool _M_is_constprop_none_of() const
+    _GLIBCXX_SIMD_INTRINSIC constexpr bool
+    _M_is_constprop_none_of() const
     {
       if (__builtin_constant_p(_M_data))
 	{
@@ -2539,12 +2611,14 @@ template <typename _Tp, size_t _Width>
 	  else
 	    __execute_n_times<_Width>(
 	      [&](auto __i) { __r &= _M_data[__i.value] == _Tp(); });
-	  return __r;
+	  if (__builtin_constant_p(__r))
+	    return __r;
 	}
       return false;
     }
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr bool _M_is_constprop_all_of() const
+    _GLIBCXX_SIMD_INTRINSIC constexpr bool
+    _M_is_constprop_all_of() const
     {
       if (__builtin_constant_p(_M_data))
 	{
@@ -2559,7 +2633,8 @@ template <typename _Tp, size_t _Width>
 	  else
 	    __execute_n_times<_Width>(
 	      [&](auto __i) { __r &= _M_data[__i.value] == ~_Tp(); });
-	  return __r;
+	  if (__builtin_constant_p(__r))
+	    return __r;
 	}
       return false;
     }
@@ -2675,6 +2750,32 @@ template <typename _Tp>
 } // namespace simd_abi
 
 // traits {{{1
+template <typename _Tp>
+  struct is_simd_flag_type
+  : false_type
+  {};
+
+template <>
+  struct is_simd_flag_type<element_aligned_tag>
+  : true_type
+  {};
+
+template <>
+  struct is_simd_flag_type<vector_aligned_tag>
+  : true_type
+  {};
+
+template <size_t _Np>
+  struct is_simd_flag_type<overaligned_tag<_Np>>
+  : __bool_constant<(_Np > 0) and __has_single_bit(_Np)>
+  {};
+
+template <typename _Tp>
+  inline constexpr bool is_simd_flag_type_v = is_simd_flag_type<_Tp>::value;
+
+template <typename _Tp, typename = enable_if_t<is_simd_flag_type_v<_Tp>>>
+  using _IsSimdFlagType = _Tp;
+
 // is_abi_tag {{{2
 template <typename _Tp, typename = void_t<>>
   struct is_abi_tag : false_type {};
@@ -2741,22 +2842,14 @@ template <typename _Tp, typename _V, typename = void>
   struct rebind_simd;
 
 template <typename _Tp, typename _Up, typename _Abi>
-  struct rebind_simd<
-    _Tp, simd<_Up, _Abi>,
-    void_t<simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>>
-  {
-    using type
-      = simd<_Tp, simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>;
-  };
+  struct rebind_simd<_Tp, simd<_Up, _Abi>,
+		     void_t<simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>>
+  { using type = simd<_Tp, simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>; };
 
 template <typename _Tp, typename _Up, typename _Abi>
-  struct rebind_simd<
-    _Tp, simd_mask<_Up, _Abi>,
-    void_t<simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>>
-  {
-    using type
-      = simd_mask<_Tp, simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>;
-  };
+  struct rebind_simd<_Tp, simd_mask<_Up, _Abi>,
+		     void_t<simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>>
+  { using type = simd_mask<_Tp, simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>; };
 
 template <typename _Tp, typename _V>
   using rebind_simd_t = typename rebind_simd<_Tp, _V>::type;
@@ -2766,13 +2859,11 @@ template <int _Np, typename _V, typename = void>
   struct resize_simd;
 
 template <int _Np, typename _Tp, typename _Abi>
-  struct resize_simd<_Np, simd<_Tp, _Abi>,
-		     void_t<simd_abi::deduce_t<_Tp, _Np, _Abi>>>
+  struct resize_simd<_Np, simd<_Tp, _Abi>, void_t<simd_abi::deduce_t<_Tp, _Np, _Abi>>>
   { using type = simd<_Tp, simd_abi::deduce_t<_Tp, _Np, _Abi>>; };
 
 template <int _Np, typename _Tp, typename _Abi>
-  struct resize_simd<_Np, simd_mask<_Tp, _Abi>,
-		     void_t<simd_abi::deduce_t<_Tp, _Np, _Abi>>>
+  struct resize_simd<_Np, simd_mask<_Tp, _Abi>, void_t<simd_abi::deduce_t<_Tp, _Np, _Abi>>>
   { using type = simd_mask<_Tp, simd_abi::deduce_t<_Tp, _Np, _Abi>>; };
 
 template <int _Np, typename _V>
@@ -2821,13 +2912,11 @@ template <typename _Tp, size_t _Np>
 
 // casts [simd.casts] {{{1
 // static_simd_cast {{{2
-template <typename _Tp, typename _Up, typename _Ap, bool = is_simd_v<_Tp>,
-	  typename = void>
+template <typename _Tp, typename _Up, typename _Ap, bool = is_simd_v<_Tp>, typename = void>
   struct __static_simd_cast_return_type;
 
 template <typename _Tp, typename _A0, typename _Up, typename _Ap>
-  struct __static_simd_cast_return_type<simd_mask<_Tp, _A0>, _Up, _Ap, false,
-					void>
+  struct __static_simd_cast_return_type<simd_mask<_Tp, _A0>, _Up, _Ap, false, void>
   : __static_simd_cast_return_type<simd<_Tp, _A0>, _Up, _Ap> {};
 
 template <typename _Tp, typename _Up, typename _Ap>
@@ -2958,6 +3047,10 @@ template <typename _Tp, typename _Up, typename _Ap>
   {
     if constexpr (is_same_v<typename _Tp::abi_type, _Ap>)
       return __x;
+    else if (__builtin_is_constant_evaluated())
+      return _Tp([&](auto __i) constexpr {
+	       return __i < simd_size_v<_Up, _Ap> ? __x[__i] : _Up();
+	     });
     else if constexpr (simd_size_v<_Up, _Ap> == 1)
       {
 	_Tp __r{};
@@ -3004,21 +3097,19 @@ template <typename _Tp, int _Np>
   { return __x; }
 
 template <typename _Tp, typename _Ap>
-  _GLIBCXX_SIMD_INTRINSIC auto
+  _GLIBCXX_SIMD_INTRINSIC fixed_size_simd<_Tp, simd_size_v<_Tp, _Ap>>
   to_fixed_size(const simd<_Tp, _Ap>& __x)
   {
-    return simd<_Tp, simd_abi::fixed_size<simd_size_v<_Tp, _Ap>>>([&__x](
-      auto __i) constexpr { return __x[__i]; });
+    using _Rp = fixed_size_simd<_Tp, simd_size_v<_Tp, _Ap>>;
+    return _Rp([&__x](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { return __x[__i]; });
   }
 
 template <typename _Tp, typename _Ap>
-  _GLIBCXX_SIMD_INTRINSIC auto
+  _GLIBCXX_SIMD_INTRINSIC fixed_size_simd_mask<_Tp, simd_size_v<_Tp, _Ap>>
   to_fixed_size(const simd_mask<_Tp, _Ap>& __x)
   {
-    constexpr int _Np = simd_mask<_Tp, _Ap>::size();
-    fixed_size_simd_mask<_Tp, _Np> __r;
-    __execute_n_times<_Np>([&](auto __i) constexpr { __r[__i] = __x[__i]; });
-    return __r;
+    return {__private_init,
+	    [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { return __x[__i]; }};
   }
 
 // to_native {{{2
@@ -3032,16 +3123,18 @@ template <typename _Tp, int _Np>
     return {__mem, vector_aligned};
   }
 
-template <typename _Tp, size_t _Np>
+template <typename _Tp, int _Np>
   _GLIBCXX_SIMD_INTRINSIC
   enable_if_t<(_Np == native_simd_mask<_Tp>::size()), native_simd_mask<_Tp>>
   to_native(const fixed_size_simd_mask<_Tp, _Np>& __x)
   {
-    return native_simd_mask<_Tp>([&](auto __i) constexpr { return __x[__i]; });
+    return native_simd_mask<_Tp>(
+	     __private_init,
+	     [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { return __x[__i]; });
   }
 
 // to_compatible {{{2
-template <typename _Tp, size_t _Np>
+template <typename _Tp, int _Np>
   _GLIBCXX_SIMD_INTRINSIC enable_if_t<(_Np == simd<_Tp>::size()), simd<_Tp>>
   to_compatible(const simd<_Tp, simd_abi::fixed_size<_Np>>& __x)
   {
@@ -3050,11 +3143,15 @@ template <typename _Tp, size_t _Np>
     return {__mem, vector_aligned};
   }
 
-template <typename _Tp, size_t _Np>
+template <typename _Tp, int _Np>
   _GLIBCXX_SIMD_INTRINSIC
   enable_if_t<(_Np == simd_mask<_Tp>::size()), simd_mask<_Tp>>
   to_compatible(const simd_mask<_Tp, simd_abi::fixed_size<_Np>>& __x)
-  { return simd_mask<_Tp>([&](auto __i) constexpr { return __x[__i]; }); }
+  {
+    return simd_mask<_Tp>(
+	     __private_init,
+	     [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { return __x[__i]; });
+  }
 
 // masked assignment [simd_mask.where] {{{1
 
@@ -3087,12 +3184,14 @@ template <typename _M, typename _Tp>
 
   public:
     const_where_expression(const const_where_expression&) = delete;
+
     const_where_expression& operator=(const const_where_expression&) = delete;
 
-    _GLIBCXX_SIMD_INTRINSIC const_where_expression(const _M& __kk, const _Tp& dd)
-      : _M_k(__kk), _M_value(const_cast<_Tp&>(dd)) {}
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    const_where_expression(const _M& __kk, const _Tp& dd)
+    : _M_k(__kk), _M_value(const_cast<_Tp&>(dd)) {}
 
-    _GLIBCXX_SIMD_INTRINSIC _V
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR _V
     operator-() const&&
     {
       return {__private_init,
@@ -3101,8 +3200,8 @@ template <typename _M, typename _Tp>
     }
 
     template <typename _Up, typename _Flags>
-      [[nodiscard]] _GLIBCXX_SIMD_INTRINSIC _V
-      copy_from(const _LoadStorePtr<_Up, value_type>* __mem, _Flags) const&&
+      [[nodiscard]] _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR _V
+      copy_from(const _LoadStorePtr<_Up, value_type>* __mem, _IsSimdFlagType<_Flags>) const&&
       {
 	return {__private_init,
 		_Impl::_S_masked_load(__data(_M_value), __data(_M_k),
@@ -3110,8 +3209,8 @@ template <typename _M, typename _Tp>
       }
 
     template <typename _Up, typename _Flags>
-      _GLIBCXX_SIMD_INTRINSIC void
-      copy_to(_LoadStorePtr<_Up, value_type>* __mem, _Flags) const&&
+      _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+      copy_to(_LoadStorePtr<_Up, value_type>* __mem, _IsSimdFlagType<_Flags>) const&&
       {
 	_Impl::_S_masked_store(__data(_M_value),
 			       _Flags::template _S_apply<_V>(__mem),
@@ -3131,8 +3230,8 @@ template <typename _Tp>
     struct _Wrapper { using value_type = _V; };
 
   protected:
-    using value_type =
-      typename conditional_t<is_arithmetic_v<_V>, _Wrapper, _V>::value_type;
+    using value_type
+      = typename conditional_t<is_arithmetic_v<_V>, _Wrapper, _V>::value_type;
 
     _GLIBCXX_SIMD_INTRINSIC friend const _M&
     __get_mask(const const_where_expression& __x)
@@ -3149,20 +3248,22 @@ template <typename _Tp>
     const_where_expression(const const_where_expression&) = delete;
     const_where_expression& operator=(const const_where_expression&) = delete;
 
-    _GLIBCXX_SIMD_INTRINSIC const_where_expression(const bool __kk, const _Tp& dd)
-      : _M_k(__kk), _M_value(const_cast<_Tp&>(dd)) {}
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    const_where_expression(const bool __kk, const _Tp& dd)
+    : _M_k(__kk), _M_value(const_cast<_Tp&>(dd)) {}
 
-    _GLIBCXX_SIMD_INTRINSIC _V operator-() const&&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR _V
+    operator-() const&&
     { return _M_k ? -_M_value : _M_value; }
 
     template <typename _Up, typename _Flags>
-      [[nodiscard]] _GLIBCXX_SIMD_INTRINSIC _V
-      copy_from(const _LoadStorePtr<_Up, value_type>* __mem, _Flags) const&&
+      [[nodiscard]] _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR _V
+      copy_from(const _LoadStorePtr<_Up, value_type>* __mem, _IsSimdFlagType<_Flags>) const&&
       { return _M_k ? static_cast<_V>(__mem[0]) : _M_value; }
 
     template <typename _Up, typename _Flags>
-      _GLIBCXX_SIMD_INTRINSIC void
-      copy_to(_LoadStorePtr<_Up, value_type>* __mem, _Flags) const&&
+      _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+      copy_to(_LoadStorePtr<_Up, value_type>* __mem, _IsSimdFlagType<_Flags>) const&&
       {
 	if (_M_k)
 	  __mem[0] = _M_value;
@@ -3187,18 +3288,21 @@ template <typename _M, typename _Tp>
       is_same<typename _M::abi_type, typename _Tp::abi_type>::value, "");
     static_assert(_M::size() == _Tp::size(), "");
 
-    _GLIBCXX_SIMD_INTRINSIC friend _Tp& __get_lvalue(where_expression& __x)
+    _GLIBCXX_SIMD_INTRINSIC friend constexpr _Tp&
+    __get_lvalue(where_expression& __x)
     { return __x._M_value; }
 
   public:
     where_expression(const where_expression&) = delete;
     where_expression& operator=(const where_expression&) = delete;
 
-    _GLIBCXX_SIMD_INTRINSIC where_expression(const _M& __kk, _Tp& dd)
-      : const_where_expression<_M, _Tp>(__kk, dd) {}
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR
+    where_expression(const _M& __kk, _Tp& dd)
+    : const_where_expression<_M, _Tp>(__kk, dd) {}
 
     template <typename _Up>
-      _GLIBCXX_SIMD_INTRINSIC void operator=(_Up&& __x) &&
+      _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+      operator=(_Up&& __x) &&
       {
 	_Impl::_S_masked_assign(__data(_M_k), __data(_M_value),
 				__to_value_type_or_member_type<_Tp>(
@@ -3207,14 +3311,15 @@ template <typename _M, typename _Tp>
 
 #define _GLIBCXX_SIMD_OP_(__op, __name)                                        \
   template <typename _Up>                                                      \
-    _GLIBCXX_SIMD_INTRINSIC void operator __op##=(_Up&& __x)&&                 \
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void                       \
+    operator __op##=(_Up&& __x)&&                                              \
     {                                                                          \
       _Impl::template _S_masked_cassign(                                       \
 	__data(_M_k), __data(_M_value),                                        \
 	__to_value_type_or_member_type<_Tp>(static_cast<_Up&&>(__x)),          \
-	[](auto __impl, auto __lhs, auto __rhs) constexpr {                    \
-	return __impl.__name(__lhs, __rhs);                                    \
-	});                                                                    \
+	[](auto __impl, auto __lhs, auto __rhs)                                \
+	  constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA                         \
+	{ return __impl.__name(__lhs, __rhs); });                              \
     }                                                                          \
   static_assert(true)
     _GLIBCXX_SIMD_OP_(+, _S_plus);
@@ -3229,48 +3334,48 @@ template <typename _M, typename _Tp>
     _GLIBCXX_SIMD_OP_(>>, _S_shift_right);
 #undef _GLIBCXX_SIMD_OP_
 
-    _GLIBCXX_SIMD_INTRINSIC void operator++() &&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+    operator++() &&
     {
       __data(_M_value)
-	= _Impl::template _S_masked_unary<__increment>(__data(_M_k),
-						       __data(_M_value));
+	= _Impl::template _S_masked_unary<__increment>(__data(_M_k), __data(_M_value));
     }
 
-    _GLIBCXX_SIMD_INTRINSIC void operator++(int) &&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+    operator++(int) &&
     {
       __data(_M_value)
-	= _Impl::template _S_masked_unary<__increment>(__data(_M_k),
-						       __data(_M_value));
+	= _Impl::template _S_masked_unary<__increment>(__data(_M_k), __data(_M_value));
     }
 
-    _GLIBCXX_SIMD_INTRINSIC void operator--() &&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+    operator--() &&
     {
       __data(_M_value)
-	= _Impl::template _S_masked_unary<__decrement>(__data(_M_k),
-						       __data(_M_value));
+	= _Impl::template _S_masked_unary<__decrement>(__data(_M_k), __data(_M_value));
     }
 
-    _GLIBCXX_SIMD_INTRINSIC void operator--(int) &&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+    operator--(int) &&
     {
       __data(_M_value)
-	= _Impl::template _S_masked_unary<__decrement>(__data(_M_k),
-						       __data(_M_value));
+	= _Impl::template _S_masked_unary<__decrement>(__data(_M_k), __data(_M_value));
     }
 
     // intentionally hides const_where_expression::copy_from
     template <typename _Up, typename _Flags>
-      _GLIBCXX_SIMD_INTRINSIC void
-      copy_from(const _LoadStorePtr<_Up, value_type>* __mem, _Flags) &&
+      _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+      copy_from(const _LoadStorePtr<_Up, value_type>* __mem, _IsSimdFlagType<_Flags>) &&
       {
-	__data(_M_value)
-	  = _Impl::_S_masked_load(__data(_M_value), __data(_M_k),
-				  _Flags::template _S_apply<_Tp>(__mem));
+	__data(_M_value) = _Impl::_S_masked_load(__data(_M_value), __data(_M_k),
+						 _Flags::template _S_apply<_Tp>(__mem));
       }
   };
 
 // where_expression<bool, T> {{{2
 template <typename _Tp>
-  class where_expression<bool, _Tp> : public const_where_expression<bool, _Tp>
+  class where_expression<bool, _Tp>
+  : public const_where_expression<bool, _Tp>
   {
     using _M = bool;
     using typename const_where_expression<_M, _Tp>::value_type;
@@ -3281,12 +3386,14 @@ template <typename _Tp>
     where_expression(const where_expression&) = delete;
     where_expression& operator=(const where_expression&) = delete;
 
-    _GLIBCXX_SIMD_INTRINSIC where_expression(const _M& __kk, _Tp& dd)
-      : const_where_expression<_M, _Tp>(__kk, dd) {}
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR
+    where_expression(const _M& __kk, _Tp& dd)
+    : const_where_expression<_M, _Tp>(__kk, dd) {}
 
 #define _GLIBCXX_SIMD_OP_(__op)                                                \
     template <typename _Up>                                                    \
-      _GLIBCXX_SIMD_INTRINSIC void operator __op(_Up&& __x)&&                  \
+      _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void                     \
+      operator __op(_Up&& __x)&&                                               \
       { if (_M_k) _M_value __op static_cast<_Up&&>(__x); }
 
     _GLIBCXX_SIMD_OP_(=)
@@ -3302,67 +3409,71 @@ template <typename _Tp>
     _GLIBCXX_SIMD_OP_(>>=)
   #undef _GLIBCXX_SIMD_OP_
 
-    _GLIBCXX_SIMD_INTRINSIC void operator++() &&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+    operator++() &&
     { if (_M_k) ++_M_value; }
 
-    _GLIBCXX_SIMD_INTRINSIC void operator++(int) &&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+    operator++(int) &&
     { if (_M_k) ++_M_value; }
 
-    _GLIBCXX_SIMD_INTRINSIC void operator--() &&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+    operator--() &&
     { if (_M_k) --_M_value; }
 
-    _GLIBCXX_SIMD_INTRINSIC void operator--(int) &&
+    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+    operator--(int) &&
     { if (_M_k) --_M_value; }
 
     // intentionally hides const_where_expression::copy_from
     template <typename _Up, typename _Flags>
-      _GLIBCXX_SIMD_INTRINSIC void
-      copy_from(const _LoadStorePtr<_Up, value_type>* __mem, _Flags) &&
+      _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR void
+      copy_from(const _LoadStorePtr<_Up, value_type>* __mem, _IsSimdFlagType<_Flags>) &&
       { if (_M_k) _M_value = __mem[0]; }
   };
 
 // where {{{1
 template <typename _Tp, typename _Ap>
-  _GLIBCXX_SIMD_INTRINSIC where_expression<simd_mask<_Tp, _Ap>, simd<_Tp, _Ap>>
+  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR
+  where_expression<simd_mask<_Tp, _Ap>, simd<_Tp, _Ap>>
   where(const typename simd<_Tp, _Ap>::mask_type& __k, simd<_Tp, _Ap>& __value)
   { return {__k, __value}; }
 
 template <typename _Tp, typename _Ap>
-  _GLIBCXX_SIMD_INTRINSIC
-    const_where_expression<simd_mask<_Tp, _Ap>, simd<_Tp, _Ap>>
-    where(const typename simd<_Tp, _Ap>::mask_type& __k,
-	  const simd<_Tp, _Ap>& __value)
+  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR
+  const_where_expression<simd_mask<_Tp, _Ap>, simd<_Tp, _Ap>>
+  where(const typename simd<_Tp, _Ap>::mask_type& __k, const simd<_Tp, _Ap>& __value)
   { return {__k, __value}; }
 
 template <typename _Tp, typename _Ap>
-  _GLIBCXX_SIMD_INTRINSIC
-    where_expression<simd_mask<_Tp, _Ap>, simd_mask<_Tp, _Ap>>
-    where(const remove_const_t<simd_mask<_Tp, _Ap>>& __k,
-	  simd_mask<_Tp, _Ap>& __value)
+  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR
+  where_expression<simd_mask<_Tp, _Ap>, simd_mask<_Tp, _Ap>>
+  where(const remove_const_t<simd_mask<_Tp, _Ap>>& __k, simd_mask<_Tp, _Ap>& __value)
   { return {__k, __value}; }
 
 template <typename _Tp, typename _Ap>
-  _GLIBCXX_SIMD_INTRINSIC
-    const_where_expression<simd_mask<_Tp, _Ap>, simd_mask<_Tp, _Ap>>
-    where(const remove_const_t<simd_mask<_Tp, _Ap>>& __k,
-	  const simd_mask<_Tp, _Ap>& __value)
+  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR
+  const_where_expression<simd_mask<_Tp, _Ap>, simd_mask<_Tp, _Ap>>
+  where(const remove_const_t<simd_mask<_Tp, _Ap>>& __k, const simd_mask<_Tp, _Ap>& __value)
   { return {__k, __value}; }
 
 template <typename _Tp>
-  _GLIBCXX_SIMD_INTRINSIC where_expression<bool, _Tp>
+  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR where_expression<bool, _Tp>
   where(_ExactBool __k, _Tp& __value)
   { return {__k, __value}; }
 
 template <typename _Tp>
-  _GLIBCXX_SIMD_INTRINSIC const_where_expression<bool, _Tp>
+  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR const_where_expression<bool, _Tp>
   where(_ExactBool __k, const _Tp& __value)
   { return {__k, __value}; }
 
-  template <typename _Tp, typename _Ap>
-    void where(bool __k, simd<_Tp, _Ap>& __value) = delete;
+template <typename _Tp, typename _Ap>
+  _GLIBCXX_SIMD_CONSTEXPR void
+  where(bool __k, simd<_Tp, _Ap>& __value) = delete;
 
-  template <typename _Tp, typename _Ap>
-    void where(bool __k, const simd<_Tp, _Ap>& __value) = delete;
+template <typename _Tp, typename _Ap>
+  _GLIBCXX_SIMD_CONSTEXPR void
+  where(bool __k, const simd<_Tp, _Ap>& __value) = delete;
 
 // proposed mask iterations {{{1
 namespace __proposed {
@@ -3379,10 +3490,12 @@ template <size_t _Np>
       size_t __mask;
       size_t __bit;
 
-      _GLIBCXX_SIMD_INTRINSIC void __next_bit()
+      _GLIBCXX_SIMD_INTRINSIC void
+      __next_bit()
       { __bit = __builtin_ctzl(__mask); }
 
-      _GLIBCXX_SIMD_INTRINSIC void __reset_lsb()
+      _GLIBCXX_SIMD_INTRINSIC void
+      __reset_lsb()
       {
 	// 01100100 - 1 = 01100011
 	__mask &= (__mask - 1);
@@ -3394,20 +3507,24 @@ template <size_t _Np>
       iterator(const iterator&) = default;
       iterator(iterator&&) = default;
 
-      _GLIBCXX_SIMD_ALWAYS_INLINE size_t operator->() const
+      _GLIBCXX_SIMD_ALWAYS_INLINE size_t
+      operator->() const
       { return __bit; }
 
-      _GLIBCXX_SIMD_ALWAYS_INLINE size_t operator*() const
+      _GLIBCXX_SIMD_ALWAYS_INLINE size_t
+      operator*() const
       { return __bit; }
 
-      _GLIBCXX_SIMD_ALWAYS_INLINE iterator& operator++()
+      _GLIBCXX_SIMD_ALWAYS_INLINE iterator&
+      operator++()
       {
 	__reset_lsb();
 	__next_bit();
 	return *this;
       }
 
-      _GLIBCXX_SIMD_ALWAYS_INLINE iterator operator++(int)
+      _GLIBCXX_SIMD_ALWAYS_INLINE iterator
+      operator++(int)
       {
 	iterator __tmp = *this;
 	__reset_lsb();
@@ -3415,17 +3532,21 @@ template <size_t _Np>
 	return __tmp;
       }
 
-      _GLIBCXX_SIMD_ALWAYS_INLINE bool operator==(const iterator& __rhs) const
+      _GLIBCXX_SIMD_ALWAYS_INLINE bool
+      operator==(const iterator& __rhs) const
       { return __mask == __rhs.__mask; }
 
-      _GLIBCXX_SIMD_ALWAYS_INLINE bool operator!=(const iterator& __rhs) const
+      _GLIBCXX_SIMD_ALWAYS_INLINE bool
+      operator!=(const iterator& __rhs) const
       { return __mask != __rhs.__mask; }
     };
 
-    iterator begin() const
+    iterator
+    begin() const
     { return __bits.to_ullong(); }
 
-    iterator end() const
+    iterator
+    end() const
     { return 0; }
   };
 
@@ -3440,15 +3561,13 @@ template <typename _Tp, typename _Ap>
 // reductions [simd.reductions] {{{1
 template <typename _Tp, typename _Abi, typename _BinaryOperation = plus<>>
   _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR _Tp
-  reduce(const simd<_Tp, _Abi>& __v,
-	 _BinaryOperation __binary_op = _BinaryOperation())
+  reduce(const simd<_Tp, _Abi>& __v, _BinaryOperation __binary_op = _BinaryOperation())
   { return _Abi::_SimdImpl::_S_reduce(__v, __binary_op); }
 
 template <typename _M, typename _V, typename _BinaryOperation = plus<>>
   _GLIBCXX_SIMD_INTRINSIC typename _V::value_type
   reduce(const const_where_expression<_M, _V>& __x,
-	 typename _V::value_type __identity_element,
-	 _BinaryOperation __binary_op)
+	 typename _V::value_type __identity_element, _BinaryOperation __binary_op)
   {
     if (__builtin_expect(none_of(__get_mask(__x)), false))
       return __identity_element;
@@ -3487,16 +3606,12 @@ template <typename _M, typename _V>
 template <typename _Tp, typename _Abi>
   _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR _Tp
   hmin(const simd<_Tp, _Abi>& __v) noexcept
-  {
-    return _Abi::_SimdImpl::_S_reduce(__v, __detail::_Minimum());
-  }
+  { return _Abi::_SimdImpl::_S_reduce(__v, __detail::_Minimum()); }
 
 template <typename _Tp, typename _Abi>
   _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR _Tp
   hmax(const simd<_Tp, _Abi>& __v) noexcept
-  {
-    return _Abi::_SimdImpl::_S_reduce(__v, __detail::_Maximum());
-  }
+  { return _Abi::_SimdImpl::_S_reduce(__v, __detail::_Maximum()); }
 
 template <typename _M, typename _V>
   _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR
@@ -3564,8 +3679,7 @@ template <typename _Tp, typename _Ap>
 
 template <typename _Tp, typename _Ap>
   _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR simd<_Tp, _Ap>
-  clamp(const simd<_Tp, _Ap>& __v, const simd<_Tp, _Ap>& __lo,
-	const simd<_Tp, _Ap>& __hi)
+  clamp(const simd<_Tp, _Ap>& __v, const simd<_Tp, _Ap>& __lo, const simd<_Tp, _Ap>& __hi)
   {
     using _Impl = typename _Ap::_SimdImpl;
     return {__private_init,
@@ -3582,13 +3696,12 @@ template <size_t... _Sizes, typename _Tp, typename _Ap,
 
 // __extract_part {{{
 template <int _Index, int _Total, int _Combine = 1, typename _Tp, size_t _Np>
-  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_CONST
+  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_CONST constexpr
   _SimdWrapper<_Tp, _Np / _Total * _Combine>
   __extract_part(const _SimdWrapper<_Tp, _Np> __x);
 
-template <int Index, int Parts, int _Combine = 1, typename _Tp, typename _A0,
-	  typename... _As>
-  _GLIBCXX_SIMD_INTRINSIC auto
+template <int _Index, int _Parts, int _Combine = 1, typename _Tp, typename _A0, typename... _As>
+  _GLIBCXX_SIMD_INTRINSIC constexpr auto
   __extract_part(const _SimdTuple<_Tp, _A0, _As...>& __x);
 
 // }}}
@@ -3597,7 +3710,8 @@ template <size_t _V0, size_t... _Values>
   struct _SizeList
   {
     template <size_t _I>
-      static constexpr size_t _S_at(_SizeConstant<_I> = {})
+      static constexpr size_t
+      _S_at(_SizeConstant<_I> = {})
       {
 	if constexpr (_I == 0)
 	  return _V0;
@@ -3606,7 +3720,8 @@ template <size_t _V0, size_t... _Values>
       }
 
     template <size_t _I>
-      static constexpr auto _S_before(_SizeConstant<_I> = {})
+      static constexpr auto
+      _S_before(_SizeConstant<_I> = {})
       {
 	if constexpr (_I == 0)
 	  return _SizeConstant<0>();
@@ -3616,7 +3731,8 @@ template <size_t _V0, size_t... _Values>
       }
 
     template <size_t _Np>
-      static constexpr auto _S_pop_front(_SizeConstant<_Np> = {})
+      static constexpr auto
+      _S_pop_front(_SizeConstant<_Np> = {})
       {
 	if constexpr (_Np == 0)
 	  return _SizeList();
@@ -3699,24 +3815,23 @@ template <size_t... _Sizes, typename _Tp, typename... _As>
 
 // split<simd>(simd) {{{
 template <typename _V, typename _Ap,
-	  size_t Parts = simd_size_v<typename _V::value_type, _Ap> / _V::size()>
-  enable_if_t<simd_size_v<typename _V::value_type, _Ap> == Parts * _V::size()
-	      && is_simd_v<_V>, array<_V, Parts>>
+	  size_t _Parts = simd_size_v<typename _V::value_type, _Ap> / _V::size()>
+  enable_if_t<simd_size_v<typename _V::value_type, _Ap> == _Parts * _V::size()
+		&& is_simd_v<_V>, array<_V, _Parts>>
   split(const simd<typename _V::value_type, _Ap>& __x)
   {
     using _Tp = typename _V::value_type;
-    if constexpr (Parts == 1)
+    if constexpr (_Parts == 1)
       {
 	return {simd_cast<_V>(__x)};
       }
     else if (__x._M_is_constprop())
       {
-	return __generate_from_n_evaluations<Parts, array<_V, Parts>>([&](
-	  auto __i) constexpr {
-	  return _V([&](auto __j) constexpr {
-	    return __x[__i * _V::size() + __j];
-	  });
-	});
+	return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>(
+		 [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return _V([&](auto __j) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+			     { return __x[__i * _V::size() + __j]; });
+		 });
       }
     else if constexpr (
       __is_fixed_size_abi_v<_Ap>
@@ -3729,49 +3844,47 @@ template <typename _V, typename _Ap,
 #ifdef _GLIBCXX_SIMD_USE_ALIASING_LOADS
       const __may_alias<_Tp>* const __element_ptr
 	= reinterpret_cast<const __may_alias<_Tp>*>(&__data(__x));
-      return __generate_from_n_evaluations<Parts, array<_V, Parts>>([&](
-	auto __i) constexpr {
-	return _V(__element_ptr + __i * _V::size(), vector_aligned);
-      });
+      return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>(
+	       [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+	       { return _V(__element_ptr + __i * _V::size(), vector_aligned); });
 #else
       const auto& __xx = __data(__x);
-      return __generate_from_n_evaluations<Parts, array<_V, Parts>>([&](
-	auto __i) constexpr {
-	[[maybe_unused]] constexpr size_t __offset
-	  = decltype(__i)::value * _V::size();
-	return _V([&](auto __j) constexpr {
-	  constexpr _SizeConstant<__j + __offset> __k;
-	  return __xx[__k];
-	});
-      });
+      return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>(
+	       [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		 [[maybe_unused]] constexpr size_t __offset
+		   = decltype(__i)::value * _V::size();
+		 return _V([&](auto __j) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			  constexpr _SizeConstant<__j + __offset> __k;
+			  return __xx[__k];
+			});
+	       });
 #endif
     }
   else if constexpr (is_same_v<typename _V::abi_type, simd_abi::scalar>)
     {
       // normally memcpy should work here as well
-      return __generate_from_n_evaluations<Parts, array<_V, Parts>>([&](
-	auto __i) constexpr { return __x[__i]; });
+      return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>(
+	       [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { return __x[__i]; });
     }
   else
     {
-      return __generate_from_n_evaluations<Parts, array<_V, Parts>>([&](
-	auto __i) constexpr {
-	if constexpr (__is_fixed_size_abi_v<typename _V::abi_type>)
-	  return _V([&](auto __j) constexpr {
-	    return __x[__i * _V::size() + __j];
-	  });
-	else
-	  return _V(__private_init,
-		    __extract_part<decltype(__i)::value, Parts>(__data(__x)));
-      });
+      return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>(
+	       [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		 if constexpr (__is_fixed_size_abi_v<typename _V::abi_type>)
+		   return _V([&](auto __j) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			    return __x[__i * _V::size() + __j];
+			  });
+		 else
+		   return _V(__private_init,
+			     __extract_part<decltype(__i)::value, _Parts>(__data(__x)));
+	       });
     }
   }
 
 // }}}
 // split<simd_mask>(simd_mask) {{{
 template <typename _V, typename _Ap,
-	  size_t _Parts
-	  = simd_size_v<typename _V::simd_type::value_type, _Ap> / _V::size()>
+	  size_t _Parts = simd_size_v<typename _V::simd_type::value_type, _Ap> / _V::size()>
   enable_if_t<is_simd_mask_v<_V> && simd_size_v<typename
     _V::simd_type::value_type, _Ap> == _Parts * _V::size(), array<_V, _Parts>>
   split(const simd_mask<typename _V::simd_type::value_type, _Ap>& __x)
@@ -3787,22 +3900,22 @@ template <typename _V, typename _Ap,
     else if constexpr (_V::size() <= __CHAR_BIT__ * sizeof(_ULLong))
       {
 	const bitset __bits = __x.__to_bitset();
-	return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>([&](
-	  auto __i) constexpr {
-	  constexpr size_t __offset = __i * _V::size();
-	  return _V(__bitset_init, (__bits >> __offset).to_ullong());
-	});
+	return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>(
+		 [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   constexpr size_t __offset = __i * _V::size();
+		   return _V(__bitset_init, (__bits >> __offset).to_ullong());
+		 });
       }
     else
       {
-	return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>([&](
-	  auto __i) constexpr {
-	  constexpr size_t __offset = __i * _V::size();
-	  return _V(
-	    __private_init, [&](auto __j) constexpr {
-	      return __x[__j + __offset];
-	    });
-	});
+	return __generate_from_n_evaluations<_Parts, array<_V, _Parts>>(
+		 [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   constexpr size_t __offset = __i * _V::size();
+		   return _V(__private_init,
+			     [&](auto __j) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			       return __x[__j + __offset];
+			     });
+		 });
       }
   }
 
@@ -3820,12 +3933,14 @@ template <size_t... _Sizes, typename _Tp, typename _Ap, typename>
     using _V = __deduced_simd<_Tp, _N0>;
 
     if (__x._M_is_constprop())
-      return __generate_from_n_evaluations<sizeof...(_Sizes), _Tuple>([&](
-	auto __i) constexpr {
-	using _Vi = __deduced_simd<_Tp, _SL::_S_at(__i)>;
-	constexpr size_t __offset = _SL::_S_before(__i);
-	return _Vi([&](auto __j) constexpr { return __x[__offset + __j]; });
-      });
+      return __generate_from_n_evaluations<sizeof...(_Sizes), _Tuple>(
+	       [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		 using _Vi = __deduced_simd<_Tp, _SL::_S_at(__i)>;
+		 constexpr size_t __offset = _SL::_S_before(__i);
+		 return _Vi([&](auto __j) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			  return __x[__offset + __j];
+			});
+	       });
     else if constexpr (_Np == _N0)
       {
 	static_assert(sizeof...(_Sizes) == 1);
@@ -3892,28 +4007,28 @@ template <size_t... _Sizes, typename _Tp, typename _Ap, typename>
 #ifdef _GLIBCXX_SIMD_USE_ALIASING_LOADS
     const __may_alias<_Tp>* const __element_ptr
       = reinterpret_cast<const __may_alias<_Tp>*>(&__x);
-    return __generate_from_n_evaluations<sizeof...(_Sizes), _Tuple>([&](
-      auto __i) constexpr {
-      using _Vi = __deduced_simd<_Tp, _SL::_S_at(__i)>;
-      constexpr size_t __offset = _SL::_S_before(__i);
-      constexpr size_t __base_align = alignof(simd<_Tp, _Ap>);
-      constexpr size_t __a
-	= __base_align - ((__offset * sizeof(_Tp)) % __base_align);
-      constexpr size_t __b = ((__a - 1) & __a) ^ __a;
-      constexpr size_t __alignment = __b == 0 ? __a : __b;
-      return _Vi(__element_ptr + __offset, overaligned<__alignment>);
-    });
+    return __generate_from_n_evaluations<sizeof...(_Sizes), _Tuple>(
+	     [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	       using _Vi = __deduced_simd<_Tp, _SL::_S_at(__i)>;
+	       constexpr size_t __offset = _SL::_S_before(__i);
+	       constexpr size_t __base_align = alignof(simd<_Tp, _Ap>);
+	       constexpr size_t __a
+		 = __base_align - ((__offset * sizeof(_Tp)) % __base_align);
+	       constexpr size_t __b = ((__a - 1) & __a) ^ __a;
+	       constexpr size_t __alignment = __b == 0 ? __a : __b;
+	       return _Vi(__element_ptr + __offset, overaligned<__alignment>);
+	     });
 #else
-    return __generate_from_n_evaluations<sizeof...(_Sizes), _Tuple>([&](
-      auto __i) constexpr {
-      using _Vi = __deduced_simd<_Tp, _SL::_S_at(__i)>;
-      const auto& __xx = __data(__x);
-      using _Offset = decltype(_SL::_S_before(__i));
-      return _Vi([&](auto __j) constexpr {
-	constexpr _SizeConstant<_Offset::value + __j> __k;
-	return __xx[__k];
-      });
-    });
+    return __generate_from_n_evaluations<sizeof...(_Sizes), _Tuple>(
+	     [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	       using _Vi = __deduced_simd<_Tp, _SL::_S_at(__i)>;
+	       const auto& __xx = __data(__x);
+	       using _Offset = decltype(_SL::_S_before(__i));
+	       return _Vi([&](auto __j) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			constexpr _SizeConstant<_Offset::value + __j> __k;
+			return __xx[__k];
+		      });
+	     });
 #endif
   }
 
@@ -3934,8 +4049,7 @@ template <size_t _I, typename _Tp, typename _Ap, typename... _As>
 // __store_pack_of_simd {{{
 template <typename _Tp, typename _A0, typename... _As>
   _GLIBCXX_SIMD_INTRINSIC void
-  __store_pack_of_simd(char* __mem, const simd<_Tp, _A0>& __x0,
-		       const simd<_Tp, _As>&... __xs)
+  __store_pack_of_simd(char* __mem, const simd<_Tp, _A0>& __x0, const simd<_Tp, _As>&... __xs)
   {
     constexpr size_t __n_bytes = sizeof(_Tp) * simd_size_v<_Tp, _A0>;
     __builtin_memcpy(__mem, &__data(__x0), __n_bytes);
@@ -3955,8 +4069,9 @@ template <typename _Tp, typename... _As>
       return simd_cast<_Rp>(__xs...);
     else if ((... && __xs._M_is_constprop()))
       return simd<_Tp,
-		  simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _As> + ...)>>([&](
-	auto __i) constexpr { return __subscript_in_pack<__i>(__xs...); });
+		  simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _As> + ...)>>(
+	       [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+	       { return __subscript_in_pack<__i>(__xs...); });
     else
       {
 	_Rp __r{};
@@ -3972,9 +4087,10 @@ template <typename _Tp, typename _Abi, size_t _Np>
   _GLIBCXX_SIMD_CONSTEXPR __deduced_simd<_Tp, simd_size_v<_Tp, _Abi> * _Np>
   concat(const array<simd<_Tp, _Abi>, _Np>& __x)
   {
-    return __call_with_subscripts<_Np>(__x, [](const auto&... __xs) {
-      return concat(__xs...);
-    });
+    return __call_with_subscripts<_Np>(
+	     __x, [](const auto&... __xs) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	       return concat(__xs...);
+	     });
   }
 
 // }}}
@@ -3989,7 +4105,8 @@ template <typename _Up, typename _Accessor = _Up,
     int _M_index;
     _Up& _M_obj;
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr _ValueType _M_read() const noexcept
+    _GLIBCXX_SIMD_INTRINSIC constexpr _ValueType
+    _M_read() const noexcept
     {
       if constexpr (is_arithmetic_v<_Up>)
 	return _M_obj;
@@ -3998,7 +4115,8 @@ template <typename _Up, typename _Accessor = _Up,
     }
 
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC constexpr void _M_write(_Tp&& __x) const
+      _GLIBCXX_SIMD_INTRINSIC constexpr void
+      _M_write(_Tp&& __x) const
       { _Accessor::_S_set(_M_obj, _M_index, static_cast<_Tp&&>(__x)); }
 
   public:
@@ -4008,32 +4126,32 @@ template <typename _Up, typename _Accessor = _Up,
 
     using value_type = _ValueType;
 
-    _GLIBCXX_SIMD_INTRINSIC _SmartReference(const _SmartReference&) = delete;
+    _GLIBCXX_SIMD_INTRINSIC
+    _SmartReference(const _SmartReference&) = delete;
 
-    _GLIBCXX_SIMD_INTRINSIC constexpr operator value_type() const noexcept
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    operator value_type() const noexcept
     { return _M_read(); }
 
-    template <typename _Tp,
-	      typename
-	      = _ValuePreservingOrInt<__remove_cvref_t<_Tp>, value_type>>
-      _GLIBCXX_SIMD_INTRINSIC constexpr _SmartReference operator=(_Tp&& __x) &&
+    template <typename _Tp, typename = _ValuePreservingOrInt<__remove_cvref_t<_Tp>, value_type>>
+      _GLIBCXX_SIMD_INTRINSIC constexpr _SmartReference
+      operator=(_Tp&& __x) &&
       {
 	_M_write(static_cast<_Tp&&>(__x));
 	return {_M_obj, _M_index};
       }
 
-#define _GLIBCXX_SIMD_OP_(__op)                                                \
-    template <typename _Tp,                                                    \
-	      typename _TT                                                     \
-	      = decltype(declval<value_type>() __op declval<_Tp>()),           \
-	      typename = _ValuePreservingOrInt<__remove_cvref_t<_Tp>, _TT>,    \
-	      typename = _ValuePreservingOrInt<_TT, value_type>>               \
-      _GLIBCXX_SIMD_INTRINSIC constexpr _SmartReference                        \
-      operator __op##=(_Tp&& __x) &&                                           \
-      {                                                                        \
-	const value_type& __lhs = _M_read();                                   \
-	_M_write(__lhs __op __x);                                              \
-	return {_M_obj, _M_index};                                             \
+#define _GLIBCXX_SIMD_OP_(__op)                                                   \
+    template <typename _Tp,                                                       \
+	      typename _TT = decltype(declval<value_type>() __op declval<_Tp>()), \
+	      typename = _ValuePreservingOrInt<__remove_cvref_t<_Tp>, _TT>,       \
+	      typename = _ValuePreservingOrInt<_TT, value_type>>                  \
+      _GLIBCXX_SIMD_INTRINSIC constexpr _SmartReference                           \
+      operator __op##=(_Tp&& __x) &&                                              \
+      {                                                                           \
+	const value_type& __lhs = _M_read();                                      \
+	_M_write(__lhs __op __x);                                                 \
+	return {_M_obj, _M_index};                                                \
       }
     _GLIBCXX_SIMD_ALL_ARITHMETICS(_GLIBCXX_SIMD_OP_);
     _GLIBCXX_SIMD_ALL_SHIFTS(_GLIBCXX_SIMD_OP_);
@@ -4041,9 +4159,9 @@ template <typename _Up, typename _Accessor = _Up,
 #undef _GLIBCXX_SIMD_OP_
 
     template <typename _Tp = void,
-	      typename
-	      = decltype(++declval<conditional_t<true, value_type, _Tp>&>())>
-      _GLIBCXX_SIMD_INTRINSIC constexpr _SmartReference operator++() &&
+	      typename = decltype(++declval<conditional_t<true, value_type, _Tp>&>())>
+      _GLIBCXX_SIMD_INTRINSIC constexpr _SmartReference
+      operator++() &&
       {
 	value_type __x = _M_read();
 	_M_write(++__x);
@@ -4051,9 +4169,9 @@ template <typename _Up, typename _Accessor = _Up,
       }
 
     template <typename _Tp = void,
-	      typename
-	      = decltype(declval<conditional_t<true, value_type, _Tp>&>()++)>
-      _GLIBCXX_SIMD_INTRINSIC constexpr value_type operator++(int) &&
+	      typename = decltype(declval<conditional_t<true, value_type, _Tp>&>()++)>
+      _GLIBCXX_SIMD_INTRINSIC constexpr value_type
+      operator++(int) &&
       {
 	const value_type __r = _M_read();
 	value_type __x = __r;
@@ -4062,9 +4180,9 @@ template <typename _Up, typename _Accessor = _Up,
       }
 
     template <typename _Tp = void,
-	      typename
-	      = decltype(--declval<conditional_t<true, value_type, _Tp>&>())>
-      _GLIBCXX_SIMD_INTRINSIC constexpr _SmartReference operator--() &&
+	      typename = decltype(--declval<conditional_t<true, value_type, _Tp>&>())>
+      _GLIBCXX_SIMD_INTRINSIC constexpr _SmartReference
+      operator--() &&
       {
 	value_type __x = _M_read();
 	_M_write(--__x);
@@ -4072,9 +4190,9 @@ template <typename _Up, typename _Accessor = _Up,
       }
 
     template <typename _Tp = void,
-	      typename
-	      = decltype(declval<conditional_t<true, value_type, _Tp>&>()--)>
-      _GLIBCXX_SIMD_INTRINSIC constexpr value_type operator--(int) &&
+	      typename = decltype(declval<conditional_t<true, value_type, _Tp>&>()--)>
+      _GLIBCXX_SIMD_INTRINSIC constexpr value_type
+      operator--(int) &&
       {
 	const value_type __r = _M_read();
 	value_type __x = __r;
@@ -4150,7 +4268,8 @@ template <int _Bytes>
 template <template <int> class _Abi, int _Bytes, typename _Tp>
   struct __find_next_valid_abi
   {
-    static constexpr auto _S_choose()
+    static constexpr auto
+    _S_choose()
     {
       constexpr int _NextBytes = std::__bit_ceil(_Bytes) / 2;
       using _NextAbi = _Abi<_NextBytes>;
@@ -4194,7 +4313,8 @@ template <template <int> class _A0, template <int> class... _Rest>
 	typename _AbiList<_Rest...>::template _FirstValidAbi<_Tp, _Np>>;
 
     template <typename _Tp, int _Np>
-      static constexpr auto _S_determine_best_abi()
+      static constexpr auto
+      _S_determine_best_abi()
       {
 	static_assert(_Np >= 1);
 	constexpr int _Bytes = sizeof(_Tp) * _Np;
@@ -4307,7 +4427,7 @@ template <typename _Tp, typename _Abi>
 
     // }}}
     // access to internal representation (optional feature) {{{
-    _GLIBCXX_SIMD_ALWAYS_INLINE explicit
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR explicit
     simd_mask(typename _Traits::_MaskCastType __init)
     : _M_data{__init} {}
     // conversions to internal type is done in _MaskBase
@@ -4318,11 +4438,11 @@ template <typename _Tp, typename _Abi>
     // Conversion of simd_mask to and from bitset makes it much easier to
     // interface with other facilities. I suggest adding `static
     // simd_mask::from_bitset` and `simd_mask::to_bitset`.
-    _GLIBCXX_SIMD_ALWAYS_INLINE static simd_mask
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR static simd_mask
     __from_bitset(bitset<size()> bs)
     { return {__bitset_init, bs}; }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE bitset<size()>
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR bitset<size()>
     __to_bitset() const
     { return _Impl::_S_to_bits(_M_data)._M_to_bitset(); }
 
@@ -4347,7 +4467,7 @@ template <typename _Tp, typename _Abi>
     template <typename _Up, typename = enable_if_t<conjunction<
 			      is_same<abi_type, simd_abi::fixed_size<size()>>,
 			      is_same<_Up, _Up>>::value>>
-      _GLIBCXX_SIMD_ALWAYS_INLINE
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR
       simd_mask(const simd_mask<_Up, simd_abi::fixed_size<size()>>& __x)
       : _M_data(_Impl::_S_from_bitmask(__data(__x), _S_type_tag)) {}
   #endif
@@ -4355,41 +4475,36 @@ template <typename _Tp, typename _Abi>
     // }}}
     // load constructor {{{
     template <typename _Flags>
-      _GLIBCXX_SIMD_ALWAYS_INLINE
-      simd_mask(const value_type* __mem, _Flags)
-      : _M_data(_Impl::template _S_load<_Ip>(
-	_Flags::template _S_apply<simd_mask>(__mem))) {}
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR
+      simd_mask(const value_type* __mem, _IsSimdFlagType<_Flags>)
+      : _M_data(_Impl::template _S_load<_Ip>(_Flags::template _S_apply<simd_mask>(__mem))) {}
 
     template <typename _Flags>
-      _GLIBCXX_SIMD_ALWAYS_INLINE
-      simd_mask(const value_type* __mem, simd_mask __k, _Flags)
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR
+      simd_mask(const value_type* __mem, simd_mask __k, _IsSimdFlagType<_Flags>)
       : _M_data{}
       {
-	_M_data
-	  = _Impl::_S_masked_load(_M_data, __k._M_data,
-				  _Flags::template _S_apply<simd_mask>(__mem));
+	_M_data = _Impl::_S_masked_load(_M_data, __k._M_data,
+					_Flags::template _S_apply<simd_mask>(__mem));
       }
 
     // }}}
     // loads [simd_mask.load] {{{
     template <typename _Flags>
-      _GLIBCXX_SIMD_ALWAYS_INLINE void
-      copy_from(const value_type* __mem, _Flags)
-      {
-	_M_data = _Impl::template _S_load<_Ip>(
-	  _Flags::template _S_apply<simd_mask>(__mem));
-      }
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR void
+      copy_from(const value_type* __mem, _IsSimdFlagType<_Flags>)
+      { _M_data = _Impl::template _S_load<_Ip>(_Flags::template _S_apply<simd_mask>(__mem)); }
 
     // }}}
     // stores [simd_mask.store] {{{
     template <typename _Flags>
-      _GLIBCXX_SIMD_ALWAYS_INLINE void
-      copy_to(value_type* __mem, _Flags) const
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR void
+      copy_to(value_type* __mem, _IsSimdFlagType<_Flags>) const
       { _Impl::_S_store(_M_data, _Flags::template _S_apply<simd_mask>(__mem)); }
 
     // }}}
     // scalar access {{{
-    _GLIBCXX_SIMD_ALWAYS_INLINE reference
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR reference
     operator[](size_t __i)
     {
       if (__i >= size())
@@ -4397,7 +4512,7 @@ template <typename _Tp, typename _Abi>
       return {_M_data, int(__i)};
     }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE value_type
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR value_type
     operator[](size_t __i) const
     {
       if (__i >= size())
@@ -4410,7 +4525,7 @@ template <typename _Tp, typename _Abi>
 
     // }}}
     // negation {{{
-    _GLIBCXX_SIMD_ALWAYS_INLINE simd_mask
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR simd_mask
     operator!() const
     { return {__private_init, _Impl::_S_bit_not(_M_data)}; }
 
@@ -4419,9 +4534,8 @@ template <typename _Tp, typename _Abi>
   #ifdef _GLIBCXX_SIMD_ENABLE_IMPLICIT_MASK_CAST
     // simd_mask<int> && simd_mask<uint> needs disambiguation
     template <typename _Up, typename _A2,
-	      typename
-	      = enable_if_t<is_convertible_v<simd_mask<_Up, _A2>, simd_mask>>>
-      _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask
+	      typename = enable_if_t<is_convertible_v<simd_mask<_Up, _A2>, simd_mask>>>
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask
       operator&&(const simd_mask& __x, const simd_mask<_Up, _A2>& __y)
       {
 	return {__private_init,
@@ -4429,9 +4543,8 @@ template <typename _Tp, typename _Abi>
       }
 
     template <typename _Up, typename _A2,
-	      typename
-	      = enable_if_t<is_convertible_v<simd_mask<_Up, _A2>, simd_mask>>>
-      _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask
+	      typename = enable_if_t<is_convertible_v<simd_mask<_Up, _A2>, simd_mask>>>
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask
       operator||(const simd_mask& __x, const simd_mask<_Up, _A2>& __y)
       {
 	return {__private_init,
@@ -4439,45 +4552,41 @@ template <typename _Tp, typename _Abi>
       }
   #endif // _GLIBCXX_SIMD_ENABLE_IMPLICIT_MASK_CAST
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask
     operator&&(const simd_mask& __x, const simd_mask& __y)
-    {
-      return {__private_init, _Impl::_S_logical_and(__x._M_data, __y._M_data)};
-    }
+    { return {__private_init, _Impl::_S_logical_and(__x._M_data, __y._M_data)}; }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask
     operator||(const simd_mask& __x, const simd_mask& __y)
-    {
-      return {__private_init, _Impl::_S_logical_or(__x._M_data, __y._M_data)};
-    }
+    { return {__private_init, _Impl::_S_logical_or(__x._M_data, __y._M_data)}; }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask
     operator&(const simd_mask& __x, const simd_mask& __y)
     { return {__private_init, _Impl::_S_bit_and(__x._M_data, __y._M_data)}; }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask
     operator|(const simd_mask& __x, const simd_mask& __y)
     { return {__private_init, _Impl::_S_bit_or(__x._M_data, __y._M_data)}; }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask
     operator^(const simd_mask& __x, const simd_mask& __y)
     { return {__private_init, _Impl::_S_bit_xor(__x._M_data, __y._M_data)}; }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask&
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask&
     operator&=(simd_mask& __x, const simd_mask& __y)
     {
       __x._M_data = _Impl::_S_bit_and(__x._M_data, __y._M_data);
       return __x;
     }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask&
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask&
     operator|=(simd_mask& __x, const simd_mask& __y)
     {
       __x._M_data = _Impl::_S_bit_or(__x._M_data, __y._M_data);
       return __x;
     }
 
-    _GLIBCXX_SIMD_ALWAYS_INLINE friend simd_mask&
+    _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR friend simd_mask&
     operator^=(simd_mask& __x, const simd_mask& __y)
     {
       __x._M_data = _Impl::_S_bit_xor(__x._M_data, __y._M_data);
@@ -4507,16 +4616,16 @@ template <typename _Tp, typename _Abi>
       simd_mask(_PrivateInit, _Fp&& __gen)
       : _M_data()
       {
-	__execute_n_times<size()>([&](auto __i) constexpr {
+	__execute_n_times<size()>([&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  _Impl::_S_set(_M_data, __i, __gen(__i));
 	});
       }
 
     // }}}
     // bitset_init ctor {{{
-    _GLIBCXX_SIMD_INTRINSIC simd_mask(_BitsetInit, bitset<size()> __init)
-    : _M_data(
-	_Impl::_S_from_bitmask(_SanitizedBitMask<size()>(__init), _S_type_tag))
+    _GLIBCXX_SIMD_INTRINSIC constexpr
+    simd_mask(_BitsetInit, bitset<size()> __init)
+    : _M_data(_Impl::_S_from_bitmask(_SanitizedBitMask<size()>(__init), _S_type_tag))
     {}
 
     // }}}
@@ -4528,8 +4637,7 @@ template <typename _Tp, typename _Abi>
     struct _CvtProxy
     {
       template <typename _Up, typename _A2,
-		typename
-		= enable_if_t<simd_size_v<_Up, _A2> == simd_size_v<_Tp, _Abi>>>
+		typename = enable_if_t<simd_size_v<_Up, _A2> == simd_size_v<_Tp, _Abi>>>
 	operator simd_mask<_Up, _A2>() &&
 	{
 	  using namespace std::experimental::__proposed;
@@ -4692,7 +4800,9 @@ template <typename _Tp, typename _Abi>
     if (__builtin_is_constant_evaluated() || __k._M_is_constprop())
       {
 	const int __r = __call_with_subscripts<simd_size_v<_Tp, _Abi>>(
-	  __k, [](auto... __elements) { return ((__elements != 0) + ...); });
+			  __k, [](auto... __elements) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			    return ((__elements != 0) + ...);
+			  });
 	if (__builtin_is_constant_evaluated() || __builtin_constant_p(__r))
 	  return __r;
       }
@@ -4707,8 +4817,11 @@ template <typename _Tp, typename _Abi>
       {
 	constexpr size_t _Np = simd_size_v<_Tp, _Abi>;
 	const size_t _Idx = __call_with_n_evaluations<_Np>(
-	  [](auto... __indexes) { return std::min({__indexes...}); },
-	  [&](auto __i) { return __k[__i] ? +__i : _Np; });
+			      [](auto... __indexes) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+				return std::min({__indexes...});
+			      }, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+				return __k[__i] ? +__i : _Np;
+			      });
 	if (_Idx >= _Np)
 	  __invoke_ub("find_first_set(empty mask) is UB");
 	if (__builtin_constant_p(_Idx))
@@ -4725,8 +4838,11 @@ template <typename _Tp, typename _Abi>
       {
 	constexpr size_t _Np = simd_size_v<_Tp, _Abi>;
 	const int _Idx = __call_with_n_evaluations<_Np>(
-	  [](auto... __indexes) { return std::max({__indexes...}); },
-	  [&](auto __i) { return __k[__i] ? int(__i) : -1; });
+			   [](auto... __indexes) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			     return std::max({__indexes...});
+			   }, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			     return __k[__i] ? int(__i) : -1;
+			   });
 	if (_Idx < 0)
 	  __invoke_ub("find_first_set(empty mask) is UB");
 	if (__builtin_constant_p(_Idx))
@@ -4773,7 +4889,8 @@ template <typename _V, typename _Impl, bool>
 template <typename _V, typename _Impl>
   class _SimdIntOperators<_V, _Impl, true>
   {
-    _GLIBCXX_SIMD_INTRINSIC const _V& __derived() const
+    _GLIBCXX_SIMD_INTRINSIC constexpr const _V&
+    __derived() const
     { return *static_cast<const _V*>(this); }
 
     template <typename _Tp>
@@ -4963,16 +5080,16 @@ template <typename _Tp, typename _Abi>
 
     // load constructor
     template <typename _Up, typename _Flags>
-      _GLIBCXX_SIMD_ALWAYS_INLINE
-      simd(const _Up* __mem, _Flags)
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR
+      simd(const _Up* __mem, _IsSimdFlagType<_Flags>)
       : _M_data(
 	  _Impl::_S_load(_Flags::template _S_apply<simd>(__mem), _S_type_tag))
       {}
 
     // loads [simd.load]
     template <typename _Up, typename _Flags>
-      _GLIBCXX_SIMD_ALWAYS_INLINE void
-      copy_from(const _Vectorizable<_Up>* __mem, _Flags)
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR void
+      copy_from(const _Vectorizable<_Up>* __mem, _IsSimdFlagType<_Flags>)
       {
 	_M_data = static_cast<decltype(_M_data)>(
 	  _Impl::_S_load(_Flags::template _S_apply<simd>(__mem), _S_type_tag));
@@ -4980,8 +5097,8 @@ template <typename _Tp, typename _Abi>
 
     // stores [simd.store]
     template <typename _Up, typename _Flags>
-      _GLIBCXX_SIMD_ALWAYS_INLINE void
-      copy_to(_Vectorizable<_Up>* __mem, _Flags) const
+      _GLIBCXX_SIMD_ALWAYS_INLINE _GLIBCXX_SIMD_CONSTEXPR void
+      copy_to(_Vectorizable<_Up>* __mem, _IsSimdFlagType<_Flags>) const
       {
 	_Impl::_S_store(_M_data, _Flags::template _S_apply<simd>(__mem),
 			_S_type_tag);
@@ -5152,7 +5269,7 @@ template <typename _Tp, typename _Abi>
     }
 
   private:
-    _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR static mask_type
+    _GLIBCXX_SIMD_INTRINSIC static constexpr mask_type
     _S_make_mask(typename mask_type::_MemberType __k)
     { return {__private_init, __k}; }
 
@@ -5179,26 +5296,17 @@ namespace __float_bitwise_operators { //{{{
 template <typename _Tp, typename _Ap>
   _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR simd<_Tp, _Ap>
   operator^(const simd<_Tp, _Ap>& __a, const simd<_Tp, _Ap>& __b)
-  {
-    return {__private_init,
-	    _Ap::_SimdImpl::_S_bit_xor(__data(__a), __data(__b))};
-  }
+  { return {__private_init, _Ap::_SimdImpl::_S_bit_xor(__data(__a), __data(__b))}; }
 
 template <typename _Tp, typename _Ap>
   _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR simd<_Tp, _Ap>
   operator|(const simd<_Tp, _Ap>& __a, const simd<_Tp, _Ap>& __b)
-  {
-    return {__private_init,
-	    _Ap::_SimdImpl::_S_bit_or(__data(__a), __data(__b))};
-  }
+  { return {__private_init, _Ap::_SimdImpl::_S_bit_or(__data(__a), __data(__b))}; }
 
 template <typename _Tp, typename _Ap>
   _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_SIMD_CONSTEXPR simd<_Tp, _Ap>
   operator&(const simd<_Tp, _Ap>& __a, const simd<_Tp, _Ap>& __b)
-  {
-    return {__private_init,
-	    _Ap::_SimdImpl::_S_bit_and(__data(__a), __data(__b))};
-  }
+  { return {__private_init, _Ap::_SimdImpl::_S_bit_and(__data(__a), __data(__b))}; }
 } // namespace __float_bitwise_operators }}}
 /// @endcond
 
diff --git a/libstdc++-v3/include/experimental/bits/simd_builtin.h b/libstdc++-v3/include/experimental/bits/simd_builtin.h
index e986ee91620..7c272c178e5 100644
--- a/libstdc++-v3/include/experimental/bits/simd_builtin.h
+++ b/libstdc++-v3/include/experimental/bits/simd_builtin.h
@@ -51,7 +51,7 @@ template <typename _V, typename = _VectorTraits<_V>>
 // __vector_permute<Indices...>{{{
 // Index == -1 requests zeroing of the output element
 template <int... _Indices, typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-  _Tp
+  constexpr _Tp
   __vector_permute(_Tp __x)
   {
     static_assert(sizeof...(_Indices) == _TVT::_S_full_size);
@@ -63,7 +63,7 @@ template <int... _Indices, typename _Tp, typename _TVT = _VectorTraits<_Tp>>
 // __vector_shuffle<Indices...>{{{
 // Index == -1 requests zeroing of the output element
 template <int... _Indices, typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-  _Tp
+  constexpr _Tp
   __vector_shuffle(_Tp __x, _Tp __y)
   {
     return _Tp{(_Indices == -1 ? 0
@@ -192,15 +192,18 @@ template <unsigned __shift, typename _Tp, typename _TVT = _VectorTraits<_Tp>>
 	using _Up = decltype(__w);
 	return __intrin_bitcast<_Tp>(
 	  __call_with_n_evaluations<(sizeof(_Tp) - __shift) / __chunksize>(
-	    [](auto... __chunks) { return _Up{__chunks...}; },
-	    [&](auto __i) { return __w[__shift / __chunksize + __i]; }));
+	    [](auto... __chunks) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	      return _Up{__chunks...};
+	    }, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	      return __w[__shift / __chunksize + __i];
+	    }));
       }
   }
 
 // }}}
 // __extract_part(_SimdWrapper<_Tp, _Np>) {{{
 template <int _Index, int _Total, int _Combine, typename _Tp, size_t _Np>
-  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_CONST
+  _GLIBCXX_SIMD_INTRINSIC _GLIBCXX_CONST constexpr
   _SimdWrapper<_Tp, _Np / _Total * _Combine>
   __extract_part(const _SimdWrapper<_Tp, _Np> __x)
   {
@@ -223,7 +226,9 @@ template <int _Index, int _Total, int _Combine, typename _Tp, size_t _Np>
 	// by _Total");
 	if (__x._M_is_constprop())
 	  return __generate_from_n_evaluations<__return_size, _R>(
-	    [&](auto __i) { return __x[__values_to_skip + __i]; });
+	    [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	      return __x[__values_to_skip + __i];
+	    });
 	if constexpr (_Index == 0 && _Total == 1)
 	  return __x;
 	else if constexpr (_Index == 0)
@@ -568,7 +573,9 @@ template <typename _To,
 	constexpr auto _Np
 	  = _NParts == 0 ? _FromVT::_S_partial_width - _Offset : _NParts;
 	return __generate_from_n_evaluations<_Np, array<_To, _Np>>(
-	  [&](auto __i) { return static_cast<_To>(__v[__i + _Offset]); });
+		 [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return static_cast<_To>(__v[__i + _Offset]);
+		 });
       }
     else
       {
@@ -609,13 +616,14 @@ template <typename _To,
 	      return __vector_bitcast<_FromT, decltype(__n)::value>(__vv);
 	    };
 	    [[maybe_unused]] const auto __vi = __to_intrin(__v);
-	    auto&& __make_array = [](auto __x0, [[maybe_unused]] auto __x1) {
-	      if constexpr (_Np == 1)
-		return _R{__intrin_bitcast<_To>(__x0)};
-	      else
-		return _R{__intrin_bitcast<_To>(__x0),
-			  __intrin_bitcast<_To>(__x1)};
-	    };
+	    auto&& __make_array
+		= [](auto __x0, [[maybe_unused]] auto __x1) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		  if constexpr (_Np == 1)
+		    return _R{__intrin_bitcast<_To>(__x0)};
+		  else
+		    return _R{__intrin_bitcast<_To>(__x0),
+			      __intrin_bitcast<_To>(__x1)};
+		};
 
 	    if constexpr (_Np == 0)
 	      return _R{};
@@ -640,7 +648,7 @@ template <typename _To,
 		      = __convert_all<__vector_type16_t<int>, _Np>(
 			__adjust(_SizeConstant<_Np * 4>(), __v));
 		    return __generate_from_n_evaluations<_Np, _R>(
-		      [&](auto __i) {
+		      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 			return __vector_convert<_To>(__as_wrapper(__ints[__i]));
 		      });
 		  }
@@ -685,36 +693,40 @@ template <typename _To,
 		  __vector_bitcast<int>(_mm_unpacklo_epi16(__vv[1], __vv[1])),
 		  __vector_bitcast<int>(_mm_unpackhi_epi16(__vv[1], __vv[1]))};
 		if constexpr (sizeof(_ToT) == 4)
-		  return __generate_from_n_evaluations<_Np, _R>([&](auto __i) {
-		    return __vector_convert<_To>(
-		      _SimdWrapper<int, 4>(__vvvv[__i] >> 24));
-		  });
+		  return __generate_from_n_evaluations<_Np, _R>(
+			   [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			     return __vector_convert<_To>(
+				      _SimdWrapper<int, 4>(__vvvv[__i] >> 24));
+			   });
 		else if constexpr (is_integral_v<_ToT>)
-		  return __generate_from_n_evaluations<_Np, _R>([&](auto __i) {
-		    const auto __signbits = __to_intrin(__vvvv[__i / 2] >> 31);
-		    const auto __sx32 = __to_intrin(__vvvv[__i / 2] >> 24);
-		    return __vector_bitcast<_ToT>(
-		      __i % 2 == 0 ? _mm_unpacklo_epi32(__sx32, __signbits)
-				   : _mm_unpackhi_epi32(__sx32, __signbits));
-		  });
+		  return __generate_from_n_evaluations<_Np, _R>(
+			   [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			     const auto __signbits = __to_intrin(__vvvv[__i / 2] >> 31);
+			     const auto __sx32 = __to_intrin(__vvvv[__i / 2] >> 24);
+			     return __vector_bitcast<_ToT>(
+				      __i % 2 == 0 ? _mm_unpacklo_epi32(__sx32, __signbits)
+						   : _mm_unpackhi_epi32(__sx32, __signbits));
+			   });
 		else
-		  return __generate_from_n_evaluations<_Np, _R>([&](auto __i) {
-		    const _SimdWrapper<int, 4> __int4 = __vvvv[__i / 2] >> 24;
-		    return __vector_convert<_To>(
-		      __i % 2 == 0 ? __int4
-				   : _SimdWrapper<int, 4>(
-				     _mm_unpackhi_epi64(__to_intrin(__int4),
-							__to_intrin(__int4))));
-		  });
+		  return __generate_from_n_evaluations<_Np, _R>(
+			   [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			     const _SimdWrapper<int, 4> __int4 = __vvvv[__i / 2] >> 24;
+			     return __vector_convert<_To>(
+				      __i % 2 == 0 ? __int4
+						   : _SimdWrapper<int, 4>(
+						       _mm_unpackhi_epi64(__to_intrin(__int4),
+									  __to_intrin(__int4))));
+			   });
 	      }
 	    else if constexpr (sizeof(_FromT) == 1 && sizeof(_ToT) == 4)
 	      {
 		const auto __shorts = __convert_all<__vector_type16_t<
 		  conditional_t<is_signed_v<_FromT>, short, unsigned short>>>(
 		  __adjust(_SizeConstant<(_Np + 1) / 2 * 8>(), __v));
-		return __generate_from_n_evaluations<_Np, _R>([&](auto __i) {
-		  return __convert_all<_To>(__shorts[__i / 2])[__i % 2];
-		});
+		return __generate_from_n_evaluations<_Np, _R>(
+			 [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			   return __convert_all<_To>(__shorts[__i / 2])[__i % 2];
+			 });
 	      }
 	    else if constexpr (sizeof(_FromT) == 2 && sizeof(_ToT) == 8
 			       && is_signed_v<_FromT> && is_integral_v<_ToT>)
@@ -734,9 +746,10 @@ template <typename _To,
 		     __vector_bitcast<int>(
 		       _mm_unpackhi_epi32(_mm_srai_epi32(__vv[1], 16),
 					  _mm_srai_epi32(__vv[1], 31)))};
-		return __generate_from_n_evaluations<_Np, _R>([&](auto __i) {
-		  return __vector_bitcast<_ToT>(__vvvv[__i]);
-		});
+		return __generate_from_n_evaluations<_Np, _R>(
+			 [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			   return __vector_bitcast<_ToT>(__vvvv[__i]);
+			 });
 	      }
 	    else if constexpr (sizeof(_FromT) <= 2 && sizeof(_ToT) == 8)
 	      {
@@ -745,9 +758,10 @@ template <typename _To,
 		    is_signed_v<_FromT> || is_floating_point_v<_ToT>, int,
 		    unsigned int>>>(
 		    __adjust(_SizeConstant<(_Np + 1) / 2 * 4>(), __v));
-		return __generate_from_n_evaluations<_Np, _R>([&](auto __i) {
-		  return __convert_all<_To>(__ints[__i / 2])[__i % 2];
-		});
+		return __generate_from_n_evaluations<_Np, _R>(
+			 [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			   return __convert_all<_To>(__ints[__i / 2])[__i % 2];
+			 });
 	      }
 	    else
 	      __assert_unreachable<_To>();
@@ -777,14 +791,14 @@ template <typename _To,
 		__extract_part<_Offset, _FromVT::_S_partial_width,
 			       _ToVT::_S_full_size>(__v))};
 	    else
-	      return __generate_from_n_evaluations<_Np, _R>([&](
-		auto __i) constexpr {
-		auto __part
-		  = __extract_part<__i * _ToVT::_S_full_size + _Offset,
-				   _FromVT::_S_partial_width,
-				   _ToVT::_S_full_size>(__v);
-		return __vector_convert<_To>(__part);
-	      });
+	      return __generate_from_n_evaluations<_Np, _R>(
+		       [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			 auto __part
+			   = __extract_part<__i * _ToVT::_S_full_size + _Offset,
+					    _FromVT::_S_partial_width,
+					    _ToVT::_S_full_size>(__v);
+			 return __vector_convert<_To>(__part);
+		       });
 	  }
 	else if constexpr (_Offset == 0)
 	  return array<_To, 1>{__vector_convert<_To>(__v)};
@@ -820,19 +834,19 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>
     // _SimdBase / base class for simd, providing extra conversions {{{
     struct _SimdBase2
     {
-      explicit operator __intrinsic_type_t<_Tp, _Np>() const
-      {
-	return __to_intrin(static_cast<const simd<_Tp, _Abi>*>(this)->_M_data);
-      }
-      explicit operator __vector_type_t<_Tp, _Np>() const
-      {
-	return static_cast<const simd<_Tp, _Abi>*>(this)->_M_data.__builtin();
-      }
+      explicit
+      operator __intrinsic_type_t<_Tp, _Np>() const
+      { return __to_intrin(static_cast<const simd<_Tp, _Abi>*>(this)->_M_data); }
+
+      explicit
+      operator __vector_type_t<_Tp, _Np>() const
+      { return static_cast<const simd<_Tp, _Abi>*>(this)->_M_data.__builtin(); }
     };
 
     struct _SimdBase1
     {
-      explicit operator __intrinsic_type_t<_Tp, _Np>() const
+      explicit
+      operator __intrinsic_type_t<_Tp, _Np>() const
       { return __data(*static_cast<const simd<_Tp, _Abi>*>(this)); }
     };
 
@@ -844,20 +858,19 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>
     // _MaskBase {{{
     struct _MaskBase2
     {
-      explicit operator __intrinsic_type_t<_Tp, _Np>() const
-      {
-	return static_cast<const simd_mask<_Tp, _Abi>*>(this)
-	  ->_M_data.__intrin();
-      }
-      explicit operator __vector_type_t<_Tp, _Np>() const
-      {
-	return static_cast<const simd_mask<_Tp, _Abi>*>(this)->_M_data._M_data;
-      }
+      explicit
+      operator __intrinsic_type_t<_Tp, _Np>() const
+      { return static_cast<const simd_mask<_Tp, _Abi>*>(this) ->_M_data.__intrin(); }
+
+      explicit
+      operator __vector_type_t<_Tp, _Np>() const
+      { return static_cast<const simd_mask<_Tp, _Abi>*>(this)->_M_data._M_data; }
     };
 
     struct _MaskBase1
     {
-      explicit operator __intrinsic_type_t<_Tp, _Np>() const
+      explicit
+      operator __intrinsic_type_t<_Tp, _Np>() const
       { return __data(*static_cast<const simd_mask<_Tp, _Abi>*>(this)); }
     };
 
@@ -875,6 +888,7 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>
 
     public:
       _MaskCastType(_Up __x) : _M_data(__x) {}
+
       operator _MaskMember() const { return _M_data; }
     };
 
@@ -887,7 +901,10 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>
       _SimdMember _M_data;
 
     public:
+      constexpr
       _SimdCastType1(_Ap __a) : _M_data(__vector_bitcast<_Tp>(__a)) {}
+
+      constexpr
       operator _SimdMember() const { return _M_data; }
     };
 
@@ -898,8 +915,13 @@ template <typename _Tp, typename _Mp, typename _Abi, size_t _Np>
       _SimdMember _M_data;
 
     public:
+      constexpr
       _SimdCastType2(_Ap __a) : _M_data(__vector_bitcast<_Tp>(__a)) {}
+
+      constexpr
       _SimdCastType2(_Bp __b) : _M_data(__b) {}
+
+      constexpr
       operator _SimdMember() const { return _M_data; }
     };
 
@@ -1002,23 +1024,21 @@ template <int _UsedBytes>
 	else
 	  {
 	    constexpr auto __size = _S_size<_Tp>;
-	    _GLIBCXX_SIMD_USE_CONSTEXPR auto __r = __generate_vector<_UV>(
-	      [](auto __i) constexpr { return __i < __size ? -1 : 0; });
+	    _GLIBCXX_SIMD_USE_CONSTEXPR auto __r
+	      = __generate_vector<_UV>([](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+				       { return __i < __size ? -1 : 0; });
 	    return __r;
 	  }
       }
 
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static constexpr __intrinsic_type_t<_Tp,
-								  _S_size<_Tp>>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr __intrinsic_type_t<_Tp, _S_size<_Tp>>
       _S_implicit_mask_intrin()
-      {
-	return __to_intrin(
-	  __vector_bitcast<_Tp>(_S_implicit_mask<_Tp>()._M_data));
-      }
+      { return __to_intrin(__vector_bitcast<_Tp>(_S_implicit_mask<_Tp>()._M_data)); }
 
     template <typename _TW, typename _TVT = _VectorTraits<_TW>>
-      _GLIBCXX_SIMD_INTRINSIC static constexpr _TW _S_masked(_TW __x)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _TW
+      _S_masked(_TW __x)
       {
 	using _Tp = typename _TVT::value_type;
 	if constexpr (!_MaskMember<_Tp>::_S_is_partial)
@@ -1140,8 +1160,7 @@ template <int _UsedBytes>
       { return __implicit_mask_n<_S_size<_Tp>>(); }
 
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static constexpr __bool_storage_member_type_t<
-	_S_size<_Tp>>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr __bool_storage_member_type_t<_S_size<_Tp>>
       _S_implicit_mask_intrin()
       { return __implicit_mask_n<_S_size<_Tp>>(); }
 
@@ -1193,7 +1212,7 @@ template <int _UsedBytes>
 	    if constexpr (is_integral_v<typename _TVT::value_type>)
 	      return __x
 		     | __generate_vector<_Tp, _S_full_size<_Tp>>(
-		       [](auto __i) -> _Tp {
+		       [](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA -> _Tp {
 			 if (__i < _Np)
 			   return 0;
 			 else
@@ -1273,7 +1292,8 @@ struct _CommonImplBuiltin
   // }}}
   // _S_store {{{
   template <size_t _ReqBytes = 0, typename _TV>
-    _GLIBCXX_SIMD_INTRINSIC static void _S_store(_TV __x, void* __addr)
+    _GLIBCXX_SIMD_INTRINSIC static void
+    _S_store(_TV __x, void* __addr)
     {
       constexpr size_t _Bytes = _ReqBytes == 0 ? sizeof(__x) : _ReqBytes;
       static_assert(sizeof(__x) >= _Bytes);
@@ -1309,8 +1329,8 @@ struct _CommonImplBuiltin
     }
 
   template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static void _S_store(_SimdWrapper<_Tp, _Np> __x,
-						 void* __addr)
+    _GLIBCXX_SIMD_INTRINSIC static void
+    _S_store(_SimdWrapper<_Tp, _Np> __x, void* __addr)
     { _S_store<_Np * sizeof(_Tp)>(__x._M_data, __addr); }
 
   // }}}
@@ -1321,6 +1341,11 @@ struct _CommonImplBuiltin
     {
       if constexpr (_Np == 1)
 	__mem[0] = __x[0];
+      else if (__builtin_is_constant_evaluated())
+	{
+	  for (size_t __i = 0; __i < _Np; ++__i)
+	    __mem[__i] = __x[__i];
+	}
       else if constexpr (_Np == 2)
 	{
 	  short __bool2 = (__x._M_to_bits() * 0x81) & 0x0101;
@@ -1333,26 +1358,27 @@ struct _CommonImplBuiltin
 	}
       else
 	{
-	  __execute_n_times<__div_roundup(_Np, 4)>([&](auto __i) {
-	    constexpr int __offset = __i * 4;
-	    constexpr int __remaining = _Np - __offset;
-	    if constexpr (__remaining > 4 && __remaining <= 7)
-	      {
-		const _ULLong __bool7
-		  = (__x.template _M_extract<__offset>()._M_to_bits()
-		     * 0x40810204081ULL)
-		    & 0x0101010101010101ULL;
-		_S_store<__remaining>(__bool7, __mem + __offset);
-	      }
-	    else if constexpr (__remaining >= 4)
-	      {
-		int __bits = __x.template _M_extract<__offset>()._M_to_bits();
-		if constexpr (__remaining > 7)
-		  __bits &= 0xf;
-		const int __bool4 = (__bits * 0x204081) & 0x01010101;
-		_S_store<4>(__bool4, __mem + __offset);
-	      }
-	  });
+	  __execute_n_times<__div_roundup(_Np, 4)>(
+	    [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	      constexpr int __offset = __i * 4;
+	      constexpr int __remaining = _Np - __offset;
+	      if constexpr (__remaining > 4 && __remaining <= 7)
+		{
+		  const _ULLong __bool7
+		    = (__x.template _M_extract<__offset>()._M_to_bits()
+			 * 0x40810204081ULL)
+			& 0x0101010101010101ULL;
+		  _S_store<__remaining>(__bool7, __mem + __offset);
+		}
+	      else if constexpr (__remaining >= 4)
+		{
+		  int __bits = __x.template _M_extract<__offset>()._M_to_bits();
+		  if constexpr (__remaining > 7)
+		    __bits &= 0xf;
+		  const int __bool4 = (__bits * 0x204081) & 0x01010101;
+		  _S_store<4>(__bool4, __mem + __offset);
+		}
+	    });
 	}
     }
 
@@ -1399,12 +1425,12 @@ template <typename _Abi>
 
     // _M_make_simd(_SimdWrapper/__intrinsic_type_t) {{{2
     template <typename _Tp, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static simd<_Tp, _Abi>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr simd<_Tp, _Abi>
       _M_make_simd(_SimdWrapper<_Tp, _Np> __x)
       { return {__private_init, __x}; }
 
     template <typename _Tp, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static simd<_Tp, _Abi>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr simd<_Tp, _Abi>
       _M_make_simd(__intrinsic_type_t<_Tp, _Np> __x)
       { return {__private_init, __vector_bitcast<_Tp>(__x)}; }
 
@@ -1416,21 +1442,21 @@ template <typename _Abi>
 
     // _S_generator {{{2
     template <typename _Fp, typename _Tp>
-      inline static constexpr _SimdMember<_Tp> _S_generator(_Fp&& __gen,
-							    _TypeTag<_Tp>)
+      inline static constexpr _SimdMember<_Tp>
+      _S_generator(_Fp&& __gen, _TypeTag<_Tp>)
       {
-	return __generate_vector<_Tp, _S_full_size<_Tp>>([&](
-	  auto __i) constexpr {
-	  if constexpr (__i < _S_size<_Tp>)
-	    return __gen(__i);
-	  else
-	    return 0;
-	});
+	return __generate_vector<_Tp, _S_full_size<_Tp>>(
+		 [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   if constexpr (__i < _S_size<_Tp>)
+		     return __gen(__i);
+		   else
+		     return 0;
+		 });
       }
 
     // _S_load {{{2
     template <typename _Tp, typename _Up>
-      _GLIBCXX_SIMD_INTRINSIC static _SimdMember<_Tp>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdMember<_Tp>
       _S_load(const _Up* __mem, _TypeTag<_Tp>) noexcept
       {
 	constexpr size_t _Np = _S_size<_Tp>;
@@ -1439,11 +1465,16 @@ template <typename _Abi>
 	    : (is_floating_point_v<_Up> && __have_avx) || __have_avx2 ? 32
 								      : 16;
 	constexpr size_t __bytes_to_load = sizeof(_Up) * _Np;
-	if constexpr (sizeof(_Up) > 8)
-	  return __generate_vector<_Tp, _SimdMember<_Tp>::_S_full_size>([&](
-	    auto __i) constexpr {
-	    return static_cast<_Tp>(__i < _Np ? __mem[__i] : 0);
-	  });
+	if (__builtin_is_constant_evaluated())
+	  return __generate_vector<_Tp, _S_full_size<_Tp>>(
+		   [&](auto __i) constexpr {
+		     return static_cast<_Tp>(__i < _Np ? __mem[__i] : 0);
+		   });
+	else if constexpr (sizeof(_Up) > 8)
+	  return __generate_vector<_Tp, _SimdMember<_Tp>::_S_full_size>(
+		   [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		     return static_cast<_Tp>(__i < _Np ? __mem[__i] : 0);
+		   });
 	else if constexpr (is_same_v<_Up, _Tp>)
 	  return _CommonImpl::template _S_load<_Tp, _S_full_size<_Tp>,
 					       _Np * sizeof(_Tp)>(__mem);
@@ -1455,13 +1486,12 @@ template <typename _Abi>
 	    constexpr size_t __n_loads = __bytes_to_load / __max_load_size;
 	    constexpr size_t __elements_per_load = _Np / __n_loads;
 	    return __call_with_n_evaluations<__n_loads>(
-	      [](auto... __uncvted) {
-		return __convert<_SimdMember<_Tp>>(__uncvted...);
-	      },
-	      [&](auto __i) {
-		return _CommonImpl::template _S_load<_Up, __elements_per_load>(
-		  __mem + __i * __elements_per_load);
-	      });
+		     [](auto... __uncvted) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		       return __convert<_SimdMember<_Tp>>(__uncvted...);
+		     }, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		       return _CommonImpl::template _S_load<_Up, __elements_per_load>(
+						      __mem + __i * __elements_per_load);
+		     });
 	  }
 	else if constexpr (__bytes_to_load % (__max_load_size / 2) == 0
 			   && __max_load_size > 16)
@@ -1470,45 +1500,50 @@ template <typename _Abi>
 	      = __bytes_to_load / (__max_load_size / 2);
 	    constexpr size_t __elements_per_load = _Np / __n_loads;
 	    return __call_with_n_evaluations<__n_loads>(
-	      [](auto... __uncvted) {
-		return __convert<_SimdMember<_Tp>>(__uncvted...);
-	      },
-	      [&](auto __i) {
-		return _CommonImpl::template _S_load<_Up, __elements_per_load>(
-		  __mem + __i * __elements_per_load);
-	      });
+		     [](auto... __uncvted) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		       return __convert<_SimdMember<_Tp>>(__uncvted...);
+		     }, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		       return _CommonImpl::template _S_load<_Up, __elements_per_load>(
+						      __mem + __i * __elements_per_load);
+		     });
 	  }
 	else // e.g. int[] -> <char, 9>
 	  return __call_with_subscripts(
-	    __mem, make_index_sequence<_Np>(), [](auto... __args) {
-	      return __vector_type_t<_Tp, _S_full_size<_Tp>>{
-		static_cast<_Tp>(__args)...};
-	    });
+	    __mem, make_index_sequence<_Np>(),
+		   [](auto... __args) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		     return __vector_type_t<_Tp, _S_full_size<_Tp>>{static_cast<_Tp>(__args)...};
+		   });
       }
 
     // _S_masked_load {{{2
     template <typename _Tp, size_t _Np, typename _Up>
-      static inline _SimdWrapper<_Tp, _Np>
+      static constexpr inline _SimdWrapper<_Tp, _Np>
       _S_masked_load(_SimdWrapper<_Tp, _Np> __merge, _MaskMember<_Tp> __k,
 		     const _Up* __mem) noexcept
       {
-	_BitOps::_S_bit_iteration(_MaskImpl::_S_to_bits(__k), [&](auto __i) {
-	  __merge._M_set(__i, static_cast<_Tp>(__mem[__i]));
-	});
+	_BitOps::_S_bit_iteration(_MaskImpl::_S_to_bits(__k),
+				  [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+				    __merge._M_set(__i, static_cast<_Tp>(__mem[__i]));
+				  });
 	return __merge;
       }
 
     // _S_store {{{2
     template <typename _Tp, typename _Up>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_store(_SimdMember<_Tp> __v, _Up* __mem, _TypeTag<_Tp>) noexcept
       {
 	// TODO: converting int -> "smaller int" can be optimized with AVX512
 	constexpr size_t _Np = _S_size<_Tp>;
 	constexpr size_t __max_store_size
 	  = _SuperImpl::template _S_max_store_size<_Up>;
-	if constexpr (sizeof(_Up) > 8)
-	  __execute_n_times<_Np>([&](auto __i) constexpr {
+	if (__builtin_is_constant_evaluated())
+	  {
+	    for (size_t __i = 0; __i < _Np; ++__i)
+	      __mem[__i] = __v[__i];
+	  }
+	else if constexpr (sizeof(_Up) > 8)
+	  __execute_n_times<_Np>([&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    __mem[__i] = __v[__i];
 	  });
 	else if constexpr (is_same_v<_Up, _Tp>)
@@ -1525,9 +1560,10 @@ template <typename _Abi>
 	    using _V = __vector_type_t<_Up, __vsize>;
 	    const array<_V, __stores> __converted
 	      = __convert_all<_V, __stores>(__v);
-	    __execute_n_times<__full_stores>([&](auto __i) constexpr {
-	      _CommonImpl::_S_store(__converted[__i], __mem + __i * __vsize);
-	    });
+	    __execute_n_times<__full_stores>(
+	      [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		_CommonImpl::_S_store(__converted[__i], __mem + __i * __vsize);
+	      });
 	    if constexpr (__full_stores < __stores)
 	      _CommonImpl::template _S_store<(_Np - __full_stores * __vsize)
 					     * sizeof(_Up)>(
@@ -1537,12 +1573,12 @@ template <typename _Abi>
 
     // _S_masked_store_nocvt {{{2
     template <typename _Tp, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void
-      _S_masked_store_nocvt(_SimdWrapper<_Tp, _Np> __v, _Tp* __mem,
-			    _MaskMember<_Tp> __k)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
+      _S_masked_store_nocvt(_SimdWrapper<_Tp, _Np> __v, _Tp* __mem, _MaskMember<_Tp> __k)
       {
 	_BitOps::_S_bit_iteration(
-	  _MaskImpl::_S_to_bits(__k), [&](auto __i) constexpr {
+	  _MaskImpl::_S_to_bits(__k),
+	  [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    __mem[__i] = __v[__i];
 	  });
       }
@@ -1550,9 +1586,8 @@ template <typename _Abi>
     // _S_masked_store {{{2
     template <typename _TW, typename _TVT = _VectorTraits<_TW>,
 	      typename _Tp = typename _TVT::value_type, typename _Up>
-      static inline void
-      _S_masked_store(const _TW __v, _Up* __mem, const _MaskMember<_Tp> __k)
-	noexcept
+      static constexpr inline void
+      _S_masked_store(const _TW __v, _Up* __mem, const _MaskMember<_Tp> __k) noexcept
       {
 	constexpr size_t _TV_size = _S_size<_Tp>;
 	[[maybe_unused]] const auto __vi = __to_intrin(__v);
@@ -1564,7 +1599,7 @@ template <typename _Abi>
 	    _Up> || (is_integral_v<_Tp> && is_integral_v<_Up> && sizeof(_Tp) == sizeof(_Up)))
 	  {
 	    // bitwise or no conversion, reinterpret:
-	    const _MaskMember<_Up> __kk = [&]() {
+	    const _MaskMember<_Up> __kk = [&]() _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	      if constexpr (__is_bitmask_v<decltype(__k)>)
 		return _MaskMember<_Up>(__k._M_data);
 	      else
@@ -1603,7 +1638,7 @@ template <typename _Abi>
 		constexpr size_t _NParts = _S_full_size<_Tp> / _UW_size;
 		const array<_UV, _NAllStores> __converted
 		  = __convert_all<_UV, _NAllStores>(__v);
-		__execute_n_times<_NFullStores>([&](auto __i) {
+		__execute_n_times<_NFullStores>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		  _SuperImpl::_S_masked_store_nocvt(
 		    _UW(__converted[__i]), __mem + __i * _UW_size,
 		    _UAbi::_MaskImpl::template _S_convert<
@@ -1622,10 +1657,10 @@ template <typename _Abi>
 	      }
 	  }
 	else
-	  _BitOps::_S_bit_iteration(
-	    _MaskImpl::_S_to_bits(__k), [&](auto __i) constexpr {
-	      __mem[__i] = static_cast<_Up>(__v[__i]);
-	    });
+	  _BitOps::_S_bit_iteration(_MaskImpl::_S_to_bits(__k),
+				    [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+				      __mem[__i] = static_cast<_Up>(__v[__i]);
+				    });
       }
 
     // _S_complement {{{2
@@ -1774,7 +1809,7 @@ template <typename _Abi>
     // reductions {{{2
     template <size_t _Np, size_t... _Is, size_t... _Zeros, typename _Tp,
 	      typename _BinaryOperation>
-      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _Tp
       _S_reduce_partial(index_sequence<_Is...>, index_sequence<_Zeros...>,
 			simd<_Tp, _Abi> __x, _BinaryOperation&& __binary_op)
       {
@@ -1804,6 +1839,13 @@ template <typename _Abi>
 	else if constexpr (_Np == 2)
 	  return __binary_op(simd<_Tp, simd_abi::scalar>(__x[0]),
 			     simd<_Tp, simd_abi::scalar>(__x[1]))[0];
+	else if (__builtin_is_constant_evaluated())
+	  {
+	    simd<_Tp, simd_abi::scalar> __acc = __x[0];
+	    for (size_t __i = 1; __i < _Np; ++__i)
+	      __acc = __binary_op(__acc, simd<_Tp, simd_abi::scalar>(__x[__i]));
+	    return __acc[0];
+	  }
 	else if constexpr (_Abi::template _S_is_partial<_Tp>) //{{{
 	  {
 	    [[maybe_unused]] constexpr auto __full_size
@@ -1909,35 +1951,41 @@ template <typename _Abi>
     // frexp, modf and copysign implemented in simd_math.h
 #define _GLIBCXX_SIMD_MATH_FALLBACK(__name)                                    \
     template <typename _Tp, typename... _More>                                 \
-      static _Tp _S_##__name(const _Tp& __x, const _More&... __more)           \
+      static _Tp                                                               \
+      _S_##__name(const _Tp& __x, const _More&... __more)                      \
       {                                                                        \
 	return __generate_vector<_Tp>(                                         \
-	  [&](auto __i) { return __name(__x[__i], __more[__i]...); });         \
+		 [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {            \
+		   return __name(__x[__i], __more[__i]...);                    \
+		 });                                                           \
       }
 
 #define _GLIBCXX_SIMD_MATH_FALLBACK_MASKRET(__name)                            \
     template <typename _Tp, typename... _More>                                 \
-      static typename _Tp::mask_type _S_##__name(const _Tp& __x,               \
-						 const _More&... __more)       \
+      static typename _Tp::mask_type                                           \
+      _S_##__name(const _Tp& __x, const _More&... __more)                      \
       {                                                                        \
 	return __generate_vector<_Tp>(                                         \
-	  [&](auto __i) { return __name(__x[__i], __more[__i]...); });         \
+		 [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {            \
+		   return __name(__x[__i], __more[__i]...);                    \
+		 });                                                           \
       }
 
-#define _GLIBCXX_SIMD_MATH_FALLBACK_FIXEDRET(_RetTp, __name)                   \
-    template <typename _Tp, typename... _More>                                 \
-      static auto _S_##__name(const _Tp& __x, const _More&... __more)          \
-      {                                                                        \
-	return __fixed_size_storage_t<_RetTp,                                  \
-				      _VectorTraits<_Tp>::_S_partial_width>::  \
-	  _S_generate([&](auto __meta) constexpr {                             \
-	    return __meta._S_generator(                                        \
-	      [&](auto __i) {                                                  \
-		return __name(__x[__meta._S_offset + __i],                     \
-			      __more[__meta._S_offset + __i]...);              \
-	      },                                                               \
-	      static_cast<_RetTp*>(nullptr));                                  \
-	  });                                                                  \
+#define _GLIBCXX_SIMD_MATH_FALLBACK_FIXEDRET(_RetTp, __name)                          \
+    template <typename _Tp, typename... _More>                                        \
+      static auto                                                                     \
+      _S_##__name(const _Tp& __x, const _More&... __more)                             \
+      {                                                                               \
+	return __fixed_size_storage_t<_RetTp,                                         \
+				      _VectorTraits<_Tp>::_S_partial_width>::         \
+	  _S_generate([&](auto __meta) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { \
+	    return __meta._S_generator(                                               \
+	      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {                      \
+		return __name(__x[__meta._S_offset + __i],                            \
+			      __more[__meta._S_offset + __i]...);                     \
+	      },                                                                      \
+	      static_cast<_RetTp*>(nullptr));                                         \
+	  });                                                                         \
       }
 
     _GLIBCXX_SIMD_MATH_FALLBACK(acos)
@@ -1990,7 +2038,7 @@ template <typename _Abi>
       _S_remquo(const _Tp __x, const _Tp __y,
 		__fixed_size_storage_t<int, _TVT::_S_partial_width>* __z)
       {
-	return __generate_vector<_Tp>([&](auto __i) {
+	return __generate_vector<_Tp>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  int __tmp;
 	  auto __r = remquo(__x[__i], __y[__i], &__tmp);
 	  __z->_M_set(__i, __tmp);
@@ -2074,22 +2122,22 @@ template <typename _Abi>
 #undef _GLIBCXX_SIMD_MATH_FALLBACK_FIXEDRET
     // _S_abs {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
-    _S_abs(_SimdWrapper<_Tp, _Np> __x) noexcept
-    {
-      // if (__builtin_is_constant_evaluated())
-      //  {
-      //    return __x._M_data < 0 ? -__x._M_data : __x._M_data;
-      //  }
-      if constexpr (is_floating_point_v<_Tp>)
-	// `v < 0 ? -v : v` cannot compile to the efficient implementation of
-	// masking the signbit off because it must consider v == -0
+      _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
+      _S_abs(_SimdWrapper<_Tp, _Np> __x) noexcept
+      {
+	// if (__builtin_is_constant_evaluated())
+	//  {
+	//    return __x._M_data < 0 ? -__x._M_data : __x._M_data;
+	//  }
+	if constexpr (is_floating_point_v<_Tp>)
+	  // `v < 0 ? -v : v` cannot compile to the efficient implementation of
+	  // masking the signbit off because it must consider v == -0
 
-	// ~(-0.) & v would be easy, but breaks with fno-signed-zeros
-	return __and(_S_absmask<__vector_type_t<_Tp, _Np>>, __x._M_data);
-      else
-	return __x._M_data < 0 ? -__x._M_data : __x._M_data;
-    }
+	  // ~(-0.) & v would be easy, but breaks with fno-signed-zeros
+	  return __and(_S_absmask<__vector_type_t<_Tp, _Np>>, __x._M_data);
+	else
+	  return __x._M_data < 0 ? -__x._M_data : __x._M_data;
+      }
 
     // }}}3
     // _S_plus_minus {{{
@@ -2097,339 +2145,337 @@ template <typename _Abi>
     // - _TV must be __vector_type_t<floating-point type, N>.
     // - _UV must be _TV or floating-point type.
     template <typename _TV, typename _UV>
-    _GLIBCXX_SIMD_INTRINSIC static constexpr _TV _S_plus_minus(_TV __x,
-							       _UV __y) noexcept
-    {
-  #if defined __i386__ && !defined __SSE_MATH__
-      if constexpr (sizeof(__x) == 8)
-	{ // operations on __x would use the FPU
-	  static_assert(is_same_v<_TV, __vector_type_t<float, 2>>);
-	  const auto __x4 = __vector_bitcast<float, 4>(__x);
-	  if constexpr (is_same_v<_TV, _UV>)
-	    return __vector_bitcast<float, 2>(
-	      _S_plus_minus(__x4, __vector_bitcast<float, 4>(__y)));
-	  else
-	    return __vector_bitcast<float, 2>(_S_plus_minus(__x4, __y));
-	}
-  #endif
-  #if !defined __clang__ && __GCC_IEC_559 == 0
-      if (__builtin_is_constant_evaluated()
-	  || (__builtin_constant_p(__x) && __builtin_constant_p(__y)))
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _TV
+      _S_plus_minus(_TV __x, _UV __y) noexcept
+      {
+#if defined __i386__ && !defined __SSE_MATH__
+	if constexpr (sizeof(__x) == 8)
+	  { // operations on __x would use the FPU
+	    static_assert(is_same_v<_TV, __vector_type_t<float, 2>>);
+	    const auto __x4 = __vector_bitcast<float, 4>(__x);
+	    if constexpr (is_same_v<_TV, _UV>)
+	      return __vector_bitcast<float, 2>(
+		       _S_plus_minus(__x4, __vector_bitcast<float, 4>(__y)));
+	    else
+	      return __vector_bitcast<float, 2>(_S_plus_minus(__x4, __y));
+	  }
+#endif
+#if !defined __clang__ && __GCC_IEC_559 == 0
+	if (__builtin_is_constant_evaluated()
+	      || (__builtin_constant_p(__x) && __builtin_constant_p(__y)))
+	  return (__x + __y) - __y;
+	else
+	  return [&] {
+	    __x += __y;
+	    if constexpr(__have_sse)
+	      {
+		if constexpr (sizeof(__x) >= 16)
+		  asm("" : "+x"(__x));
+		else if constexpr (is_same_v<__vector_type_t<float, 2>, _TV>)
+		  asm("" : "+x"(__x[0]), "+x"(__x[1]));
+		else
+		  __assert_unreachable<_TV>();
+	      }
+	    else if constexpr(__have_neon)
+	      asm("" : "+w"(__x));
+	    else if constexpr (__have_power_vmx)
+	      {
+		if constexpr (is_same_v<__vector_type_t<float, 2>, _TV>)
+		  asm("" : "+fgr"(__x[0]), "+fgr"(__x[1]));
+		else
+		  asm("" : "+v"(__x));
+	      }
+	    else
+	      asm("" : "+g"(__x));
+	    return __x - __y;
+	  }();
+#else
 	return (__x + __y) - __y;
-      else
-	return [&] {
-	  __x += __y;
-	  if constexpr(__have_sse)
-	    {
-	      if constexpr (sizeof(__x) >= 16)
-		asm("" : "+x"(__x));
-	      else if constexpr (is_same_v<__vector_type_t<float, 2>, _TV>)
-		asm("" : "+x"(__x[0]), "+x"(__x[1]));
-	      else
-		__assert_unreachable<_TV>();
-	    }
-	  else if constexpr(__have_neon)
-	    asm("" : "+w"(__x));
-	  else if constexpr (__have_power_vmx)
-	    {
-	      if constexpr (is_same_v<__vector_type_t<float, 2>, _TV>)
-		asm("" : "+fgr"(__x[0]), "+fgr"(__x[1]));
-	      else
-		asm("" : "+v"(__x));
-	    }
-	  else
-	    asm("" : "+g"(__x));
-	  return __x - __y;
-	}();
-  #else
-      return (__x + __y) - __y;
-  #endif
-    }
+#endif
+      }
 
     // }}}
     // _S_nearbyint {{{3
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_nearbyint(_Tp __x_) noexcept
-    {
-      using value_type = typename _TVT::value_type;
-      using _V = typename _TVT::type;
-      const _V __x = __x_;
-      const _V __absx = __and(__x, _S_absmask<_V>);
-      static_assert(__CHAR_BIT__ * sizeof(1ull) >= __digits_v<value_type>);
-      _GLIBCXX_SIMD_USE_CONSTEXPR _V __shifter_abs
-	= _V() + (1ull << (__digits_v<value_type> - 1));
-      const _V __shifter = __or(__and(_S_signmask<_V>, __x), __shifter_abs);
-      const _V __shifted = _S_plus_minus(__x, __shifter);
-      return __absx < __shifter_abs ? __shifted : __x;
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _S_nearbyint(_Tp __x_) noexcept
+      {
+	using value_type = typename _TVT::value_type;
+	using _V = typename _TVT::type;
+	const _V __x = __x_;
+	const _V __absx = __and(__x, _S_absmask<_V>);
+	static_assert(__CHAR_BIT__ * sizeof(1ull) >= __digits_v<value_type>);
+	_GLIBCXX_SIMD_USE_CONSTEXPR _V __shifter_abs
+	  = _V() + (1ull << (__digits_v<value_type> - 1));
+	const _V __shifter = __or(__and(_S_signmask<_V>, __x), __shifter_abs);
+	const _V __shifted = _S_plus_minus(__x, __shifter);
+	return __absx < __shifter_abs ? __shifted : __x;
+      }
 
     // _S_rint {{{3
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_rint(_Tp __x) noexcept
-    {
-      return _SuperImpl::_S_nearbyint(__x);
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _S_rint(_Tp __x) noexcept
+      { return _SuperImpl::_S_nearbyint(__x); }
 
     // _S_trunc {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
-    _S_trunc(_SimdWrapper<_Tp, _Np> __x)
-    {
-      using _V = __vector_type_t<_Tp, _Np>;
-      const _V __absx = __and(__x._M_data, _S_absmask<_V>);
-      static_assert(__CHAR_BIT__ * sizeof(1ull) >= __digits_v<_Tp>);
-      constexpr _Tp __shifter = 1ull << (__digits_v<_Tp> - 1);
-      _V __truncated = _S_plus_minus(__absx, __shifter);
-      __truncated -= __truncated > __absx ? _V() + 1 : _V();
-      return __absx < __shifter ? __or(__xor(__absx, __x._M_data), __truncated)
-				: __x._M_data;
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
+      _S_trunc(_SimdWrapper<_Tp, _Np> __x)
+      {
+	using _V = __vector_type_t<_Tp, _Np>;
+	const _V __absx = __and(__x._M_data, _S_absmask<_V>);
+	static_assert(__CHAR_BIT__ * sizeof(1ull) >= __digits_v<_Tp>);
+	constexpr _Tp __shifter = 1ull << (__digits_v<_Tp> - 1);
+	_V __truncated = _S_plus_minus(__absx, __shifter);
+	__truncated -= __truncated > __absx ? _V() + 1 : _V();
+	return __absx < __shifter ? __or(__xor(__absx, __x._M_data), __truncated)
+				  : __x._M_data;
+      }
 
     // _S_round {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
-    _S_round(_SimdWrapper<_Tp, _Np> __x)
-    {
-      const auto __abs_x = _SuperImpl::_S_abs(__x);
-      const auto __t_abs = _SuperImpl::_S_trunc(__abs_x)._M_data;
-      const auto __r_abs // round(abs(x)) =
-	= __t_abs + (__abs_x._M_data - __t_abs >= _Tp(.5) ? _Tp(1) : 0);
-      return __or(__xor(__abs_x._M_data, __x._M_data), __r_abs);
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
+      _S_round(_SimdWrapper<_Tp, _Np> __x)
+      {
+	const auto __abs_x = _SuperImpl::_S_abs(__x);
+	const auto __t_abs = _SuperImpl::_S_trunc(__abs_x)._M_data;
+	const auto __r_abs // round(abs(x)) =
+	  = __t_abs + (__abs_x._M_data - __t_abs >= _Tp(.5) ? _Tp(1) : 0);
+	return __or(__xor(__abs_x._M_data, __x._M_data), __r_abs);
+      }
 
     // _S_floor {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
-    _S_floor(_SimdWrapper<_Tp, _Np> __x)
-    {
-      const auto __y = _SuperImpl::_S_trunc(__x)._M_data;
-      const auto __negative_input
-	= __vector_bitcast<_Tp>(__x._M_data < __vector_broadcast<_Np, _Tp>(0));
-      const auto __mask
-	= __andnot(__vector_bitcast<_Tp>(__y == __x._M_data), __negative_input);
-      return __or(__andnot(__mask, __y),
-		  __and(__mask, __y - __vector_broadcast<_Np, _Tp>(1)));
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
+      _S_floor(_SimdWrapper<_Tp, _Np> __x)
+      {
+	const auto __y = _SuperImpl::_S_trunc(__x)._M_data;
+	const auto __negative_input
+	  = __vector_bitcast<_Tp>(__x._M_data < __vector_broadcast<_Np, _Tp>(0));
+	const auto __mask
+	  = __andnot(__vector_bitcast<_Tp>(__y == __x._M_data), __negative_input);
+	return __or(__andnot(__mask, __y),
+		    __and(__mask, __y - __vector_broadcast<_Np, _Tp>(1)));
+      }
 
     // _S_ceil {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
-    _S_ceil(_SimdWrapper<_Tp, _Np> __x)
-    {
-      const auto __y = _SuperImpl::_S_trunc(__x)._M_data;
-      const auto __negative_input
-	= __vector_bitcast<_Tp>(__x._M_data < __vector_broadcast<_Np, _Tp>(0));
-      const auto __inv_mask
-	= __or(__vector_bitcast<_Tp>(__y == __x._M_data), __negative_input);
-      return __or(__and(__inv_mask, __y),
-		  __andnot(__inv_mask, __y + __vector_broadcast<_Np, _Tp>(1)));
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
+      _S_ceil(_SimdWrapper<_Tp, _Np> __x)
+      {
+	const auto __y = _SuperImpl::_S_trunc(__x)._M_data;
+	const auto __negative_input
+	  = __vector_bitcast<_Tp>(__x._M_data < __vector_broadcast<_Np, _Tp>(0));
+	const auto __inv_mask
+	  = __or(__vector_bitcast<_Tp>(__y == __x._M_data), __negative_input);
+	return __or(__and(__inv_mask, __y),
+		    __andnot(__inv_mask, __y + __vector_broadcast<_Np, _Tp>(1)));
+      }
 
     // _S_isnan {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
-    _S_isnan([[maybe_unused]] _SimdWrapper<_Tp, _Np> __x)
-    {
-  #if __FINITE_MATH_ONLY__
-      return {}; // false
-  #elif !defined __SUPPORT_SNAN__
-      return ~(__x._M_data == __x._M_data);
-  #elif defined __STDC_IEC_559__
-      using _Ip = __int_for_sizeof_t<_Tp>;
-      const auto __absn = __vector_bitcast<_Ip>(_SuperImpl::_S_abs(__x));
-      const auto __infn
-	= __vector_bitcast<_Ip>(__vector_broadcast<_Np>(__infinity_v<_Tp>));
-      return __infn < __absn;
-  #else
-  #error "Not implemented: how to support SNaN but non-IEC559 floating-point?"
-  #endif
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
+      _S_isnan([[maybe_unused]] _SimdWrapper<_Tp, _Np> __x)
+      {
+#if __FINITE_MATH_ONLY__
+	return {}; // false
+#elif !defined __SUPPORT_SNAN__
+	return ~(__x._M_data == __x._M_data);
+#elif defined __STDC_IEC_559__
+	using _Ip = __int_for_sizeof_t<_Tp>;
+	const auto __absn = __vector_bitcast<_Ip>(_SuperImpl::_S_abs(__x));
+	const auto __infn
+	  = __vector_bitcast<_Ip>(__vector_broadcast<_Np>(__infinity_v<_Tp>));
+	return __infn < __absn;
+#else
+#error "Not implemented: how to support SNaN but non-IEC559 floating-point?"
+#endif
+      }
 
     // _S_isfinite {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
-    _S_isfinite([[maybe_unused]] _SimdWrapper<_Tp, _Np> __x)
-    {
-  #if __FINITE_MATH_ONLY__
-      using _UV = typename _MaskMember<_Tp>::_BuiltinType;
-      _GLIBCXX_SIMD_USE_CONSTEXPR _UV __alltrue = ~_UV();
-      return __alltrue;
-  #else
-      // if all exponent bits are set, __x is either inf or NaN
-      using _Ip = __int_for_sizeof_t<_Tp>;
-      const auto __absn = __vector_bitcast<_Ip>(_SuperImpl::_S_abs(__x));
-      const auto __maxn
-	= __vector_bitcast<_Ip>(__vector_broadcast<_Np>(__finite_max_v<_Tp>));
-      return __absn <= __maxn;
-  #endif
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
+      _S_isfinite([[maybe_unused]] _SimdWrapper<_Tp, _Np> __x)
+      {
+#if __FINITE_MATH_ONLY__
+	using _UV = typename _MaskMember<_Tp>::_BuiltinType;
+	_GLIBCXX_SIMD_USE_CONSTEXPR _UV __alltrue = ~_UV();
+	return __alltrue;
+#else
+	// if all exponent bits are set, __x is either inf or NaN
+	using _Ip = __int_for_sizeof_t<_Tp>;
+	const auto __absn = __vector_bitcast<_Ip>(_SuperImpl::_S_abs(__x));
+	const auto __maxn
+	  = __vector_bitcast<_Ip>(__vector_broadcast<_Np>(__finite_max_v<_Tp>));
+	return __absn <= __maxn;
+#endif
+      }
 
     // _S_isunordered {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
-    _S_isunordered(_SimdWrapper<_Tp, _Np> __x, _SimdWrapper<_Tp, _Np> __y)
-    {
-      return __or(_S_isnan(__x), _S_isnan(__y));
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
+      _S_isunordered(_SimdWrapper<_Tp, _Np> __x, _SimdWrapper<_Tp, _Np> __y)
+      { return __or(_S_isnan(__x), _S_isnan(__y)); }
 
     // _S_signbit {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
-    _S_signbit(_SimdWrapper<_Tp, _Np> __x)
-    {
-      using _Ip = __int_for_sizeof_t<_Tp>;
-      return __vector_bitcast<_Ip>(__x) < 0;
-      // Arithmetic right shift (SRA) would also work (instead of compare), but
-      // 64-bit SRA isn't available on x86 before AVX512. And in general,
-      // compares are more likely to be efficient than SRA.
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
+      _S_signbit(_SimdWrapper<_Tp, _Np> __x)
+      {
+	using _Ip = __int_for_sizeof_t<_Tp>;
+	return __vector_bitcast<_Ip>(__x) < 0;
+	// Arithmetic right shift (SRA) would also work (instead of compare), but
+	// 64-bit SRA isn't available on x86 before AVX512. And in general,
+	// compares are more likely to be efficient than SRA.
+      }
 
     // _S_isinf {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
-    _S_isinf([[maybe_unused]] _SimdWrapper<_Tp, _Np> __x)
-    {
-  #if __FINITE_MATH_ONLY__
-      return {}; // false
-  #else
-      return _SuperImpl::template _S_equal_to<_Tp, _Np>(_SuperImpl::_S_abs(__x),
-							__vector_broadcast<_Np>(
-							  __infinity_v<_Tp>));
-      // alternative:
-      // compare to inf using the corresponding integer type
-      /*
-	 return
-	 __vector_bitcast<_Tp>(__vector_bitcast<__int_for_sizeof_t<_Tp>>(
-			       _S_abs(__x)._M_data)
-	 ==
-	 __vector_bitcast<__int_for_sizeof_t<_Tp>>(__vector_broadcast<_Np>(
-	 __infinity_v<_Tp>)));
-	 */
-  #endif
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
+      _S_isinf([[maybe_unused]] _SimdWrapper<_Tp, _Np> __x)
+      {
+#if __FINITE_MATH_ONLY__
+	return {}; // false
+#else
+	return _SuperImpl::template _S_equal_to<_Tp, _Np>(_SuperImpl::_S_abs(__x),
+							  __vector_broadcast<_Np>(
+							    __infinity_v<_Tp>));
+	// alternative:
+	// compare to inf using the corresponding integer type
+	/*
+	   return
+	   __vector_bitcast<_Tp>(__vector_bitcast<__int_for_sizeof_t<_Tp>>(
+				 _S_abs(__x)._M_data)
+	   ==
+	   __vector_bitcast<__int_for_sizeof_t<_Tp>>(__vector_broadcast<_Np>(
+	   __infinity_v<_Tp>)));
+	   */
+#endif
+      }
 
     // _S_isnormal {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
-    _S_isnormal(_SimdWrapper<_Tp, _Np> __x)
-    {
-      using _Ip = __int_for_sizeof_t<_Tp>;
-      const auto __absn = __vector_bitcast<_Ip>(_SuperImpl::_S_abs(__x));
-      const auto __minn
-	= __vector_bitcast<_Ip>(__vector_broadcast<_Np>(__norm_min_v<_Tp>));
-  #if __FINITE_MATH_ONLY__
-      return __absn >= __minn;
-  #else
-      const auto __maxn
-	= __vector_bitcast<_Ip>(__vector_broadcast<_Np>(__finite_max_v<_Tp>));
-      return __minn <= __absn && __absn <= __maxn;
-  #endif
-    }
+      _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
+      _S_isnormal(_SimdWrapper<_Tp, _Np> __x)
+      {
+	using _Ip = __int_for_sizeof_t<_Tp>;
+	const auto __absn = __vector_bitcast<_Ip>(_SuperImpl::_S_abs(__x));
+	const auto __minn
+	  = __vector_bitcast<_Ip>(__vector_broadcast<_Np>(__norm_min_v<_Tp>));
+#if __FINITE_MATH_ONLY__
+	return __absn >= __minn;
+#else
+	const auto __maxn
+	  = __vector_bitcast<_Ip>(__vector_broadcast<_Np>(__finite_max_v<_Tp>));
+	return __minn <= __absn && __absn <= __maxn;
+#endif
+      }
 
     // _S_fpclassify {{{3
     template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static __fixed_size_storage_t<int, _Np>
-    _S_fpclassify(_SimdWrapper<_Tp, _Np> __x)
-    {
-      using _I = __int_for_sizeof_t<_Tp>;
-      const auto __xn
-	= __vector_bitcast<_I>(__to_intrin(_SuperImpl::_S_abs(__x)));
-      constexpr size_t _NI = sizeof(__xn) / sizeof(_I);
-      _GLIBCXX_SIMD_USE_CONSTEXPR auto __minn
-	= __vector_bitcast<_I>(__vector_broadcast<_NI>(__norm_min_v<_Tp>));
-      _GLIBCXX_SIMD_USE_CONSTEXPR auto __infn
-	= __vector_bitcast<_I>(__vector_broadcast<_NI>(__infinity_v<_Tp>));
+      _GLIBCXX_SIMD_INTRINSIC static __fixed_size_storage_t<int, _Np>
+      _S_fpclassify(_SimdWrapper<_Tp, _Np> __x)
+      {
+	using _I = __int_for_sizeof_t<_Tp>;
+	const auto __xn
+	  = __vector_bitcast<_I>(__to_intrin(_SuperImpl::_S_abs(__x)));
+	constexpr size_t _NI = sizeof(__xn) / sizeof(_I);
+	_GLIBCXX_SIMD_USE_CONSTEXPR auto __minn
+	  = __vector_bitcast<_I>(__vector_broadcast<_NI>(__norm_min_v<_Tp>));
 
-      _GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_normal
-	= __vector_broadcast<_NI, _I>(FP_NORMAL);
-  #if !__FINITE_MATH_ONLY__
-      _GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_nan
-	= __vector_broadcast<_NI, _I>(FP_NAN);
-      _GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_infinite
-	= __vector_broadcast<_NI, _I>(FP_INFINITE);
-  #endif
-  #ifndef __FAST_MATH__
-      _GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_subnormal
-	= __vector_broadcast<_NI, _I>(FP_SUBNORMAL);
-  #endif
-      _GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_zero
-	= __vector_broadcast<_NI, _I>(FP_ZERO);
+	_GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_normal
+	  = __vector_broadcast<_NI, _I>(FP_NORMAL);
+#if !__FINITE_MATH_ONLY__
+	_GLIBCXX_SIMD_USE_CONSTEXPR auto __infn
+	  = __vector_bitcast<_I>(__vector_broadcast<_NI>(__infinity_v<_Tp>));
+	_GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_nan
+	  = __vector_broadcast<_NI, _I>(FP_NAN);
+	_GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_infinite
+	  = __vector_broadcast<_NI, _I>(FP_INFINITE);
+#endif
+#ifndef __FAST_MATH__
+	_GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_subnormal
+	  = __vector_broadcast<_NI, _I>(FP_SUBNORMAL);
+#endif
+	_GLIBCXX_SIMD_USE_CONSTEXPR auto __fp_zero
+	  = __vector_broadcast<_NI, _I>(FP_ZERO);
 
-      __vector_type_t<_I, _NI>
-	__tmp = __xn < __minn
+	__vector_type_t<_I, _NI>
+	  __tmp = __xn < __minn
   #ifdef __FAST_MATH__
-		  ? __fp_zero
+		    ? __fp_zero
   #else
-		  ? (__xn == 0 ? __fp_zero : __fp_subnormal)
+		    ? (__xn == 0 ? __fp_zero : __fp_subnormal)
   #endif
   #if __FINITE_MATH_ONLY__
-		  : __fp_normal;
+		    : __fp_normal;
   #else
-		  : (__xn < __infn ? __fp_normal
-				   : (__xn == __infn ? __fp_infinite : __fp_nan));
+		    : (__xn < __infn ? __fp_normal
+				     : (__xn == __infn ? __fp_infinite : __fp_nan));
   #endif
 
-      if constexpr (sizeof(_I) == sizeof(int))
-	{
-	  using _FixedInt = __fixed_size_storage_t<int, _Np>;
-	  const auto __as_int = __vector_bitcast<int, _Np>(__tmp);
-	  if constexpr (_FixedInt::_S_tuple_size == 1)
-	    return {__as_int};
-	  else if constexpr (_FixedInt::_S_tuple_size == 2
-			     && is_same_v<
-			       typename _FixedInt::_SecondType::_FirstAbi,
-			       simd_abi::scalar>)
-	    return {__extract<0, 2>(__as_int), __as_int[_Np - 1]};
-	  else if constexpr (_FixedInt::_S_tuple_size == 2)
-	    return {__extract<0, 2>(__as_int),
-		    __auto_bitcast(__extract<1, 2>(__as_int))};
-	  else
-	    __assert_unreachable<_Tp>();
-	}
-      else if constexpr (_Np == 2 && sizeof(_I) == 8
-			 && __fixed_size_storage_t<int, _Np>::_S_tuple_size == 2)
-	{
-	  const auto __aslong = __vector_bitcast<_LLong>(__tmp);
-	  return {int(__aslong[0]), {int(__aslong[1])}};
-	}
-  #if _GLIBCXX_SIMD_X86INTRIN
-      else if constexpr (sizeof(_Tp) == 8 && sizeof(__tmp) == 32
-			 && __fixed_size_storage_t<int, _Np>::_S_tuple_size == 1)
-	return {_mm_packs_epi32(__to_intrin(__lo128(__tmp)),
-				__to_intrin(__hi128(__tmp)))};
-      else if constexpr (sizeof(_Tp) == 8 && sizeof(__tmp) == 64
-			 && __fixed_size_storage_t<int, _Np>::_S_tuple_size == 1)
-	return {_mm512_cvtepi64_epi32(__to_intrin(__tmp))};
-  #endif // _GLIBCXX_SIMD_X86INTRIN
-      else if constexpr (__fixed_size_storage_t<int, _Np>::_S_tuple_size == 1)
-	return {__call_with_subscripts<_Np>(__vector_bitcast<_LLong>(__tmp),
-					    [](auto... __l) {
-					      return __make_wrapper<int>(__l...);
-					    })};
-      else
-	__assert_unreachable<_Tp>();
-    }
+	if constexpr (sizeof(_I) == sizeof(int))
+	  {
+	    using _FixedInt = __fixed_size_storage_t<int, _Np>;
+	    const auto __as_int = __vector_bitcast<int, _Np>(__tmp);
+	    if constexpr (_FixedInt::_S_tuple_size == 1)
+	      return {__as_int};
+	    else if constexpr (_FixedInt::_S_tuple_size == 2
+				 && is_same_v<
+				      typename _FixedInt::_SecondType::_FirstAbi,
+				      simd_abi::scalar>)
+	      return {__extract<0, 2>(__as_int), __as_int[_Np - 1]};
+	    else if constexpr (_FixedInt::_S_tuple_size == 2)
+	      return {__extract<0, 2>(__as_int),
+		      __auto_bitcast(__extract<1, 2>(__as_int))};
+	    else
+	      __assert_unreachable<_Tp>();
+	  }
+	else if constexpr (_Np == 2 && sizeof(_I) == 8
+			     && __fixed_size_storage_t<int, _Np>::_S_tuple_size == 2)
+	  {
+	    const auto __aslong = __vector_bitcast<_LLong>(__tmp);
+	    return {int(__aslong[0]), {int(__aslong[1])}};
+	  }
+#if _GLIBCXX_SIMD_X86INTRIN
+	else if constexpr (sizeof(_Tp) == 8 && sizeof(__tmp) == 32
+			     && __fixed_size_storage_t<int, _Np>::_S_tuple_size == 1)
+	  return {_mm_packs_epi32(__to_intrin(__lo128(__tmp)),
+				  __to_intrin(__hi128(__tmp)))};
+	else if constexpr (sizeof(_Tp) == 8 && sizeof(__tmp) == 64
+			     && __fixed_size_storage_t<int, _Np>::_S_tuple_size == 1)
+	  return {_mm512_cvtepi64_epi32(__to_intrin(__tmp))};
+#endif // _GLIBCXX_SIMD_X86INTRIN
+	else if constexpr (__fixed_size_storage_t<int, _Np>::_S_tuple_size == 1)
+	  return {__call_with_subscripts<_Np>(__vector_bitcast<_LLong>(__tmp),
+					      [](auto... __l) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+						return __make_wrapper<int>(__l...);
+					      })};
+	else
+	  __assert_unreachable<_Tp>();
+      }
 
     // _S_increment & _S_decrement{{{2
     template <typename _Tp, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_increment(_SimdWrapper<_Tp, _Np>& __x)
       { __x = __x._M_data + 1; }
 
     template <typename _Tp, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_decrement(_SimdWrapper<_Tp, _Np>& __x)
       { __x = __x._M_data - 1; }
 
     // smart_reference access {{{2
     template <typename _Tp, size_t _Np, typename _Up>
-      _GLIBCXX_SIMD_INTRINSIC constexpr static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_set(_SimdWrapper<_Tp, _Np>& __v, int __i, _Up&& __x) noexcept
       { __v._M_set(__i, static_cast<_Up&&>(__x)); }
 
     // _S_masked_assign{{{2
     template <typename _Tp, typename _K, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_masked_assign(_SimdWrapper<_K, _Np> __k, _SimdWrapper<_Tp, _Np>& __lhs,
 		       __type_identity_t<_SimdWrapper<_Tp, _Np>> __rhs)
       {
@@ -2442,7 +2488,7 @@ template <typename _Abi>
       }
 
     template <typename _Tp, typename _K, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_masked_assign(_SimdWrapper<_K, _Np> __k, _SimdWrapper<_Tp, _Np>& __lhs,
 		       __type_identity_t<_Tp> __rhs)
       {
@@ -2470,7 +2516,7 @@ template <typename _Abi>
 
     // _S_masked_cassign {{{2
     template <typename _Op, typename _Tp, typename _K, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_masked_cassign(const _SimdWrapper<_K, _Np> __k,
 			_SimdWrapper<_Tp, _Np>& __lhs,
 			const __type_identity_t<_SimdWrapper<_Tp, _Np>> __rhs,
@@ -2486,7 +2532,7 @@ template <typename _Abi>
       }
 
     template <typename _Op, typename _Tp, typename _K, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_masked_cassign(const _SimdWrapper<_K, _Np> __k,
 			_SimdWrapper<_Tp, _Np>& __lhs,
 			const __type_identity_t<_Tp> __rhs, _Op __op)
@@ -2495,7 +2541,7 @@ template <typename _Abi>
     // _S_masked_unary {{{2
     template <template <typename> class _Op, typename _Tp, typename _K,
 	      size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
       _S_masked_unary(const _SimdWrapper<_K, _Np> __k,
 		      const _SimdWrapper<_Tp, _Np> __v)
       {
@@ -2505,8 +2551,31 @@ template <typename _Abi>
 	_Op<decltype(__vv)> __op;
 	if (__k._M_is_constprop_all_of())
 	  return __data(__op(__vv));
-	else
-	  return _CommonImpl::_S_blend(__k, __v, __data(__op(__vv)));
+	else if constexpr (is_same_v<_Op<void>, __increment<void>>)
+	  {
+	    static_assert(not std::is_same_v<_K, bool>);
+	    if constexpr (is_integral_v<_Tp>)
+	      // Take a shortcut knowing that __k is an integer vector with values -1 or 0.
+	      return __v._M_data - __vector_bitcast<_Tp>(__k._M_data);
+	    else if constexpr (not __have_avx2)
+	      return __v._M_data
+		       + __vector_bitcast<_Tp>(__k._M_data & __builtin_bit_cast(
+							       _K, _Tp(1)));
+	    // starting with AVX2 it is more efficient to blend after add
+	  }
+	else if constexpr (is_same_v<_Op<void>, __decrement<void>>)
+	  {
+	    static_assert(not std::is_same_v<_K, bool>);
+	    if constexpr (is_integral_v<_Tp>)
+	      // Take a shortcut knowing that __k is an integer vector with values -1 or 0.
+	      return __v._M_data + __vector_bitcast<_Tp>(__k._M_data);
+	    else if constexpr (not __have_avx2)
+	      return __v._M_data
+		       - __vector_bitcast<_Tp>(__k._M_data & __builtin_bit_cast(
+							       _K, _Tp(1)));
+	    // starting with AVX2 it is more efficient to blend after sub
+	  }
+	return _CommonImpl::_S_blend(__k, __v, __data(__op(__vv)));
       }
 
     //}}}2
@@ -2534,13 +2603,13 @@ struct _MaskImplBuiltinMixin
     _S_to_maskvector(_BitMask<_Np, _Sanitized> __x)
     {
       static_assert(is_same_v<_Up, __int_for_sizeof_t<_Up>>);
-      return __generate_vector<__vector_type_t<_Up, _ToN>>([&](
-	auto __i) constexpr {
-	if constexpr (__i < _Np)
-	  return __x[__i] ? ~_Up() : _Up();
-	else
-	  return _Up();
-      });
+      return __generate_vector<__vector_type_t<_Up, _ToN>>(
+	       [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		 if constexpr (__i < _Np)
+		   return __x[__i] ? ~_Up() : _Up();
+		 else
+		   return _Up();
+	       });
     }
 
   template <typename _Up, size_t _UpN = 0, typename _Tp, size_t _Np,
@@ -2581,13 +2650,13 @@ struct _MaskImplBuiltinMixin
 	  -1, -1, -1, -1, -1>(__y); else
 	  */
 	  {
-	    return __generate_vector<__vector_type_t<_Up, _ToN>>([&](
-	      auto __i) constexpr {
-	      if constexpr (__i < _Np)
-		return _Up(__x[__i.value]);
-	      else
-		return _Up();
-	    });
+	    return __generate_vector<__vector_type_t<_Up, _ToN>>(
+		     [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		       if constexpr (__i < _Np)
+			 return _Up(__x[__i.value]);
+		       else
+			 return _Up();
+		     });
 	  }
 	}
     }
@@ -2605,7 +2674,9 @@ struct _MaskImplBuiltinMixin
 	= __vector_bitcast<_Up>(__x) >> (sizeof(_Up) * __CHAR_BIT__ - 1);
       _ULLong __r = 0;
       __execute_n_times<_Np>(
-	[&](auto __i) { __r |= _ULLong(__bools[__i.value]) << __i; });
+	[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	  __r |= _ULLong(__bools[__i.value]) << __i;
+	});
       return __r;
     }
 
@@ -2637,10 +2708,7 @@ template <typename _Abi>
     template <typename _Tp>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember<_Tp>
       _S_broadcast(bool __x)
-      {
-	return __x ? _Abi::template _S_implicit_mask<_Tp>()
-		   : _MaskMember<_Tp>();
-      }
+      { return __x ? _Abi::template _S_implicit_mask<_Tp>() : _MaskMember<_Tp>(); }
 
     // }}}
     // _S_load {{{
@@ -2649,17 +2717,18 @@ template <typename _Abi>
       _S_load(const bool* __mem)
       {
 	using _I = __int_for_sizeof_t<_Tp>;
-	if constexpr (sizeof(_Tp) == sizeof(bool))
-	  {
-	    const auto __bools
-	      = _CommonImpl::template _S_load<_I, _S_size<_Tp>>(__mem);
-	    // bool is {0, 1}, everything else is UB
-	    return __bools > 0;
-	  }
-	else
-	  return __generate_vector<_I, _S_size<_Tp>>([&](auto __i) constexpr {
-	    return __mem[__i] ? ~_I() : _I();
-	  });
+	if (not __builtin_is_constant_evaluated())
+	  if constexpr (sizeof(_Tp) == sizeof(bool))
+	    {
+	      const auto __bools
+		= _CommonImpl::template _S_load<_I, _S_size<_Tp>>(__mem);
+	      // bool is {0, 1}, everything else is UB
+	      return __bools > 0;
+	    }
+	return __generate_vector<_I, _S_size<_Tp>>(
+		 [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __mem[__i] ? ~_I() : _I();
+		 });
       }
 
     // }}}
@@ -2732,7 +2801,7 @@ template <typename _Abi>
 	// AVX(2) has 32/64 bit maskload, but nothing at 8 bit granularity
 	auto __tmp = __wrapper_bitcast<__int_for_sizeof_t<_Tp>>(__merge);
 	_BitOps::_S_bit_iteration(_SuperImpl::_S_to_bits(__mask),
-				  [&](auto __i) {
+				  [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 				    __tmp._M_set(__i, -__mem[__i]);
 				  });
 	__merge = __wrapper_bitcast<_Tp>(__tmp);
@@ -2741,10 +2810,10 @@ template <typename _Abi>
 
     // _S_store {{{2
     template <typename _Tp, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void _S_store(_SimdWrapper<_Tp, _Np> __v,
-						   bool* __mem) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
+      _S_store(_SimdWrapper<_Tp, _Np> __v, bool* __mem) noexcept
       {
-	__execute_n_times<_Np>([&](auto __i) constexpr {
+	__execute_n_times<_Np>([&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  __mem[__i] = __v[__i];
 	});
       }
@@ -2755,31 +2824,27 @@ template <typename _Abi>
       _S_masked_store(const _SimdWrapper<_Tp, _Np> __v, bool* __mem,
 		      const _SimdWrapper<_Tp, _Np> __k) noexcept
       {
-	_BitOps::_S_bit_iteration(
-	  _SuperImpl::_S_to_bits(__k), [&](auto __i) constexpr {
-	    __mem[__i] = __v[__i];
-	  });
+	_BitOps::_S_bit_iteration(_SuperImpl::_S_to_bits(__k),
+				  [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+				    __mem[__i] = __v[__i];
+				  });
       }
 
     // _S_from_bitmask{{{2
     template <size_t _Np, typename _Tp>
       _GLIBCXX_SIMD_INTRINSIC static _MaskMember<_Tp>
       _S_from_bitmask(_SanitizedBitMask<_Np> __bits, _TypeTag<_Tp>)
-      {
-	return _SuperImpl::template _S_to_maskvector<_Tp, _S_size<_Tp>>(__bits);
-      }
+      { return _SuperImpl::template _S_to_maskvector<_Tp, _S_size<_Tp>>(__bits); }
 
     // logical and bitwise operators {{{2
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_logical_and(const _SimdWrapper<_Tp, _Np>& __x,
-		     const _SimdWrapper<_Tp, _Np>& __y)
+      _S_logical_and(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       { return __and(__x._M_data, __y._M_data); }
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_logical_or(const _SimdWrapper<_Tp, _Np>& __x,
-		    const _SimdWrapper<_Tp, _Np>& __y)
+      _S_logical_or(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       { return __or(__x._M_data, __y._M_data); }
 
     template <typename _Tp, size_t _Np>
@@ -2795,26 +2860,23 @@ template <typename _Abi>
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_bit_and(const _SimdWrapper<_Tp, _Np>& __x,
-		 const _SimdWrapper<_Tp, _Np>& __y)
+      _S_bit_and(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       { return __and(__x._M_data, __y._M_data); }
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_bit_or(const _SimdWrapper<_Tp, _Np>& __x,
-		const _SimdWrapper<_Tp, _Np>& __y)
+      _S_bit_or(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       { return __or(__x._M_data, __y._M_data); }
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_bit_xor(const _SimdWrapper<_Tp, _Np>& __x,
-		 const _SimdWrapper<_Tp, _Np>& __y)
+      _S_bit_xor(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       { return __xor(__x._M_data, __y._M_data); }
 
     // smart_reference access {{{2
     template <typename _Tp, size_t _Np>
-      static constexpr void _S_set(_SimdWrapper<_Tp, _Np>& __k, int __i,
-				   bool __x) noexcept
+      static constexpr void
+      _S_set(_SimdWrapper<_Tp, _Np>& __k, int __i, bool __x) noexcept
       {
 	if constexpr (is_same_v<_Tp, bool>)
 	  __k._M_set(__i, __x);
@@ -2825,8 +2887,8 @@ template <typename _Abi>
 	      {
 		__k = __generate_from_n_evaluations<_Np,
 						    __vector_type_t<_Tp, _Np>>(
-		  [&](auto __j) {
-		    if (__i == __j)
+		  [&](auto __j) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		    if (__i == static_cast<int>(__j))
 		      return _Tp(-__x);
 		    else
 		      return __k[+__j];
@@ -2840,15 +2902,13 @@ template <typename _Abi>
     // _S_masked_assign{{{2
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static void
-      _S_masked_assign(_SimdWrapper<_Tp, _Np> __k,
-		       _SimdWrapper<_Tp, _Np>& __lhs,
+      _S_masked_assign(_SimdWrapper<_Tp, _Np> __k, _SimdWrapper<_Tp, _Np>& __lhs,
 		       __type_identity_t<_SimdWrapper<_Tp, _Np>> __rhs)
       { __lhs = _CommonImpl::_S_blend(__k, __lhs, __rhs); }
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static void
-      _S_masked_assign(_SimdWrapper<_Tp, _Np> __k,
-		       _SimdWrapper<_Tp, _Np>& __lhs, bool __rhs)
+      _S_masked_assign(_SimdWrapper<_Tp, _Np> __k, _SimdWrapper<_Tp, _Np>& __lhs, bool __rhs)
       {
 	if (__builtin_constant_p(__rhs))
 	  {
@@ -2870,7 +2930,8 @@ template <typename _Abi>
       {
 	return __call_with_subscripts(
 	  __data(__k), make_index_sequence<_S_size<_Tp>>(),
-	  [](const auto... __ent) constexpr { return (... && !(__ent == 0)); });
+	  [](const auto... __ent) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+	  { return (... && !(__ent == 0)); });
       }
 
     // }}}
@@ -2881,7 +2942,8 @@ template <typename _Abi>
       {
 	return __call_with_subscripts(
 	  __data(__k), make_index_sequence<_S_size<_Tp>>(),
-	  [](const auto... __ent) constexpr { return (... || !(__ent == 0)); });
+	  [](const auto... __ent) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+	  { return (... || !(__ent == 0)); });
       }
 
     // }}}
@@ -2892,7 +2954,8 @@ template <typename _Abi>
       {
 	return __call_with_subscripts(
 	  __data(__k), make_index_sequence<_S_size<_Tp>>(),
-	  [](const auto... __ent) constexpr { return (... && (__ent == 0)); });
+	  [](const auto... __ent) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+	  { return (... && (__ent == 0)); });
       }
 
     // }}}
@@ -2925,20 +2988,14 @@ template <typename _Abi>
     template <typename _Tp>
       _GLIBCXX_SIMD_INTRINSIC static int
       _S_find_first_set(simd_mask<_Tp, _Abi> __k)
-      {
-	return std::__countr_zero(
-	  _SuperImpl::_S_to_bits(__data(__k))._M_to_bits());
-      }
+      { return std::__countr_zero(_SuperImpl::_S_to_bits(__data(__k))._M_to_bits()); }
 
     // }}}
     // _S_find_last_set {{{
     template <typename _Tp>
       _GLIBCXX_SIMD_INTRINSIC static int
       _S_find_last_set(simd_mask<_Tp, _Abi> __k)
-      {
-	return std::__bit_width(
-	  _SuperImpl::_S_to_bits(__data(__k))._M_to_bits()) - 1;
-      }
+      { return std::__bit_width(_SuperImpl::_S_to_bits(__data(__k))._M_to_bits()) - 1; }
 
     // }}}
   };
diff --git a/libstdc++-v3/include/experimental/bits/simd_converter.h b/libstdc++-v3/include/experimental/bits/simd_converter.h
index 9c8bf382df9..66fdf24c588 100644
--- a/libstdc++-v3/include/experimental/bits/simd_converter.h
+++ b/libstdc++-v3/include/experimental/bits/simd_converter.h
@@ -121,7 +121,7 @@ template <typename _From, typename _To, int _Np>
 	{
 	  return __call_with_subscripts(
 	    __x, make_index_sequence<_Np>(),
-	    [](auto... __values) constexpr->_Ret {
+	    [](auto... __values) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA -> _Ret {
 	      return __make_simd_tuple<_To, decltype((void) __values,
 						     simd_abi::scalar())...>(
 		static_cast<_To>(__values)...);
@@ -233,7 +233,9 @@ template <typename _From, typename _To, int _Np>
 	  static_assert(_Ret::_FirstAbi::template _S_is_partial<_To>);
 	  return _Ret{__generate_from_n_evaluations<
 	    _Np, typename _VectorTraits<typename _Ret::_FirstType>::type>(
-	    [&](auto __i) { return static_cast<_To>(__x[__i]); })};
+	    [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	      return static_cast<_To>(__x[__i]);
+	    })};
 	}
       else
 	{
@@ -241,7 +243,7 @@ template <typename _From, typename _To, int _Np>
 	  constexpr auto __n
 	    = __div_roundup(_Ret::_S_first_size, _Arg::_S_first_size);
 	  return __call_with_n_evaluations<__n>(
-	    [&__x](auto... __uncvted) {
+	    [&__x](auto... __uncvted) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	      // assuming _Arg Abi tags for all __i are _Arg::_FirstAbi
 	      _SimdConverter<_From, typename _Arg::_FirstAbi, _To,
 			     typename _Ret::_FirstAbi>
@@ -255,8 +257,9 @@ template <typename _From, typename _To, int _Np>
 		    _From, simd_abi::fixed_size<_Np - _Ret::_S_first_size>, _To,
 		    simd_abi::fixed_size<_Np - _Ret::_S_first_size>>()(
 		    __simd_tuple_pop_front<_Ret::_S_first_size>(__x))};
-	    },
-	    [&__x](auto __i) { return __get_tuple_at<__i>(__x); });
+	    }, [&__x](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	      return __get_tuple_at<__i>(__x);
+	    });
 	}
     }
   };
@@ -322,13 +325,14 @@ template <typename _From, int _Np, typename _To, typename _Ap>
 	return __vector_convert<__vector_type_t<_To, _Np>>(__x.first);
       else if constexpr (_Arg::_S_is_homogeneous)
 	return __call_with_n_evaluations<_Arg::_S_tuple_size>(
-	  [](auto... __members) {
+	  [](auto... __members) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    if constexpr ((is_convertible_v<decltype(__members), _To> && ...))
 	      return __vector_type_t<_To, _Np>{static_cast<_To>(__members)...};
 	    else
 	      return __vector_convert<__vector_type_t<_To, _Np>>(__members...);
-	  },
-	  [&](auto __i) { return __get_tuple_at<__i>(__x); });
+	  }, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	    return __get_tuple_at<__i>(__x);
+	  });
       else if constexpr (__fixed_size_storage_t<_To, _Np>::_S_tuple_size == 1)
 	{
 	  _SimdConverter<_From, simd_abi::fixed_size<_Np>, _To,
@@ -340,7 +344,7 @@ template <typename _From, int _Np, typename _To, typename _Ap>
 	{
 	  const _SimdWrapper<_From, _Np> __xv
 	    = __generate_from_n_evaluations<_Np, __vector_type_t<_From, _Np>>(
-	      [&](auto __i) { return __x[__i]; });
+		[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { return __x[__i]; });
 	  return __vector_convert<__vector_type_t<_To, _Np>>(__xv);
 	}
     }
diff --git a/libstdc++-v3/include/experimental/bits/simd_detail.h b/libstdc++-v3/include/experimental/bits/simd_detail.h
index ecd059610cd..03d219844cd 100644
--- a/libstdc++-v3/include/experimental/bits/simd_detail.h
+++ b/libstdc++-v3/include/experimental/bits/simd_detail.h
@@ -214,9 +214,11 @@
 
 #ifdef __clang__
 #define _GLIBCXX_SIMD_NORMAL_MATH
+#define _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
 #else
 #define _GLIBCXX_SIMD_NORMAL_MATH                                              \
   [[__gnu__::__optimize__("finite-math-only,no-signed-zeros")]]
+#define _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA __attribute__((__always_inline__))
 #endif
 #define _GLIBCXX_SIMD_NEVER_INLINE [[__gnu__::__noinline__]]
 #define _GLIBCXX_SIMD_INTRINSIC                                                \
@@ -225,7 +227,7 @@
 #define _GLIBCXX_SIMD_IS_UNLIKELY(__x) __builtin_expect(__x, 0)
 #define _GLIBCXX_SIMD_IS_LIKELY(__x) __builtin_expect(__x, 1)
 
-#if defined __STRICT_ANSI__ && __STRICT_ANSI__
+#if __STRICT_ANSI__ || defined __clang__
 #define _GLIBCXX_SIMD_CONSTEXPR
 #define _GLIBCXX_SIMD_USE_CONSTEXPR_API const
 #else
@@ -254,6 +256,8 @@
 #ifdef _GLIBCXX_SIMD_NO_ALWAYS_INLINE
 #undef _GLIBCXX_SIMD_ALWAYS_INLINE
 #define _GLIBCXX_SIMD_ALWAYS_INLINE inline
+#undef _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+#define _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
 #undef _GLIBCXX_SIMD_INTRINSIC
 #define _GLIBCXX_SIMD_INTRINSIC inline
 #endif
@@ -276,7 +280,9 @@
 #endif
 
 // integer division not optimized
+#ifndef __clang__
 #define _GLIBCXX_SIMD_WORKAROUND_PR90993 1
+#endif
 
 // very bad codegen for extraction and concatenation of 128/256 "subregisters"
 // with sizeof(element type) < 8: https://godbolt.org/g/mqUsgM
diff --git a/libstdc++-v3/include/experimental/bits/simd_fixed_size.h b/libstdc++-v3/include/experimental/bits/simd_fixed_size.h
index 2722055c899..dc5121a740a 100644
--- a/libstdc++-v3/include/experimental/bits/simd_fixed_size.h
+++ b/libstdc++-v3/include/experimental/bits/simd_fixed_size.h
@@ -55,10 +55,7 @@ template <typename _Tp, typename _A0, typename... _As>
 
 template <size_t _I, typename _Tp, typename _A0, typename... _As>
   struct __simd_tuple_element<_I, _SimdTuple<_Tp, _A0, _As...>>
-  {
-    using type =
-      typename __simd_tuple_element<_I - 1, _SimdTuple<_Tp, _As...>>::type;
-  };
+  { using type = typename __simd_tuple_element<_I - 1, _SimdTuple<_Tp, _As...>>::type; };
 
 template <size_t _I, typename _Tp>
   using __simd_tuple_element_t = typename __simd_tuple_element<_I, _Tp>::type;
@@ -80,10 +77,8 @@ template <typename _Tp, typename... _A0s, typename... _A1s>
   }
 
 template <typename _Tp, typename _A10, typename... _A1s>
-  _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple<_Tp, simd_abi::scalar, _A10,
-					       _A1s...>
-  __simd_tuple_concat(const _Tp& __left,
-		      const _SimdTuple<_Tp, _A10, _A1s...>& __right)
+  _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple<_Tp, simd_abi::scalar, _A10, _A1s...>
+  __simd_tuple_concat(const _Tp& __left, const _SimdTuple<_Tp, _A10, _A1s...>& __right)
   { return {__left, __right}; }
 
 // }}}
@@ -112,37 +107,29 @@ struct __as_simd_tuple {};
 
 template <typename _Tp, typename _A0, typename... _Abis>
   _GLIBCXX_SIMD_INTRINSIC constexpr simd<_Tp, _A0>
-  __simd_tuple_get_impl(__as_simd, const _SimdTuple<_Tp, _A0, _Abis...>& __t,
-			_SizeConstant<0>)
+  __simd_tuple_get_impl(__as_simd, const _SimdTuple<_Tp, _A0, _Abis...>& __t, _SizeConstant<0>)
   { return {__private_init, __t.first}; }
 
 template <typename _Tp, typename _A0, typename... _Abis>
   _GLIBCXX_SIMD_INTRINSIC constexpr const auto&
-  __simd_tuple_get_impl(__as_simd_tuple,
-			const _SimdTuple<_Tp, _A0, _Abis...>& __t,
+  __simd_tuple_get_impl(__as_simd_tuple, const _SimdTuple<_Tp, _A0, _Abis...>& __t,
 			_SizeConstant<0>)
   { return __t.first; }
 
 template <typename _Tp, typename _A0, typename... _Abis>
   _GLIBCXX_SIMD_INTRINSIC constexpr auto&
-  __simd_tuple_get_impl(__as_simd_tuple, _SimdTuple<_Tp, _A0, _Abis...>& __t,
-			_SizeConstant<0>)
+  __simd_tuple_get_impl(__as_simd_tuple, _SimdTuple<_Tp, _A0, _Abis...>& __t, _SizeConstant<0>)
   { return __t.first; }
 
 template <typename _R, size_t _Np, typename _Tp, typename... _Abis>
   _GLIBCXX_SIMD_INTRINSIC constexpr auto
-  __simd_tuple_get_impl(_R, const _SimdTuple<_Tp, _Abis...>& __t,
-			_SizeConstant<_Np>)
+  __simd_tuple_get_impl(_R, const _SimdTuple<_Tp, _Abis...>& __t, _SizeConstant<_Np>)
   { return __simd_tuple_get_impl(_R(), __t.second, _SizeConstant<_Np - 1>()); }
 
 template <size_t _Np, typename _Tp, typename... _Abis>
   _GLIBCXX_SIMD_INTRINSIC constexpr auto&
-  __simd_tuple_get_impl(__as_simd_tuple, _SimdTuple<_Tp, _Abis...>& __t,
-			_SizeConstant<_Np>)
-  {
-    return __simd_tuple_get_impl(__as_simd_tuple(), __t.second,
-				 _SizeConstant<_Np - 1>());
-  }
+  __simd_tuple_get_impl(__as_simd_tuple, _SimdTuple<_Tp, _Abis...>& __t, _SizeConstant<_Np>)
+  { return __simd_tuple_get_impl(__as_simd_tuple(), __t.second, _SizeConstant<_Np - 1>()); }
 
 template <size_t _Np, typename _Tp, typename... _Abis>
   _GLIBCXX_SIMD_INTRINSIC constexpr auto
@@ -154,16 +141,12 @@ template <size_t _Np, typename _Tp, typename... _Abis>
 template <size_t _Np, typename _Tp, typename... _Abis>
   _GLIBCXX_SIMD_INTRINSIC constexpr auto
   __get_tuple_at(const _SimdTuple<_Tp, _Abis...>& __t)
-  {
-    return __simd_tuple_get_impl(__as_simd_tuple(), __t, _SizeConstant<_Np>());
-  }
+  { return __simd_tuple_get_impl(__as_simd_tuple(), __t, _SizeConstant<_Np>()); }
 
 template <size_t _Np, typename _Tp, typename... _Abis>
   _GLIBCXX_SIMD_INTRINSIC constexpr auto&
   __get_tuple_at(_SimdTuple<_Tp, _Abis...>& __t)
-  {
-    return __simd_tuple_get_impl(__as_simd_tuple(), __t, _SizeConstant<_Np>());
-  }
+  { return __simd_tuple_get_impl(__as_simd_tuple(), __t, _SizeConstant<_Np>()); }
 
 // __tuple_element_meta {{{1
 template <typename _Tp, typename _Abi, size_t _Offset>
@@ -183,24 +166,25 @@ template <typename _Tp, typename _Abi, size_t _Offset>
     static constexpr _MaskImpl _S_mask_impl = {};
 
     template <size_t _Np, bool _Sanitized>
-      _GLIBCXX_SIMD_INTRINSIC static auto
+      _GLIBCXX_SIMD_INTRINSIC static constexpr auto
       _S_submask(_BitMask<_Np, _Sanitized> __bits)
       { return __bits.template _M_extract<_Offset, _S_size()>(); }
 
     template <size_t _Np, bool _Sanitized>
-      _GLIBCXX_SIMD_INTRINSIC static _MaskMember
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember
       _S_make_mask(_BitMask<_Np, _Sanitized> __bits)
       {
 	return _MaskImpl::template _S_convert<_Tp>(
 	  __bits.template _M_extract<_Offset, _S_size()>()._M_sanitized());
       }
 
-    _GLIBCXX_SIMD_INTRINSIC static _ULLong
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _ULLong
     _S_mask_to_shifted_ullong(_MaskMember __k)
     { return _MaskImpl::_S_to_bits(__k).to_ullong() << _Offset; }
   };
 
 template <size_t _Offset, typename _Tp, typename _Abi, typename... _As>
+  constexpr
   __tuple_element_meta<_Tp, _Abi, _Offset>
   __make_meta(const _SimdTuple<_Tp, _Abi, _As...>&)
   { return {}; }
@@ -212,17 +196,13 @@ template <size_t _Offset, typename _Base>
   {
     static inline constexpr size_t _S_offset = _Offset;
 
-    _GLIBCXX_SIMD_INTRINSIC char* _M_as_charptr()
-    {
-      return reinterpret_cast<char*>(this)
-	     + _S_offset * sizeof(typename _Base::value_type);
-    }
+    _GLIBCXX_SIMD_INTRINSIC char*
+    _M_as_charptr()
+    { return reinterpret_cast<char*>(this) + _S_offset * sizeof(typename _Base::value_type); }
 
-    _GLIBCXX_SIMD_INTRINSIC const char* _M_as_charptr() const
-    {
-      return reinterpret_cast<const char*>(this)
-	     + _S_offset * sizeof(typename _Base::value_type);
-    }
+    _GLIBCXX_SIMD_INTRINSIC const char*
+    _M_as_charptr() const
+    { return reinterpret_cast<const char*>(this) + _S_offset * sizeof(typename _Base::value_type); }
   };
 
 // make _WithOffset<_WithOffset> ill-formed to use:
@@ -237,18 +217,12 @@ template <size_t _Offset, typename _Tp>
 template <size_t _Offset, typename _Tp>
   decltype(auto)
   __add_offset(const _Tp& __base)
-  {
-    return static_cast<const _WithOffset<_Offset, __remove_cvref_t<_Tp>>&>(
-      __base);
-  }
+  { return static_cast<const _WithOffset<_Offset, __remove_cvref_t<_Tp>>&>(__base); }
 
 template <size_t _Offset, size_t _ExistingOffset, typename _Tp>
   decltype(auto)
   __add_offset(_WithOffset<_ExistingOffset, _Tp>& __base)
-  {
-    return static_cast<_WithOffset<_Offset + _ExistingOffset, _Tp>&>(
-      static_cast<_Tp&>(__base));
-  }
+  { return static_cast<_WithOffset<_Offset + _ExistingOffset, _Tp>&>(static_cast<_Tp&>(__base)); }
 
 template <size_t _Offset, size_t _ExistingOffset, typename _Tp>
   decltype(auto)
@@ -293,7 +267,8 @@ template <typename _FirstType, typename _SecondType>
     _SecondType second;
 
     _GLIBCXX_SIMD_INTRINSIC
-    constexpr bool _M_is_constprop() const
+    constexpr bool
+    _M_is_constprop() const
     {
       if constexpr (is_class_v<_FirstType>)
 	return first._M_is_constprop() && second._M_is_constprop();
@@ -309,7 +284,8 @@ template <typename _FirstType, typename _Tp>
     static constexpr _SimdTuple<_Tp> second = {};
 
     _GLIBCXX_SIMD_INTRINSIC
-    constexpr bool _M_is_constprop() const
+    constexpr bool
+    _M_is_constprop() const
     {
       if constexpr (is_class_v<_FirstType>)
 	return first._M_is_constprop();
@@ -348,25 +324,31 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
       = default;
 
     template <typename _Up>
-      _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple(_Up&& __x)
+      _GLIBCXX_SIMD_INTRINSIC constexpr
+      _SimdTuple(_Up&& __x)
       : _Base{static_cast<_Up&&>(__x)} {}
 
     template <typename _Up, typename _Up2>
-      _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple(_Up&& __x, _Up2&& __y)
+      _GLIBCXX_SIMD_INTRINSIC constexpr
+      _SimdTuple(_Up&& __x, _Up2&& __y)
       : _Base{static_cast<_Up&&>(__x), static_cast<_Up2&&>(__y)} {}
 
     template <typename _Up>
-      _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple(_Up&& __x, _SimdTuple<_Tp>)
+      _GLIBCXX_SIMD_INTRINSIC constexpr
+      _SimdTuple(_Up&& __x, _SimdTuple<_Tp>)
       : _Base{static_cast<_Up&&>(__x)} {}
 
-    _GLIBCXX_SIMD_INTRINSIC char* _M_as_charptr()
+    _GLIBCXX_SIMD_INTRINSIC char*
+    _M_as_charptr()
     { return reinterpret_cast<char*>(this); }
 
-    _GLIBCXX_SIMD_INTRINSIC const char* _M_as_charptr() const
+    _GLIBCXX_SIMD_INTRINSIC const char*
+    _M_as_charptr() const
     { return reinterpret_cast<const char*>(this); }
 
     template <size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC constexpr auto& _M_at()
+      _GLIBCXX_SIMD_INTRINSIC constexpr auto&
+      _M_at()
       {
 	if constexpr (_Np == 0)
 	  return first;
@@ -375,7 +357,8 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
       }
 
     template <size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC constexpr const auto& _M_at() const
+      _GLIBCXX_SIMD_INTRINSIC constexpr const auto&
+      _M_at() const
       {
 	if constexpr (_Np == 0)
 	  return first;
@@ -384,7 +367,8 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
       }
 
     template <size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC constexpr auto _M_simd_at() const
+      _GLIBCXX_SIMD_INTRINSIC constexpr auto
+      _M_simd_at() const
       {
 	if constexpr (_Np == 0)
 	  return simd<_Tp, _Abi0>(__private_init, first);
@@ -429,14 +413,15 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
 	if constexpr (is_same_v<_SimdTuple, __remove_cvref_t<_Tup>>)
 	  return __tup.first;
 	else if (__builtin_is_constant_evaluated())
-	  return __fixed_size_storage_t<_TupT, _S_first_size>::_S_generate([&](
-	    auto __meta) constexpr {
-	    return __meta._S_generator(
-	      [&](auto __i) constexpr { return __tup[__i]; },
-	      static_cast<_TupT*>(nullptr));
+	  return __fixed_size_storage_t<_TupT, _S_first_size>::_S_generate(
+		   [&](auto __meta) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		     return __meta._S_generator(
+			      [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+				return __tup[__i];
+			      }, static_cast<_TupT*>(nullptr));
 	  });
 	else
-	  return [&]() {
+	  return [&]() { // not always_inline; allow the compiler to decide
 	    __fixed_size_storage_t<_TupT, _S_first_size> __r;
 	    __builtin_memcpy(__r._M_as_charptr(), __tup._M_as_charptr(),
 			     sizeof(__r));
@@ -510,12 +495,11 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
 			 negation<is_const<remove_reference_t<_More>>>>) )
 	  {
 	    // need to write back at least one of __more after calling __fun
-	    auto&& __first = [&](auto... __args) constexpr
-	    {
+	    auto&& __first = [&](auto... __args) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	      auto __r = __fun(__tuple_element_meta<_Tp, _Abi0, 0>(), first,
 			       __args...);
 	      [[maybe_unused]] auto&& __ignore_me = {(
-		[](auto&& __dst, const auto& __src) {
+		[](auto&& __dst, const auto& __src) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		  if constexpr (is_assignable_v<decltype(__dst),
 						decltype(__dst)>)
 		    {
@@ -525,8 +509,7 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
 		}(static_cast<_More&&>(__more), __args),
 		0)...};
 	      return __r;
-	    }
-	    (_M_extract_argument(__more)...);
+	    }(_M_extract_argument(__more)...);
 	    if constexpr (_S_tuple_size == 1)
 	      return {__first};
 	    else
@@ -548,8 +531,8 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
       }
 
     template <typename _R = _Tp, typename _Fp, typename... _More>
-      _GLIBCXX_SIMD_INTRINSIC auto _M_apply_r(_Fp&& __fun,
-					      const _More&... __more) const
+      _GLIBCXX_SIMD_INTRINSIC constexpr auto
+      _M_apply_r(_Fp&& __fun, const _More&... __more) const
       {
 	auto&& __first = __fun(__tuple_element_meta<_Tp, _Abi0, 0>(), first,
 			       __more.first...);
@@ -586,48 +569,44 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
 	  return second[integral_constant<_Up, _I - simd_size_v<_Tp, _Abi0>>()];
       }
 
-    _Tp operator[](size_t __i) const noexcept
+    constexpr _Tp
+    operator[](size_t __i) const noexcept
     {
       if constexpr (_S_tuple_size == 1)
 	return _M_subscript_read(__i);
-      else
-	{
 #ifdef _GLIBCXX_SIMD_USE_ALIASING_LOADS
-	  return reinterpret_cast<const __may_alias<_Tp>*>(this)[__i];
-#else
-	  if constexpr (__is_scalar_abi<_Abi0>())
-	    {
-	      const _Tp* ptr = &first;
-	      return ptr[__i];
-	    }
-	  else
-	    return __i < simd_size_v<_Tp, _Abi0>
-		     ? _M_subscript_read(__i)
-		     : second[__i - simd_size_v<_Tp, _Abi0>];
+      else if (not __builtin_is_constant_evaluated())
+	return reinterpret_cast<const __may_alias<_Tp>*>(this)[__i];
 #endif
+      else if constexpr (__is_scalar_abi<_Abi0>())
+	{
+	  const _Tp* ptr = &first;
+	  return ptr[__i];
 	}
+      else
+	return __i < simd_size_v<_Tp, _Abi0> ? _M_subscript_read(__i)
+					     : second[__i - simd_size_v<_Tp, _Abi0>];
     }
 
-    void _M_set(size_t __i, _Tp __val) noexcept
+    constexpr void
+    _M_set(size_t __i, _Tp __val) noexcept
     {
       if constexpr (_S_tuple_size == 1)
 	return _M_subscript_write(__i, __val);
-      else
-	{
 #ifdef _GLIBCXX_SIMD_USE_ALIASING_LOADS
-	  reinterpret_cast<__may_alias<_Tp>*>(this)[__i] = __val;
-#else
-	  if (__i < simd_size_v<_Tp, _Abi0>)
-	    _M_subscript_write(__i, __val);
-	  else
-	    second._M_set(__i - simd_size_v<_Tp, _Abi0>, __val);
+      else if (not __builtin_is_constant_evaluated())
+	reinterpret_cast<__may_alias<_Tp>*>(this)[__i] = __val;
 #endif
-	}
+      else if (__i < simd_size_v<_Tp, _Abi0>)
+	_M_subscript_write(__i, __val);
+      else
+	second._M_set(__i - simd_size_v<_Tp, _Abi0>, __val);
     }
 
   private:
     // _M_subscript_read/_write {{{
-    _Tp _M_subscript_read([[maybe_unused]] size_t __i) const noexcept
+    constexpr _Tp
+    _M_subscript_read([[maybe_unused]] size_t __i) const noexcept
     {
       if constexpr (__is_vectorizable_v<_FirstType>)
 	return first;
@@ -635,7 +614,8 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
 	return first[__i];
     }
 
-    void _M_subscript_write([[maybe_unused]] size_t __i, _Tp __y) noexcept
+    constexpr void
+    _M_subscript_write([[maybe_unused]] size_t __i, _Tp __y) noexcept
     {
       if constexpr (__is_vectorizable_v<_FirstType>)
 	first = __y;
@@ -648,22 +628,22 @@ template <typename _Tp, typename _Abi0, typename... _Abis>
 
 // __make_simd_tuple {{{1
 template <typename _Tp, typename _A0>
-  _GLIBCXX_SIMD_INTRINSIC _SimdTuple<_Tp, _A0>
+  _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple<_Tp, _A0>
   __make_simd_tuple(simd<_Tp, _A0> __x0)
   { return {__data(__x0)}; }
 
 template <typename _Tp, typename _A0, typename... _As>
-  _GLIBCXX_SIMD_INTRINSIC _SimdTuple<_Tp, _A0, _As...>
+  _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple<_Tp, _A0, _As...>
   __make_simd_tuple(const simd<_Tp, _A0>& __x0, const simd<_Tp, _As>&... __xs)
   { return {__data(__x0), __make_simd_tuple(__xs...)}; }
 
 template <typename _Tp, typename _A0>
-  _GLIBCXX_SIMD_INTRINSIC _SimdTuple<_Tp, _A0>
+  _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple<_Tp, _A0>
   __make_simd_tuple(const typename _SimdTraits<_Tp, _A0>::_SimdMember& __arg0)
   { return {__arg0}; }
 
 template <typename _Tp, typename _A0, typename _A1, typename... _Abis>
-  _GLIBCXX_SIMD_INTRINSIC _SimdTuple<_Tp, _A0, _A1, _Abis...>
+  _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple<_Tp, _A0, _A1, _Abis...>
   __make_simd_tuple(
     const typename _SimdTraits<_Tp, _A0>::_SimdMember& __arg0,
     const typename _SimdTraits<_Tp, _A1>::_SimdMember& __arg1,
@@ -679,8 +659,7 @@ template <typename _Tp, size_t _Np,
 	  size_t _Offset = 0, // skip this many elements in __from0
 	  typename _R = __fixed_size_storage_t<_Tp, _Np>, typename _V0,
 	  typename _V0VT = _VectorTraits<_V0>, typename... _VX>
-  _GLIBCXX_SIMD_INTRINSIC _R constexpr __to_simd_tuple(const _V0 __from0,
-						       const _VX... __fromX)
+  _GLIBCXX_SIMD_INTRINSIC _R constexpr __to_simd_tuple(const _V0 __from0, const _VX... __fromX)
   {
     static_assert(is_same_v<typename _V0VT::value_type, _Tp>);
     static_assert(_Offset < _V0VT::_S_full_size);
@@ -767,18 +746,18 @@ template <typename _Tp, size_t _Np, typename _V, size_t _NV, typename... _VX>
 	  sizeof...(_VX) == 0,
 	  "An array of scalars must be the last argument to __to_simd_tuple");
 	return __call_with_subscripts(
-	  __from,
-	  make_index_sequence<_NV>(), [&](const auto... __args) constexpr {
-	    return __simd_tuple_concat(
-	      _SimdTuple<_Tp, simd_abi::scalar>{__args}..., _SimdTuple<_Tp>());
-	  });
+		 __from, make_index_sequence<_NV>(),
+		 [&](const auto... __args) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __simd_tuple_concat(
+			    _SimdTuple<_Tp, simd_abi::scalar>{__args}..., _SimdTuple<_Tp>());
+		 });
       }
     else
       return __call_with_subscripts(
-	__from,
-	make_index_sequence<_NV>(), [&](const auto... __args) constexpr {
-	  return __to_simd_tuple<_Tp, _Np>(__args..., __fromX...);
-	});
+	       __from, make_index_sequence<_NV>(),
+	       [&](const auto... __args) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		 return __to_simd_tuple<_Tp, _Np>(__args..., __fromX...);
+	       });
   }
 
 template <size_t, typename _Tp>
@@ -807,19 +786,19 @@ template <typename _Tp, typename _A0, size_t _NOut, size_t _Np,
 
 // __optimize_simd_tuple {{{1
 template <typename _Tp>
-  _GLIBCXX_SIMD_INTRINSIC _SimdTuple<_Tp>
+  _GLIBCXX_SIMD_INTRINSIC constexpr _SimdTuple<_Tp>
   __optimize_simd_tuple(const _SimdTuple<_Tp>)
   { return {}; }
 
 template <typename _Tp, typename _Ap>
-  _GLIBCXX_SIMD_INTRINSIC const _SimdTuple<_Tp, _Ap>&
+  _GLIBCXX_SIMD_INTRINSIC constexpr const _SimdTuple<_Tp, _Ap>&
   __optimize_simd_tuple(const _SimdTuple<_Tp, _Ap>& __x)
   { return __x; }
 
 template <typename _Tp, typename _A0, typename _A1, typename... _Abis,
 	  typename _R = __fixed_size_storage_t<
 	    _Tp, _SimdTuple<_Tp, _A0, _A1, _Abis...>::_S_size()>>
-  _GLIBCXX_SIMD_INTRINSIC _R
+  _GLIBCXX_SIMD_INTRINSIC constexpr _R
   __optimize_simd_tuple(const _SimdTuple<_Tp, _A0, _A1, _Abis...>& __x)
   {
     using _Tup = _SimdTuple<_Tp, _A0, _A1, _Abis...>;
@@ -832,7 +811,7 @@ template <typename _Tp, typename _A0, typename _A1, typename... _Abis,
 		       || _A0::template _S_is_partial<_Tp>)
       return {__generate_from_n_evaluations<_R::_S_first_size,
 					    typename _R::_FirstType>(
-		[&](auto __i) { return __x[__i]; }),
+		[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { return __x[__i]; }),
 	      __optimize_simd_tuple(
 		__simd_tuple_pop_front<_R::_S_first_size>(__x))};
     else if constexpr (is_same_v<_A0, _A1>
@@ -892,11 +871,8 @@ template <size_t _Offset = 0, typename _Tp, typename _A0, typename _A1,
 // __for_each(_SimdTuple &, const _SimdTuple &, Fun) {{{1
 template <size_t _Offset = 0, typename _Tp, typename _A0, typename _Fp>
   _GLIBCXX_SIMD_INTRINSIC constexpr void
-  __for_each(_SimdTuple<_Tp, _A0>& __a, const _SimdTuple<_Tp, _A0>& __b,
-	     _Fp&& __fun)
-  {
-    static_cast<_Fp&&>(__fun)(__make_meta<_Offset>(__a), __a.first, __b.first);
-  }
+  __for_each(_SimdTuple<_Tp, _A0>& __a, const _SimdTuple<_Tp, _A0>& __b, _Fp&& __fun)
+  { static_cast<_Fp&&>(__fun)(__make_meta<_Offset>(__a), __a.first, __b.first); }
 
 template <size_t _Offset = 0, typename _Tp, typename _A0, typename _A1,
 	  typename... _As, typename _Fp>
@@ -912,11 +888,8 @@ template <size_t _Offset = 0, typename _Tp, typename _A0, typename _A1,
 // __for_each(const _SimdTuple &, const _SimdTuple &, Fun) {{{1
 template <size_t _Offset = 0, typename _Tp, typename _A0, typename _Fp>
   _GLIBCXX_SIMD_INTRINSIC constexpr void
-  __for_each(const _SimdTuple<_Tp, _A0>& __a, const _SimdTuple<_Tp, _A0>& __b,
-	     _Fp&& __fun)
-  {
-    static_cast<_Fp&&>(__fun)(__make_meta<_Offset>(__a), __a.first, __b.first);
-  }
+  __for_each(const _SimdTuple<_Tp, _A0>& __a, const _SimdTuple<_Tp, _A0>& __b, _Fp&& __fun)
+  { static_cast<_Fp&&>(__fun)(__make_meta<_Offset>(__a), __a.first, __b.first); }
 
 template <size_t _Offset = 0, typename _Tp, typename _A0, typename _A1,
 	  typename... _As, typename _Fp>
@@ -931,9 +904,8 @@ template <size_t _Offset = 0, typename _Tp, typename _A0, typename _A1,
 
 // }}}1
 // __extract_part(_SimdTuple) {{{
-template <int _Index, int _Total, int _Combine, typename _Tp, typename _A0,
-	  typename... _As>
-  _GLIBCXX_SIMD_INTRINSIC auto // __vector_type_t or _SimdTuple
+template <int _Index, int _Total, int _Combine, typename _Tp, typename _A0, typename... _As>
+  _GLIBCXX_SIMD_INTRINSIC constexpr auto // __vector_type_t or _SimdTuple
   __extract_part(const _SimdTuple<_Tp, _A0, _As...>& __x)
   {
     // worst cases:
@@ -985,10 +957,11 @@ template <int _Index, int _Total, int _Combine, typename _Tp, typename _A0,
 	return __as_vector(simd<_Tp, _RetAbi>(element_ptr, element_aligned));
 #else
 	[[maybe_unused]] constexpr size_t __offset = __values_to_skip;
-	return __as_vector(simd<_Tp, _RetAbi>([&](auto __i) constexpr {
-	  constexpr _SizeConstant<__i + __offset> __k;
-	  return __x[__k];
-	}));
+	return __as_vector(simd<_Tp, _RetAbi>(
+			     [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			       constexpr _SizeConstant<__i + __offset> __k;
+			       return __x[__k];
+			     }));
 #endif
       }
 
@@ -1082,9 +1055,11 @@ template <typename _Tp, bool = is_arithmetic_v<__remove_cvref_t<_Tp>>>
     _Tp _M_data;
     using _TT = __remove_cvref_t<_Tp>;
 
+    constexpr
     operator _TT()
     { return _M_data; }
 
+    constexpr
     operator _TT&()
     {
       static_assert(is_lvalue_reference<_Tp>::value, "");
@@ -1092,6 +1067,7 @@ template <typename _Tp, bool = is_arithmetic_v<__remove_cvref_t<_Tp>>>
       return _M_data;
     }
 
+    constexpr
     operator _TT*()
     {
       static_assert(is_lvalue_reference<_Tp>::value, "");
@@ -1099,25 +1075,23 @@ template <typename _Tp, bool = is_arithmetic_v<__remove_cvref_t<_Tp>>>
       return &_M_data;
     }
 
-    constexpr inline __autocvt_to_simd(_Tp dd) : _M_data(dd) {}
+    constexpr inline
+    __autocvt_to_simd(_Tp dd) : _M_data(dd) {}
 
     template <typename _Abi>
+      constexpr
       operator simd<typename _TT::value_type, _Abi>()
       { return {__private_init, _M_data}; }
 
     template <typename _Abi>
+      constexpr
       operator simd<typename _TT::value_type, _Abi>&()
-      {
-	return *reinterpret_cast<simd<typename _TT::value_type, _Abi>*>(
-	  &_M_data);
-      }
+      { return *reinterpret_cast<simd<typename _TT::value_type, _Abi>*>(&_M_data); }
 
     template <typename _Abi>
+      constexpr
       operator simd<typename _TT::value_type, _Abi>*()
-      {
-	return reinterpret_cast<simd<typename _TT::value_type, _Abi>*>(
-	  &_M_data);
-      }
+      { return reinterpret_cast<simd<typename _TT::value_type, _Abi>*>(&_M_data); }
   };
 
 template <typename _Tp>
@@ -1135,9 +1109,11 @@ template <typename _Tp>
     ~__autocvt_to_simd()
     { _M_data = __data(_M_fd).first; }
 
+    constexpr
     operator fixed_size_simd<_TT, 1>()
     { return _M_fd; }
 
+    constexpr
     operator fixed_size_simd<_TT, 1> &()
     {
       static_assert(is_lvalue_reference<_Tp>::value, "");
@@ -1145,6 +1121,7 @@ template <typename _Tp>
       return _M_fd;
     }
 
+    constexpr
     operator fixed_size_simd<_TT, 1> *()
     {
       static_assert(is_lvalue_reference<_Tp>::value, "");
@@ -1221,13 +1198,17 @@ template <int _Np>
 	{
 	  // The following ensures, function arguments are passed via the stack.
 	  // This is important for ABI compatibility across TU boundaries
+	  constexpr
 	  _SimdBase(const _SimdBase&) {}
+
 	  _SimdBase() = default;
 
-	  explicit operator const _SimdMember &() const
+	  constexpr explicit
+	  operator const _SimdMember &() const
 	  { return static_cast<const simd<_Tp, _Fixed>*>(this)->_M_data; }
 
-	  explicit operator array<_Tp, _Np>() const
+	  constexpr explicit
+	  operator array<_Tp, _Np>() const
 	  {
 	    array<_Tp, _Np> __r;
 	    // _SimdMember can be larger because of higher alignment
@@ -1247,9 +1228,14 @@ template <int _Np>
 	// _SimdCastType {{{
 	struct _SimdCastType
 	{
+	  constexpr
 	  _SimdCastType(const array<_Tp, _Np>&);
+
+	  constexpr
 	  _SimdCastType(const _SimdMember& dd) : _M_data(dd) {}
-	  explicit operator const _SimdMember &() const { return _M_data; }
+
+	  constexpr explicit
+	  operator const _SimdMember &() const { return _M_data; }
 
 	private:
 	  const _SimdMember& _M_data;
@@ -1306,52 +1292,56 @@ template <int _Np>
 
     // broadcast {{{2
     template <typename _Tp>
-      static constexpr inline _SimdMember<_Tp> _S_broadcast(_Tp __x) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdMember<_Tp>
+      _S_broadcast(_Tp __x) noexcept
       {
-	return _SimdMember<_Tp>::_S_generate([&](auto __meta) constexpr {
-	  return __meta._S_broadcast(__x);
-	});
+	return _SimdMember<_Tp>::_S_generate(
+		 [&](auto __meta) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __meta._S_broadcast(__x);
+		 });
       }
 
     // _S_generator {{{2
     template <typename _Fp, typename _Tp>
-      static constexpr inline _SimdMember<_Tp> _S_generator(_Fp&& __gen,
-							    _TypeTag<_Tp>)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdMember<_Tp>
+      _S_generator(_Fp&& __gen, _TypeTag<_Tp>)
       {
-	return _SimdMember<_Tp>::_S_generate([&__gen](auto __meta) constexpr {
-	  return __meta._S_generator(
-	    [&](auto __i) constexpr {
-	      return __i < _Np ? __gen(_SizeConstant<__meta._S_offset + __i>())
-			       : 0;
-	    },
-	    _TypeTag<_Tp>());
-	});
+	return _SimdMember<_Tp>::_S_generate(
+		 [&__gen](auto __meta) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __meta._S_generator(
+			    [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			      return __i < _Np ? __gen(_SizeConstant<__meta._S_offset + __i>())
+					       : 0;
+			    },
+			    _TypeTag<_Tp>());
+		 });
       }
 
     // _S_load {{{2
     template <typename _Tp, typename _Up>
-      static inline _SimdMember<_Tp> _S_load(const _Up* __mem,
-					     _TypeTag<_Tp>) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdMember<_Tp>
+      _S_load(const _Up* __mem, _TypeTag<_Tp>) noexcept
       {
-	return _SimdMember<_Tp>::_S_generate([&](auto __meta) {
-	  return __meta._S_load(&__mem[__meta._S_offset], _TypeTag<_Tp>());
-	});
+	return _SimdMember<_Tp>::_S_generate(
+		 [&](auto __meta) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __meta._S_load(&__mem[__meta._S_offset], _TypeTag<_Tp>());
+		 });
       }
 
     // _S_masked_load {{{2
     template <typename _Tp, typename... _As, typename _Up>
-      static inline _SimdTuple<_Tp, _As...>
+      _GLIBCXX_SIMD_INTRINSIC static _SimdTuple<_Tp, _As...>
       _S_masked_load(const _SimdTuple<_Tp, _As...>& __old,
 		     const _MaskMember __bits, const _Up* __mem) noexcept
       {
 	auto __merge = __old;
-	__for_each(__merge, [&](auto __meta, auto& __native) {
+	__for_each(__merge, [&](auto __meta, auto& __native) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  if (__meta._S_submask(__bits).any())
 #pragma GCC diagnostic push
-	  // __mem + __mem._S_offset could be UB ([expr.add]/4.3, but it punts
-	  // the responsibility for avoiding UB to the caller of the masked load
-	  // via the mask. Consequently, the compiler may assume this branch is
-	  // unreachable, if the pointer arithmetic is UB.
+	    // Dereferencing __mem + __meta._S_offset could be UB ([expr.add]/4.3).
+	    // It is the responsibility of the caller of the masked load (via the mask's value) to
+	    // avoid UB. Consequently, the compiler may assume this branch is unreachable, if the
+	    // pointer arithmetic is UB.
 #pragma GCC diagnostic ignored "-Warray-bounds"
 	    __native
 	      = __meta._S_masked_load(__native, __meta._S_make_mask(__bits),
@@ -1363,21 +1353,21 @@ template <int _Np>
 
     // _S_store {{{2
     template <typename _Tp, typename _Up>
-      static inline void _S_store(const _SimdMember<_Tp>& __v, _Up* __mem,
-				  _TypeTag<_Tp>) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
+      _S_store(const _SimdMember<_Tp>& __v, _Up* __mem, _TypeTag<_Tp>) noexcept
       {
-	__for_each(__v, [&](auto __meta, auto __native) {
+	__for_each(__v, [&](auto __meta, auto __native) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  __meta._S_store(__native, &__mem[__meta._S_offset], _TypeTag<_Tp>());
 	});
       }
 
     // _S_masked_store {{{2
     template <typename _Tp, typename... _As, typename _Up>
-      static inline void _S_masked_store(const _SimdTuple<_Tp, _As...>& __v,
-					 _Up* __mem,
-					 const _MaskMember __bits) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static void
+      _S_masked_store(const _SimdTuple<_Tp, _As...>& __v, _Up* __mem,
+		      const _MaskMember __bits) noexcept
       {
-	__for_each(__v, [&](auto __meta, auto __native) {
+	__for_each(__v, [&](auto __meta, auto __native) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  if (__meta._S_submask(__bits).any())
 #pragma GCC diagnostic push
 	  // __mem + __mem._S_offset could be UB ([expr.add]/4.3, but it punts
@@ -1393,12 +1383,12 @@ template <int _Np>
 
     // negation {{{2
     template <typename _Tp, typename... _As>
-      static inline _MaskMember
+      static constexpr inline _MaskMember
       _S_negate(const _SimdTuple<_Tp, _As...>& __x) noexcept
       {
 	_MaskMember __bits = 0;
 	__for_each(
-	  __x, [&__bits](auto __meta, auto __native) constexpr {
+	  __x, [&__bits](auto __meta, auto __native) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    __bits
 	      |= __meta._S_mask_to_shifted_ullong(__meta._S_negate(__native));
 	  });
@@ -1436,7 +1426,7 @@ template <int _Np>
 	  {
 	    const auto& __x2 = __call_with_n_evaluations<
 	      __div_roundup(_Tup::_S_tuple_size, 2)>(
-	      [](auto __first_simd, auto... __remaining) {
+	      [](auto __first_simd, auto... __remaining) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		if constexpr (sizeof...(__remaining) == 0)
 		  return __first_simd;
 		else
@@ -1450,7 +1440,7 @@ template <int _Np>
 		      __make_simd_tuple(__first_simd, __remaining...));
 		  }
 	      },
-	      [&](auto __i) {
+	      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		auto __left = __tup.template _M_simd_at<2 * __i>();
 		if constexpr (2 * __i + 1 == _Tup::_S_tuple_size)
 		  return __left;
@@ -1466,7 +1456,9 @@ template <int _Np>
 			_GLIBCXX_SIMD_USE_CONSTEXPR_API
 			typename _LT::mask_type __k(
 			  __private_init,
-			  [](auto __j) constexpr { return __j < _RT::size(); });
+			  [](auto __j) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			    return __j < _RT::size();
+			  });
 			_LT __ext_right = __left;
 			where(__k, __ext_right)
 			  = __proposed::resizing_simd_cast<_LT>(__right);
@@ -1481,24 +1473,22 @@ template <int _Np>
 
     // _S_min, _S_max {{{2
     template <typename _Tp, typename... _As>
-      static inline constexpr _SimdTuple<_Tp, _As...>
-      _S_min(const _SimdTuple<_Tp, _As...>& __a,
-	     const _SimdTuple<_Tp, _As...>& __b)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdTuple<_Tp, _As...>
+      _S_min(const _SimdTuple<_Tp, _As...>& __a, const _SimdTuple<_Tp, _As...>& __b)
       {
 	return __a._M_apply_per_chunk(
-	  [](auto __impl, auto __aa, auto __bb) constexpr {
+	  [](auto __impl, auto __aa, auto __bb) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    return __impl._S_min(__aa, __bb);
 	  },
 	  __b);
       }
 
     template <typename _Tp, typename... _As>
-      static inline constexpr _SimdTuple<_Tp, _As...>
-      _S_max(const _SimdTuple<_Tp, _As...>& __a,
-	     const _SimdTuple<_Tp, _As...>& __b)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdTuple<_Tp, _As...>
+      _S_max(const _SimdTuple<_Tp, _As...>& __a, const _SimdTuple<_Tp, _As...>& __b)
       {
 	return __a._M_apply_per_chunk(
-	  [](auto __impl, auto __aa, auto __bb) constexpr {
+	  [](auto __impl, auto __aa, auto __bb) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    return __impl._S_max(__aa, __bb);
 	  },
 	  __b);
@@ -1506,36 +1496,38 @@ template <int _Np>
 
     // _S_complement {{{2
     template <typename _Tp, typename... _As>
-      static inline constexpr _SimdTuple<_Tp, _As...>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdTuple<_Tp, _As...>
       _S_complement(const _SimdTuple<_Tp, _As...>& __x) noexcept
       {
-	return __x._M_apply_per_chunk([](auto __impl, auto __xx) constexpr {
-	  return __impl._S_complement(__xx);
-	});
+	return __x._M_apply_per_chunk(
+		 [](auto __impl, auto __xx) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __impl._S_complement(__xx);
+		 });
       }
 
     // _S_unary_minus {{{2
     template <typename _Tp, typename... _As>
-      static inline constexpr _SimdTuple<_Tp, _As...>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdTuple<_Tp, _As...>
       _S_unary_minus(const _SimdTuple<_Tp, _As...>& __x) noexcept
       {
-	return __x._M_apply_per_chunk([](auto __impl, auto __xx) constexpr {
-	  return __impl._S_unary_minus(__xx);
-	});
+	return __x._M_apply_per_chunk(
+		 [](auto __impl, auto __xx) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __impl._S_unary_minus(__xx);
+		 });
       }
 
     // arithmetic operators {{{2
 
-#define _GLIBCXX_SIMD_FIXED_OP(name_, op_)                                     \
-    template <typename _Tp, typename... _As>                                   \
-      static inline constexpr _SimdTuple<_Tp, _As...> name_(                   \
-	const _SimdTuple<_Tp, _As...> __x, const _SimdTuple<_Tp, _As...> __y)  \
-      {                                                                        \
-	return __x._M_apply_per_chunk(                                         \
-	  [](auto __impl, auto __xx, auto __yy) constexpr {                    \
-	    return __impl.name_(__xx, __yy);                                   \
-	  },                                                                   \
-	  __y);                                                                \
+#define _GLIBCXX_SIMD_FIXED_OP(name_, op_)                                                     \
+    template <typename _Tp, typename... _As>                                                   \
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdTuple<_Tp, _As...> name_(                  \
+	const _SimdTuple<_Tp, _As...>& __x, const _SimdTuple<_Tp, _As...>& __y)                \
+      {                                                                                        \
+	return __x._M_apply_per_chunk(                                                         \
+	  [](auto __impl, auto __xx, auto __yy) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { \
+	    return __impl.name_(__xx, __yy);                                                   \
+	  },                                                                                   \
+	  __y);                                                                                \
       }
 
     _GLIBCXX_SIMD_FIXED_OP(_S_plus, +)
@@ -1551,21 +1543,23 @@ template <int _Np>
 #undef _GLIBCXX_SIMD_FIXED_OP
 
     template <typename _Tp, typename... _As>
-      static inline constexpr _SimdTuple<_Tp, _As...>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdTuple<_Tp, _As...>
       _S_bit_shift_left(const _SimdTuple<_Tp, _As...>& __x, int __y)
       {
-	return __x._M_apply_per_chunk([__y](auto __impl, auto __xx) constexpr {
-	  return __impl._S_bit_shift_left(__xx, __y);
-	});
+	return __x._M_apply_per_chunk(
+		 [__y](auto __impl, auto __xx) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __impl._S_bit_shift_left(__xx, __y);
+		 });
       }
 
     template <typename _Tp, typename... _As>
-      static inline constexpr _SimdTuple<_Tp, _As...>
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdTuple<_Tp, _As...>
       _S_bit_shift_right(const _SimdTuple<_Tp, _As...>& __x, int __y)
       {
-	return __x._M_apply_per_chunk([__y](auto __impl, auto __xx) constexpr {
-	  return __impl._S_bit_shift_right(__xx, __y);
-	});
+	return __x._M_apply_per_chunk(
+		 [__y](auto __impl, auto __xx) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __impl._S_bit_shift_right(__xx, __y);
+		 });
       }
 
   // math {{{2
@@ -1579,35 +1573,40 @@ template <int _Np>
 	  {                                                                    \
 	    if constexpr (is_same_v<_Tp, _RetTp>)                              \
 	      return __x._M_apply_per_chunk(                                   \
-		[](auto __impl, auto __xx) constexpr {                         \
-		  using _V = typename decltype(__impl)::simd_type;             \
-		  return __data(__name(_V(__private_init, __xx)));             \
-		});                                                            \
+		       [](auto __impl, auto __xx)                              \
+			 constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA          \
+		       {                                                       \
+			 using _V = typename decltype(__impl)::simd_type;      \
+			 return __data(__name(_V(__private_init, __xx)));      \
+		       });                                                     \
 	    else                                                               \
 	      return __optimize_simd_tuple(                                    \
-		__x.template _M_apply_r<_RetTp>([](auto __impl, auto __xx) {   \
-		  return __impl._S_##__name(__xx);                             \
-		}));                                                           \
+		       __x.template _M_apply_r<_RetTp>(                        \
+			 [](auto __impl, auto __xx)                            \
+			   _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA                  \
+			 { return __impl._S_##__name(__xx); }));               \
 	  }                                                                    \
 	else if constexpr (                                                    \
 	  is_same_v<                                                           \
 	    _Tp,                                                               \
 	    _RetTp> && (... && is_same_v<_SimdTuple<_Tp, _As...>, _More>) )    \
 	  return __x._M_apply_per_chunk(                                       \
-	    [](auto __impl, auto __xx, auto... __pack) constexpr {             \
-	      using _V = typename decltype(__impl)::simd_type;                 \
-	      return __data(__name(_V(__private_init, __xx),                   \
-				   _V(__private_init, __pack)...));            \
-	    },                                                                 \
-	    __more...);                                                        \
+		   [](auto __impl, auto __xx, auto... __pack)                  \
+		     constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA              \
+		   {                                                           \
+		     using _V = typename decltype(__impl)::simd_type;          \
+		     return __data(__name(_V(__private_init, __xx),            \
+					  _V(__private_init, __pack)...));     \
+		   }, __more...);                                              \
 	else if constexpr (is_same_v<_Tp, _RetTp>)                             \
 	  return __x._M_apply_per_chunk(                                       \
-	    [](auto __impl, auto __xx, auto... __pack) constexpr {             \
-	      using _V = typename decltype(__impl)::simd_type;                 \
-	      return __data(__name(_V(__private_init, __xx),                   \
-				   __autocvt_to_simd(__pack)...));             \
-	    },                                                                 \
-	    __more...);                                                        \
+		   [](auto __impl, auto __xx, auto... __pack)                  \
+		     constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA              \
+		   {                                                           \
+		     using _V = typename decltype(__impl)::simd_type;          \
+		     return __data(__name(_V(__private_init, __xx),            \
+					  __autocvt_to_simd(__pack)...));      \
+		   }, __more...);                                              \
 	else                                                                   \
 	  __assert_unreachable<_Tp>();                                         \
       }
@@ -1673,16 +1672,15 @@ template <int _Np>
 #undef _GLIBCXX_SIMD_APPLY_ON_TUPLE
 
     template <typename _Tp, typename... _Abis>
-      static _SimdTuple<_Tp, _Abis...> _S_remquo(
-	const _SimdTuple<_Tp, _Abis...>& __x,
-	const _SimdTuple<_Tp, _Abis...>& __y,
-	__fixed_size_storage_t<int, _SimdTuple<_Tp, _Abis...>::_S_size()>* __z)
+      static inline _SimdTuple<_Tp, _Abis...>
+      _S_remquo(const _SimdTuple<_Tp, _Abis...>& __x, const _SimdTuple<_Tp, _Abis...>& __y,
+		__fixed_size_storage_t<int, _SimdTuple<_Tp, _Abis...>::_S_size()>* __z)
       {
 	return __x._M_apply_per_chunk(
-	  [](auto __impl, const auto __xx, const auto __yy, auto& __zz) {
-	    return __impl._S_remquo(__xx, __yy, &__zz);
-	  },
-	  __y, *__z);
+		 [](auto __impl, const auto __xx, const auto __yy, auto& __zz)
+		   _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+		 { return __impl._S_remquo(__xx, __yy, &__zz); },
+		 __y, *__z);
       }
 
     template <typename _Tp, typename... _As>
@@ -1691,22 +1689,20 @@ template <int _Np>
 	       __fixed_size_storage_t<int, _Np>& __exp) noexcept
       {
 	return __x._M_apply_per_chunk(
-	  [](auto __impl, const auto& __a, auto& __b) {
-	    return __data(
-	      frexp(typename decltype(__impl)::simd_type(__private_init, __a),
-		    __autocvt_to_simd(__b)));
-	  },
-	  __exp);
+		 [](auto __impl, const auto& __a, auto& __b) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __data(frexp(typename decltype(__impl)::simd_type(__private_init, __a),
+				       __autocvt_to_simd(__b)));
+		 }, __exp);
       }
 
-#define _GLIBCXX_SIMD_TEST_ON_TUPLE_(name_)                                    \
-    template <typename _Tp, typename... _As>                                   \
-      static inline _MaskMember                                                \
-	_S_##name_(const _SimdTuple<_Tp, _As...>& __x) noexcept                \
-      {                                                                        \
-	return _M_test([](auto __impl,                                         \
-			  auto __xx) { return __impl._S_##name_(__xx); },      \
-		       __x);                                                   \
+#define _GLIBCXX_SIMD_TEST_ON_TUPLE_(name_)                                              \
+    template <typename _Tp, typename... _As>                                             \
+      static inline _MaskMember                                                          \
+      _S_##name_(const _SimdTuple<_Tp, _As...>& __x) noexcept                            \
+      {                                                                                  \
+	return _M_test([] (auto __impl, auto __xx) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA  { \
+		 return __impl._S_##name_(__xx);                                         \
+	       }, __x);                                                                  \
       }
 
     _GLIBCXX_SIMD_TEST_ON_TUPLE_(isinf)
@@ -1722,7 +1718,7 @@ template <int _Np>
       _S_increment(_SimdTuple<_Ts...>& __x)
       {
 	__for_each(
-	  __x, [](auto __meta, auto& native) constexpr {
+	  __x, [](auto __meta, auto& native) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    __meta._S_increment(native);
 	  });
       }
@@ -1732,7 +1728,7 @@ template <int _Np>
       _S_decrement(_SimdTuple<_Ts...>& __x)
       {
 	__for_each(
-	  __x, [](auto __meta, auto& native) constexpr {
+	  __x, [](auto __meta, auto& native) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    __meta._S_decrement(native);
 	  });
       }
@@ -1740,15 +1736,14 @@ template <int _Np>
     // compares {{{2
 #define _GLIBCXX_SIMD_CMP_OPERATIONS(__cmp)                                    \
     template <typename _Tp, typename... _As>                                   \
-      _GLIBCXX_SIMD_INTRINSIC constexpr static _MaskMember                     \
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember                     \
       __cmp(const _SimdTuple<_Tp, _As...>& __x,                                \
 	    const _SimdTuple<_Tp, _As...>& __y)                                \
       {                                                                        \
-	return _M_test(                                                        \
-	  [](auto __impl, auto __xx, auto __yy) constexpr {                    \
-	    return __impl.__cmp(__xx, __yy);                                   \
-	  },                                                                   \
-	  __x, __y);                                                           \
+	return _M_test([](auto __impl, auto __xx, auto __yy)                   \
+			 constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA          \
+		       { return __impl.__cmp(__xx, __yy); },                   \
+		       __x, __y);                                              \
       }
 
     _GLIBCXX_SIMD_CMP_OPERATIONS(_S_equal_to)
@@ -1765,33 +1760,34 @@ template <int _Np>
 
     // smart_reference access {{{2
     template <typename _Tp, typename... _As, typename _Up>
-      _GLIBCXX_SIMD_INTRINSIC static void _S_set(_SimdTuple<_Tp, _As...>& __v,
-						 int __i, _Up&& __x) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
+      _S_set(_SimdTuple<_Tp, _As...>& __v, int __i, _Up&& __x) noexcept
       { __v._M_set(__i, static_cast<_Up&&>(__x)); }
 
     // _S_masked_assign {{{2
     template <typename _Tp, typename... _As>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_masked_assign(const _MaskMember __bits, _SimdTuple<_Tp, _As...>& __lhs,
 		       const __type_identity_t<_SimdTuple<_Tp, _As...>>& __rhs)
       {
-	__for_each(
-	  __lhs, __rhs,
-	  [&](auto __meta, auto& __native_lhs, auto __native_rhs) constexpr {
-	    __meta._S_masked_assign(__meta._S_make_mask(__bits), __native_lhs,
-				    __native_rhs);
-	  });
+	__for_each(__lhs, __rhs,
+		   [&](auto __meta, auto& __native_lhs, auto __native_rhs)
+		     constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+		   {
+		     __meta._S_masked_assign(__meta._S_make_mask(__bits), __native_lhs,
+					     __native_rhs);
+		   });
       }
 
     // Optimization for the case where the RHS is a scalar. No need to broadcast
     // the scalar to a simd first.
     template <typename _Tp, typename... _As>
-      _GLIBCXX_SIMD_INTRINSIC static void
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
       _S_masked_assign(const _MaskMember __bits, _SimdTuple<_Tp, _As...>& __lhs,
 		       const __type_identity_t<_Tp> __rhs)
       {
 	__for_each(
-	  __lhs, [&](auto __meta, auto& __native_lhs) constexpr {
+	  __lhs, [&](auto __meta, auto& __native_lhs) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    __meta._S_masked_assign(__meta._S_make_mask(__bits), __native_lhs,
 				    __rhs);
 	  });
@@ -1799,28 +1795,28 @@ template <int _Np>
 
     // _S_masked_cassign {{{2
     template <typename _Op, typename _Tp, typename... _As>
-      static inline void _S_masked_cassign(const _MaskMember __bits,
-					   _SimdTuple<_Tp, _As...>& __lhs,
-					   const _SimdTuple<_Tp, _As...>& __rhs,
-					   _Op __op)
+      static constexpr inline void
+      _S_masked_cassign(const _MaskMember __bits, _SimdTuple<_Tp, _As...>& __lhs,
+			const _SimdTuple<_Tp, _As...>& __rhs, _Op __op)
       {
-	__for_each(
-	  __lhs, __rhs,
-	  [&](auto __meta, auto& __native_lhs, auto __native_rhs) constexpr {
-	    __meta.template _S_masked_cassign(__meta._S_make_mask(__bits),
-					      __native_lhs, __native_rhs, __op);
-	  });
+	__for_each(__lhs, __rhs,
+		   [&](auto __meta, auto& __native_lhs, auto __native_rhs)
+		     constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+		   {
+		     __meta.template _S_masked_cassign(__meta._S_make_mask(__bits),
+						       __native_lhs, __native_rhs, __op);
+		   });
       }
 
     // Optimization for the case where the RHS is a scalar. No need to broadcast
     // the scalar to a simd first.
     template <typename _Op, typename _Tp, typename... _As>
-      static inline void _S_masked_cassign(const _MaskMember __bits,
-					   _SimdTuple<_Tp, _As...>& __lhs,
-					   const _Tp& __rhs, _Op __op)
+      static constexpr inline void
+      _S_masked_cassign(const _MaskMember __bits, _SimdTuple<_Tp, _As...>& __lhs,
+			const _Tp& __rhs, _Op __op)
       {
 	__for_each(
-	  __lhs, [&](auto __meta, auto& __native_lhs) constexpr {
+	  __lhs, [&](auto __meta, auto& __native_lhs) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	    __meta.template _S_masked_cassign(__meta._S_make_mask(__bits),
 					      __native_lhs, __rhs, __op);
 	  });
@@ -1828,7 +1824,7 @@ template <int _Np>
 
     // _S_masked_unary {{{2
     template <template <typename> class _Op, typename _Tp, typename... _As>
-      static inline _SimdTuple<_Tp, _As...>
+      static constexpr inline _SimdTuple<_Tp, _As...>
       _S_masked_unary(const _MaskMember __bits,
 		      const _SimdTuple<_Tp, _As...> __v) // TODO: const-ref __v?
       {
@@ -1876,6 +1872,13 @@ template <int _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember
       _S_load(const bool* __mem)
       {
+	if (__builtin_is_constant_evaluated())
+	  {
+	    _MaskMember __r{};
+	    for (size_t __i = 0; __i < _Np; ++__i)
+	      __r.set(__i, __mem[__i]);
+	    return __r;
+	  }
 	using _Ip = __int_for_sizeof_t<bool>;
 	// the following load uses element_aligned and relies on __mem already
 	// carrying alignment information from when this load function was
@@ -1911,18 +1914,19 @@ template <int _Np>
     // }}}
     // _S_from_bitmask {{{2
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static _MaskMember
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember
       _S_from_bitmask(_MaskMember __bits, _TypeTag<_Tp>) noexcept
       { return __bits; }
 
     // _S_load {{{2
-    static inline _MaskMember _S_load(const bool* __mem) noexcept
+    static constexpr inline _MaskMember
+    _S_load(const bool* __mem) noexcept
     {
       // TODO: _UChar is not necessarily the best type to use here. For smaller
       // _Np _UShort, _UInt, _ULLong, float, and double can be more efficient.
       _ULLong __r = 0;
       using _Vs = __fixed_size_storage_t<_UChar, _Np>;
-      __for_each(_Vs{}, [&](auto __meta, auto) {
+      __for_each(_Vs{}, [&](auto __meta, auto) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	__r |= __meta._S_mask_to_shifted_ullong(
 	  __meta._S_mask_impl._S_load(&__mem[__meta._S_offset],
 				      _SizeConstant<__meta._S_size()>()));
@@ -1931,19 +1935,19 @@ template <int _Np>
     }
 
     // _S_masked_load {{{2
-    static inline _MaskMember _S_masked_load(_MaskMember __merge,
-					     _MaskMember __mask,
-					     const bool* __mem) noexcept
+    static constexpr inline _MaskMember
+    _S_masked_load(_MaskMember __merge, _MaskMember __mask, const bool* __mem) noexcept
     {
-      _BitOps::_S_bit_iteration(__mask.to_ullong(), [&](auto __i) {
-	__merge.set(__i, __mem[__i]);
-      });
+      _BitOps::_S_bit_iteration(__mask.to_ullong(),
+				[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+				  __merge.set(__i, __mem[__i]);
+				});
       return __merge;
     }
 
     // _S_store {{{2
-    static inline void _S_store(const _MaskMember __bitmask,
-				bool* __mem) noexcept
+    static constexpr inline void
+    _S_store(const _MaskMember __bitmask, bool* __mem) noexcept
     {
       if constexpr (_Np == 1)
 	__mem[0] = __bitmask[0];
@@ -1952,18 +1956,19 @@ template <int _Np>
     }
 
     // _S_masked_store {{{2
-    static inline void _S_masked_store(const _MaskMember __v, bool* __mem,
-				       const _MaskMember __k) noexcept
+    static constexpr inline void
+    _S_masked_store(const _MaskMember __v, bool* __mem, const _MaskMember __k) noexcept
     {
-      _BitOps::_S_bit_iteration(__k, [&](auto __i) { __mem[__i] = __v[__i]; });
+      _BitOps::_S_bit_iteration(
+	__k, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA { __mem[__i] = __v[__i]; });
     }
 
     // logical and bitwise operators {{{2
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember
     _S_logical_and(const _MaskMember& __x, const _MaskMember& __y) noexcept
     { return __x & __y; }
 
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember
     _S_logical_or(const _MaskMember& __x, const _MaskMember& __y) noexcept
     { return __x | __y; }
 
@@ -1971,33 +1976,31 @@ template <int _Np>
     _S_bit_not(const _MaskMember& __x) noexcept
     { return ~__x; }
 
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember
     _S_bit_and(const _MaskMember& __x, const _MaskMember& __y) noexcept
     { return __x & __y; }
 
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember
     _S_bit_or(const _MaskMember& __x, const _MaskMember& __y) noexcept
     { return __x | __y; }
 
-    _GLIBCXX_SIMD_INTRINSIC static _MaskMember
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _MaskMember
     _S_bit_xor(const _MaskMember& __x, const _MaskMember& __y) noexcept
     { return __x ^ __y; }
 
     // smart_reference access {{{2
-    _GLIBCXX_SIMD_INTRINSIC static void _S_set(_MaskMember& __k, int __i,
-					       bool __x) noexcept
+    _GLIBCXX_SIMD_INTRINSIC static constexpr void
+    _S_set(_MaskMember& __k, int __i, bool __x) noexcept
     { __k.set(__i, __x); }
 
     // _S_masked_assign {{{2
-    _GLIBCXX_SIMD_INTRINSIC static void
-    _S_masked_assign(const _MaskMember __k, _MaskMember& __lhs,
-		     const _MaskMember __rhs)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr void
+    _S_masked_assign(const _MaskMember __k, _MaskMember& __lhs, const _MaskMember __rhs)
     { __lhs = (__lhs & ~__k) | (__rhs & __k); }
 
     // Optimization for the case where the RHS is a scalar.
-    _GLIBCXX_SIMD_INTRINSIC static void _S_masked_assign(const _MaskMember __k,
-							 _MaskMember& __lhs,
-							 const bool __rhs)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr void
+    _S_masked_assign(const _MaskMember __k, _MaskMember& __lhs, const bool __rhs)
     {
       if (__rhs)
 	__lhs |= __k;
@@ -2008,25 +2011,28 @@ template <int _Np>
     // }}}2
     // _S_all_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_all_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+      _S_all_of(simd_mask<_Tp, _Abi> __k)
       { return __data(__k).all(); }
 
     // }}}
     // _S_any_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_any_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+      _S_any_of(simd_mask<_Tp, _Abi> __k)
       { return __data(__k).any(); }
 
     // }}}
     // _S_none_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_none_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+      _S_none_of(simd_mask<_Tp, _Abi> __k)
       { return __data(__k).none(); }
 
     // }}}
     // _S_some_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool
+      _GLIBCXX_SIMD_INTRINSIC static constexpr bool
       _S_some_of([[maybe_unused]] simd_mask<_Tp, _Abi> __k)
       {
 	if constexpr (_Np == 1)
@@ -2038,20 +2044,21 @@ template <int _Np>
     // }}}
     // _S_popcount {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static int _S_popcount(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr int
+      _S_popcount(simd_mask<_Tp, _Abi> __k)
       { return __data(__k).count(); }
 
     // }}}
     // _S_find_first_set {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static int
+      _GLIBCXX_SIMD_INTRINSIC static constexpr int
       _S_find_first_set(simd_mask<_Tp, _Abi> __k)
       { return std::__countr_zero(__data(__k).to_ullong()); }
 
     // }}}
     // _S_find_last_set {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static int
+      _GLIBCXX_SIMD_INTRINSIC static constexpr int
       _S_find_last_set(simd_mask<_Tp, _Abi> __k)
       { return std::__bit_width(__data(__k).to_ullong()) - 1; }
 
diff --git a/libstdc++-v3/include/experimental/bits/simd_math.h b/libstdc++-v3/include/experimental/bits/simd_math.h
index 4799803a200..a78ccb4570b 100644
--- a/libstdc++-v3/include/experimental/bits/simd_math.h
+++ b/libstdc++-v3/include/experimental/bits/simd_math.h
@@ -792,7 +792,7 @@ template <typename _Tp, typename _Abi>
 
 	// __exponent(__x) returns the exponent value (bias removed) as
 	// simd<_Up> with integral _Up
-	auto&& __exponent = [](const _V& __v) {
+	auto&& __exponent = [](const _V& __v) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  using namespace std::experimental::__proposed;
 	  using _IV = rebind_simd_t<
 	    conditional_t<sizeof(_Tp) == sizeof(_LLong), _LLong, int>, _V>;
@@ -952,7 +952,7 @@ template <typename _R, typename _ToApply, typename _Tp, typename... _Tps>
   {
     return {__private_init,
 	    __data(__arg0)._M_apply_per_chunk(
-	      [&](auto __impl, const auto&... __inner) {
+	      [&](auto __impl, const auto&... __inner) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		using _V = typename decltype(__impl)::simd_type;
 		return __data(__apply(_V(__private_init, __inner)...));
 	      },
@@ -1112,8 +1112,9 @@ _GLIBCXX_SIMD_CVTING2(hypot)
     if constexpr (__is_fixed_size_abi_v<_Abi> && _V::size() > 1)
       {
 	return __fixed_size_apply<simd<_Tp, _Abi>>(
-	  [](auto __a, auto __b, auto __c) { return hypot(__a, __b, __c); },
-	  __x, __y, __z);
+		 [](auto __a, auto __b, auto __c) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return hypot(__a, __b, __c);
+		 }, __x, __y, __z);
       }
     else
       {
@@ -1400,9 +1401,9 @@ template <typename _Tp, typename _Abi>
 		 const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __m,
 		 const simd<_Tp, _Abi>& __x)
   {
-    return simd<_Tp, _Abi>([&](auto __i) {
-      return std::assoc_laguerre(__n[__i], __m[__i], __x[__i]);
-    });
+    return simd<_Tp, _Abi>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	     return std::assoc_laguerre(__n[__i], __m[__i], __x[__i]);
+	   });
   }
 
 template <typename _Tp, typename _Abi>
@@ -1411,9 +1412,9 @@ template <typename _Tp, typename _Abi>
 		 const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __m,
 		 const simd<_Tp, _Abi>& __x)
   {
-    return simd<_Tp, _Abi>([&](auto __i) {
-      return std::assoc_legendre(__n[__i], __m[__i], __x[__i]);
-    });
+    return simd<_Tp, _Abi>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	     return std::assoc_legendre(__n[__i], __m[__i], __x[__i]);
+	   });
   }
 
 _GLIBCXX_SIMD_MATH_CALL2_(beta, _Tp)
@@ -1434,8 +1435,9 @@ template <typename _Tp, typename _Abi>
   hermite(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,
 	  const simd<_Tp, _Abi>& __x)
   {
-    return simd<_Tp, _Abi>(
-      [&](auto __i) { return std::hermite(__n[__i], __x[__i]); });
+    return simd<_Tp, _Abi>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	     return std::hermite(__n[__i], __x[__i]);
+	   });
   }
 
 template <typename _Tp, typename _Abi>
@@ -1443,8 +1445,9 @@ template <typename _Tp, typename _Abi>
   laguerre(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,
 	   const simd<_Tp, _Abi>& __x)
   {
-    return simd<_Tp, _Abi>(
-      [&](auto __i) { return std::laguerre(__n[__i], __x[__i]); });
+    return simd<_Tp, _Abi>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	     return std::laguerre(__n[__i], __x[__i]);
+	   });
   }
 
 template <typename _Tp, typename _Abi>
@@ -1452,8 +1455,9 @@ template <typename _Tp, typename _Abi>
   legendre(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,
 	   const simd<_Tp, _Abi>& __x)
   {
-    return simd<_Tp, _Abi>(
-      [&](auto __i) { return std::legendre(__n[__i], __x[__i]); });
+    return simd<_Tp, _Abi>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	     return std::legendre(__n[__i], __x[__i]);
+	   });
   }
 
 _GLIBCXX_SIMD_MATH_CALL_(riemann_zeta)
@@ -1463,8 +1467,9 @@ template <typename _Tp, typename _Abi>
   sph_bessel(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,
 	     const simd<_Tp, _Abi>& __x)
   {
-    return simd<_Tp, _Abi>(
-      [&](auto __i) { return std::sph_bessel(__n[__i], __x[__i]); });
+    return simd<_Tp, _Abi>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	     return std::sph_bessel(__n[__i], __x[__i]);
+	   });
   }
 
 template <typename _Tp, typename _Abi>
@@ -1473,9 +1478,9 @@ template <typename _Tp, typename _Abi>
 	       const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __m,
 	       const simd<_Tp, _Abi>& theta)
   {
-    return simd<_Tp, _Abi>([&](auto __i) {
-      return std::assoc_legendre(__l[__i], __m[__i], theta[__i]);
-    });
+    return simd<_Tp, _Abi>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	     return std::assoc_legendre(__l[__i], __m[__i], theta[__i]);
+	   });
   }
 
 template <typename _Tp, typename _Abi>
@@ -1483,8 +1488,9 @@ template <typename _Tp, typename _Abi>
   sph_neumann(const fixed_size_simd<unsigned, simd_size_v<_Tp, _Abi>>& __n,
 	      const simd<_Tp, _Abi>& __x)
   {
-    return simd<_Tp, _Abi>(
-      [&](auto __i) { return std::sph_neumann(__n[__i], __x[__i]); });
+    return simd<_Tp, _Abi>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+	     return std::sph_neumann(__n[__i], __x[__i]);
+	   });
   }
 // }}}
 
diff --git a/libstdc++-v3/include/experimental/bits/simd_neon.h b/libstdc++-v3/include/experimental/bits/simd_neon.h
index 7f472e88649..5ead69c927c 100644
--- a/libstdc++-v3/include/experimental/bits/simd_neon.h
+++ b/libstdc++-v3/include/experimental/bits/simd_neon.h
@@ -61,7 +61,7 @@ template <typename _Abi>
       _S_masked_load(_SimdWrapper<_Tp, _Np> __merge, _MaskMember<_Tp> __k,
 		     const _Up* __mem) noexcept
       {
-	__execute_n_times<_Np>([&](auto __i) {
+	__execute_n_times<_Np>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  if (__k[__i] != 0)
 	    __merge._M_set(__i, static_cast<_Tp>(__mem[__i]));
 	});
@@ -75,7 +75,7 @@ template <typename _Abi>
       _S_masked_store_nocvt(_SimdWrapper<_Tp, _Np> __v, _Tp* __mem,
 			    _MaskMember<_Tp> __k)
       {
-	__execute_n_times<_Np>([&](auto __i) {
+	__execute_n_times<_Np>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  if (__k[__i] != 0)
 	    __mem[__i] = __v[__i];
 	});
@@ -84,57 +84,54 @@ template <typename _Abi>
     // }}}
     // _S_reduce {{{
     template <typename _Tp, typename _BinaryOperation>
-      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _Tp
       _S_reduce(simd<_Tp, _Abi> __x, _BinaryOperation&& __binary_op)
       {
-	constexpr size_t _Np = __x.size();
-	if constexpr (sizeof(__x) == 16 && _Np >= 4
-		      && !_Abi::template _S_is_partial<_Tp>)
+	if (not __builtin_is_constant_evaluated())
 	  {
-	    const auto __halves = split<simd<_Tp, simd_abi::_Neon<8>>>(__x);
-	    const auto __y = __binary_op(__halves[0], __halves[1]);
-	    return _SimdImplNeon<simd_abi::_Neon<8>>::_S_reduce(
-	      __y, static_cast<_BinaryOperation&&>(__binary_op));
+	    constexpr size_t _Np = __x.size();
+	    if constexpr (sizeof(__x) == 16 && _Np >= 4
+			    && !_Abi::template _S_is_partial<_Tp>)
+	      {
+		const auto __halves = split<simd<_Tp, simd_abi::_Neon<8>>>(__x);
+		const auto __y = __binary_op(__halves[0], __halves[1]);
+		return _SimdImplNeon<simd_abi::_Neon<8>>::_S_reduce(
+			 __y, static_cast<_BinaryOperation&&>(__binary_op));
+	      }
+	    else if constexpr (_Np == 8)
+	      {
+		__x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
+					 __vector_permute<1, 0, 3, 2, 5, 4, 7, 6>(__x._M_data)));
+		__x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
+					 __vector_permute<3, 2, 1, 0, 7, 6, 5, 4>(__x._M_data)));
+		__x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
+					 __vector_permute<7, 6, 5, 4, 3, 2, 1, 0>(__x._M_data)));
+		return __x[0];
+	      }
+	    else if constexpr (_Np == 4)
+	      {
+		__x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
+					 __vector_permute<1, 0, 3, 2>(__x._M_data)));
+		__x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
+					 __vector_permute<3, 2, 1, 0>(__x._M_data)));
+		return __x[0];
+	      }
+	    else if constexpr (_Np == 2)
+	      {
+		__x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
+					 __vector_permute<1, 0>(__x._M_data)));
+		return __x[0];
+	      }
 	  }
-	else if constexpr (_Np == 8)
-	  {
-	    __x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
-				     __vector_permute<1, 0, 3, 2, 5, 4, 7, 6>(
-				       __x._M_data)));
-	    __x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
-				     __vector_permute<3, 2, 1, 0, 7, 6, 5, 4>(
-				       __x._M_data)));
-	    __x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
-				     __vector_permute<7, 6, 5, 4, 3, 2, 1, 0>(
-				       __x._M_data)));
-	    return __x[0];
-	  }
-	else if constexpr (_Np == 4)
-	  {
-	    __x
-	      = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
-				   __vector_permute<1, 0, 3, 2>(__x._M_data)));
-	    __x
-	      = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
-				   __vector_permute<3, 2, 1, 0>(__x._M_data)));
-	    return __x[0];
-	  }
-	else if constexpr (_Np == 2)
-	  {
-	    __x = __binary_op(__x, _Base::template _M_make_simd<_Tp, _Np>(
-				     __vector_permute<1, 0>(__x._M_data)));
-	    return __x[0];
-	  }
-	else
-	  return _Base::_S_reduce(__x,
-				  static_cast<_BinaryOperation&&>(__binary_op));
+	return _Base::_S_reduce(__x, static_cast<_BinaryOperation&&>(__binary_op));
       }
 
     // }}}
     // math {{{
     // _S_sqrt {{{
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      _GLIBCXX_SIMD_INTRINSIC static _Tp _S_sqrt(_Tp __x)
+      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _S_sqrt(_Tp __x)
       {
 	if constexpr (__have_neon_a64)
 	  {
@@ -157,7 +154,8 @@ template <typename _Abi>
     // }}}
     // _S_trunc {{{
     template <typename _TW, typename _TVT = _VectorTraits<_TW>>
-      _GLIBCXX_SIMD_INTRINSIC static _TW _S_trunc(_TW __x)
+      _GLIBCXX_SIMD_INTRINSIC static _TW
+      _S_trunc(_TW __x)
       {
 	using _Tp = typename _TVT::value_type;
 	if constexpr (__have_neon_a32)
@@ -216,7 +214,8 @@ template <typename _Abi>
     // }}}
     // _S_floor {{{
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      _GLIBCXX_SIMD_INTRINSIC static _Tp _S_floor(_Tp __x)
+      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _S_floor(_Tp __x)
       {
 	if constexpr (__have_neon_a32)
 	  {
@@ -239,7 +238,8 @@ template <typename _Abi>
     // }}}
     // _S_ceil {{{
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      _GLIBCXX_SIMD_INTRINSIC static _Tp _S_ceil(_Tp __x)
+      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _S_ceil(_Tp __x)
       {
 	if constexpr (__have_neon_a32)
 	  {
@@ -286,7 +286,7 @@ struct _MaskImplNeonMixin
 	    {
 	      constexpr auto __bitsel
 		= __generate_from_n_evaluations<16, __vector_type_t<_I, 16>>(
-		  [&](auto __i) {
+		  [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		    return static_cast<_I>(
 		      __i < _Np ? (__i < 8 ? 1 << __i : 1 << (__i - 8)) : 0);
 		  });
@@ -306,7 +306,7 @@ struct _MaskImplNeonMixin
 	    {
 	      constexpr auto __bitsel
 		= __generate_from_n_evaluations<8, __vector_type_t<_I, 8>>(
-		  [&](auto __i) {
+		  [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		    return static_cast<_I>(__i < _Np ? 1 << __i : 0);
 		  });
 	      __asint &= __bitsel;
@@ -322,7 +322,7 @@ struct _MaskImplNeonMixin
 	    {
 	      constexpr auto __bitsel
 		= __generate_from_n_evaluations<4, __vector_type_t<_I, 4>>(
-		  [&](auto __i) {
+		  [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		    return static_cast<_I>(__i < _Np ? 1 << __i : 0);
 		  });
 	      __asint &= __bitsel;
@@ -346,7 +346,7 @@ struct _MaskImplNeonMixin
 	    {
 	      constexpr auto __bitsel
 		= __generate_from_n_evaluations<8, __vector_type_t<_I, 8>>(
-		  [&](auto __i) {
+		  [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		    return static_cast<_I>(__i < _Np ? 1 << __i : 0);
 		  });
 	      __asint &= __bitsel;
@@ -361,7 +361,7 @@ struct _MaskImplNeonMixin
 	    {
 	      constexpr auto __bitsel
 		= __generate_from_n_evaluations<4, __vector_type_t<_I, 4>>(
-		  [&](auto __i) {
+		  [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		    return static_cast<_I>(__i < _Np ? 1 << __i : 0);
 		  });
 	      __asint &= __bitsel;
@@ -400,7 +400,8 @@ template <typename _Abi>
 
     // _S_all_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_all_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static bool
+      _S_all_of(simd_mask<_Tp, _Abi> __k)
       {
 	const auto __kk
 	  = __vector_bitcast<char>(__k._M_data)
@@ -419,7 +420,8 @@ template <typename _Abi>
     // }}}
     // _S_any_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_any_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static bool
+      _S_any_of(simd_mask<_Tp, _Abi> __k)
       {
 	const auto __kk
 	  = __vector_bitcast<char>(__k._M_data)
@@ -438,7 +440,8 @@ template <typename _Abi>
     // }}}
     // _S_none_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_none_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static bool
+      _S_none_of(simd_mask<_Tp, _Abi> __k)
       {
 	const auto __kk = _Abi::_S_masked(__k._M_data);
 	if constexpr (sizeof(__k) == 16)
@@ -472,7 +475,8 @@ template <typename _Abi>
     // }}}
     // _S_popcount {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static int _S_popcount(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static int
+      _S_popcount(simd_mask<_Tp, _Abi> __k)
       {
 	if constexpr (sizeof(_Tp) == 1)
 	  {
diff --git a/libstdc++-v3/include/experimental/bits/simd_ppc.h b/libstdc++-v3/include/experimental/bits/simd_ppc.h
index ef52d129a85..6e4a6ec606e 100644
--- a/libstdc++-v3/include/experimental/bits/simd_ppc.h
+++ b/libstdc++-v3/include/experimental/bits/simd_ppc.h
@@ -64,7 +64,7 @@ template <typename _Abi>
 	__x = _Base::_S_bit_shift_left(__x, __y);
 	if constexpr (sizeof(_Tp) < sizeof(int))
 	  {
-	    if (__y >= sizeof(_Tp) * __CHAR_BIT__)
+	    if (__y >= int(sizeof(_Tp) * __CHAR_BIT__))
 	      return {};
 	  }
 	return __x;
@@ -124,12 +124,14 @@ template <typename _Abi>
 
     // _S_popcount {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static int _S_popcount(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static int
+      _S_popcount(simd_mask<_Tp, _Abi> __k)
       {
 	const auto __kv = __as_vector(__k);
 	if constexpr (__have_power10vec)
 	  {
-	    return vec_cntm(__to_intrin(__kv), 1);
+	    using _Intrin = __intrinsic_type16_t<make_unsigned_t<__int_for_sizeof_t<_Tp>>>;
+	    return vec_cntm(reinterpret_cast<_Intrin>(__kv), 1);
 	  }
 	else if constexpr (sizeof(_Tp) >= sizeof(int))
 	  {
diff --git a/libstdc++-v3/include/experimental/bits/simd_scalar.h b/libstdc++-v3/include/experimental/bits/simd_scalar.h
index 48e13f6c719..841893cce59 100644
--- a/libstdc++-v3/include/experimental/bits/simd_scalar.h
+++ b/libstdc++-v3/include/experimental/bits/simd_scalar.h
@@ -74,7 +74,8 @@ struct simd_abi::_Scalar
   template <typename _Tp>
     static constexpr bool _S_is_valid_v = _IsValid<_Tp>::value;
 
-  _GLIBCXX_SIMD_INTRINSIC static constexpr bool _S_masked(bool __x)
+  _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+  _S_masked(bool __x)
   { return __x; }
 
   using _CommonImpl = _CommonImplScalar;
@@ -110,7 +111,8 @@ struct _CommonImplScalar
 {
   // _S_store {{{
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static void _S_store(_Tp __x, void* __addr)
+    _GLIBCXX_SIMD_INTRINSIC static void
+    _S_store(_Tp __x, void* __addr)
     { __builtin_memcpy(__addr, &__x, sizeof(_Tp)); }
 
   // }}}
@@ -138,25 +140,26 @@ struct _SimdImplScalar
 
   // _S_broadcast {{{2
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static constexpr _Tp _S_broadcast(_Tp __x) noexcept
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _Tp
+    _S_broadcast(_Tp __x) noexcept
     { return __x; }
 
   // _S_generator {{{2
   template <typename _Fp, typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static constexpr _Tp _S_generator(_Fp&& __gen,
-							      _TypeTag<_Tp>)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _Tp
+    _S_generator(_Fp&& __gen, _TypeTag<_Tp>)
     { return __gen(_SizeConstant<0>()); }
 
   // _S_load {{{2
   template <typename _Tp, typename _Up>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_load(const _Up* __mem,
-					       _TypeTag<_Tp>) noexcept
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _Tp
+    _S_load(const _Up* __mem, _TypeTag<_Tp>) noexcept
     { return static_cast<_Tp>(__mem[0]); }
 
   // _S_masked_load {{{2
   template <typename _Tp, typename _Up>
-    static inline _Tp _S_masked_load(_Tp __merge, bool __k,
-				     const _Up* __mem) noexcept
+    static constexpr _Tp
+    _S_masked_load(_Tp __merge, bool __k, const _Up* __mem) noexcept
     {
       if (__k)
 	__merge = static_cast<_Tp>(__mem[0]);
@@ -165,18 +168,20 @@ struct _SimdImplScalar
 
   // _S_store {{{2
   template <typename _Tp, typename _Up>
-    static inline void _S_store(_Tp __v, _Up* __mem, _TypeTag<_Tp>) noexcept
+    static constexpr void
+    _S_store(_Tp __v, _Up* __mem, _TypeTag<_Tp>) noexcept
     { __mem[0] = static_cast<_Up>(__v); }
 
   // _S_masked_store {{{2
   template <typename _Tp, typename _Up>
-    static inline void _S_masked_store(const _Tp __v, _Up* __mem,
-				       const bool __k) noexcept
+    static constexpr void
+    _S_masked_store(const _Tp __v, _Up* __mem, const bool __k) noexcept
     { if (__k) __mem[0] = __v; }
 
   // _S_negate {{{2
   template <typename _Tp>
-    static constexpr inline bool _S_negate(_Tp __x) noexcept
+    static constexpr inline bool
+    _S_negate(_Tp __x) noexcept
     { return !__x; }
 
   // _S_reduce {{{2
@@ -187,61 +192,71 @@ struct _SimdImplScalar
 
   // _S_min, _S_max {{{2
   template <typename _Tp>
-    static constexpr inline _Tp _S_min(const _Tp __a, const _Tp __b)
+    static constexpr inline _Tp
+    _S_min(const _Tp __a, const _Tp __b)
     { return std::min(__a, __b); }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_max(const _Tp __a, const _Tp __b)
+    static constexpr inline _Tp
+    _S_max(const _Tp __a, const _Tp __b)
     { return std::max(__a, __b); }
 
   // _S_complement {{{2
   template <typename _Tp>
-    static constexpr inline _Tp _S_complement(_Tp __x) noexcept
+    static constexpr inline _Tp
+    _S_complement(_Tp __x) noexcept
     { return static_cast<_Tp>(~__x); }
 
   // _S_unary_minus {{{2
   template <typename _Tp>
-    static constexpr inline _Tp _S_unary_minus(_Tp __x) noexcept
+    static constexpr inline _Tp
+    _S_unary_minus(_Tp __x) noexcept
     { return static_cast<_Tp>(-__x); }
 
   // arithmetic operators {{{2
   template <typename _Tp>
-    static constexpr inline _Tp _S_plus(_Tp __x, _Tp __y)
+    static constexpr inline _Tp
+    _S_plus(_Tp __x, _Tp __y)
     {
       return static_cast<_Tp>(__promote_preserving_unsigned(__x)
 			      + __promote_preserving_unsigned(__y));
     }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_minus(_Tp __x, _Tp __y)
+    static constexpr inline _Tp
+    _S_minus(_Tp __x, _Tp __y)
     {
       return static_cast<_Tp>(__promote_preserving_unsigned(__x)
 			      - __promote_preserving_unsigned(__y));
     }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_multiplies(_Tp __x, _Tp __y)
+    static constexpr inline _Tp
+    _S_multiplies(_Tp __x, _Tp __y)
     {
       return static_cast<_Tp>(__promote_preserving_unsigned(__x)
 			      * __promote_preserving_unsigned(__y));
     }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_divides(_Tp __x, _Tp __y)
+    static constexpr inline _Tp
+    _S_divides(_Tp __x, _Tp __y)
     {
       return static_cast<_Tp>(__promote_preserving_unsigned(__x)
 			      / __promote_preserving_unsigned(__y));
     }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_modulus(_Tp __x, _Tp __y)
+    static constexpr inline _Tp
+    _S_modulus(_Tp __x, _Tp __y)
     {
       return static_cast<_Tp>(__promote_preserving_unsigned(__x)
 			      % __promote_preserving_unsigned(__y));
     }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_bit_and(_Tp __x, _Tp __y)
+    static constexpr inline _Tp
+    _S_bit_and(_Tp __x, _Tp __y)
     {
       if constexpr (is_floating_point_v<_Tp>)
 	{
@@ -254,7 +269,8 @@ struct _SimdImplScalar
     }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_bit_or(_Tp __x, _Tp __y)
+    static constexpr inline _Tp
+    _S_bit_or(_Tp __x, _Tp __y)
     {
       if constexpr (is_floating_point_v<_Tp>)
 	{
@@ -267,7 +283,8 @@ struct _SimdImplScalar
     }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_bit_xor(_Tp __x, _Tp __y)
+    static constexpr inline _Tp
+    _S_bit_xor(_Tp __x, _Tp __y)
     {
       if constexpr (is_floating_point_v<_Tp>)
 	{
@@ -280,11 +297,13 @@ struct _SimdImplScalar
     }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_bit_shift_left(_Tp __x, int __y)
+    static constexpr inline _Tp
+    _S_bit_shift_left(_Tp __x, int __y)
     { return static_cast<_Tp>(__promote_preserving_unsigned(__x) << __y); }
 
   template <typename _Tp>
-    static constexpr inline _Tp _S_bit_shift_right(_Tp __x, int __y)
+    static constexpr inline _Tp
+    _S_bit_shift_right(_Tp __x, int __y)
     { return static_cast<_Tp>(__promote_preserving_unsigned(__x) >> __y); }
 
   // math {{{2
@@ -293,297 +312,361 @@ struct _SimdImplScalar
     using _ST = _SimdTuple<_Tp, simd_abi::scalar>;
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_acos(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_acos(_Tp __x)
     { return std::acos(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_asin(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_asin(_Tp __x)
     { return std::asin(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_atan(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_atan(_Tp __x)
     { return std::atan(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_cos(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_cos(_Tp __x)
     { return std::cos(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_sin(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_sin(_Tp __x)
     { return std::sin(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_tan(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_tan(_Tp __x)
     { return std::tan(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_acosh(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_acosh(_Tp __x)
     { return std::acosh(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_asinh(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_asinh(_Tp __x)
     { return std::asinh(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_atanh(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_atanh(_Tp __x)
     { return std::atanh(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_cosh(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_cosh(_Tp __x)
     { return std::cosh(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_sinh(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_sinh(_Tp __x)
     { return std::sinh(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_tanh(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_tanh(_Tp __x)
     { return std::tanh(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_atan2(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_atan2(_Tp __x, _Tp __y)
     { return std::atan2(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_exp(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_exp(_Tp __x)
     { return std::exp(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_exp2(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_exp2(_Tp __x)
     { return std::exp2(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_expm1(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_expm1(_Tp __x)
     { return std::expm1(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_log(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_log(_Tp __x)
     { return std::log(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_log10(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_log10(_Tp __x)
     { return std::log10(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_log1p(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_log1p(_Tp __x)
     { return std::log1p(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_log2(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_log2(_Tp __x)
     { return std::log2(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_logb(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_logb(_Tp __x)
     { return std::logb(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _ST<int> _S_ilogb(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _ST<int>
+    _S_ilogb(_Tp __x)
     { return {std::ilogb(__x)}; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_pow(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_pow(_Tp __x, _Tp __y)
     { return std::pow(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_abs(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_abs(_Tp __x)
     { return std::abs(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_fabs(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_fabs(_Tp __x)
     { return std::fabs(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_sqrt(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_sqrt(_Tp __x)
     { return std::sqrt(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_cbrt(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_cbrt(_Tp __x)
     { return std::cbrt(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_erf(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_erf(_Tp __x)
     { return std::erf(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_erfc(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_erfc(_Tp __x)
     { return std::erfc(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_lgamma(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_lgamma(_Tp __x)
     { return std::lgamma(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_tgamma(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_tgamma(_Tp __x)
     { return std::tgamma(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_trunc(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_trunc(_Tp __x)
     { return std::trunc(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_floor(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_floor(_Tp __x)
     { return std::floor(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_ceil(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_ceil(_Tp __x)
     { return std::ceil(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_nearbyint(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_nearbyint(_Tp __x)
     { return std::nearbyint(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_rint(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_rint(_Tp __x)
     { return std::rint(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _ST<long> _S_lrint(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _ST<long>
+    _S_lrint(_Tp __x)
     { return {std::lrint(__x)}; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _ST<long long> _S_llrint(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _ST<long long>
+    _S_llrint(_Tp __x)
     { return {std::llrint(__x)}; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_round(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_round(_Tp __x)
     { return std::round(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _ST<long> _S_lround(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _ST<long>
+    _S_lround(_Tp __x)
     { return {std::lround(__x)}; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _ST<long long> _S_llround(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static _ST<long long>
+    _S_llround(_Tp __x)
     { return {std::llround(__x)}; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_ldexp(_Tp __x, _ST<int> __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_ldexp(_Tp __x, _ST<int> __y)
     { return std::ldexp(__x, __y.first); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_scalbn(_Tp __x, _ST<int> __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_scalbn(_Tp __x, _ST<int> __y)
     { return std::scalbn(__x, __y.first); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_scalbln(_Tp __x, _ST<long> __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_scalbln(_Tp __x, _ST<long> __y)
     { return std::scalbln(__x, __y.first); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_fmod(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_fmod(_Tp __x, _Tp __y)
     { return std::fmod(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_remainder(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_remainder(_Tp __x, _Tp __y)
     { return std::remainder(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_nextafter(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_nextafter(_Tp __x, _Tp __y)
     { return std::nextafter(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_fdim(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_fdim(_Tp __x, _Tp __y)
     { return std::fdim(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_fmax(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_fmax(_Tp __x, _Tp __y)
     { return std::fmax(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_fmin(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_fmin(_Tp __x, _Tp __y)
     { return std::fmin(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_fma(_Tp __x, _Tp __y, _Tp __z)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_fma(_Tp __x, _Tp __y, _Tp __z)
     { return std::fma(__x, __y, __z); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_remquo(_Tp __x, _Tp __y, _ST<int>* __z)
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_remquo(_Tp __x, _Tp __y, _ST<int>* __z)
     { return std::remquo(__x, __y, &__z->first); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static _ST<int> _S_fpclassify(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _ST<int>
+    _S_fpclassify(_Tp __x)
     { return {std::fpclassify(__x)}; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_isfinite(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_isfinite(_Tp __x)
     { return std::isfinite(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_isinf(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_isinf(_Tp __x)
     { return std::isinf(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_isnan(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_isnan(_Tp __x)
     { return std::isnan(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_isnormal(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_isnormal(_Tp __x)
     { return std::isnormal(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_signbit(_Tp __x)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_signbit(_Tp __x)
     { return std::signbit(__x); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_isgreater(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_isgreater(_Tp __x, _Tp __y)
     { return std::isgreater(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_isgreaterequal(_Tp __x,
-								    _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_isgreaterequal(_Tp __x, _Tp __y)
     { return std::isgreaterequal(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_isless(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_isless(_Tp __x, _Tp __y)
     { return std::isless(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_islessequal(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_islessequal(_Tp __x, _Tp __y)
     { return std::islessequal(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_islessgreater(_Tp __x,
-								   _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_islessgreater(_Tp __x, _Tp __y)
     { return std::islessgreater(__x, __y); }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_isunordered(_Tp __x,
-								 _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_isunordered(_Tp __x, _Tp __y)
     { return std::isunordered(__x, __y); }
 
   // _S_increment & _S_decrement{{{2
   template <typename _Tp>
-    constexpr static inline void _S_increment(_Tp& __x)
+    static constexpr void
+    _S_increment(_Tp& __x)
     { ++__x; }
 
   template <typename _Tp>
-    constexpr static inline void _S_decrement(_Tp& __x)
+    static constexpr void
+    _S_decrement(_Tp& __x)
     { --__x; }
 
-
   // compares {{{2
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_equal_to(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_equal_to(_Tp __x, _Tp __y)
     { return __x == __y; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_not_equal_to(_Tp __x,
-								  _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_not_equal_to(_Tp __x, _Tp __y)
     { return __x != __y; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_less(_Tp __x, _Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_less(_Tp __x, _Tp __y)
     { return __x < __y; }
 
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool _S_less_equal(_Tp __x,
-								_Tp __y)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_less_equal(_Tp __x, _Tp __y)
     { return __x <= __y; }
 
   // smart_reference access {{{2
   template <typename _Tp, typename _Up>
-    constexpr static void _S_set(_Tp& __v, [[maybe_unused]] int __i,
-				 _Up&& __x) noexcept
+    static constexpr void
+    _S_set(_Tp& __v, [[maybe_unused]] int __i, _Up&& __x) noexcept
     {
       _GLIBCXX_DEBUG_ASSERT(__i == 0);
       __v = static_cast<_Up&&>(__x);
@@ -591,20 +674,20 @@ struct _SimdImplScalar
 
   // _S_masked_assign {{{2
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static void
+    _GLIBCXX_SIMD_INTRINSIC static constexpr void
     _S_masked_assign(bool __k, _Tp& __lhs, _Tp __rhs)
     { if (__k) __lhs = __rhs; }
 
   // _S_masked_cassign {{{2
   template <typename _Op, typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static void
+    _GLIBCXX_SIMD_INTRINSIC static constexpr void
     _S_masked_cassign(const bool __k, _Tp& __lhs, const _Tp __rhs, _Op __op)
     { if (__k) __lhs = __op(_SimdImplScalar{}, __lhs, __rhs); }
 
   // _S_masked_unary {{{2
   template <template <typename> class _Op, typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static _Tp _S_masked_unary(const bool __k,
-								 const _Tp __v)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr _Tp
+    _S_masked_unary(const bool __k, const _Tp __v)
     { return static_cast<_Tp>(__k ? _Op<_Tp>{}(__v) : __v); }
 
   // }}}2
@@ -621,13 +704,15 @@ struct _MaskImplScalar
   // }}}
   // _S_broadcast {{{
   template <typename>
-    _GLIBCXX_SIMD_INTRINSIC static constexpr bool _S_broadcast(bool __x)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_broadcast(bool __x)
     { return __x; }
 
   // }}}
   // _S_load {{{
   template <typename>
-    _GLIBCXX_SIMD_INTRINSIC static constexpr bool _S_load(const bool* __mem)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
+    _S_load(const bool* __mem)
     { return __mem[0]; }
 
   // }}}
@@ -651,12 +736,12 @@ struct _MaskImplScalar
   // }}}
   // _S_from_bitmask {{{2
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
     _S_from_bitmask(_SanitizedBitMask<1> __bits, _TypeTag<_Tp>) noexcept
     { return __bits[0]; }
 
   // _S_masked_load {{{2
-  _GLIBCXX_SIMD_INTRINSIC constexpr static bool
+  _GLIBCXX_SIMD_INTRINSIC static constexpr bool
   _S_masked_load(bool __merge, bool __mask, const bool* __mem) noexcept
   {
     if (__mask)
@@ -665,11 +750,12 @@ struct _MaskImplScalar
   }
 
   // _S_store {{{2
-  _GLIBCXX_SIMD_INTRINSIC static void _S_store(bool __v, bool* __mem) noexcept
+  _GLIBCXX_SIMD_INTRINSIC static constexpr void
+  _S_store(bool __v, bool* __mem) noexcept
   { __mem[0] = __v; }
 
   // _S_masked_store {{{2
-  _GLIBCXX_SIMD_INTRINSIC static void
+  _GLIBCXX_SIMD_INTRINSIC static constexpr void
   _S_masked_store(const bool __v, bool* __mem, const bool __k) noexcept
   {
     if (__k)
@@ -677,35 +763,41 @@ struct _MaskImplScalar
   }
 
   // logical and bitwise operators {{{2
-  static constexpr bool _S_logical_and(bool __x, bool __y)
+  static constexpr bool
+  _S_logical_and(bool __x, bool __y)
   { return __x && __y; }
 
-  static constexpr bool _S_logical_or(bool __x, bool __y)
+  static constexpr bool
+  _S_logical_or(bool __x, bool __y)
   { return __x || __y; }
 
-  static constexpr bool _S_bit_not(bool __x)
+  static constexpr bool
+  _S_bit_not(bool __x)
   { return !__x; }
 
-  static constexpr bool _S_bit_and(bool __x, bool __y)
+  static constexpr bool
+  _S_bit_and(bool __x, bool __y)
   { return __x && __y; }
 
-  static constexpr bool _S_bit_or(bool __x, bool __y)
+  static constexpr bool
+  _S_bit_or(bool __x, bool __y)
   { return __x || __y; }
 
-  static constexpr bool _S_bit_xor(bool __x, bool __y)
+  static constexpr bool
+  _S_bit_xor(bool __x, bool __y)
   { return __x != __y; }
 
   // smart_reference access {{{2
-  constexpr static void _S_set(bool& __k, [[maybe_unused]] int __i,
-			       bool __x) noexcept
+  static constexpr void
+  _S_set(bool& __k, [[maybe_unused]] int __i, bool __x) noexcept
   {
     _GLIBCXX_DEBUG_ASSERT(__i == 0);
     __k = __x;
   }
 
   // _S_masked_assign {{{2
-  _GLIBCXX_SIMD_INTRINSIC static void _S_masked_assign(bool __k, bool& __lhs,
-						       bool __rhs)
+  _GLIBCXX_SIMD_INTRINSIC static constexpr void
+  _S_masked_assign(bool __k, bool& __lhs, bool __rhs)
   {
     if (__k)
       __lhs = __rhs;
@@ -714,49 +806,49 @@ struct _MaskImplScalar
   // }}}2
   // _S_all_of {{{
   template <typename _Tp, typename _Abi>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
     _S_all_of(simd_mask<_Tp, _Abi> __k)
     { return __k._M_data; }
 
   // }}}
   // _S_any_of {{{
   template <typename _Tp, typename _Abi>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
     _S_any_of(simd_mask<_Tp, _Abi> __k)
     { return __k._M_data; }
 
   // }}}
   // _S_none_of {{{
   template <typename _Tp, typename _Abi>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
     _S_none_of(simd_mask<_Tp, _Abi> __k)
     { return !__k._M_data; }
 
   // }}}
   // _S_some_of {{{
   template <typename _Tp, typename _Abi>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static bool
+    _GLIBCXX_SIMD_INTRINSIC static constexpr bool
     _S_some_of(simd_mask<_Tp, _Abi>)
     { return false; }
 
   // }}}
   // _S_popcount {{{
   template <typename _Tp, typename _Abi>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static int
+    _GLIBCXX_SIMD_INTRINSIC static constexpr int
     _S_popcount(simd_mask<_Tp, _Abi> __k)
     { return __k._M_data; }
 
   // }}}
   // _S_find_first_set {{{
   template <typename _Tp, typename _Abi>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static int
+    _GLIBCXX_SIMD_INTRINSIC static constexpr int
     _S_find_first_set(simd_mask<_Tp, _Abi>)
     { return 0; }
 
   // }}}
   // _S_find_last_set {{{
   template <typename _Tp, typename _Abi>
-    _GLIBCXX_SIMD_INTRINSIC constexpr static int
+    _GLIBCXX_SIMD_INTRINSIC static constexpr int
     _S_find_last_set(simd_mask<_Tp, _Abi>)
     { return 0; }
 
diff --git a/libstdc++-v3/include/experimental/bits/simd_x86.h b/libstdc++-v3/include/experimental/bits/simd_x86.h
index 305d7a9fa54..0b86927ab6e 100644
--- a/libstdc++-v3/include/experimental/bits/simd_x86.h
+++ b/libstdc++-v3/include/experimental/bits/simd_x86.h
@@ -40,10 +40,7 @@ _GLIBCXX_SIMD_BEGIN_NAMESPACE
 template <typename _Tp, size_t _Np>
   _GLIBCXX_SIMD_INTRINSIC constexpr _SimdWrapper<__int_for_sizeof_t<_Tp>, _Np>
   __to_masktype(_SimdWrapper<_Tp, _Np> __x)
-  {
-    return reinterpret_cast<__vector_type_t<__int_for_sizeof_t<_Tp>, _Np>>(
-      __x._M_data);
-  }
+  { return reinterpret_cast<__vector_type_t<__int_for_sizeof_t<_Tp>, _Np>>(__x._M_data); }
 
 template <typename _TV,
 	  typename _TVT
@@ -366,6 +363,53 @@ template <typename _Tp>
 
 // }}}
 
+#ifdef __clang__
+template <size_t _Np, typename _Tp, typename _Kp>
+  _GLIBCXX_SIMD_INTRINSIC constexpr auto
+  __movm(_Kp __k) noexcept
+  {
+    static_assert(is_unsigned_v<_Kp>);
+    if constexpr (sizeof(_Tp) == 1 && __have_avx512bw)
+      {
+	if constexpr (_Np <= 16 && __have_avx512vl)
+	  return __builtin_ia32_cvtmask2b128(__k);
+	else if constexpr (_Np <= 32 && __have_avx512vl)
+	  return __builtin_ia32_cvtmask2b256(__k);
+	else
+	  return __builtin_ia32_cvtmask2b512(__k);
+      }
+    else if constexpr (sizeof(_Tp) == 2 && __have_avx512bw)
+      {
+	if constexpr (_Np <= 8 && __have_avx512vl)
+	  return __builtin_ia32_cvtmask2w128(__k);
+	else if constexpr (_Np <= 16 && __have_avx512vl)
+	  return __builtin_ia32_cvtmask2w256(__k);
+	else
+	  return __builtin_ia32_cvtmask2w512(__k);
+      }
+    else if constexpr (sizeof(_Tp) == 4 && __have_avx512dq)
+      {
+	if constexpr (_Np <= 4 && __have_avx512vl)
+	  return __builtin_ia32_cvtmask2d128(__k);
+	else if constexpr (_Np <= 8 && __have_avx512vl)
+	  return __builtin_ia32_cvtmask2d256(__k);
+	else
+	  return __builtin_ia32_cvtmask2d512(__k);
+      }
+    else if constexpr (sizeof(_Tp) == 8 && __have_avx512dq)
+      {
+	if constexpr (_Np <= 2 && __have_avx512vl)
+	  return __builtin_ia32_cvtmask2q128(__k);
+	else if constexpr (_Np <= 4 && __have_avx512vl)
+	  return __builtin_ia32_cvtmask2q256(__k);
+	else
+	  return __builtin_ia32_cvtmask2q512(__k);
+      }
+    else
+      __assert_unreachable<_Tp>();
+  }
+#endif // __clang__
+
 #ifdef _GLIBCXX_SIMD_WORKAROUND_PR85048
 #include "simd_x86_conversions.h"
 #endif
@@ -434,7 +478,8 @@ struct _CommonImplX86 : _CommonImplBuiltin
 #ifdef _GLIBCXX_SIMD_WORKAROUND_PR85048
   // _S_converts_via_decomposition {{{
   template <typename _From, typename _To, size_t _ToSize>
-    static constexpr bool _S_converts_via_decomposition()
+    static constexpr bool
+    _S_converts_via_decomposition()
     {
       if constexpr (is_integral_v<
 		      _From> && is_integral_v<_To> && sizeof(_From) == 8
@@ -465,12 +510,14 @@ struct _CommonImplX86 : _CommonImplBuiltin
   using _CommonImplBuiltin::_S_store;
 
   template <typename _Tp, size_t _Np>
-    _GLIBCXX_SIMD_INTRINSIC static void _S_store(_SimdWrapper<_Tp, _Np> __x,
-						 void* __addr)
+    _GLIBCXX_SIMD_INTRINSIC static constexpr void
+    _S_store(_SimdWrapper<_Tp, _Np> __x, void* __addr)
     {
       constexpr size_t _Bytes = _Np * sizeof(_Tp);
 
-      if constexpr ((_Bytes & (_Bytes - 1)) != 0 && __have_avx512bw_vl)
+      if (__builtin_is_constant_evaluated())
+	_CommonImplBuiltin::_S_store(__x, __addr);
+      else if constexpr ((_Bytes & (_Bytes - 1)) != 0 && __have_avx512bw_vl)
 	{
 	  const auto __v = __to_intrin(__x);
 
@@ -536,17 +583,20 @@ struct _CommonImplX86 : _CommonImplBuiltin
     _GLIBCXX_SIMD_INTRINSIC static constexpr void
     _S_store_bool_array(const _BitMask<_Np, _Sanitized> __x, bool* __mem)
     {
-      if constexpr (__have_avx512bw_vl) // don't care for BW w/o VL
-	_S_store<_Np>(1 & __vector_bitcast<_UChar, _Np>([=]() constexpr {
-			if constexpr (_Np <= 16)
-			  return _mm_movm_epi8(__x._M_to_bits());
-			else if constexpr (_Np <= 32)
-			  return _mm256_movm_epi8(__x._M_to_bits());
-			else if constexpr (_Np <= 64)
-			  return _mm512_movm_epi8(__x._M_to_bits());
-			else
-			  __assert_unreachable<_SizeConstant<_Np>>();
-		      }()),
+      if (__builtin_is_constant_evaluated())
+	_CommonImplBuiltin::_S_store_bool_array(__x, __mem);
+      else if constexpr (__have_avx512bw_vl) // don't care for BW w/o VL
+	_S_store<_Np>(1 & __vector_bitcast<_UChar, _Np>(
+			    [=]() constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+			      if constexpr (_Np <= 16)
+				return _mm_movm_epi8(__x._M_to_bits());
+			      else if constexpr (_Np <= 32)
+				return _mm256_movm_epi8(__x._M_to_bits());
+			      else if constexpr (_Np <= 64)
+				return _mm512_movm_epi8(__x._M_to_bits());
+			      else
+				__assert_unreachable<_SizeConstant<_Np>>();
+			    }()),
 		      __mem);
       else if constexpr (__have_bmi2)
 	{
@@ -554,7 +604,7 @@ struct _CommonImplX86 : _CommonImplBuiltin
 	    _S_store<_Np>(_pdep_u32(__x._M_to_bits(), 0x01010101U), __mem);
 	  else
 	    __execute_n_times<__div_roundup(_Np, sizeof(size_t))>(
-	      [&](auto __i) {
+	      [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		constexpr size_t __offset = __i * sizeof(size_t);
 		constexpr int __todo = std::min(sizeof(size_t), _Np - __offset);
 		if constexpr (__todo == 1)
@@ -575,7 +625,7 @@ struct _CommonImplX86 : _CommonImplBuiltin
 	      });
 	}
       else if constexpr (__have_sse2 && _Np > 7)
-	__execute_n_times<__div_roundup(_Np, 16)>([&](auto __i) {
+	__execute_n_times<__div_roundup(_Np, 16)>([&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 	  constexpr int __offset = __i * 16;
 	  constexpr int __todo = std::min(16, int(_Np) - __offset);
 	  const int __bits = __x.template _M_extract<__offset>()._M_to_bits();
@@ -620,14 +670,13 @@ struct _CommonImplX86 : _CommonImplBuiltin
     _GLIBCXX_SIMD_INTRINSIC static _TV
     _S_blend_avx512(const _Kp __k, const _TV __a, const _TV __b) noexcept
     {
-#ifdef __clang__
-      // FIXME: this does a boolean choice, not a blend
-      return __k ? __a : __b;
-#else
       static_assert(__is_vector_type_v<_TV>);
       using _Tp = typename _VectorTraits<_TV>::value_type;
       static_assert(sizeof(_TV) >= 16);
       static_assert(sizeof(_Tp) <= 8);
+#ifdef __clang__
+      return __movm<_VectorTraits<_TV>::_S_full_size, _Tp>(__k) ? __b : __a;
+#else
       using _IntT
 	= conditional_t<(sizeof(_Tp) > 2),
 			conditional_t<sizeof(_Tp) == 4, int, long long>,
@@ -701,8 +750,8 @@ struct _CommonImplX86 : _CommonImplBuiltin
   // Requires: _Tp to be an intrinsic type (integers blend per byte) and 16/32
   //           Bytes wide
   template <typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static _Tp _S_blend_intrin(_Tp __k, _Tp __a,
-						       _Tp __b) noexcept
+    _GLIBCXX_SIMD_INTRINSIC static _Tp
+    _S_blend_intrin(_Tp __k, _Tp __a, _Tp __b) noexcept
     {
       static_assert(is_same_v<decltype(__to_intrin(__a)), _Tp>);
       constexpr struct
@@ -765,9 +814,10 @@ struct _CommonImplX86 : _CommonImplBuiltin
       static_assert(is_same_v<_Tp, _Tp> && __have_avx512f);
       if (__k._M_is_constprop() && __at0._M_is_constprop()
 	  && __at1._M_is_constprop())
-	return __generate_from_n_evaluations<_Np,
-					     __vector_type_t<_Tp, _Np>>([&](
-	  auto __i) constexpr { return __k[__i] ? __at1[__i] : __at0[__i]; });
+	return __generate_from_n_evaluations<_Np, __vector_type_t<_Tp, _Np>>(
+		 [&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		   return __k[__i] ? __at1[__i] : __at0[__i];
+		 });
       else if constexpr (sizeof(__at0) == 64
 			 || (__have_avx512vl && sizeof(__at0) >= 16))
 	return _S_blend_avx512(__k._M_data, __at0._M_data, __at1._M_data);
@@ -841,6 +891,7 @@ template <typename _Abi>
 	= (sizeof(_Tp) >= 4 && __have_avx512f) || __have_avx512bw  ? 64
 	  : (is_floating_point_v<_Tp>&& __have_avx) || __have_avx2 ? 32
 								   : 16;
+
     using _MaskImpl = typename _Abi::_MaskImpl;
 
     // _S_masked_load {{{
@@ -994,9 +1045,8 @@ template <typename _Abi>
 	      }
 	    else
 	      _BitOps::_S_bit_iteration(_MaskImpl::_S_to_bits(__k),
-					[&](auto __i) {
-					  __merge._M_set(__i, static_cast<_Tp>(
-								__mem[__i]));
+					[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+					  __merge._M_set(__i, static_cast<_Tp>(__mem[__i]));
 					});
 	  }
 	/* Very uncertain, that the following improves anything. Needs
@@ -1032,8 +1082,7 @@ template <typename _Abi>
     // _S_masked_store_nocvt {{{
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static void
-      _S_masked_store_nocvt(_SimdWrapper<_Tp, _Np> __v, _Tp* __mem,
-			    _SimdWrapper<bool, _Np> __k)
+      _S_masked_store_nocvt(_SimdWrapper<_Tp, _Np> __v, _Tp* __mem, _SimdWrapper<bool, _Np> __k)
       {
 	[[maybe_unused]] const auto __vi = __to_intrin(__v);
 	if constexpr (sizeof(__vi) == 64)
@@ -1300,7 +1349,8 @@ template <typename _Abi>
     // }}}
     // _S_multiplies {{{
     template <typename _V, typename _VVT = _VectorTraits<_V>>
-      _GLIBCXX_SIMD_INTRINSIC static constexpr _V _S_multiplies(_V __x, _V __y)
+      _GLIBCXX_SIMD_INTRINSIC static constexpr _V
+      _S_multiplies(_V __x, _V __y)
       {
 	using _Tp = typename _VVT::value_type;
 	if (__builtin_is_constant_evaluated() || __x._M_is_constprop()
@@ -1417,12 +1467,13 @@ template <typename _Abi>
 	      const auto __yf = __convert_all<_FloatV, __n_floatv>(
 		_Abi::__make_padding_nonzero(__as_vector(__y)));
 	      return __call_with_n_evaluations<__n_floatv>(
-		[](auto... __quotients) {
+		[](auto... __quotients) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		  return __vector_convert<_R>(__quotients...);
 		},
-		[&__xf,
-		 &__yf](auto __i) -> _SimdWrapper<_Float, __n_intermediate> {
-#if !defined __clang__ && __GCC_IEC_559 == 0
+		[&__xf, &__yf](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA
+		  -> _SimdWrapper<_Float, __n_intermediate>
+		{
+#if __RECIPROCAL_MATH__
 		  // If -freciprocal-math is active, using the `/` operator is
 		  // incorrect because it may be translated to an imprecise
 		  // multiplication with reciprocal. We need to use inline
@@ -1477,7 +1528,9 @@ template <typename _Abi>
 	  */
 	return _Base::_S_divides(__x, __y);
       }
-  #endif // _GLIBCXX_SIMD_WORKAROUND_PR90993
+#else
+    using _Base::_S_divides;
+#endif // _GLIBCXX_SIMD_WORKAROUND_PR90993
 
     // }}}
     // _S_modulus {{{
@@ -1524,7 +1577,7 @@ template <typename _Abi>
     // values.
   #ifndef _GLIBCXX_SIMD_NO_SHIFT_OPT
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      inline _GLIBCXX_CONST static typename _TVT::type
+      constexpr inline _GLIBCXX_CONST static typename _TVT::type
       _S_bit_shift_left(_Tp __xx, int __y)
       {
 	using _V = typename _TVT::type;
@@ -1629,7 +1682,7 @@ template <typename _Abi>
       }
 
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      inline _GLIBCXX_CONST static typename _TVT::type
+      constexpr inline _GLIBCXX_CONST static typename _TVT::type
       _S_bit_shift_left(_Tp __xx, typename _TVT::type __y)
       {
 	using _V = typename _TVT::type;
@@ -1798,7 +1851,7 @@ template <typename _Abi>
     // _S_bit_shift_right {{{
 #ifndef _GLIBCXX_SIMD_NO_SHIFT_OPT
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      inline _GLIBCXX_CONST static typename _TVT::type
+      constexpr inline _GLIBCXX_CONST static typename _TVT::type
       _S_bit_shift_right(_Tp __xx, int __y)
       {
 	using _V = typename _TVT::type;
@@ -1848,7 +1901,7 @@ template <typename _Abi>
       }
 
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      inline _GLIBCXX_CONST static typename _TVT::type
+      constexpr inline _GLIBCXX_CONST static typename _TVT::type
       _S_bit_shift_right(_Tp __xx, typename _TVT::type __y)
       {
 	using _V = typename _TVT::type;
@@ -1980,7 +2033,7 @@ template <typename _Abi>
 	      {
 		auto __mask = __vector_bitcast<_UChar>(
 		  __vector_bitcast<_UShort>(__iy) << 5);
-		auto __maskl = [&]() {
+		auto __maskl = [&]() _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		  return __to_intrin(__vector_bitcast<_UShort>(__mask) << 8);
 		};
 		auto __xh = __vector_bitcast<short>(__ix);
@@ -2067,19 +2120,20 @@ template <typename _Abi>
 	  }                                                      //}}}
 	else if constexpr (sizeof(_Up) == 2 && sizeof(__x) >= 4) //{{{
 	  {
-	    [[maybe_unused]] auto __blend_0xaa = [](auto __a, auto __b) {
-	      if constexpr (sizeof(__a) == 16)
-		return _mm_blend_epi16(__to_intrin(__a), __to_intrin(__b),
-				       0xaa);
-	      else if constexpr (sizeof(__a) == 32)
-		return _mm256_blend_epi16(__to_intrin(__a), __to_intrin(__b),
-					  0xaa);
-	      else if constexpr (sizeof(__a) == 64)
-		return _mm512_mask_blend_epi16(0xaaaa'aaaaU, __to_intrin(__a),
-					       __to_intrin(__b));
-	      else
-		__assert_unreachable<decltype(__a)>();
-	    };
+	    [[maybe_unused]] auto __blend_0xaa
+	      = [](auto __a, auto __b) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		if constexpr (sizeof(__a) == 16)
+		  return _mm_blend_epi16(__to_intrin(__a), __to_intrin(__b),
+					 0xaa);
+		else if constexpr (sizeof(__a) == 32)
+		  return _mm256_blend_epi16(__to_intrin(__a), __to_intrin(__b),
+					    0xaa);
+		else if constexpr (sizeof(__a) == 64)
+		  return _mm512_mask_blend_epi16(0xaaaa'aaaaU, __to_intrin(__a),
+						 __to_intrin(__b));
+		else
+		  __assert_unreachable<decltype(__a)>();
+	      };
 	    if constexpr (__have_avx512bw_vl && sizeof(_Tp) <= 16)
 	      return __intrin_bitcast<_V>(is_signed_v<_Up>
 					    ? _mm_srav_epi16(__ix, __iy)
@@ -2136,9 +2190,10 @@ template <typename _Abi>
 	      {
 		auto __k = __vector_bitcast<_UShort>(__iy) << 11;
 		auto __x128 = __vector_bitcast<_Up>(__ix);
-		auto __mask = [](__vector_type16_t<_UShort> __kk) {
-		  return __vector_bitcast<short>(__kk) < 0;
-		};
+		auto __mask
+		  = [](__vector_type16_t<_UShort> __kk) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		    return __vector_bitcast<short>(__kk) < 0;
+		  };
 		// do __x128 = 0 where __y[4] is set
 		__x128 = __mask(__k) ? decltype(__x128)() : __x128;
 		// do __x128 =>> 8 where __y[3] is set
@@ -2178,7 +2233,7 @@ template <typename _Abi>
 	      }
 	    else
 	      {
-		auto __shift = [](auto __a, auto __b) {
+		auto __shift = [](auto __a, auto __b) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		  if constexpr (is_signed_v<_Up>)
 		    return _mm_sra_epi32(__a, __b);
 		  else
@@ -2268,14 +2323,14 @@ template <typename _Abi>
 	  } // }}}
 	else if (__builtin_is_constant_evaluated())
 	  return _Base::_S_equal_to(__x, __y);
-	else if constexpr (sizeof(__x) == 8) // {{{
+	else if constexpr (sizeof(__x) == 8)
 	  {
 	    const auto __r128 = __vector_bitcast<_Tp, 16 / sizeof(_Tp)>(__x)
 				== __vector_bitcast<_Tp, 16 / sizeof(_Tp)>(__y);
-	    _MaskMember<_Tp> __r64;
+	    _MaskMember<_Tp> __r64{};
 	    __builtin_memcpy(&__r64._M_data, &__r128, sizeof(__r64));
 	    return __r64;
-	  } // }}}
+	  }
 	else
 	  return _Base::_S_equal_to(__x, __y);
       }
@@ -2340,15 +2395,16 @@ template <typename _Abi>
 	    else
 	      __assert_unreachable<_Tp>();
 	  }                                                   // }}}
-	else if constexpr (!__builtin_is_constant_evaluated() // {{{
-			   && sizeof(__x) == 8)
+	else if (__builtin_is_constant_evaluated())
+	  return _Base::_S_not_equal_to(__x, __y);
+	else if constexpr (sizeof(__x) == 8)
 	  {
 	    const auto __r128 = __vector_bitcast<_Tp, 16 / sizeof(_Tp)>(__x)
 				!= __vector_bitcast<_Tp, 16 / sizeof(_Tp)>(__y);
-	    _MaskMember<_Tp> __r64;
+	    _MaskMember<_Tp> __r64{};
 	    __builtin_memcpy(&__r64._M_data, &__r128, sizeof(__r64));
 	    return __r64;
-	  } // }}}
+	  }
 	else
 	  return _Base::_S_not_equal_to(__x, __y);
       }
@@ -2447,15 +2503,16 @@ template <typename _Abi>
 	    else
 	      __assert_unreachable<_Tp>();
 	  }                                                   // }}}
-	else if constexpr (!__builtin_is_constant_evaluated() // {{{
-			   && sizeof(__x) == 8)
+	else if (__builtin_is_constant_evaluated())
+	  return _Base::_S_less(__x, __y);
+	else if constexpr (sizeof(__x) == 8)
 	  {
 	    const auto __r128 = __vector_bitcast<_Tp, 16 / sizeof(_Tp)>(__x)
 				< __vector_bitcast<_Tp, 16 / sizeof(_Tp)>(__y);
-	    _MaskMember<_Tp> __r64;
+	    _MaskMember<_Tp> __r64{};
 	    __builtin_memcpy(&__r64._M_data, &__r128, sizeof(__r64));
 	    return __r64;
-	  } // }}}
+	  }
 	else
 	  return _Base::_S_less(__x, __y);
       }
@@ -2554,15 +2611,16 @@ template <typename _Abi>
 	    else
 	      __assert_unreachable<_Tp>();
 	  }                                                   // }}}
-	else if constexpr (!__builtin_is_constant_evaluated() // {{{
-			   && sizeof(__x) == 8)
+	else if (__builtin_is_constant_evaluated())
+	  return _Base::_S_less_equal(__x, __y);
+	else if constexpr (sizeof(__x) == 8)
 	  {
 	    const auto __r128 = __vector_bitcast<_Tp, 16 / sizeof(_Tp)>(__x)
 				<= __vector_bitcast<_Tp, 16 / sizeof(_Tp)>(__y);
-	    _MaskMember<_Tp> __r64;
+	    _MaskMember<_Tp> __r64{};
 	    __builtin_memcpy(&__r64._M_data, &__r128, sizeof(__r64));
 	    return __r64;
-	  } // }}}
+	  }
 	else
 	  return _Base::_S_less_equal(__x, __y);
       }
@@ -2731,7 +2789,8 @@ template <typename _Abi>
     // }}}
     // _S_nearbyint {{{
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      _GLIBCXX_SIMD_INTRINSIC static _Tp _S_nearbyint(_Tp __x) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _S_nearbyint(_Tp __x) noexcept
       {
 	if constexpr (_TVT::template _S_is<float, 16>)
 	  return _mm512_roundscale_ps(__x, 0x0c);
@@ -2756,7 +2815,8 @@ template <typename _Abi>
     // }}}
     // _S_rint {{{
     template <typename _Tp, typename _TVT = _VectorTraits<_Tp>>
-      _GLIBCXX_SIMD_INTRINSIC static _Tp _S_rint(_Tp __x) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static _Tp
+      _S_rint(_Tp __x) noexcept
       {
 	if constexpr (_TVT::template _S_is<float, 16>)
 	  return _mm512_roundscale_ps(__x, 0x04);
@@ -2904,7 +2964,8 @@ template <typename _Abi>
     // _S_isnonzerovalue_mask {{{
     // (isnormal | is subnormal == !isinf & !isnan & !is zero)
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static auto _S_isnonzerovalue_mask(_Tp __x)
+      _GLIBCXX_SIMD_INTRINSIC static auto
+      _S_isnonzerovalue_mask(_Tp __x)
       {
 	using _Traits = _VectorTraits<_Tp>;
 	if constexpr (__have_avx512dq_vl)
@@ -3171,8 +3232,8 @@ template <typename _Abi>
     // }}}
     // _S_isgreater {{{
     template <typename _Tp, size_t _Np>
-      static constexpr _MaskMember<_Tp> _S_isgreater(_SimdWrapper<_Tp, _Np> __x,
-						     _SimdWrapper<_Tp, _Np> __y)
+      static constexpr _MaskMember<_Tp>
+      _S_isgreater(_SimdWrapper<_Tp, _Np> __x, _SimdWrapper<_Tp, _Np> __y)
       {
 	const auto __xi = __to_intrin(__x);
 	const auto __yi = __to_intrin(__y);
@@ -3289,8 +3350,8 @@ template <typename _Abi>
     // }}}
     // _S_isless {{{
     template <typename _Tp, size_t _Np>
-      static constexpr _MaskMember<_Tp> _S_isless(_SimdWrapper<_Tp, _Np> __x,
-						  _SimdWrapper<_Tp, _Np> __y)
+      static constexpr _MaskMember<_Tp>
+      _S_isless(_SimdWrapper<_Tp, _Np> __x, _SimdWrapper<_Tp, _Np> __y)
       {
 	const auto __xi = __to_intrin(__x);
 	const auto __yi = __to_intrin(__y);
@@ -3454,6 +3515,76 @@ template <typename _Abi>
       }
 
     //}}} }}}
+    template <template <typename> class _Op, typename _Tp, typename _K, size_t _Np>
+      _GLIBCXX_SIMD_INTRINSIC static _SimdWrapper<_Tp, _Np>
+      _S_masked_unary(const _SimdWrapper<_K, _Np> __k, const _SimdWrapper<_Tp, _Np> __v)
+      {
+	if (__k._M_is_constprop_none_of())
+	  return __v;
+	else if (__k._M_is_constprop_all_of())
+	  {
+	    auto __vv = _Base::_M_make_simd(__v);
+	    _Op<decltype(__vv)> __op;
+	    return __data(__op(__vv));
+	  }
+	else if constexpr (__is_bitmask_v<decltype(__k)>
+			     && (is_same_v<_Op<void>, __increment<void>>
+				   || is_same_v<_Op<void>, __decrement<void>>))
+	  {
+	    // optimize masked unary increment and decrement as masked sub +/-1
+	    constexpr int __pm_one
+	      = is_same_v<_Op<void>, __increment<void>> ? -1 : 1;
+#ifdef __clang__
+	    return __movm<_Np, _Tp>(__k._M_data) ? __v._M_data - __pm_one : __v._M_data;
+#else // __clang__
+	    if constexpr (is_integral_v<_Tp>)
+	      {
+		constexpr bool __lp64 = sizeof(long) == sizeof(long long);
+		using _Ip = std::make_signed_t<_Tp>;
+		using _Up = std::conditional_t<
+			      std::is_same_v<_Ip, long>,
+			      std::conditional_t<__lp64, long long, int>,
+			      std::conditional_t<
+				std::is_same_v<_Ip, signed char>, char, _Ip>>;
+		const auto __value = __vector_bitcast<_Up>(__v._M_data);
+#define _GLIBCXX_SIMD_MASK_SUB(_Sizeof, _Width, _Instr)                        \
+  if constexpr (sizeof(_Tp) == _Sizeof && sizeof(__v) == _Width)               \
+    return __vector_bitcast<_Tp>(__builtin_ia32_##_Instr##_mask(__value,       \
+	     __vector_broadcast<_Np>(_Up(__pm_one)), __value, __k._M_data))
+		_GLIBCXX_SIMD_MASK_SUB(1, 64, psubb512);
+		_GLIBCXX_SIMD_MASK_SUB(1, 32, psubb256);
+		_GLIBCXX_SIMD_MASK_SUB(1, 16, psubb128);
+		_GLIBCXX_SIMD_MASK_SUB(2, 64, psubw512);
+		_GLIBCXX_SIMD_MASK_SUB(2, 32, psubw256);
+		_GLIBCXX_SIMD_MASK_SUB(2, 16, psubw128);
+		_GLIBCXX_SIMD_MASK_SUB(4, 64, psubd512);
+		_GLIBCXX_SIMD_MASK_SUB(4, 32, psubd256);
+		_GLIBCXX_SIMD_MASK_SUB(4, 16, psubd128);
+		_GLIBCXX_SIMD_MASK_SUB(8, 64, psubq512);
+		_GLIBCXX_SIMD_MASK_SUB(8, 32, psubq256);
+		_GLIBCXX_SIMD_MASK_SUB(8, 16, psubq128);
+#undef _GLIBCXX_SIMD_MASK_SUB
+	      }
+	    else
+	      {
+#define _GLIBCXX_SIMD_MASK_SUB(_Sizeof, _Width, _Instr)                        \
+  if constexpr (sizeof(_Tp) == _Sizeof && sizeof(__v) == _Width)               \
+    return __builtin_ia32_##_Instr##_mask(                                     \
+	     __v._M_data, __vector_broadcast<_Np>(_Tp(__pm_one)), __v._M_data, \
+	     __k._M_data, _MM_FROUND_CUR_DIRECTION)
+		_GLIBCXX_SIMD_MASK_SUB(4, 64, subps512);
+		_GLIBCXX_SIMD_MASK_SUB(4, 32, subps256);
+		_GLIBCXX_SIMD_MASK_SUB(4, 16, subps128);
+		_GLIBCXX_SIMD_MASK_SUB(8, 64, subpd512);
+		_GLIBCXX_SIMD_MASK_SUB(8, 32, subpd256);
+		_GLIBCXX_SIMD_MASK_SUB(8, 16, subpd128);
+#undef _GLIBCXX_SIMD_MASK_SUB
+	      }
+#endif // __clang__
+	  }
+	else
+	  return _Base::template _S_masked_unary<_Op>(__k, __v);
+      }
   };
 
 // }}}
@@ -3467,8 +3598,8 @@ struct _MaskImplX86Mixin
 
   // _S_to_maskvector(bool) {{{
   template <typename _Up, size_t _ToN = 1, typename _Tp>
-    _GLIBCXX_SIMD_INTRINSIC static constexpr enable_if_t<
-      is_same_v<_Tp, bool>, _SimdWrapper<_Up, _ToN>>
+    _GLIBCXX_SIMD_INTRINSIC static constexpr
+    enable_if_t<is_same_v<_Tp, bool>, _SimdWrapper<_Up, _ToN>>
     _S_to_maskvector(_Tp __x)
     {
       static_assert(is_same_v<_Up, __int_for_sizeof_t<_Up>>);
@@ -3478,8 +3609,7 @@ struct _MaskImplX86Mixin
 
   // }}}
   // _S_to_maskvector(_SanitizedBitMask) {{{
-  template <typename _Up, size_t _UpN = 0, size_t _Np,
-	    size_t _ToN = _UpN == 0 ? _Np : _UpN>
+  template <typename _Up, size_t _UpN = 0, size_t _Np, size_t _ToN = _UpN == 0 ? _Np : _UpN>
     _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Up, _ToN>
     _S_to_maskvector(_SanitizedBitMask<_Np> __x)
     {
@@ -3491,7 +3621,7 @@ struct _MaskImplX86Mixin
 	return _S_to_maskvector<_Up, _ToN>(__k);
       else if (__x._M_is_constprop() || __builtin_is_constant_evaluated())
 	return __generate_from_n_evaluations<std::min(_ToN, _Np), _UV>(
-	  [&](auto __i) -> _Up { return -__x[__i.value]; });
+	  [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA -> _Up { return -__x[__i.value]; });
       else if constexpr (sizeof(_Up) == 1)
 	{
 	  if constexpr (sizeof(_UI) == 16)
@@ -3736,9 +3866,9 @@ struct _MaskImplX86Mixin
       else if constexpr (__bits_per_element >= _ToN)
 	{
 	  constexpr auto __bitmask
-	    = __generate_vector<_V>([](auto __i) constexpr->_UpUInt {
-		return __i < _ToN ? 1ull << __i : 0;
-	      });
+	    = __generate_vector<_V>([](auto __i)
+				    constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA -> _UpUInt
+				    { return __i < _ToN ? 1ull << __i : 0; });
 	  const auto __bits
 	    = __vector_broadcast<_ToN, _UpUInt>(__k) & __bitmask;
 	  if constexpr (__bits_per_element > _ToN)
@@ -3749,11 +3879,11 @@ struct _MaskImplX86Mixin
       else
 	{
 	  const _V __tmp
-	    = __generate_vector<_V>([&](auto __i) constexpr {
+	    = __generate_vector<_V>([&](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		return static_cast<_UpUInt>(
 		  __k >> (__bits_per_element * (__i / __bits_per_element)));
 	      })
-	      & __generate_vector<_V>([](auto __i) constexpr {
+	      & __generate_vector<_V>([](auto __i) constexpr _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		  return static_cast<_UpUInt>(1ull
 					      << (__i % __bits_per_element));
 		}); // mask bit index
@@ -3789,7 +3919,7 @@ struct _MaskImplX86Mixin
 	      const auto __y = __vector_bitcast<__int_for_sizeof_t<_Tp>>(__x);
 	      return __generate_from_n_evaluations<std::min(_ToN, _Np),
 						   __vector_type_t<_Up, _ToN>>(
-		[&](auto __i) -> _Up { return __y[__i.value]; });
+		[&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA -> _Up { return __y[__i.value]; });
 	    }
 	  using _To = __vector_type_t<_Up, _ToN>;
 	  [[maybe_unused]] constexpr size_t _FromN = _Np;
@@ -4124,8 +4254,11 @@ struct _MaskImplX86Mixin
 	    {
 	      const auto __bools = -__x._M_data;
 	      const _ULLong __k = __call_with_n_evaluations<_Np>(
-		[](auto... __bits) { return (__bits | ...); },
-		[&](auto __i) { return _ULLong(__bools[+__i]) << __i; });
+		[](auto... __bits) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		  return (__bits | ...);
+		}, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
+		  return _ULLong(__bools[+__i]) << __i;
+		});
 	      if (__builtin_is_constant_evaluated()
 		  || __builtin_constant_p(__k))
 		return __k;
@@ -4279,15 +4412,28 @@ template <typename _Abi>
       _S_load(const bool* __mem)
       {
 	static_assert(is_same_v<_Tp, __int_for_sizeof_t<_Tp>>);
-	if constexpr (__have_avx512bw)
+	if (__builtin_is_constant_evaluated())
 	  {
-	    const auto __to_vec_or_bits = [](auto __bits) -> decltype(auto) {
-	      if constexpr (__is_avx512_abi<_Abi>())
-		return __bits;
-	      else
-		return _S_to_maskvector<_Tp>(
-		  _BitMask<_S_size<_Tp>>(__bits)._M_sanitized());
-	    };
+	    if constexpr (__is_avx512_abi<_Abi>())
+	      {
+		_MaskMember<_Tp> __r{};
+		for (size_t __i = 0; __i < _S_size<_Tp>; ++__i)
+		  __r._M_data |= _ULLong(__mem[__i]) << __i;
+		return __r;
+	      }
+	    else
+	      return _Base::template _S_load<_Tp>(__mem);
+	  }
+	else if constexpr (__have_avx512bw)
+	  {
+	    const auto __to_vec_or_bits
+	      = [](auto __bits) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA -> decltype(auto) {
+		if constexpr (__is_avx512_abi<_Abi>())
+		  return __bits;
+		else
+		  return _S_to_maskvector<_Tp>(
+			   _BitMask<_S_size<_Tp>>(__bits)._M_sanitized());
+	      };
 
 	    if constexpr (_S_size<_Tp> <= 16 && __have_avx512vl)
 	      {
@@ -4474,7 +4620,7 @@ template <typename _Abi>
 	      }
 	    else
 	      {
-		_BitOps::_S_bit_iteration(__mask, [&](auto __i) {
+		_BitOps::_S_bit_iteration(__mask, [&](auto __i) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		  __merge._M_set(__i, __mem[__i]);
 		});
 		return __merge;
@@ -4546,14 +4692,16 @@ template <typename _Abi>
 
     // _S_store {{{2
     template <typename _Tp, size_t _Np>
-      _GLIBCXX_SIMD_INTRINSIC static void _S_store(_SimdWrapper<_Tp, _Np> __v,
-						   bool* __mem) noexcept
+      _GLIBCXX_SIMD_INTRINSIC static constexpr void
+      _S_store(_SimdWrapper<_Tp, _Np> __v, bool* __mem) noexcept
       {
-	if constexpr (__is_avx512_abi<_Abi>())
+	if (__builtin_is_constant_evaluated())
+	  _Base::_S_store(__v, __mem);
+	else if constexpr (__is_avx512_abi<_Abi>())
 	  {
 	    if constexpr (__have_avx512bw_vl)
 	      _CommonImplX86::_S_store<_Np>(
-		__vector_bitcast<char>([](auto __data) {
+		__vector_bitcast<char>([](auto __data) _GLIBCXX_SIMD_ALWAYS_INLINE_LAMBDA {
 		  if constexpr (_Np <= 16)
 		    return _mm_maskz_set1_epi8(__data, 1);
 		  else if constexpr (_Np <= 32)
@@ -4631,7 +4779,7 @@ template <typename _Abi>
 	    if constexpr (_Np <= 4 && sizeof(_Tp) == 8)
 	      {
 		auto __k = __intrin_bitcast<__m256i>(__to_intrin(__v));
-		int __bool4;
+		int __bool4{};
 		if constexpr (__have_avx2)
 		  __bool4 = _mm256_movemask_epi8(__k);
 		else
@@ -4711,12 +4859,13 @@ template <typename _Abi>
     // logical and bitwise operators {{{2
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_logical_and(const _SimdWrapper<_Tp, _Np>& __x,
-		     const _SimdWrapper<_Tp, _Np>& __y)
+      _S_logical_and(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       {
 	if constexpr (is_same_v<_Tp, bool>)
 	  {
-	    if constexpr (__have_avx512dq && _Np <= 8)
+	    if (__builtin_is_constant_evaluated())
+	      return __x._M_data & __y._M_data;
+	    else if constexpr (__have_avx512dq && _Np <= 8)
 	      return _kand_mask8(__x._M_data, __y._M_data);
 	    else if constexpr (_Np <= 16)
 	      return _kand_mask16(__x._M_data, __y._M_data);
@@ -4733,12 +4882,13 @@ template <typename _Abi>
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_logical_or(const _SimdWrapper<_Tp, _Np>& __x,
-		    const _SimdWrapper<_Tp, _Np>& __y)
+      _S_logical_or(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       {
 	if constexpr (is_same_v<_Tp, bool>)
 	  {
-	    if constexpr (__have_avx512dq && _Np <= 8)
+	    if (__builtin_is_constant_evaluated())
+	      return __x._M_data | __y._M_data;
+	    else if constexpr (__have_avx512dq && _Np <= 8)
 	      return _kor_mask8(__x._M_data, __y._M_data);
 	    else if constexpr (_Np <= 16)
 	      return _kor_mask16(__x._M_data, __y._M_data);
@@ -4759,7 +4909,9 @@ template <typename _Abi>
       {
 	if constexpr (is_same_v<_Tp, bool>)
 	  {
-	    if constexpr (__have_avx512dq && _Np <= 8)
+	    if (__builtin_is_constant_evaluated())
+	      return __x._M_data ^ _Abi::template __implicit_mask_n<_Np>();
+	    else if constexpr (__have_avx512dq && _Np <= 8)
 	      return _kandn_mask8(__x._M_data,
 				  _Abi::template __implicit_mask_n<_Np>());
 	    else if constexpr (_Np <= 16)
@@ -4780,12 +4932,13 @@ template <typename _Abi>
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_bit_and(const _SimdWrapper<_Tp, _Np>& __x,
-		 const _SimdWrapper<_Tp, _Np>& __y)
+      _S_bit_and(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       {
 	if constexpr (is_same_v<_Tp, bool>)
 	  {
-	    if constexpr (__have_avx512dq && _Np <= 8)
+	    if (__builtin_is_constant_evaluated())
+	      return __x._M_data & __y._M_data;
+	    else if constexpr (__have_avx512dq && _Np <= 8)
 	      return _kand_mask8(__x._M_data, __y._M_data);
 	    else if constexpr (_Np <= 16)
 	      return _kand_mask16(__x._M_data, __y._M_data);
@@ -4802,12 +4955,13 @@ template <typename _Abi>
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_bit_or(const _SimdWrapper<_Tp, _Np>& __x,
-		const _SimdWrapper<_Tp, _Np>& __y)
+      _S_bit_or(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       {
 	if constexpr (is_same_v<_Tp, bool>)
 	  {
-	    if constexpr (__have_avx512dq && _Np <= 8)
+	    if (__builtin_is_constant_evaluated())
+	      return __x._M_data | __y._M_data;
+	    else if constexpr (__have_avx512dq && _Np <= 8)
 	      return _kor_mask8(__x._M_data, __y._M_data);
 	    else if constexpr (_Np <= 16)
 	      return _kor_mask16(__x._M_data, __y._M_data);
@@ -4824,12 +4978,13 @@ template <typename _Abi>
 
     template <typename _Tp, size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
-      _S_bit_xor(const _SimdWrapper<_Tp, _Np>& __x,
-		 const _SimdWrapper<_Tp, _Np>& __y)
+      _S_bit_xor(const _SimdWrapper<_Tp, _Np>& __x, const _SimdWrapper<_Tp, _Np>& __y)
       {
 	if constexpr (is_same_v<_Tp, bool>)
 	  {
-	    if constexpr (__have_avx512dq && _Np <= 8)
+	    if (__builtin_is_constant_evaluated())
+	      return __x._M_data ^ __y._M_data;
+	    else if constexpr (__have_avx512dq && _Np <= 8)
 	      return _kxor_mask8(__x._M_data, __y._M_data);
 	    else if constexpr (_Np <= 16)
 	      return _kxor_mask16(__x._M_data, __y._M_data);
@@ -4849,8 +5004,7 @@ template <typename _Abi>
     template <size_t _Np>
       _GLIBCXX_SIMD_INTRINSIC static void
       _S_masked_assign(_SimdWrapper<bool, _Np> __k,
-		       _SimdWrapper<bool, _Np>& __lhs,
-		       _SimdWrapper<bool, _Np> __rhs)
+		       _SimdWrapper<bool, _Np>& __lhs, _SimdWrapper<bool, _Np> __rhs)
       {
 	__lhs._M_data
 	  = (~__k._M_data & __lhs._M_data) | (__k._M_data & __rhs._M_data);
@@ -4872,7 +5026,8 @@ template <typename _Abi>
     //}}}
     // _S_all_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_all_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static bool
+      _S_all_of(simd_mask<_Tp, _Abi> __k)
       {
 	if constexpr (__is_sse_abi<_Abi>() || __is_avx_abi<_Abi>())
 	  {
@@ -4928,7 +5083,8 @@ template <typename _Abi>
     // }}}
     // _S_any_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_any_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static bool
+      _S_any_of(simd_mask<_Tp, _Abi> __k)
       {
 	if constexpr (__is_sse_abi<_Abi>() || __is_avx_abi<_Abi>())
 	  {
@@ -4963,7 +5119,8 @@ template <typename _Abi>
     // }}}
     // _S_none_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_none_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static bool
+      _S_none_of(simd_mask<_Tp, _Abi> __k)
       {
 	if constexpr (__is_sse_abi<_Abi>() || __is_avx_abi<_Abi>())
 	  {
@@ -4998,7 +5155,8 @@ template <typename _Abi>
     // }}}
     // _S_some_of {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static bool _S_some_of(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static bool
+      _S_some_of(simd_mask<_Tp, _Abi> __k)
       {
 	if constexpr (__is_sse_abi<_Abi>() || __is_avx_abi<_Abi>())
 	  {
@@ -5039,7 +5197,8 @@ template <typename _Abi>
     // }}}
     // _S_popcount {{{
     template <typename _Tp>
-      _GLIBCXX_SIMD_INTRINSIC static int _S_popcount(simd_mask<_Tp, _Abi> __k)
+      _GLIBCXX_SIMD_INTRINSIC static int
+      _S_popcount(simd_mask<_Tp, _Abi> __k)
       {
 	constexpr size_t _Np = simd_size_v<_Tp, _Abi>;
 	const auto __kk = _Abi::_S_masked(__k._M_data)._M_data;
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index 6ce070ae775..07eb137fb80 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -441,13 +441,15 @@ namespace ip
     // constructors:
     constexpr address() noexcept : _M_v4(), _M_is_v4(true) { }
 
+#if __cpp_constexpr_dynamic_alloc
     constexpr
+#endif
     address(const address& __a) noexcept : _M_uninit(), _M_is_v4(__a._M_is_v4)
     {
       if (_M_is_v4)
-	::new (std::addressof(_M_v4)) address_v4(__a.to_v4());
+	std::_Construct(std::addressof(_M_v4), __a.to_v4());
       else
-	::new (std::addressof(_M_v6)) address_v6(__a.to_v6());
+	std::_Construct(std::addressof(_M_v6), __a.to_v6());
     }
 
     constexpr
@@ -470,7 +472,7 @@ namespace ip
     address&
     operator=(const address_v4& __a) noexcept
     {
-      ::new (std::addressof(_M_v4)) address_v4(__a);
+      std::_Construct(std::addressof(_M_v4), __a);
       _M_is_v4 = true;
       return *this;
     }
@@ -478,7 +480,7 @@ namespace ip
     address&
     operator=(const address_v6& __a) noexcept
     {
-      ::new (std::addressof(_M_v6)) address_v6(__a);
+      std::_Construct(std::addressof(_M_v6), __a);
       _M_is_v4 = false;
       return *this;
     }
diff --git a/libstdc++-v3/include/experimental/numeric b/libstdc++-v3/include/experimental/numeric
index 2731ddf573d..51cdfb4d2fe 100644
--- a/libstdc++-v3/include/experimental/numeric
+++ b/libstdc++-v3/include/experimental/numeric
@@ -56,17 +56,15 @@ inline namespace fundamentals_v2
     constexpr common_type_t<_Mn, _Nn>
     gcd(_Mn __m, _Nn __n) noexcept
     {
-      static_assert(is_integral_v<_Mn>,
-	  "std::experimental::gcd arguments must be integers");
-      static_assert(is_integral_v<_Nn>,
-	  "std::experimental::gcd arguments must be integers");
-      static_assert(_Mn(2) != _Mn(1),
-	  "std::experimental::gcd arguments must not be bool");
-      static_assert(_Nn(2) != _Nn(1),
-	  "std::experimental::gcd arguments must not be bool");
-      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;
-      return std::__detail::__gcd(std::__detail::__absu<_Up>(__m),
-				  std::__detail::__absu<_Up>(__n));
+      static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,
+		    "std::experimental::gcd arguments must be integers");
+      static_assert(_Mn(2) == 2 && _Nn(2) == 2,
+		    "std::experimental::gcd arguments must not be bool");
+      namespace __detail = std::__detail;
+      using _Ct = common_type_t<_Mn, _Nn>;
+      const _Ct __m2 = __detail::__abs_r<_Ct>(__m);
+      const _Ct __n2 = __detail::__abs_r<_Ct>(__n);
+      return __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);
     }
 
   /// Least common multiple
@@ -74,17 +72,27 @@ inline namespace fundamentals_v2
     constexpr common_type_t<_Mn, _Nn>
     lcm(_Mn __m, _Nn __n)
     {
-      static_assert(is_integral_v<_Mn>,
+      static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,
 	  "std::experimental::lcm arguments must be integers");
-      static_assert(is_integral_v<_Nn>,
-	  "std::experimental::lcm arguments must be integers");
-      static_assert(_Mn(2) != _Mn(1),
-	  "std::experimental::lcm arguments must not be bool");
-      static_assert(_Nn(2) != _Nn(1),
+      static_assert(_Mn(2) == 2 && _Nn(2) == 2,
 	  "std::experimental::lcm arguments must not be bool");
-      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;
-      return std::__detail::__lcm(std::__detail::__absu<_Up>(__m),
-				  std::__detail::__absu<_Up>(__n));
+      namespace __detail = std::__detail;
+      using _Ct = common_type_t<_Mn, _Nn>;
+      const _Ct __m2 = __detail::__abs_r<_Ct>(__m);
+      const _Ct __n2 = __detail::__abs_r<_Ct>(__n);
+      if (__m2 == 0 || __n2 == 0)
+	return 0;
+      _Ct __r = __m2 / __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);
+
+#if defined _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
+      if _GLIBCXX17_CONSTEXPR (is_signed_v<_Ct>)
+	if (__builtin_is_constant_evaluated())
+	  return __r * __n2; // constant evaluation can detect overflow here.
+#endif
+
+      bool __overflow = __builtin_mul_overflow(__r, __n2, &__r);
+      __glibcxx_assert(!__overflow);
+      return __r;
     }
 } // namespace fundamentals_v2
 } // namespace experimental
diff --git a/libstdc++-v3/include/experimental/optional b/libstdc++-v3/include/experimental/optional
index c1d61d6a0d7..2d934115923 100644
--- a/libstdc++-v3/include/experimental/optional
+++ b/libstdc++-v3/include/experimental/optional
@@ -1,4 +1,4 @@
-// <optional> -*- C++ -*-
+// <experimental/optional> -*- C++ -*-
 
 // Copyright (C) 2013-2021 Free Software Foundation, Inc.
 //
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
index d96ea06c1ae..5aec4040064 100644
--- a/libstdc++-v3/include/std/any
+++ b/libstdc++-v3/include/std/any
@@ -184,8 +184,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     /// Construct with a copy of @p __value as the contained object.
     template <typename _Tp, typename _VTp = _Decay_if_not_any<_Tp>,
 	      typename _Mgr = _Manager<_VTp>,
-	      typename = _Require<__not_<__is_in_place_type<_VTp>>,
-				  is_copy_constructible<_VTp>>>
+	      enable_if_t<is_copy_constructible_v<_VTp>
+			  && !__is_in_place_type_v<_VTp>, bool> = true>
       any(_Tp&& __value)
       : _M_manager(&_Mgr::_S_manage)
       {
diff --git a/libstdc++-v3/include/std/array b/libstdc++-v3/include/std/array
index 0c6f33e3276..95c9b688cdc 100644
--- a/libstdc++-v3/include/std/array
+++ b/libstdc++-v3/include/std/array
@@ -409,7 +409,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static_assert(!is_array_v<_Tp>);
       static_assert(is_constructible_v<_Tp, _Tp&>);
       if constexpr (is_constructible_v<_Tp, _Tp&>)
-	return __to_array(__a, make_index_sequence<_Nm>{});
+	return std::__to_array(__a, make_index_sequence<_Nm>{});
       __builtin_unreachable(); // FIXME: see PR c++/91388
     }
 
@@ -421,7 +421,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       static_assert(!is_array_v<_Tp>);
       static_assert(is_move_constructible_v<_Tp>);
       if constexpr (is_move_constructible_v<_Tp>)
-	return __to_array<1>(__a, make_index_sequence<_Nm>{});
+	return std::__to_array<1>(__a, make_index_sequence<_Nm>{});
       __builtin_unreachable(); // FIXME: see PR c++/91388
     }
 #endif // C++20
diff --git a/libstdc++-v3/include/std/atomic b/libstdc++-v3/include/std/atomic
index fdffacc35df..83102d02b4a 100644
--- a/libstdc++-v3/include/std/atomic
+++ b/libstdc++-v3/include/std/atomic
@@ -172,11 +172,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { _M_base.notify_one(); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { _M_base.notify_all(); }
 #endif // __cpp_lib_atomic_wait
   };
@@ -320,6 +320,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
 			    memory_order __f) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -330,6 +332,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
 			    memory_order __f) volatile noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -352,6 +356,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
 			      memory_order __f) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -362,6 +368,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
 			      memory_order __f) volatile noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -380,7 +388,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       { return compare_exchange_strong(__e, __i, __m,
                                        __cmpexch_failure_order(__m)); }
 
-#if __cpp_lib_atomic_wait 
+#if __cpp_lib_atomic_wait
     void
     wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept
     {
@@ -391,13 +399,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { std::__atomic_notify_address(&_M_i, false); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { std::__atomic_notify_address(&_M_i, true); }
-#endif // __cpp_lib_atomic_wait 
+#endif // __cpp_lib_atomic_wait
 
     };
 #undef _GLIBCXX20_INIT
@@ -645,11 +653,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { _M_b.notify_one(); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { _M_b.notify_all(); }
 #endif // __cpp_lib_atomic_wait
       __pointer_type
@@ -1203,6 +1211,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 				    memory_order __m) noexcept
   { return __a->test_and_set(__m); }
 
+#if __cpp_lib_atomic_flag_test
+  inline bool
+  atomic_flag_test(const atomic_flag* __a) noexcept
+  { return __a->test(); }
+
+  inline bool
+  atomic_flag_test(const volatile atomic_flag* __a) noexcept
+  { return __a->test(); }
+
+  inline bool
+  atomic_flag_test_explicit(const atomic_flag* __a,
+			    memory_order __m) noexcept
+  { return __a->test(__m); }
+
+  inline bool
+  atomic_flag_test_explicit(const volatile atomic_flag* __a,
+			    memory_order __m) noexcept
+  { return __a->test(__m); }
+#endif
+
   inline void
   atomic_flag_clear_explicit(atomic_flag* __a, memory_order __m) noexcept
   { __a->clear(__m); }
@@ -1228,11 +1256,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   atomic_flag_clear(volatile atomic_flag* __a) noexcept
   { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }
 
+#if __cpp_lib_atomic_wait
+  inline void
+  atomic_flag_wait(atomic_flag* __a, bool __old) noexcept
+  { __a->wait(__old); }
 
+  inline void
+  atomic_flag_wait_explicit(atomic_flag* __a, bool __old,
+                                memory_order __m) noexcept
+  { __a->wait(__old, __m); }
+
+  inline void
+  atomic_flag_notify_one(atomic_flag* __a) noexcept
+  { __a->notify_one(); }
+
+  inline void
+  atomic_flag_notify_all(atomic_flag* __a) noexcept
+  { __a->notify_all(); }
+#endif // __cpp_lib_atomic_wait
+
+  /// @cond undocumented
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 3220. P0558 broke conforming C++14 uses of atomic shared_ptr
   template<typename _Tp>
-    using __atomic_val_t = typename atomic<_Tp>::value_type;
+    using __atomic_val_t = __type_identity_t<_Tp>;
   template<typename _Tp>
     using __atomic_diff_t = typename atomic<_Tp>::difference_type;
+  /// @endcond
 
   // [atomics.nonmembers] Non-member functions.
   // Function templates generally applicable to atomic types.
@@ -1421,12 +1471,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _Tp>
     inline void
-    atomic_notify_one(const atomic<_Tp>* __a) noexcept
+    atomic_notify_one(atomic<_Tp>* __a) noexcept
     { __a->notify_one(); }
 
   template<typename _Tp>
     inline void
-    atomic_notify_all(const atomic<_Tp>* __a) noexcept
+    atomic_notify_all(atomic<_Tp>* __a) noexcept
     { __a->notify_all(); }
 #endif // __cpp_lib_atomic_wait
 
diff --git a/libstdc++-v3/include/std/barrier b/libstdc++-v3/include/std/barrier
index 4210e30d1ce..02501639f8e 100644
--- a/libstdc++-v3/include/std/barrier
+++ b/libstdc++-v3/include/std/barrier
@@ -13,8 +13,13 @@
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 // GNU General Public License for more details.
 
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
 // This implementation is based on libcxx/include/barrier
diff --git a/libstdc++-v3/include/std/charconv b/libstdc++-v3/include/std/charconv
index 8572e376c92..dc93c4c07bb 100644
--- a/libstdc++-v3/include/std/charconv
+++ b/libstdc++-v3/include/std/charconv
@@ -39,7 +39,6 @@
 
 #include <type_traits>
 #include <bit>			// for __bit_width
-#include <cctype>		// for isdigit
 #include <bits/charconv.h>	// for __to_chars_len, __to_chars_10_impl
 #include <bits/error_constants.h> // for std::errc
 #include <ext/numeric_traits.h>
@@ -236,7 +235,7 @@ namespace __detail
       static_assert(is_unsigned<_Tp>::value, "implementation bug");
 
       to_chars_result __res;
-      unsigned __len;
+      unsigned __len = 0;
 
       if _GLIBCXX17_CONSTEXPR (__gnu_cxx::__int_traits<_Tp>::__digits <= 16)
 	{
@@ -466,7 +465,7 @@ namespace __detail
       return true;
     }
 
-  constexpr unsigned char
+  constexpr char
   __from_chars_alpha_to_num(char __c)
   {
     switch (__c)
@@ -550,10 +549,10 @@ namespace __detail
     case 'Z':
       return 35;
     }
-    return __gnu_cxx::__int_traits<unsigned char>::__max;
+    return 127;
   }
 
-  /// std::from_chars implementation for integers in bases 11 to 26.
+  /// std::from_chars implementation for integers in bases 11 to 36.
   template<typename _Tp>
     bool
     __from_chars_alnum(const char*& __first, const char* __last, _Tp& __val,
@@ -562,8 +561,8 @@ namespace __detail
       bool __valid = true;
       while (__first != __last)
 	{
-	  unsigned char __c = *__first;
-	  if (std::isdigit(__c))
+	  char __c = *__first;
+	  if ('0' <= __c && __c <= '9') // isdigit
 	    __c -= '0';
 	  else
 	    {
diff --git a/libstdc++-v3/include/std/chrono b/libstdc++-v3/include/std/chrono
index a52304b1738..ca89ce89d87 100644
--- a/libstdc++-v3/include/std/chrono
+++ b/libstdc++-v3/include/std/chrono
@@ -3083,6 +3083,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return __width;
 	}
 
+	constexpr
+	hh_mm_ss(_Duration __d, bool __is_neg)
+	: _M_is_neg(__is_neg),
+	  _M_h (duration_cast<chrono::hours>(__d)),
+	  _M_m (duration_cast<chrono::minutes>(__d - hours())),
+	  _M_s (duration_cast<chrono::seconds>(__d - hours() - minutes()))
+	{
+	  auto __ss = __d - hours() - minutes() - seconds();
+	  if constexpr (treat_as_floating_point_v<typename precision::rep>)
+	    _M_ss = __ss;
+	  else
+	    _M_ss = duration_cast<precision>(__ss);
+	}
+
+	static constexpr _Duration
+	_S_abs(_Duration __d)
+	{
+	  if constexpr (numeric_limits<typename _Duration::rep>::is_signed)
+	    return chrono::abs(__d);
+	  else
+	    return __d;
+	}
+
       public:
 	static constexpr unsigned fractional_width = {_S_fractional_width()};
 
@@ -3097,18 +3120,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{ }
 
 	constexpr explicit
-	hh_mm_ss(_Duration __d) noexcept
-	: _M_is_neg (__d < _Duration::zero()),
-	  _M_h (duration_cast<chrono::hours>(abs(__d))),
-	  _M_m (duration_cast<chrono::minutes>(abs(__d) - hours())),
-	  _M_s (duration_cast<chrono::seconds>(abs(__d) - hours() - minutes()))
-	{
-	  if constexpr (treat_as_floating_point_v<typename precision::rep>)
-	    _M_ss = abs(__d) - hours() - minutes() - seconds();
-	  else
-	    _M_ss = duration_cast<precision>(abs(__d) - hours()
-					     - minutes() - seconds());
-	}
+	hh_mm_ss(_Duration __d)
+	: hh_mm_ss(_S_abs(__d), __d < _Duration::zero())
+	{ }
 
 	constexpr bool
 	is_negative() const noexcept
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 09e54c3703b..7aa243eb625 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -139,34 +139,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     deferred = 2
   };
 
-  constexpr launch operator&(launch __x, launch __y)
+  constexpr launch operator&(launch __x, launch __y) noexcept
   {
     return static_cast<launch>(
 	static_cast<int>(__x) & static_cast<int>(__y));
   }
 
-  constexpr launch operator|(launch __x, launch __y)
+  constexpr launch operator|(launch __x, launch __y) noexcept
   {
     return static_cast<launch>(
 	static_cast<int>(__x) | static_cast<int>(__y));
   }
 
-  constexpr launch operator^(launch __x, launch __y)
+  constexpr launch operator^(launch __x, launch __y) noexcept
   {
     return static_cast<launch>(
 	static_cast<int>(__x) ^ static_cast<int>(__y));
   }
 
-  constexpr launch operator~(launch __x)
+  constexpr launch operator~(launch __x) noexcept
   { return static_cast<launch>(~static_cast<int>(__x)); }
 
-  inline launch& operator&=(launch& __x, launch __y)
+  inline launch& operator&=(launch& __x, launch __y) noexcept
   { return __x = __x & __y; }
 
-  inline launch& operator|=(launch& __x, launch __y)
+  inline launch& operator|=(launch& __x, launch __y) noexcept
   { return __x = __x | __y; }
 
-  inline launch& operator^=(launch& __x, launch __y)
+  inline launch& operator^=(launch& __x, launch __y) noexcept
   { return __x = __x ^ __y; }
 
   /// Status code for futures
@@ -1621,6 +1621,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
     };
 
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 3117. Missing packaged_task deduction guides
+#if __cpp_deduction_guides >= 201606
+  template<typename _Res, typename... _ArgTypes>
+    packaged_task(_Res(*)(_ArgTypes...)) -> packaged_task<_Res(_ArgTypes...)>;
+
+  template<typename _Fun, typename _Signature = typename
+	   __function_guide_helper<decltype(&_Fun::operator())>::type>
+    packaged_task(_Fun) -> packaged_task<_Signature>;
+#endif
+
   /// swap
   template<typename _Res, typename... _ArgTypes>
     inline void
@@ -1647,7 +1658,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	explicit
 	_Deferred_state(_Args&&... __args)
 	: _M_result(new _Result<_Res>()),
-	  _M_fn{{std::forward<_Args>(__args)...}}
+	  _M_fn(std::forward<_Args>(__args)...)
 	{ }
 
     private:
@@ -1714,7 +1725,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	explicit
 	_Async_state_impl(_Args&&... __args)
 	: _M_result(new _Result<_Res>()),
-	  _M_fn{{std::forward<_Args>(__args)...}}
+	  _M_fn(std::forward<_Args>(__args)...)
 	{
 	  _M_thread = std::thread{&_Async_state_impl::_M_run, this};
 	}
diff --git a/libstdc++-v3/include/std/iosfwd b/libstdc++-v3/include/std/iosfwd
index 52fa4b6cccb..610383992fb 100644
--- a/libstdc++-v3/include/std/iosfwd
+++ b/libstdc++-v3/include/std/iosfwd
@@ -207,6 +207,24 @@ _GLIBCXX_END_NAMESPACE_CXX11
   /// Class for @c wchar_t mixed input and output file streams.
   typedef basic_fstream<wchar_t> 	wfstream;
 #endif
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+           typename _Allocator = allocator<_CharT>>
+    class basic_syncbuf;
+  template<typename _CharT, typename _Traits = char_traits<_CharT>,
+           typename _Allocator = allocator<_CharT>>
+    class basic_osyncstream;
+
+  using syncbuf = basic_syncbuf<char>;
+  using osyncstream = basic_osyncstream<char>;
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  using wsyncbuf = basic_syncbuf<wchar_t>;
+  using wosyncstream = basic_osyncstream<wchar_t>;
+#endif
+#endif // C++20 && CXX11_ABI
+
   /** @}  */
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/include/std/istream b/libstdc++-v3/include/std/istream
index 5ad60dbd709..109564b3c0d 100644
--- a/libstdc++-v3/include/std/istream
+++ b/libstdc++-v3/include/std/istream
@@ -784,7 +784,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
    *  - if `width()` is greater than zero, `n` is `min(width(), n)`
    *  - otherwise `n` is the number of elements of the array
    *  - (before C++20 the pointer is assumed to point to an array of
-   *  - the largest possible size for an array of `char_type`).
+   *    the largest possible size for an array of `char_type`).
    *
    *  Characters are extracted and stored until one of the following happens:
    *  - `n - 1` characters are stored
@@ -802,19 +802,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline basic_istream<_CharT, _Traits>&
     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
     {
+#ifdef __OPTIMIZE__
+      // Function inlining might make the buffer size known, allowing us to
+      // prevent overflow.
       size_t __n = __builtin_object_size(__s, 0);
-      if (__builtin_expect(__n < sizeof(_CharT), false))
+      if (__n < sizeof(_CharT))
 	{
 	  // There is not even space for the required null terminator.
 	  __glibcxx_assert(__n >= sizeof(_CharT));
+	  // No point calling __istream_extract, but still need to reset width.
 	  __in.width(0);
 	  __in.setstate(ios_base::failbit);
 	}
+      else if (__n != (size_t)-1)
+	{
+	  __n /= sizeof(_CharT);
+	  streamsize __w = __in.width();
+	  std::__istream_extract(__in, __s, __n);
+	  if (__in.good() && (__w <= 0 || __n < __w))
+	    {
+	      // Stopped extracting early to avoid overflowing the buffer,
+	      // but might have stopped anyway (and set eofbit) if at EOF.
+	      const typename _Traits::int_type __c = __in.rdbuf()->sgetc();
+	      const bool __eof = _Traits::eq_int_type(__c, _Traits::eof());
+	      if (__builtin_expect(__eof, true)) // Assume EOF, not overflow.
+		__in.setstate(ios_base::eofbit);
+	    }
+	}
       else
+#endif // __OPTIMIZE
 	{
-	  if (__n == (size_t)-1)
-	    __n = __gnu_cxx::__numeric_traits<streamsize>::__max;
-	  std::__istream_extract(__in, __s, __n / sizeof(_CharT));
+	  // Buffer size is unknown, have to assume it's huge.
+	  streamsize __n = __gnu_cxx::__numeric_traits<streamsize>::__max;
+	  __n /= sizeof(_CharT);
+	  std::__istream_extract(__in, __s, __n);
 	}
       return __in;
     }
diff --git a/libstdc++-v3/include/std/numeric b/libstdc++-v3/include/std/numeric
index 2ab337a0f3a..2828e16b8ea 100644
--- a/libstdc++-v3/include/std/numeric
+++ b/libstdc++-v3/include/std/numeric
@@ -68,6 +68,7 @@
 #if __cplusplus >= 201402L
 # include <type_traits>
 # include <bit>
+# include <ext/numeric_traits.h>
 #endif
 
 #if __cplusplus >= 201703L
@@ -93,19 +94,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #if __cplusplus >= 201402L
 namespace __detail
 {
-  // std::abs is not constexpr, doesn't support unsigned integers,
-  // and std::abs(std::numeric_limits<T>::min()) is undefined.
-  template<typename _Up, typename _Tp>
-    constexpr _Up
-    __absu(_Tp __val)
+  // Like std::abs, but supports unsigned types and returns the specified type,
+  // so |std::numeric_limits<_Tp>::min()| is OK if representable in _Res.
+  template<typename _Res, typename _Tp>
+    constexpr _Res
+    __abs_r(_Tp __val)
     {
-      static_assert(is_unsigned<_Up>::value, "result type must be unsigned");
-      static_assert(sizeof(_Up) >= sizeof(_Tp),
+      static_assert(sizeof(_Res) >= sizeof(_Tp),
 	  "result type must be at least as wide as the input type");
-      return __val < 0 ? -(_Up)__val : (_Up)__val;
+
+      if (__val >= 0)
+	return __val;
+#if defined _GLIBCXX_ASSERTIONS && defined _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
+      if (!__builtin_is_constant_evaluated()) // overflow already detected in constexpr
+	__glibcxx_assert(__val != __gnu_cxx::__int_traits<_Res>::__min);
+#endif
+      return -static_cast<_Res>(__val);
     }
 
-  template<typename _Up> void __absu(bool) = delete;
+  template<typename> void __abs_r(bool) = delete;
 
   // GCD implementation, using Stein's algorithm
   template<typename _Tp>
@@ -142,16 +149,6 @@ namespace __detail
 	  __n >>= std::__countr_zero(__n);
 	}
     }
-
-  // LCM implementation
-  template<typename _Tp>
-    constexpr _Tp
-    __lcm(_Tp __m, _Tp __n)
-    {
-      return (__m != 0 && __n != 0)
-	? (__m / __detail::__gcd(__m, __n)) * __n
-	: 0;
-    }
 } // namespace __detail
 
 #if __cplusplus >= 201703L
@@ -166,13 +163,14 @@ namespace __detail
     constexpr common_type_t<_Mn, _Nn>
     gcd(_Mn __m, _Nn __n) noexcept
     {
-      static_assert(is_integral_v<_Mn>, "std::gcd arguments must be integers");
-      static_assert(is_integral_v<_Nn>, "std::gcd arguments must be integers");
-      static_assert(_Mn(2) != _Mn(1), "std::gcd arguments must not be bool");
-      static_assert(_Nn(2) != _Nn(1), "std::gcd arguments must not be bool");
-      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;
-      return __detail::__gcd(__detail::__absu<_Up>(__m),
-			     __detail::__absu<_Up>(__n));
+      static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,
+		    "std::gcd arguments must be integers");
+      static_assert(_Mn(2) == 2 && _Nn(2) == 2,
+		    "std::gcd arguments must not be bool");
+      using _Ct = common_type_t<_Mn, _Nn>;
+      const _Ct __m2 = __detail::__abs_r<_Ct>(__m);
+      const _Ct __n2 = __detail::__abs_r<_Ct>(__n);
+      return __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);
     }
 
   /// Least common multiple
@@ -180,13 +178,26 @@ namespace __detail
     constexpr common_type_t<_Mn, _Nn>
     lcm(_Mn __m, _Nn __n) noexcept
     {
-      static_assert(is_integral_v<_Mn>, "std::lcm arguments must be integers");
-      static_assert(is_integral_v<_Nn>, "std::lcm arguments must be integers");
-      static_assert(_Mn(2) == 2, "std::lcm arguments must not be bool");
-      static_assert(_Nn(2) == 2, "std::lcm arguments must not be bool");
-      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;
-      return __detail::__lcm(__detail::__absu<_Up>(__m),
-			     __detail::__absu<_Up>(__n));
+      static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,
+		    "std::lcm arguments must be integers");
+      static_assert(_Mn(2) == 2 && _Nn(2) == 2,
+		    "std::lcm arguments must not be bool");
+      using _Ct = common_type_t<_Mn, _Nn>;
+      const _Ct __m2 = __detail::__abs_r<_Ct>(__m);
+      const _Ct __n2 = __detail::__abs_r<_Ct>(__n);
+      if (__m2 == 0 || __n2 == 0)
+	return 0;
+      _Ct __r = __m2 / __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);
+
+#if defined _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
+      if constexpr (is_signed_v<_Ct>)
+	if (__builtin_is_constant_evaluated())
+	  return __r * __n2; // constant evaluation can detect overflow here.
+#endif
+
+      bool __overflow = __builtin_mul_overflow(__r, __n2, &__r);
+      __glibcxx_assert(!__overflow);
+      return __r;
     }
 
 #endif // C++17
diff --git a/libstdc++-v3/include/std/ranges b/libstdc++-v3/include/std/ranges
index f55ee15e1b1..0a67c45f1b8 100644
--- a/libstdc++-v3/include/std/ranges
+++ b/libstdc++-v3/include/std/ranges
@@ -200,7 +200,7 @@ namespace ranges
     class single_view : public view_interface<single_view<_Tp>>
     {
     public:
-      single_view() requires default_initializable<_Tp> = default;
+      single_view() = default;
 
       constexpr explicit
       single_view(const _Tp& __t)
@@ -1463,9 +1463,7 @@ namespace views::__adaptor
       _Vp _M_base = _Vp();
 
     public:
-      filter_view() requires (default_initializable<_Vp>
-			      && default_initializable<_Pred>)
-	= default;
+      filter_view() requires default_initializable<_Vp> = default;
 
       constexpr
       filter_view(_Vp __base, _Pred __pred)
@@ -1829,9 +1827,7 @@ namespace views::__adaptor
       _Vp _M_base = _Vp();
 
     public:
-      transform_view() requires (default_initializable<_Vp>
-				 && default_initializable<_Fp>)
-	= default;
+      transform_view() requires default_initializable<_Vp> = default;
 
       constexpr
       transform_view(_Vp __base, _Fp __fun)
@@ -2150,9 +2146,7 @@ namespace views::__adaptor
       _Vp _M_base = _Vp();
 
     public:
-      take_while_view() requires (default_initializable<_Vp>
-				  && default_initializable<_Pred>)
-	= default;
+      take_while_view() requires default_initializable<_Vp> = default;
 
       constexpr
       take_while_view(_Vp base, _Pred __pred)
@@ -2356,9 +2350,7 @@ namespace views::__adaptor
       _Vp _M_base = _Vp();
 
     public:
-      drop_while_view() requires (default_initializable<_Vp>
-				  && default_initializable<_Pred>)
-	= default;
+      drop_while_view() requires default_initializable<_Vp> = default;
 
       constexpr
       drop_while_view(_Vp __base, _Pred __pred)
@@ -2916,7 +2908,7 @@ namespace views::__adaptor
 	    { return _InnerIter<_Const>{_M_i}; }
 
 	    constexpr default_sentinel_t
-	    end() const
+	    end() const noexcept
 	    { return default_sentinel; }
 	  };
 
diff --git a/libstdc++-v3/include/std/source_location b/libstdc++-v3/include/std/source_location
index 6cf6d7949cf..647ca0b9e3d 100644
--- a/libstdc++-v3/include/std/source_location
+++ b/libstdc++-v3/include/std/source_location
@@ -43,12 +43,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   {
   private:
     using uint_least32_t = __UINT_LEAST32_TYPE__;
+    struct __impl
+    {
+      const char* _M_file_name;
+      const char* _M_function_name;
+      unsigned _M_line;
+      unsigned _M_column;
+    };
+    using __builtin_ret_type = decltype(__builtin_source_location());
 
   public:
 
     // [support.srcloc.cons], creation
     static consteval source_location
-    current(const void* __p = __builtin_source_location()) noexcept
+    current(__builtin_ret_type __p = __builtin_source_location()) noexcept
     {
       source_location __ret;
       __ret._M_impl = static_cast <const __impl*>(__p);
@@ -75,14 +83,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     { return _M_impl ? _M_impl->_M_function_name : ""; }
 
   private:
-    struct __impl
-    {
-      const char* _M_file_name;
-      const char* _M_function_name;
-      unsigned _M_line;
-      unsigned _M_column;
-    };
-
     const __impl* _M_impl = nullptr;
   };
 
diff --git a/libstdc++-v3/include/std/span b/libstdc++-v3/include/std/span
index af0d24b29f2..2adf1ca2e09 100644
--- a/libstdc++-v3/include/std/span
+++ b/libstdc++-v3/include/std/span
@@ -201,11 +201,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{ }
 
       template<typename _Range>
-	requires ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
-	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
-	  && (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
+	requires (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
 	  && (!__detail::__is_std_array<remove_cvref_t<_Range>>::value)
 	  && (!is_array_v<remove_cvref_t<_Range>>)
+	  && ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
+	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
 	  && __is_compatible_ref<ranges::range_reference_t<_Range>>::value
 	constexpr explicit(extent != dynamic_extent)
 	span(_Range&& __range)
diff --git a/libstdc++-v3/include/std/sstream b/libstdc++-v3/include/std/sstream
index f21664100ab..56555ecd98a 100644
--- a/libstdc++-v3/include/std/sstream
+++ b/libstdc++-v3/include/std/sstream
@@ -425,6 +425,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
       // This might not be the same character as _M_string.end() because
       // basic_stringbuf::overflow might have written to unused capacity
       // in _M_string without updating its length.
+      __attribute__((__always_inline__))
       char_type*
       _M_high_mark() const _GLIBCXX_NOEXCEPT
       {
diff --git a/libstdc++-v3/include/std/string_view b/libstdc++-v3/include/std/string_view
index d8cbee9bee0..68df70e99f1 100644
--- a/libstdc++-v3/include/std/string_view
+++ b/libstdc++-v3/include/std/string_view
@@ -160,7 +160,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	      })
 	  && (!requires { typename _DRange::traits_type; }
 	      || is_same_v<typename _DRange::traits_type, _Traits>)
-	constexpr
+	constexpr explicit
 	basic_string_view(_Range&& __r)
 	noexcept(noexcept(ranges::size(__r)) && noexcept(ranges::data(__r)))
 	: _M_len(ranges::size(__r)), _M_str(ranges::data(__r))
diff --git a/libstdc++-v3/include/std/syncstream b/libstdc++-v3/include/std/syncstream
index db6ebd50471..ac39d0f2243 100644
--- a/libstdc++-v3/include/std/syncstream
+++ b/libstdc++-v3/include/std/syncstream
@@ -50,8 +50,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  template<typename _CharT, typename _Traits = char_traits<_CharT>,
-	    typename _Alloc = allocator<_CharT>>
+  template<typename _CharT, typename _Traits, typename _Alloc>
     class basic_syncbuf : public __syncbuf_base<_CharT, _Traits>
     {
     public:
@@ -241,8 +240,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __mutex _M_mtx;
     };
 
-  template <typename _CharT, typename _Traits = char_traits<_CharT>,
-	    typename _Alloc = allocator<_CharT>>
+  template <typename _CharT, typename _Traits, typename _Alloc>
     class basic_osyncstream : public basic_ostream<_CharT, _Traits>
     {
       using __ostream_type = basic_ostream<_CharT, _Traits>;
diff --git a/libstdc++-v3/include/std/tuple b/libstdc++-v3/include/std/tuple
index dcf30bd9a8d..63bd68fbe43 100644
--- a/libstdc++-v3/include/std/tuple
+++ b/libstdc++-v3/include/std/tuple
@@ -553,10 +553,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<bool, typename... _Types>
     struct _TupleConstraints
     {
-      template<typename _Tp, typename _Up> // Workaround for PR 96592
-	using is_constructible
-	  = __bool_constant<__is_constructible(_Tp, _Up)>;
-
       // Constraint for a non-explicit constructor.
       // True iff each Ti in _Types... can be constructed from Ui in _UTypes...
       // and every Ui is implicitly convertible to Ti.
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
index cccc6eed763..d544759f28e 100644
--- a/libstdc++-v3/include/std/type_traits
+++ b/libstdc++-v3/include/std/type_traits
@@ -1492,12 +1492,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 #pragma GCC diagnostic pop
 
-  // is_nothrow_convertible for C++11
-  template<typename _From, typename _To>
-    struct __is_nothrow_convertible
-    : public __is_nt_convertible_helper<_From, _To>::type
-    { };
-
 #if __cplusplus > 201703L
 #define __cpp_lib_is_nothrow_convertible 201806L
   /// is_nothrow_convertible
@@ -2881,7 +2875,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // The primary template is used for invalid INVOKE expressions.
   template<typename _Result, typename _Ret,
 	   bool = is_void<_Ret>::value, typename = void>
-    struct __is_invocable_impl : false_type { };
+    struct __is_invocable_impl
+    : false_type
+    {
+      using __nothrow_type = false_type; // For is_nothrow_invocable_r
+    };
 
   // Used for valid INVOKE and INVOKE<void> expressions.
   template<typename _Result, typename _Ret>
@@ -2889,7 +2887,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			       /* is_void<_Ret> = */ true,
 			       __void_t<typename _Result::type>>
     : true_type
-    { };
+    {
+      using __nothrow_type = true_type; // For is_nothrow_invocable_r
+    };
 
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
@@ -2901,23 +2901,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     {
     private:
       // The type of the INVOKE expression.
-      // Unlike declval, this doesn't add_rvalue_reference.
-      static typename _Result::type _S_get();
+      // Unlike declval, this doesn't add_rvalue_reference, so it respects
+      // guaranteed copy elision.
+      static typename _Result::type _S_get() noexcept;
 
       template<typename _Tp>
-	static void _S_conv(_Tp);
+	static void _S_conv(_Tp) noexcept;
 
       // This overload is viable if INVOKE(f, args...) can convert to _Tp.
-      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
-	static true_type
+      template<typename _Tp, bool _Check_Noex = false,
+	       typename = decltype(_S_conv<_Tp>(_S_get())),
+	       bool _Noex = noexcept(_S_conv<_Tp>(_S_get()))>
+	static __bool_constant<_Check_Noex ? _Noex : true>
 	_S_test(int);
 
-      template<typename _Tp>
+      template<typename _Tp, bool = false>
 	static false_type
 	_S_test(...);
 
     public:
+      // For is_invocable_r
       using type = decltype(_S_test<_Ret>(1));
+
+      // For is_nothrow_invocable_r
+      using __nothrow_type = decltype(_S_test<_Ret, true>(1));
     };
 #pragma GCC diagnostic pop
 
@@ -3048,15 +3055,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     };
 
   /// @cond undocumented
-  template<typename _Result, typename _Ret, typename = void>
-    struct __is_nt_invocable_impl : false_type { };
-
   template<typename _Result, typename _Ret>
-    struct __is_nt_invocable_impl<_Result, _Ret,
-				  __void_t<typename _Result::type>>
-    : __or_<is_void<_Ret>,
-	    __is_nothrow_convertible<typename _Result::type, _Ret>>
-    { };
+    using __is_nt_invocable_impl
+      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_type;
   /// @endcond
 
   /// std::is_nothrow_invocable_r
diff --git a/libstdc++-v3/include/std/utility b/libstdc++-v3/include/std/utility
index f54f75b4d38..7ebb8a552c1 100644
--- a/libstdc++-v3/include/std/utility
+++ b/libstdc++-v3/include/std/utility
@@ -331,7 +331,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #if __has_builtin(__make_integer_seq)
       = __make_integer_seq<integer_sequence, _Tp, _Num>;
 #else
-      = integer_sequence<_Tp, __integer_pack(_Num)...>;
+      = integer_sequence<_Tp, __integer_pack(_Tp(_Num))...>;
 #endif
 
   /// Alias template index_sequence
diff --git a/libstdc++-v3/include/std/valarray b/libstdc++-v3/include/std/valarray
index 72eb7a9d56d..458c7cd7811 100644
--- a/libstdc++-v3/include/std/valarray
+++ b/libstdc++-v3/include/std/valarray
@@ -1076,6 +1076,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       return _Expr<_Closure, _Tp>(_Closure(*this, func));
     }
 
+  /// @cond undocumented
 #define _DEFINE_VALARRAY_UNARY_OPERATOR(_Op, _Name)                     \
   template<typename _Tp>						\
     inline typename valarray<_Tp>::template _UnaryOp<_Name>::_Rt	\
@@ -1202,6 +1203,7 @@ _DEFINE_BINARY_OPERATOR(<=, __less_equal)
 _DEFINE_BINARY_OPERATOR(>=, __greater_equal)
 
 #undef _DEFINE_BINARY_OPERATOR
+  /// @endcond
 
 #if __cplusplus >= 201103L
   /**
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
index c0585cb5999..922d2100c2f 100644
--- a/libstdc++-v3/include/std/variant
+++ b/libstdc++-v3/include/std/variant
@@ -435,13 +435,6 @@ namespace __variant
       ~_Variant_storage()
       { _M_reset(); }
 
-      void*
-      _M_storage() const noexcept
-      {
-	return const_cast<void*>(static_cast<const void*>(
-	    std::addressof(_M_u)));
-      }
-
       constexpr bool
       _M_valid() const noexcept
       {
@@ -473,13 +466,6 @@ namespace __variant
       void _M_reset() noexcept
       { _M_index = static_cast<__index_type>(variant_npos); }
 
-      void*
-      _M_storage() const noexcept
-      {
-	return const_cast<void*>(static_cast<const void*>(
-	    std::addressof(_M_u)));
-      }
-
       constexpr bool
       _M_valid() const noexcept
       {
@@ -804,11 +790,6 @@ namespace __variant
     : _FUN_type<_Tp, _Variant>
     { };
 
-  // Returns the raw storage for __v.
-  template<typename _Variant>
-    void* __get_storage(_Variant&& __v) noexcept
-    { return __v._M_storage(); }
-
   template <typename _Maybe_variant_cookie, typename _Variant>
     struct _Extra_visit_slot_needed
     {
@@ -1108,19 +1089,21 @@ namespace __variant
 	>;
     }
 
-} // namespace __variant
-} // namespace __detail
-
   template<size_t _Np, typename _Variant, typename... _Args>
-    void __variant_construct_by_index(_Variant& __v, _Args&&... __args)
+    inline void
+    __construct_by_index(_Variant& __v, _Args&&... __args)
     {
-      __v._M_index = _Np;
       auto&& __storage = __detail::__variant::__get<_Np>(__v);
       ::new ((void*)std::addressof(__storage))
         remove_reference_t<decltype(__storage)>
 	  (std::forward<_Args>(__args)...);
+      // Construction didn't throw, so can set the new index now:
+      __v._M_index = _Np;
     }
 
+} // namespace __variant
+} // namespace __detail
+
   template<typename _Tp, typename... _Types>
     constexpr bool
     holds_alternative(const variant<_Types...>& __v) noexcept
@@ -1356,8 +1339,9 @@ namespace __variant
       template <typename... _UTypes, typename _Tp>
 	friend decltype(auto) __variant_cast(_Tp&&);
       template<size_t _Np, typename _Variant, typename... _Args>
-	friend void __variant_construct_by_index(_Variant& __v,
-						 _Args&&... __args);
+	friend void
+	__detail::__variant::__construct_by_index(_Variant& __v,
+						  _Args&&... __args);
 
       static_assert(sizeof...(_Types) > 0,
 		    "variant must have at least one alternative");
@@ -1488,7 +1472,9 @@ namespace __variant
 			    || !is_nothrow_move_constructible_v<_Tj>)
 		this->emplace<__index>(std::forward<_Tp>(__rhs));
 	      else
-		operator=(variant(std::forward<_Tp>(__rhs)));
+		// _GLIBCXX_RESOLVE_LIB_DEFECTS
+		// 3585. converting assignment with immovable alternative
+		this->emplace<__index>(_Tj(std::forward<_Tp>(__rhs)));
 	    }
 	  return *this;
 	}
@@ -1521,12 +1507,13 @@ namespace __variant
 	  static_assert(_Np < sizeof...(_Types),
 			"The index must be in [0, number of alternatives)");
 	  using type = variant_alternative_t<_Np, variant>;
+	  namespace __variant = std::__detail::__variant;
 	  // Provide the strong exception-safety guarantee when possible,
 	  // to avoid becoming valueless.
 	  if constexpr (is_nothrow_constructible_v<type, _Args...>)
 	    {
 	      this->_M_reset();
-	      __variant_construct_by_index<_Np>(*this,
+	      __variant::__construct_by_index<_Np>(*this,
 		  std::forward<_Args>(__args)...);
 	    }
 	  else if constexpr (is_scalar_v<type>)
@@ -1535,9 +1522,9 @@ namespace __variant
 	      const type __tmp(std::forward<_Args>(__args)...);
 	      // But these steps won't throw:
 	      this->_M_reset();
-	      __variant_construct_by_index<_Np>(*this, __tmp);
+	      __variant::__construct_by_index<_Np>(*this, __tmp);
 	    }
-	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
+	  else if constexpr (__variant::_Never_valueless_alt<type>()
 	      && _Traits::_S_move_assign)
 	    {
 	      // This construction might throw:
@@ -1551,17 +1538,8 @@ namespace __variant
 	      // This case only provides the basic exception-safety guarantee,
 	      // i.e. the variant can become valueless.
 	      this->_M_reset();
-	      __try
-		{
-		  __variant_construct_by_index<_Np>(*this,
-		    std::forward<_Args>(__args)...);
-		}
-	      __catch (...)
-		{
-		  using __index_type = decltype(this->_M_index);
-		  this->_M_index = static_cast<__index_type>(variant_npos);
-		  __throw_exception_again;
-		}
+	      __variant::__construct_by_index<_Np>(*this,
+		std::forward<_Args>(__args)...);
 	    }
 	  return std::get<_Np>(*this);
 	}
@@ -1575,6 +1553,7 @@ namespace __variant
 	  static_assert(_Np < sizeof...(_Types),
 			"The index must be in [0, number of alternatives)");
 	  using type = variant_alternative_t<_Np, variant>;
+	  namespace __variant = std::__detail::__variant;
 	  // Provide the strong exception-safety guarantee when possible,
 	  // to avoid becoming valueless.
 	  if constexpr (is_nothrow_constructible_v<type,
@@ -1582,10 +1561,10 @@ namespace __variant
 						   _Args...>)
 	    {
 	      this->_M_reset();
-	      __variant_construct_by_index<_Np>(*this, __il,
+	      __variant::__construct_by_index<_Np>(*this, __il,
 		  std::forward<_Args>(__args)...);
 	    }
-	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
+	  else if constexpr (__variant::_Never_valueless_alt<type>()
 	      && _Traits::_S_move_assign)
 	    {
 	      // This construction might throw:
@@ -1599,17 +1578,8 @@ namespace __variant
 	      // This case only provides the basic exception-safety guarantee,
 	      // i.e. the variant can become valueless.
 	      this->_M_reset();
-	      __try
-		{
-		  __variant_construct_by_index<_Np>(*this, __il,
-		    std::forward<_Args>(__args)...);
-		}
-	      __catch (...)
-		{
-		  using __index_type = decltype(this->_M_index);
-		  this->_M_index = static_cast<__index_type>(variant_npos);
-		  __throw_exception_again;
-		}
+	      __variant::__construct_by_index<_Np>(*this, __il,
+		std::forward<_Args>(__args)...);
 	    }
 	  return std::get<_Np>(*this);
 	}
@@ -1685,10 +1655,6 @@ namespace __variant
 	friend constexpr decltype(auto)
 	__detail::__variant::__get(_Vp&& __v) noexcept;
 
-      template<typename _Vp>
-	friend void*
-	__detail::__variant::__get_storage(_Vp&& __v) noexcept;
-
 #define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP) \
       template<typename... _Tp> \
 	friend constexpr bool \
diff --git a/libstdc++-v3/include/std/version b/libstdc++-v3/include/std/version
index f35b9da2307..00aae90a3ab 100644
--- a/libstdc++-v3/include/std/version
+++ b/libstdc++-v3/include/std/version
@@ -177,6 +177,9 @@
 #define __cpp_lib_atomic_float 201711L
 #define __cpp_lib_atomic_ref 201806L
 #define __cpp_lib_atomic_value_initialization 201911L
+#if __has_builtin(__builtin_bit_cast)
+# define __cpp_lib_bit_cast 201806L
+#endif
 #define __cpp_lib_bitops 201907L
 #define __cpp_lib_bounded_array_traits 201902L
 // __cpp_lib_char8_t is defined in <bits/c++config.h>
@@ -209,9 +212,6 @@
 # endif
 #endif
 #define __cpp_lib_bind_front 201907L
-#if __has_builtin(__builtin_bit_cast)
-# define __cpp_lib_bit_cast 201806L
-#endif
 // FIXME: #define __cpp_lib_execution 201902L
 #define __cpp_lib_integer_comparison_functions 202002L
 #define __cpp_lib_constexpr_algorithms 201806L
@@ -248,6 +248,7 @@
 #define __cpp_lib_polymorphic_allocator 201902L
 #if __cpp_lib_concepts
 # define __cpp_lib_ranges 202106L
+# define __cpp_lib_move_iterator_concept 202207L
 #endif
 #if __cpp_lib_atomic_wait || _GLIBCXX_HAVE_POSIX_SEMAPHORE
 # define __cpp_lib_semaphore 201907L
@@ -272,8 +273,10 @@
 #if __cplusplus > 202002L
 // c++2b
 #define __cpp_lib_is_scoped_enum 202011L
+#if _GLIBCXX_HOSTED
 #define __cpp_lib_string_contains 202011L
 #define __cpp_lib_to_underlying 202102L
+#endif
 #endif // C++2b
 #endif // C++20
 #endif // C++17
diff --git a/libstdc++-v3/python/libstdcxx/v6/printers.py b/libstdc++-v3/python/libstdcxx/v6/printers.py
index b5b523c4b5a..081eec454dd 100644
--- a/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -1626,6 +1626,60 @@ class StdErrorCodePrinter:
         return '%s = {%s: %s}' % (self.typename, name, strval)
 
 
+class StdSpanPrinter:
+    "Print a std::span"
+
+    class iterator(Iterator):
+        def __init__(self, begin, size):
+            self.count = 0
+            self.begin = begin
+            self.size = size
+
+        def __iter__ (self):
+            return self
+
+        def __next__ (self):
+            if self.count == self.size:
+                raise StopIteration
+
+            count = self.count
+            self.count = self.count + 1
+            return '[%d]' % count, (self.begin + count).dereference()
+
+    def __init__(self, typename, val):
+        self.typename = strip_versioned_namespace(typename)
+        self.val = val
+        if val.type.template_argument(1) == gdb.parse_and_eval('static_cast<std::size_t>(-1)'):
+            self.size = val['_M_extent']['_M_extent_value']
+        else:
+            self.size = val.type.template_argument(1)
+
+    def to_string(self):
+        return '%s of length %d' % (self.typename, self.size)
+
+    def children(self):
+        return self.iterator(self.val['_M_ptr'], self.size)
+
+    def display_hint(self):
+        return 'array'
+
+class StdInitializerListPrinter:
+    "Print a std::initializer_list"
+
+    def __init__(self, typename, val):
+        self.typename = typename
+        self.val = val
+        self.size = val['_M_len']
+
+    def to_string(self):
+        return '%s of length %d' % (self.typename, self.size)
+
+    def children(self):
+        return StdSpanPrinter.iterator(self.val['_M_array'], self.size)
+
+    def display_hint(self):
+        return 'array'
+
 # A "regular expression" printer which conforms to the
 # "SubPrettyPrinter" protocol from gdb.printing.
 class RxPrinter(object):
@@ -1866,7 +1920,7 @@ class FilteringTypePrinter(object):
         self.enabled = True
 
     class _recognizer(object):
-        "The recognizer class for TemplateTypePrinter."
+        "The recognizer class for FilteringTypePrinter."
 
         def __init__(self, match, name):
             self.match = match
@@ -2091,6 +2145,10 @@ def build_libstdcxx_dictionary ():
     libstdcxx_printer.add_version('std::tr1::', 'unordered_multiset',
                                   Tr1UnorderedSetPrinter)
 
+    libstdcxx_printer.add_version('std::', 'initializer_list',
+                                  StdInitializerListPrinter)
+
+
     # These are the C++11 printer registrations for -D_GLIBCXX_DEBUG cases.
     # The tr1 namespace containers do not have any debug equivalents,
     # so do not register printers for them.
@@ -2138,6 +2196,7 @@ def build_libstdcxx_dictionary ():
     libstdcxx_printer.add_version('std::', 'partial_ordering', StdCmpCatPrinter)
     libstdcxx_printer.add_version('std::', 'weak_ordering', StdCmpCatPrinter)
     libstdcxx_printer.add_version('std::', 'strong_ordering', StdCmpCatPrinter)
+    libstdcxx_printer.add_version('std::', 'span', StdSpanPrinter)
 
     # Extensions.
     libstdcxx_printer.add_version('__gnu_cxx::', 'slist', StdSlistPrinter)
diff --git a/libstdc++-v3/python/libstdcxx/v6/xmethods.py b/libstdc++-v3/python/libstdcxx/v6/xmethods.py
index 991d945321a..d6cbcf139c5 100644
--- a/libstdc++-v3/python/libstdcxx/v6/xmethods.py
+++ b/libstdc++-v3/python/libstdcxx/v6/xmethods.py
@@ -730,7 +730,7 @@ class SharedPtrUseCountWorker(gdb.xmethod.XMethodWorker):
     "Implements std::shared_ptr<T>::use_count()"
 
     def __init__(self, elem_type):
-        SharedPtrUseCountWorker.__init__(self, elem_type)
+        pass
 
     def get_arg_types(self):
         return None
@@ -738,6 +738,9 @@ class SharedPtrUseCountWorker(gdb.xmethod.XMethodWorker):
     def get_result_type(self, obj):
         return gdb.lookup_type('long')
 
+    def _supports(self, method_name):
+        return True
+
     def __call__(self, obj):
         refcounts = obj['_M_refcount']['_M_pi']
         return refcounts['_M_use_count'] if refcounts else 0
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 16f4cc6eff4..f92a52748c5 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -267,7 +267,9 @@ CXXLINK = \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CXX) \
 	$(VTV_CXXLINKFLAGS) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) \
+	$(LTLDFLAGS) $(LTLIBICONV) \
+	-o $@
 
 # Symbol versioning for shared libraries.
 if ENABLE_SYMVERS
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index 4df5c829a7f..2fff46209ad 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -631,7 +631,9 @@ CXXLINK = \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CXX) \
 	$(VTV_CXXLINKFLAGS) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) \
+	$(LTLDFLAGS) $(LTLIBICONV) \
+	-o $@
 
 @ENABLE_SYMVERS_TRUE@CLEANFILES = libstdc++-symbols.ver $(version_dep)
 @ENABLE_SYMVERS_DARWIN_TRUE@@ENABLE_SYMVERS_TRUE@version_arg = -Wl,-exported_symbols_list,libstdc++-symbols.explist
diff --git a/libstdc++-v3/src/c++11/codecvt.cc b/libstdc++-v3/src/c++11/codecvt.cc
index f8a50fb7150..04252d6dc2a 100644
--- a/libstdc++-v3/src/c++11/codecvt.cc
+++ b/libstdc++-v3/src/c++11/codecvt.cc
@@ -254,7 +254,7 @@ namespace
     const size_t avail = from.size();
     if (avail == 0)
       return incomplete_mb_character;
-    unsigned char c1 = from[0];
+    char32_t c1 = (unsigned char) from[0];
     // https://en.wikipedia.org/wiki/UTF-8#Sample_code
     if (c1 < 0x80)
     {
@@ -267,7 +267,7 @@ namespace
     {
       if (avail < 2)
 	return incomplete_mb_character;
-      unsigned char c2 = from[1];
+      char32_t c2 = (unsigned char) from[1];
       if ((c2 & 0xC0) != 0x80)
 	return invalid_mb_sequence;
       char32_t c = (c1 << 6) + c2 - 0x3080;
@@ -279,12 +279,12 @@ namespace
     {
       if (avail < 3)
 	return incomplete_mb_character;
-      unsigned char c2 = from[1];
+      char32_t c2 = (unsigned char) from[1];
       if ((c2 & 0xC0) != 0x80)
 	return invalid_mb_sequence;
       if (c1 == 0xE0 && c2 < 0xA0) // overlong
 	return invalid_mb_sequence;
-      unsigned char c3 = from[2];
+      char32_t c3 = (unsigned char) from[2];
       if ((c3 & 0xC0) != 0x80)
 	return invalid_mb_sequence;
       char32_t c = (c1 << 12) + (c2 << 6) + c3 - 0xE2080;
@@ -296,17 +296,17 @@ namespace
     {
       if (avail < 4)
 	return incomplete_mb_character;
-      unsigned char c2 = from[1];
+      char32_t c2 = (unsigned char) from[1];
       if ((c2 & 0xC0) != 0x80)
 	return invalid_mb_sequence;
       if (c1 == 0xF0 && c2 < 0x90) // overlong
 	return invalid_mb_sequence;
       if (c1 == 0xF4 && c2 >= 0x90) // > U+10FFFF
       return invalid_mb_sequence;
-      unsigned char c3 = from[2];
+      char32_t c3 = (unsigned char) from[2];
       if ((c3 & 0xC0) != 0x80)
 	return invalid_mb_sequence;
-      unsigned char c4 = from[3];
+      char32_t c4 = (unsigned char) from[3];
       if ((c4 & 0xC0) != 0x80)
 	return invalid_mb_sequence;
       char32_t c = (c1 << 18) + (c2 << 12) + (c3 << 6) + c4 - 0x3C82080;
diff --git a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
index a918ab21015..e40685bf45a 100644
--- a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
+++ b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
@@ -44,14 +44,15 @@
 
 namespace
 {
-  struct io_error_category : std::error_category
+  struct io_error_category final : std::error_category
   {
-    virtual const char*
-    name() const noexcept
+    const char*
+    name() const noexcept final
     { return "iostream"; }
 
     _GLIBCXX_DEFAULT_ABI_TAG
-    virtual std::string message(int __ec) const
+    std::string
+    message(int __ec) const final
     {
       std::string __msg;
       switch (std::io_errc(__ec))
@@ -67,13 +68,17 @@ namespace
     }
   };
 
-  const io_error_category&
-  __io_category_instance() noexcept
+  struct constant_init
   {
-    static const io_error_category __ec{};
-    return __ec;
-  }
+    union {
+      unsigned char unused;
+      io_error_category cat;
+    };
+    constexpr constant_init() : cat() { }
+    ~constant_init() { /* do nothing, union member is not destroyed */ }
+  };
 
+  __constinit constant_init io_category_instance{};
 } // namespace
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -82,7 +87,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   const error_category&
   iostream_category() noexcept
-  { return __io_category_instance(); }
+  { return io_category_instance.cat; }
 
   ios_base::failure::failure(const string& __str)
   : system_error(io_errc::stream, __str) { }
diff --git a/libstdc++-v3/src/c++11/future.cc b/libstdc++-v3/src/c++11/future.cc
index c1a1a828e27..75f832ec1c5 100644
--- a/libstdc++-v3/src/c++11/future.cc
+++ b/libstdc++-v3/src/c++11/future.cc
@@ -27,14 +27,15 @@
 
 namespace
 {
-  struct future_error_category : public std::error_category
+  struct future_error_category final : public std::error_category
   {
-    virtual const char*
-    name() const noexcept
+    const char*
+    name() const noexcept final
     { return "future"; }
 
     _GLIBCXX_DEFAULT_ABI_TAG
-    virtual std::string message(int __ec) const
+    std::string
+    message(int __ec) const final
     {
       std::string __msg;
       switch (std::future_errc(__ec))
@@ -59,12 +60,17 @@ namespace
     }
   };
 
-  const future_error_category&
-  __future_category_instance() noexcept
+  struct constant_init
   {
-    static const future_error_category __fec{};
-    return __fec;
-  }
+    union {
+      unsigned char unused;
+      future_error_category cat;
+    };
+    constexpr constant_init() : cat() { }
+    ~constant_init() { /* do nothing, union member is not destroyed */ }
+  };
+
+  __constinit constant_init future_category_instance{};
 }
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -76,7 +82,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   { _GLIBCXX_THROW_OR_ABORT(future_error(make_error_code(future_errc(__i)))); }
 
   const error_category& future_category() noexcept
-  { return __future_category_instance(); }
+  { return future_category_instance.cat; }
 
   future_error::~future_error() noexcept { }
 
diff --git a/libstdc++-v3/src/c++11/random.cc b/libstdc++-v3/src/c++11/random.cc
index 44b9f30e4a9..f2dc5f3021f 100644
--- a/libstdc++-v3/src/c++11/random.cc
+++ b/libstdc++-v3/src/c++11/random.cc
@@ -395,6 +395,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
       }
 #endif
 
+#ifdef _GLIBCXX_USE_DEV_RANDOM
 #ifdef USE_POSIX_FILE_IO
     ::close(_M_fd);
     _M_fd = -1;
@@ -402,6 +403,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
     std::fclose(static_cast<FILE*>(_M_file));
 #endif
     _M_file = nullptr;
+#endif
   }
 
   random_device::result_type
diff --git a/libstdc++-v3/src/c++11/system_error.cc b/libstdc++-v3/src/c++11/system_error.cc
index 34274387637..2b5010dbb40 100644
--- a/libstdc++-v3/src/c++11/system_error.cc
+++ b/libstdc++-v3/src/c++11/system_error.cc
@@ -93,6 +93,16 @@ namespace
       // and system category otherwise.
       switch (ev)
       {
+#if defined __AVR__
+      // avr-libc only defines a few distinct error numbers. Most <errno.h>
+      // constants are not usable in #if directives and have the same value.
+      case EDOM:
+      case ERANGE:
+      case ENOSYS:
+      case EINTR:
+      case 0:
+	return std::error_condition(ev, generic_category_instance.obj);
+#else
       // List of errno macros from [cerrno.syn].
       // C11 only defines EDOM, EILSEQ and ERANGE, the rest are from POSIX.
       // They expand to integer constant expressions with type int,
@@ -339,7 +349,7 @@ namespace
       case EBLAH:
 	return std::error_condition(EINVAL, std::generic_category());
        */
-
+#endif
       default:
 	return std::error_condition(ev, *this);
       }
diff --git a/libstdc++-v3/src/c++17/floating_from_chars.cc b/libstdc++-v3/src/c++17/floating_from_chars.cc
index aa074869872..ca1ad84e2ca 100644
--- a/libstdc++-v3/src/c++17/floating_from_chars.cc
+++ b/libstdc++-v3/src/c++17/floating_from_chars.cc
@@ -37,7 +37,6 @@
 #include <cmath>
 #include <cstdlib>
 #include <cstring>
-#include <cctype>
 #include <locale.h>
 #include <bits/functexcept.h>
 #if _GLIBCXX_HAVE_XLOCALE_H
@@ -75,7 +74,6 @@ namespace
 	return m_buf + std::__exchange(m_bytes, m_bytes + bytes);
 
       __glibcxx_assert(m_ptr == nullptr);
-      __glibcxx_assert(alignment != 1);
 
       m_ptr = operator new(bytes);
       m_bytes = bytes;
@@ -116,10 +114,10 @@ namespace
 
   // Find initial portion of [first, last) containing a floating-point number.
   // The string `digits` is either `dec_digits` or `hex_digits`
-  // and `exp` is 'e' or 'p' or '\0'.
+  // and `exp` is "eE", "pP" or NULL.
   const char*
   find_end_of_float(const char* first, const char* last, const char* digits,
-		    char exp)
+		    const char *exp)
   {
     while (first < last && strchr(digits, *first) != nullptr)
       ++first;
@@ -129,7 +127,7 @@ namespace
 	while (first < last && strchr(digits, *first))
 	  ++first;
       }
-    if (first < last && exp != 0 && std::tolower((unsigned char)*first) == exp)
+    if (first < last && exp != nullptr && (*first == exp[0] || *first == exp[1]))
       {
 	++first;
 	if (first < last && (*first == '-' || *first == '+'))
@@ -211,7 +209,7 @@ namespace
 
 	if ((last - first + 2) > buffer_resource::guaranteed_capacity())
 	  {
-	    last = find_end_of_float(first + neg, last, digits, 'p');
+	    last = find_end_of_float(first + neg, last, digits, "pP");
 #ifndef __cpp_exceptions
 	    if ((last - first + 2) > buffer_resource::guaranteed_capacity())
 	      {
@@ -235,7 +233,7 @@ namespace
 	if ((last - first) > buffer_resource::guaranteed_capacity())
 	  {
 	    last = find_end_of_float(first + neg, last, digits,
-				     "e"[fmt == chars_format::fixed]);
+				     fmt == chars_format::fixed ? nullptr : "eE");
 #ifndef __cpp_exceptions
 	    if ((last - first) > buffer_resource::guaranteed_capacity())
 	      {
diff --git a/libstdc++-v3/src/c++17/fs_dir.cc b/libstdc++-v3/src/c++17/fs_dir.cc
index 054d3908991..39d12ec130a 100644
--- a/libstdc++-v3/src/c++17/fs_dir.cc
+++ b/libstdc++-v3/src/c++17/fs_dir.cc
@@ -44,14 +44,20 @@ template class std::__shared_ptr<fs::recursive_directory_iterator::_Dir_stack>;
 
 struct fs::_Dir : _Dir_base
 {
-  _Dir(const fs::path& p, bool skip_permission_denied, error_code& ec)
-  : _Dir_base(p.c_str(), skip_permission_denied, ec)
+  _Dir(const fs::path& p, bool skip_permission_denied, bool nofollow,
+       [[maybe_unused]] bool filename_only, error_code& ec)
+  : _Dir_base(fdcwd(), p.c_str(), skip_permission_denied, nofollow, ec)
   {
+#if _GLIBCXX_HAVE_DIRFD && _GLIBCXX_HAVE_OPENAT && _GLIBCXX_HAVE_UNLINKAT
+    if (filename_only)
+      return; // Do not store path p when we aren't going to use it.
+#endif
+
     if (!ec)
       path = p;
   }
 
-  _Dir(posix::DIR* dirp, const path& p) : _Dir_base(dirp), path(p) { }
+  _Dir(_Dir_base&& d, const path& p) : _Dir_base(std::move(d)), path(p) { }
 
   _Dir(_Dir&&) = default;
 
@@ -111,7 +117,63 @@ struct fs::_Dir : _Dir_base
     return false;
   }
 
-  fs::path		path;
+  // Return a file descriptor for the directory and current entry's path.
+  // If dirfd is available, use it and return only the filename.
+  // Otherwise, return AT_FDCWD and return the full path.
+  pair<int, const posix::char_type*>
+  dir_and_pathname() const noexcept
+  {
+    const fs::path& p = entry.path();
+#if _GLIBCXX_HAVE_DIRFD && _GLIBCXX_HAVE_OPENAT
+    if (!p.empty())
+      return {::dirfd(this->dirp), std::prev(p.end())->c_str()};
+#endif
+    return {this->fdcwd(), p.c_str()};
+  }
+
+  // Create a new _Dir for the directory this->entry.path().
+  _Dir
+  open_subdir(bool skip_permission_denied, bool nofollow,
+	      error_code& ec) const noexcept
+  {
+    auto [dirfd, pathname] = dir_and_pathname();
+    _Dir_base d(dirfd, pathname, skip_permission_denied, nofollow, ec);
+    // If this->path is empty, the new _Dir should have an empty path too.
+    const fs::path& p = this->path.empty() ? this->path : this->entry.path();
+    return _Dir(std::move(d), p);
+  }
+
+  bool
+  do_unlink(bool is_directory, error_code& ec) const noexcept
+  {
+#if _GLIBCXX_HAVE_UNLINKAT
+    auto [dirfd, pathname] = dir_and_pathname();
+    if (::unlinkat(dirfd, pathname, is_directory ? AT_REMOVEDIR : 0) == -1)
+      {
+	ec.assign(errno, std::generic_category());
+	return false;
+      }
+    else
+      {
+	ec.clear();
+	return true;
+      }
+#else
+    return fs::remove(entry.path(), ec);
+#endif
+  }
+
+  // Remove the non-directory that this->entry refers to.
+  bool
+  unlink(error_code& ec) const noexcept
+  { return do_unlink(/* is_directory*/ false, ec); }
+
+  // Remove the directory that this->entry refers to.
+  bool
+  rmdir(error_code& ec) const noexcept
+  { return do_unlink(/* is_directory*/ true, ec); }
+
+  fs::path		path; // Empty if only using unlinkat with file descr.
   directory_entry	entry;
 };
 
@@ -123,16 +185,33 @@ namespace
     {
       return (obj & bits) != Bitmask::none;
     }
+
+// Non-standard directory option flags, currently only for internal use:
+//
+// Do not allow directory iterator to open a symlink.
+// This might seem redundant given directory_options::follow_directory_symlink
+// but that is only checked for recursing into sub-directories, and we need
+// something that controls the initial opendir() call in the constructor.
+constexpr fs::directory_options __directory_iterator_nofollow{64};
+// Do not store full paths in std::filesystem::recursive_directory_iterator.
+// When fs::remove_all uses recursive_directory_iterator::__erase and unlinkat
+// is available in libc, we do not need the parent directory's path, only the
+// filenames of the directory entries (and a file descriptor for the parent).
+// This flag avoids allocating memory for full paths that won't be needed.
+constexpr fs::directory_options __directory_iterator_filename_only{128};
 }
 
 fs::directory_iterator::
 directory_iterator(const path& p, directory_options options, error_code* ecptr)
 {
+  // Do not report an error for permission denied errors.
   const bool skip_permission_denied
     = is_set(options, directory_options::skip_permission_denied);
+  // Do not allow opening a symlink.
+  const bool nofollow = is_set(options, __directory_iterator_nofollow);
 
   error_code ec;
-  _Dir dir(p, skip_permission_denied, ec);
+  _Dir dir(p, skip_permission_denied, nofollow, /*filename only*/false, ec);
 
   if (dir.dirp)
     {
@@ -180,48 +259,66 @@ fs::directory_iterator::increment(error_code& ec)
 
 struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>
 {
-  _Dir_stack(directory_options opts, posix::DIR* dirp, const path& p)
+  _Dir_stack(directory_options opts, _Dir&& dir)
   : options(opts), pending(true)
   {
-    this->emplace(dirp, p);
+    this->push(std::move(dir));
   }
 
+  path::string_type orig;
   const directory_options options;
   bool pending;
 
   void clear() { c.clear(); }
+
+  path current_path() const
+  {
+    path p;
+    if (top().path.empty())
+      {
+	// Reconstruct path that failed from dir stack.
+	p = orig;
+	for (auto& d : this->c)
+	  p /= d.entry.path();
+      }
+    else
+      p = top().entry.path();
+    return p;
+  }
 };
 
 fs::recursive_directory_iterator::
 recursive_directory_iterator(const path& p, directory_options options,
                              error_code* ecptr)
 {
-  if (posix::DIR* dirp = posix::opendir(p.c_str()))
+  // Do not report an error for permission denied errors.
+  const bool skip_permission_denied
+    = is_set(options, directory_options::skip_permission_denied);
+  // Do not allow opening a symlink as the starting directory.
+  const bool nofollow = is_set(options, __directory_iterator_nofollow);
+  // Prefer to store only filenames (not full paths) in directory_entry values.
+  const bool filename_only
+     = is_set(options, __directory_iterator_filename_only);
+
+  error_code ec;
+  _Dir dir(p, skip_permission_denied, nofollow, filename_only, ec);
+
+  if (dir.dirp)
     {
-      if (ecptr)
-	ecptr->clear();
-      auto sp = std::__make_shared<_Dir_stack>(options, dirp, p);
-      if (ecptr ? sp->top().advance(*ecptr) : sp->top().advance())
-	_M_dirs.swap(sp);
-    }
-  else
-    {
-      const int err = errno;
-      if (fs::is_permission_denied_error(err)
-	  && is_set(options, fs::directory_options::skip_permission_denied))
+      auto sp = std::__make_shared<_Dir_stack>(options, std::move(dir));
+      if (ecptr ? sp->top().advance(skip_permission_denied, *ecptr)
+		: sp->top().advance(skip_permission_denied))
 	{
-	  if (ecptr)
-	    ecptr->clear();
-	  return;
+	  _M_dirs.swap(sp);
+	  if (filename_only) // Need to save original path for error reporting.
+	    _M_dirs->orig = p.native();
 	}
-
-      if (!ecptr)
-	_GLIBCXX_THROW_OR_ABORT(filesystem_error(
-	      "recursive directory iterator cannot open directory", p,
-	      std::error_code(err, std::generic_category())));
-
-      ecptr->assign(err, std::generic_category());
     }
+  else if (ecptr)
+    *ecptr = ec;
+  else if (ec)
+    _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(
+	  "recursive directory iterator cannot open directory", p, ec));
 }
 
 fs::recursive_directory_iterator::~recursive_directory_iterator() = default;
@@ -287,14 +384,14 @@ fs::recursive_directory_iterator::increment(error_code& ec)
 
   if (std::exchange(_M_dirs->pending, true) && top.should_recurse(follow, ec))
     {
-      _Dir dir(top.entry.path(), skip_permission_denied, ec);
+      _Dir dir = top.open_subdir(skip_permission_denied, !follow, ec);
       if (ec)
 	{
 	  _M_dirs.reset();
 	  return *this;
 	}
       if (dir.dirp)
-	  _M_dirs->push(std::move(dir));
+	_M_dirs->push(std::move(dir));
     }
 
   while (!_M_dirs->top().advance(skip_permission_denied, ec) && !ec)
@@ -357,3 +454,108 @@ fs::recursive_directory_iterator::disable_recursion_pending() noexcept
 {
   _M_dirs->pending = false;
 }
+
+// Used to implement filesystem::remove_all.
+fs::recursive_directory_iterator&
+fs::recursive_directory_iterator::__erase(error_code* ecptr)
+{
+  error_code ec;
+  if (!_M_dirs)
+    {
+      ec = std::make_error_code(errc::invalid_argument);
+      return *this;
+    }
+
+  // We never want to skip permission denied when removing files.
+  const bool skip_permission_denied = false;
+  // We never want to follow directory symlinks when removing files.
+  const bool nofollow = true;
+
+  // Loop until we find something we can remove.
+  while (!ec)
+    {
+      auto& top = _M_dirs->top();
+
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      // _Dir::unlink uses fs::remove which uses std::system_category() for
+      // Windows errror codes, so we can't just check for EPERM and EISDIR.
+      // Use directory_entry::refresh() here to check if we have a directory.
+      // This can be a TOCTTOU race, but we don't have openat or unlinkat to
+      // solve that on Windows, and generally don't support symlinks anyway.
+      if (top.entry._M_type == file_type::none)
+	top.entry.refresh();
+#endif
+
+      if (top.entry._M_type == file_type::directory)
+	{
+	  _Dir dir = top.open_subdir(skip_permission_denied, nofollow, ec);
+	  if (!ec)
+	    {
+	      __glibcxx_assert(dir.dirp != nullptr);
+	      if (dir.advance(skip_permission_denied, ec))
+		{
+		  // Non-empty directory, recurse into it.
+		  _M_dirs->push(std::move(dir));
+		  continue;
+		}
+	      if (!ec)
+		{
+		  // Directory is empty so we can remove it.
+		  if (top.rmdir(ec))
+		    break; // Success
+		}
+	    }
+	}
+      else if (top.unlink(ec))
+	break; // Success
+#if ! _GLIBCXX_FILESYSTEM_IS_WINDOWS
+      else if (top.entry._M_type == file_type::none)
+	{
+	  // We did not have a cached type, so it's possible that top.entry
+	  // is actually a directory, and that's why the unlink above failed.
+#ifdef EPERM
+	  // POSIX.1-2017 says unlink on a directory returns EPERM,
+	  // but LSB allows EISDIR too. Some targets don't even define EPERM.
+	  if (ec.value() == EPERM || ec.value() == EISDIR)
+#else
+	  if (ec.value() == EISDIR)
+#endif
+	    {
+	      // Retry, treating it as a directory.
+	      top.entry._M_type = file_type::directory;
+	      ec.clear();
+	      continue;
+	    }
+	}
+#endif
+    }
+
+  if (!ec)
+    {
+      // We successfully removed the current entry, so advance to the next one.
+      if (_M_dirs->top().advance(skip_permission_denied, ec))
+	return *this;
+      else if (!ec)
+	{
+	  // Reached the end of the current directory.
+	  _M_dirs->pop();
+	  if (_M_dirs->empty())
+	    _M_dirs.reset();
+	  return *this;
+	}
+    }
+
+  // Reset _M_dirs to empty.
+  auto dirs = std::move(_M_dirs);
+
+  // Need to report an error
+  if (ecptr)
+    *ecptr = ec;
+  else
+    _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error("cannot remove all",
+						 dirs->orig,
+						 dirs->current_path(),
+						 ec));
+
+  return *this;
+}
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index acff0ff926e..84737453ada 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -27,6 +27,10 @@
 # define NEED_DO_COPY_FILE
 # define NEED_DO_SPACE
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <filesystem>
@@ -113,7 +117,7 @@ fs::absolute(const path& p, error_code& ec)
   while (len > buf.size());
 
   if (len == 0)
-    ec.assign((int)GetLastError(), std::system_category());
+    ec = __last_system_error();
   else
     {
       buf.resize(len);
@@ -353,7 +357,7 @@ fs::copy(const path& from, const path& to, copy_options options,
     }
   if (is_other(f) || is_other(t))
     {
-      ec = std::make_error_code(std::errc::not_supported);
+      ec = std::make_error_code(std::errc::invalid_argument);
       return;
     }
   if (is_directory(f) && is_regular_file(t))
@@ -404,15 +408,19 @@ fs::copy(const path& from, const path& to, copy_options options,
       // set an unused bit in options to disable further recursion
       if (!is_set(options, copy_options::recursive))
 	options |= static_cast<copy_options>(4096);
-      for (const directory_entry& x : directory_iterator(from))
-	copy(x.path(), to/x.path().filename(), options, ec);
+      for (const directory_entry& x : directory_iterator(from, ec))
+	{
+	  copy(x.path(), to/x.path().filename(), options, ec);
+	  if (ec)
+	    return;
+	}
     }
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2683. filesystem::copy() says "no effects"
   else
     ec.clear();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -435,7 +443,7 @@ fs::copy_file(const path& from, const path& to, copy_options options,
   return do_copy_file(from.c_str(), to.c_str(), copy_file_options(options),
 		      nullptr, nullptr, ec);
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
   return false;
 #endif
 }
@@ -583,7 +591,7 @@ namespace
 	created = true;
       }
 #else
-    ec = std::make_error_code(std::errc::not_supported);
+    ec = std::make_error_code(std::errc::function_not_supported);
 #endif
     return created;
   }
@@ -631,7 +639,7 @@ fs::create_directory(const path& p, const path& attributes,
     }
   return create_dir(p, static_cast<perms>(st.st_mode), ec);
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
   return false;
 #endif
 }
@@ -652,7 +660,7 @@ fs::create_directory_symlink(const path& to, const path& new_symlink,
 			     error_code& ec) noexcept
 {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #else
   create_symlink(to, new_symlink, ec);
 #endif
@@ -682,9 +690,9 @@ fs::create_hard_link(const path& to, const path& new_hard_link,
   if (CreateHardLinkW(new_hard_link.c_str(), to.c_str(), NULL))
     ec.clear();
   else
-    ec.assign((int)GetLastError(), system_category());
+    ec = __last_system_error();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -708,7 +716,7 @@ fs::create_symlink(const path& to, const path& new_symlink,
   else
     ec.clear();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -727,7 +735,7 @@ fs::path
 fs::current_path(error_code& ec)
 {
   path p;
-#ifdef _GLIBCXX_HAVE_UNISTD_H
+#if defined _GLIBCXX_HAVE_UNISTD_H && ! defined __AVR__
 #if defined __GLIBC__ || defined _GLIBCXX_FILESYSTEM_IS_WINDOWS
   if (char_ptr cwd = char_ptr{posix::getcwd(nullptr, 0)})
     {
@@ -776,7 +784,7 @@ fs::current_path(error_code& ec)
     }
 #endif  // __GLIBC__
 #else   // _GLIBCXX_HAVE_UNISTD_H
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
   return p;
 }
@@ -799,7 +807,7 @@ fs::current_path(const path& p, error_code& ec) noexcept
   else
     ec.clear();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -839,7 +847,7 @@ fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept
     {
       if (is_other(s1) && is_other(s2))
 	{
-	  ec = std::make_error_code(std::errc::not_supported);
+	  ec = std::__unsupported();
 	  return false;
 	}
       ec.clear();
@@ -874,12 +882,12 @@ fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept
       if (!h1 || !h2)
 	{
 	  if (!h1 && !h2)
-	    ec.assign((int)GetLastError(), system_category());
+	    ec = __last_system_error();
 	  return false;
 	}
       if (!h1.get_info() || !h2.get_info())
 	{
-	  ec.assign((int)GetLastError(), system_category());
+	  ec = __last_system_error();
 	  return false;
 	}
       return h1.info.dwVolumeSerialNumber == h2.info.dwVolumeSerialNumber
@@ -897,7 +905,7 @@ fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept
     ec.clear();
   return false;
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
   return false;
 }
@@ -928,7 +936,7 @@ namespace
       ec.clear();
       return f(st);
 #else
-      ec = std::make_error_code(std::errc::not_supported);
+      ec = std::make_error_code(std::errc::function_not_supported);
       return deflt;
 #endif
     }
@@ -953,10 +961,10 @@ fs::file_size(const path& p, error_code& ec) noexcept
       if (s.type == file_type::directory)
 	ec = std::make_error_code(std::errc::is_a_directory);
       else
-	ec = std::make_error_code(std::errc::not_supported);
+	ec = std::__unsupported();
     }
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
   return -1;
 }
@@ -978,7 +986,7 @@ fs::hard_link_count(const path& p, error_code& ec) noexcept
   return do_stat(p, ec, std::mem_fn(&stat_type::st_nlink),
 		 static_cast<uintmax_t>(-1));
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
   return static_cast<uintmax_t>(-1);
 #endif
 }
@@ -1026,7 +1034,7 @@ fs::last_write_time(const path& p, error_code& ec) noexcept
 		 },
 		 file_time_type::min());
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
   return file_time_type::min();
 #endif
 }
@@ -1072,7 +1080,7 @@ fs::last_write_time(const path& p,
   else
     ec.clear();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -1121,7 +1129,7 @@ fs::permissions(const path& p, perms prms, perm_options opts,
     err = errno;
 #else
   if (nofollow && is_symlink(st))
-    ec = std::make_error_code(std::errc::not_supported);
+    ec = std::__unsupported();
   else if (posix::chmod(p.c_str(), static_cast<posix::mode_t>(prms)))
     err = errno;
 #endif
@@ -1206,7 +1214,7 @@ fs::path fs::read_symlink(const path& p, error_code& ec)
     }
   while (true);
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
   return result;
 }
@@ -1255,7 +1263,7 @@ fs::remove(const path& p, error_code& ec) noexcept
 	  return true;
 	}
       else if (!ec)
-	ec.assign((int)GetLastError(), system_category());
+	ec = __last_system_error();
     }
   else if (status_known(st))
     ec.clear();
@@ -1273,105 +1281,84 @@ fs::remove(const path& p, error_code& ec) noexcept
   return false;
 }
 
-namespace std::filesystem
-{
-namespace
-{
-  struct ErrorReporter
-  {
-    explicit
-    ErrorReporter(error_code& ec) : code(&ec)
-    { }
-
-    explicit
-    ErrorReporter(const char* s, const path& p)
-    : code(nullptr), msg(s), path1(&p)
-    { }
-
-    error_code* code;
-    const char* msg;
-    const path* path1;
-
-    void
-    report(const error_code& ec) const
-    {
-      if (code)
-	*code = ec;
-      else
-	_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, ec));
-    }
-
-    void
-    report(const error_code& ec, const path& path2) const
-    {
-      if (code)
-	*code = ec;
-      else if (path2 != *path1)
-	_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, path2, ec));
-      else
-	_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, ec));
-    }
-  };
-
-  uintmax_t
-  do_remove_all(const path& p, const ErrorReporter& err)
-  {
-    error_code ec;
-    const auto s = symlink_status(p, ec);
-    if (!status_known(s))
-      {
-	if (ec)
-	  err.report(ec, p);
-	return -1;
-      }
-
-    ec.clear();
-    if (s.type() == file_type::not_found)
-      return 0;
-
-    uintmax_t count = 0;
-    if (s.type() == file_type::directory)
-      {
-	directory_iterator d(p, ec), end;
-	while (d != end)
-	  {
-	    const auto removed = fs::do_remove_all(d->path(), err);
-	    if (removed == numeric_limits<uintmax_t>::max())
-	      return -1;
-	    count += removed;
-
-	    d.increment(ec);
-	    if (ec)
-	      {
-		err.report(ec, p);
-		return -1;
-	      }
-	  }
-      }
-
-    if (fs::remove(p, ec))
-      ++count;
-    if (ec)
-      {
-	err.report(ec, p);
-	return -1;
-      }
-    return count;
-  }
-}
-}
-
 std::uintmax_t
 fs::remove_all(const path& p)
 {
-  return fs::do_remove_all(p, ErrorReporter{"cannot remove all", p});
+  error_code ec;
+  uintmax_t count = 0;
+  recursive_directory_iterator dir(p, directory_options{64|128}, ec);
+  switch (ec.value()) // N.B. assumes ec.category() == std::generic_category()
+  {
+  case 0:
+    // Iterate over the directory removing everything.
+    {
+      const recursive_directory_iterator end;
+      while (dir != end)
+	{
+	  dir.__erase(); // throws on error
+	  ++count;
+	}
+    }
+    // Directory is empty now, will remove it below.
+    break;
+#ifndef __AVR__
+  case ENOENT:
+    // Our work here is done.
+    return 0;
+  case ENOTDIR:
+  case ELOOP:
+    // Not a directory, will remove below.
+    break;
+#endif
+  default:
+    // An error occurred.
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot remove all", p, ec));
+  }
+
+  // Remove p itself, which is either a non-directory or is now empty.
+  return count + fs::remove(p);
 }
 
 std::uintmax_t
 fs::remove_all(const path& p, error_code& ec)
 {
-  ec.clear();
-  return fs::do_remove_all(p, ErrorReporter{ec});
+  uintmax_t count = 0;
+  recursive_directory_iterator dir(p, directory_options{64|128}, ec);
+  switch (ec.value()) // N.B. assumes ec.category() == std::generic_category()
+  {
+  case 0:
+    // Iterate over the directory removing everything.
+    {
+      const recursive_directory_iterator end;
+      while (dir != end)
+	{
+	  dir.__erase(&ec);
+	  if (ec)
+	    return -1;
+	  ++count;
+	}
+    }
+    // Directory is empty now, will remove it below.
+    break;
+#ifndef __AVR__
+  case ENOENT:
+    // Our work here is done.
+    ec.clear();
+    return 0;
+  case ENOTDIR:
+  case ELOOP:
+    // Not a directory, will remove below.
+    break;
+#endif
+  default:
+    // An error occurred.
+    return -1;
+  }
+
+  // Remove p itself, which is either a non-directory or is now empty.
+  if (int last = fs::remove(p, ec); !ec)
+    return count + last;
+  return -1;
 }
 
 void
@@ -1434,7 +1421,7 @@ fs::resize_file(const path& p, uintmax_t size)
 void
 fs::resize_file(const path& p, uintmax_t size, error_code& ec) noexcept
 {
-  if (size > static_cast<uintmax_t>(std::numeric_limits<off_t>::max()))
+  if (size > static_cast<uintmax_t>(std::numeric_limits<posix::off_t>::max()))
     ec.assign(EINVAL, std::generic_category());
   else if (posix::truncate(p.c_str(), size))
     ec.assign(errno, std::generic_category());
@@ -1584,7 +1571,8 @@ fs::symlink_status(const fs::path& p)
   return result;
 }
 
-fs::path fs::temp_directory_path()
+fs::path
+fs::temp_directory_path()
 {
   error_code ec;
   path tmp = temp_directory_path(ec);
@@ -1593,32 +1581,12 @@ fs::path fs::temp_directory_path()
   return tmp;
 }
 
-fs::path fs::temp_directory_path(error_code& ec)
+fs::path
+fs::temp_directory_path(error_code& ec)
 {
-  path p;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  unsigned len = 1024;
-  std::wstring buf;
-  do
-    {
-      buf.resize(len);
-      len = GetTempPathW(buf.size(), buf.data());
-    } while (len > buf.size());
-
-  if (len == 0)
-    {
-      ec.assign((int)GetLastError(), std::system_category());
-      return p;
-    }
-  buf.resize(len);
-  p = std::move(buf);
-#else
-  const char* tmpdir = nullptr;
-  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
-  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
-    tmpdir = ::getenv(*e);
-  p = tmpdir ? tmpdir : "/tmp";
-#endif
+  path p = fs::get_temp_directory_from_env(ec);
+  if (ec)
+    return p;
   auto st = status(p, ec);
   if (ec)
     p.clear();
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index 506ff25f9a6..5d3f40a9ddf 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -186,6 +186,19 @@ struct path::_Parser
   { return origin + c.str.data() - input.data(); }
 };
 
+inline
+path::path(basic_string_view<value_type> __str, _Type __type)
+: _M_pathname(__str)
+{
+  __glibcxx_assert(__type != _Type::_Multi);
+  _M_cmpts.type(__type);
+}
+
+inline
+path::_Cmpt::_Cmpt(basic_string_view<value_type> __s, _Type __t, size_t __pos)
+: path(__s, __t), _M_pos(__pos)
+{ }
+
 struct path::_List::_Impl
 {
   using value_type = _Cmpt;
@@ -1872,11 +1885,6 @@ path::_M_split_cmpts()
       _M_cmpts.type(_Type::_Filename);
       return;
     }
-  if (_M_pathname.length() == 1 && _M_pathname[0] == preferred_separator)
-    {
-      _M_cmpts.type(_Type::_Root_dir);
-      return;
-    }
 
   _Parser parser(_M_pathname);
 
diff --git a/libstdc++-v3/src/c++17/memory_resource.cc b/libstdc++-v3/src/c++17/memory_resource.cc
index 5dfc29fc0ec..9c2aef8e520 100644
--- a/libstdc++-v3/src/c++17/memory_resource.cc
+++ b/libstdc++-v3/src/c++17/memory_resource.cc
@@ -502,7 +502,7 @@ namespace pmr
     }
 
     // Allocated size of chunk:
-    uint32_t _M_bytes = 0;
+    bitset::size_type _M_bytes = 0;
     // Start of allocated chunk:
     std::byte* _M_p = nullptr;
 
@@ -576,7 +576,7 @@ namespace pmr
   // For 16-bit pointers it's five pointers (10 bytes).
   // TODO pad 64-bit to 4*sizeof(void*) to avoid splitting across cache lines?
   static_assert(sizeof(chunk)
-      == sizeof(bitset::size_type) + sizeof(uint32_t) + 2 * sizeof(void*));
+      == 2 * sizeof(bitset::size_type) + 2 * sizeof(void*));
 
   // An oversized allocation that doesn't fit in a pool.
   struct big_block
@@ -731,7 +731,7 @@ namespace pmr
 	  _M_blocks_per_chunk = std::min({
 	      max_blocks,
 	      __opts.max_blocks_per_chunk,
-	      (size_t)_M_blocks_per_chunk * 2
+	      size_t(_M_blocks_per_chunk * 2)
 	  });
 	}
     }
@@ -870,9 +870,11 @@ namespace pmr
       256, 320, 384, 448,
       512, 768,
 #if __SIZE_WIDTH__ > 16
+      // Use bigger pools if size_t has at least 20 bits.
       1024, 1536,
       2048, 3072,
-#if __SIZE_WIDTH__ > 20
+#if __INT_WIDTH__ >= 32
+      // Use even bigger pools if int has at least 32 bits.
       1<<12, 1<<13, 1<<14,
       1<<15, 1<<16, 1<<17,
       1<<20, 1<<21, 1<<22 // 4MB should be enough for anybody
@@ -1052,7 +1054,8 @@ namespace pmr
 	// Decide on initial number of blocks per chunk.
 	// At least 16 blocks per chunk seems reasonable,
 	// more for smaller blocks:
-	size_t blocks_per_chunk = std::max(size_t(16), 1024 / block_size);
+	size_t blocks_per_chunk = 1024 / block_size;
+	blocks_per_chunk = std::max(size_t(16), blocks_per_chunk);
 	// But don't exceed the requested max_blocks_per_chunk:
 	blocks_per_chunk
 	  = std::min(blocks_per_chunk, _M_opts.max_blocks_per_chunk);
diff --git a/libstdc++-v3/src/c++20/sstream-inst.cc b/libstdc++-v3/src/c++20/sstream-inst.cc
index b3fbd6ead44..55d1fe5234d 100644
--- a/libstdc++-v3/src/c++20/sstream-inst.cc
+++ b/libstdc++-v3/src/c++20/sstream-inst.cc
@@ -26,7 +26,9 @@
 // ISO C++ 14882:
 //
 
-// Instantiations in this file are only for the new SSO std::string ABI
+// Instantiations in this file are only for the new SSO std::string ABI.
+#define _GLIBCXX_USE_CXX11_ABI 1
+
 #include <sstream>
 
 #if _GLIBCXX_USE_CXX11_ABI
diff --git a/libstdc++-v3/src/filesystem/dir-common.h b/libstdc++-v3/src/filesystem/dir-common.h
index a49b8304a29..f6b9cc8779d 100644
--- a/libstdc++-v3/src/filesystem/dir-common.h
+++ b/libstdc++-v3/src/filesystem/dir-common.h
@@ -34,7 +34,11 @@
 # ifdef _GLIBCXX_HAVE_SYS_TYPES_H
 #  include <sys/types.h>
 # endif
-# include <dirent.h>
+# include <dirent.h> // opendir, readdir, fdopendir, dirfd
+# ifdef _GLIBCXX_HAVE_FCNTL_H
+#  include <fcntl.h>  // open, openat, fcntl, AT_FDCWD, O_NOFOLLOW etc.
+#  include <unistd.h> // close, unlinkat
+# endif
 #endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -66,31 +70,40 @@ struct DIR { };
 inline DIR* opendir(const char*) { return nullptr; }
 inline dirent* readdir(DIR*) { return nullptr; }
 inline int closedir(DIR*) { return -1; }
+#undef _GLIBCXX_HAVE_DIRFD
+#undef _GLIBCXX_HAVE_UNLINKAT
 #endif
 } // namespace __gnu_posix
 
 namespace posix = __gnu_posix;
 
+inline bool
+is_permission_denied_error(int e)
+{
+  if (e == EACCES)
+    return true;
+#ifdef __APPLE__
+  if (e == EPERM) // See PR 99533
+    return true;
+#endif
+  return false;
+}
+
 struct _Dir_base
 {
-  _Dir_base(posix::DIR* dirp = nullptr) : dirp(dirp) { }
-
   // If no error occurs then dirp is non-null,
-  // otherwise null (whether error ignored or not).
-  _Dir_base(const posix::char_type* pathname, bool skip_permission_denied,
+  // otherwise null (even if a permission denied error is ignored).
+  _Dir_base(int fd, const posix::char_type* pathname,
+	    bool skip_permission_denied, bool nofollow,
 	    error_code& ec) noexcept
-  : dirp(posix::opendir(pathname))
+  : dirp(_Dir_base::openat(fd, pathname, nofollow))
   {
     if (dirp)
       ec.clear();
+    else if (is_permission_denied_error(errno) && skip_permission_denied)
+      ec.clear();
     else
-    {
-      const int err = errno;
-      if (err == EACCES && skip_permission_denied)
-	ec.clear();
-      else
-	ec.assign(err, std::generic_category());
-    }
+      ec.assign(errno, std::generic_category());
   }
 
   _Dir_base(_Dir_base&& d) : dirp(std::exchange(d.dirp, nullptr)) { }
@@ -130,6 +143,16 @@ struct _Dir_base
       }
   }
 
+  static constexpr int
+  fdcwd() noexcept
+  {
+#ifdef AT_FDCWD
+    return AT_FDCWD;
+#else
+    return -1; // Use invalid fd if AT_FDCWD isn't supported.
+#endif
+  }
+
   static bool is_dot_or_dotdot(const char* s) noexcept
   { return !strcmp(s, ".") || !strcmp(s, ".."); }
 
@@ -138,21 +161,72 @@ struct _Dir_base
   { return !wcscmp(s, L".") || !wcscmp(s, L".."); }
 #endif
 
+  // Set the close-on-exec flag if not already done via O_CLOEXEC.
+  static bool
+  set_close_on_exec([[maybe_unused]] int fd)
+  {
+#if ! defined O_CLOEXEC && defined FD_CLOEXEC
+    int flags = ::fcntl(fd, F_GETFD);
+    if (flags == -1 || ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
+      return false;
+#endif
+    return true;
+  }
+
+  static posix::DIR*
+  openat(int fd, const posix::char_type* pathname, bool nofollow)
+  {
+#if _GLIBCXX_HAVE_FDOPENDIR && defined O_RDONLY && defined O_DIRECTORY \
+    && ! _GLIBCXX_FILESYSTEM_IS_WINDOWS
+
+    // Any file descriptor we open here should be closed on exec.
+#ifdef O_CLOEXEC
+    constexpr int close_on_exec = O_CLOEXEC;
+#else
+    constexpr int close_on_exec = 0;
+#endif
+
+    int flags = O_RDONLY | O_DIRECTORY | close_on_exec;
+
+    // Directory iterators are vulnerable to race conditions unless O_NOFOLLOW
+    // is supported, because a directory could be replaced with a symlink after
+    // checking is_directory(symlink_status(f)). O_NOFOLLOW avoids the race.
+#ifdef O_NOFOLLOW
+    if (nofollow)
+      flags |= O_NOFOLLOW;
+#else
+    nofollow = false;
+#endif
+
+
+#if _GLIBCXX_HAVE_OPENAT && defined AT_FDCWD
+    fd = ::openat(fd, pathname, flags);
+#else
+    // If we cannot use openat, there's no benefit to using posix::open unless
+    // we will use O_NOFOLLOW, so just use the simpler posix::opendir.
+    if (!nofollow)
+      return posix::opendir(pathname);
+
+    fd = ::open(pathname, flags);
+#endif
+
+    if (fd == -1)
+      return nullptr;
+    if (set_close_on_exec(fd))
+      if (::DIR* dirp = ::fdopendir(fd))
+	return dirp;
+    int err = errno;
+    ::close(fd);
+    errno = err;
+    return nullptr;
+#else
+    return posix::opendir(pathname);
+#endif
+  }
+
   posix::DIR*	dirp;
 };
 
-inline bool
-is_permission_denied_error(int e)
-{
-  if (e == EACCES)
-    return true;
-#ifdef __APPLE__
-  if (e == EPERM) // See PR 99533
-    return true;
-#endif
-  return false;
-}
-
 } // namespace filesystem
 
 // BEGIN/END macros must be defined before including this file.
@@ -187,6 +261,7 @@ get_file_type(const std::filesystem::__gnu_posix::dirent& d [[gnu::unused]])
   return file_type::none;
 #endif
 }
+
 _GLIBCXX_END_NAMESPACE_FILESYSTEM
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/src/filesystem/dir.cc b/libstdc++-v3/src/filesystem/dir.cc
index 06e165b8888..2fedca36a06 100644
--- a/libstdc++-v3/src/filesystem/dir.cc
+++ b/libstdc++-v3/src/filesystem/dir.cc
@@ -25,6 +25,10 @@
 #ifndef _GLIBCXX_USE_CXX11_ABI
 # define _GLIBCXX_USE_CXX11_ABI 1
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <experimental/filesystem>
@@ -47,14 +51,15 @@ namespace posix = std::filesystem::__gnu_posix;
 
 struct fs::_Dir : std::filesystem::_Dir_base
 {
-  _Dir(const fs::path& p, bool skip_permission_denied, error_code& ec)
-  : _Dir_base(p.c_str(), skip_permission_denied, ec)
+  _Dir(const fs::path& p, bool skip_permission_denied, bool nofollow,
+       error_code& ec)
+  : _Dir_base(this->fdcwd(), p.c_str(), skip_permission_denied, nofollow, ec)
   {
     if (!ec)
       path = p;
   }
 
-  _Dir(posix::DIR* dirp, const path& p) : _Dir_base(dirp), path(p) { }
+  _Dir(_Dir_base&& d, const path& p) : _Dir_base(std::move(d)), path(p) { }
 
   _Dir(_Dir&&) = default;
 
@@ -108,6 +113,29 @@ struct fs::_Dir : std::filesystem::_Dir_base
     return false;
   }
 
+  // Return a file descriptor for the directory and current entry's path.
+  // If dirfd is available, use it and return only the filename.
+  // Otherwise, return AT_FDCWD and return the full path.
+  pair<int, const posix::char_type*>
+  dir_and_pathname() const noexcept
+  {
+    const fs::path& p = entry.path();
+#if _GLIBCXX_HAVE_DIRFD && _GLIBCXX_HAVE_OPENAT
+    return {::dirfd(this->dirp), std::prev(p.end())->c_str()};
+#endif
+    return {this->fdcwd(), p.c_str()};
+  }
+
+  // Create a new _Dir for the directory this->entry.path().
+  _Dir
+  open_subdir(bool skip_permission_denied, bool nofollow,
+	      error_code& ec) noexcept
+  {
+    auto [dirfd, pathname] = dir_and_pathname();
+    _Dir_base d(dirfd, pathname, skip_permission_denied, nofollow, ec);
+    return _Dir(std::move(d), entry.path());
+  }
+
   fs::path		path;
   directory_entry	entry;
   file_type		type = file_type::none;
@@ -126,11 +154,12 @@ namespace
 fs::directory_iterator::
 directory_iterator(const path& p, directory_options options, error_code* ecptr)
 {
+  // Do not report an error for permission denied errors.
   const bool skip_permission_denied
     = is_set(options, directory_options::skip_permission_denied);
 
   error_code ec;
-  _Dir dir(p, skip_permission_denied, ec);
+  _Dir dir(p, skip_permission_denied, /*nofollow*/false, ec);
 
   if (dir.dirp)
     {
@@ -182,6 +211,11 @@ fs::directory_iterator::increment(error_code& ec) noexcept
 
 struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>
 {
+  _Dir_stack(_Dir&& dir)
+  {
+    this->push(std::move(dir));
+  }
+
   void clear() { c.clear(); }
 };
 
@@ -190,33 +224,27 @@ recursive_directory_iterator(const path& p, directory_options options,
                              error_code* ecptr)
 : _M_options(options), _M_pending(true)
 {
-  if (posix::DIR* dirp = posix::opendir(p.c_str()))
+  // Do not report an error for permission denied errors.
+  const bool skip_permission_denied
+    = is_set(options, directory_options::skip_permission_denied);
+
+  error_code ec;
+  _Dir dir(p, skip_permission_denied, /*nofollow*/false, ec);
+
+  if (dir.dirp)
     {
-      if (ecptr)
-	ecptr->clear();
-      auto sp = std::make_shared<_Dir_stack>();
-      sp->push(_Dir{ dirp, p });
-      if (ecptr ? sp->top().advance(*ecptr) : sp->top().advance())
-	_M_dirs.swap(sp);
-    }
-  else
-    {
-      const int err = errno;
-      if (std::filesystem::is_permission_denied_error(err)
-	  && is_set(options, fs::directory_options::skip_permission_denied))
+      auto sp = std::__make_shared<_Dir_stack>(std::move(dir));
+      if (ecptr ? sp->top().advance(skip_permission_denied, *ecptr)
+		: sp->top().advance(skip_permission_denied))
 	{
-	  if (ecptr)
-	    ecptr->clear();
-	  return;
+	  _M_dirs.swap(sp);
 	}
-
-      if (!ecptr)
-	_GLIBCXX_THROW_OR_ABORT(filesystem_error(
-	      "recursive directory iterator cannot open directory", p,
-	      std::error_code(err, std::generic_category())));
-
-      ecptr->assign(err, std::generic_category());
     }
+  else if (ecptr)
+    *ecptr = ec;
+  else if (ec)
+    _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(
+	  "recursive directory iterator cannot open directory", p, ec));
 }
 
 fs::recursive_directory_iterator::~recursive_directory_iterator() = default;
@@ -270,7 +298,7 @@ fs::recursive_directory_iterator::increment(error_code& ec) noexcept
 
   if (std::exchange(_M_pending, true) && top.should_recurse(follow, ec))
     {
-      _Dir dir(top.entry.path(), skip_permission_denied, ec);
+      _Dir dir = top.open_subdir(skip_permission_denied, !follow, ec);
       if (ec)
 	{
 	  _M_dirs.reset();
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 529d4e09016..c7c8f3f4cb7 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -56,6 +56,48 @@
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  // Get the last OS error (for POSIX this is just errno).
+  inline error_code
+  __last_system_error() noexcept
+  {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+    // N.B. use error_code::default_error_condition() to convert to generic.
+    return {(int)::GetLastError(), std::system_category()};
+#else
+    return {errno, std::generic_category()};
+#endif
+  }
+
+  // Get an error code indicating unsupported functionality.
+  //
+  // This should be used when a function is unable to behave as specified
+  // due to an incomplete or partial implementation, e.g.
+  // filesystem::equivalent(a, b) if is_other(a) && is_other(b) is true.
+  //
+  // Use errc::function_not_supported for functions that are entirely
+  // unimplemented, e.g. create_symlink on Windows.
+  //
+  // Use errc::invalid_argument for requests to perform operations outside
+  // the spec, e.g. trying to copy a directory using filesystem::copy_file.
+  inline error_code
+  __unsupported() noexcept
+  {
+#if defined __AVR__
+    // avr-libc defines ENOTSUP and EOPNOTSUPP but with nonsense values.
+    // ENOSYS is defined though, so use an error_code corresponding to that.
+    // This contradicts the comment above, but we don't have much choice.
+    return std::make_error_code(std::errc::function_not_supported);
+#elif defined ENOTSUP
+    return std::make_error_code(std::errc::not_supported);
+#elif defined EOPNOTSUPP
+    // This is supposed to be for socket operations
+    return std::make_error_code(std::errc::operation_not_supported);
+#else
+    return std::make_error_code(std::errc::invalid_argument);
+#endif
+  }
+
 namespace filesystem
 {
 namespace __gnu_posix
@@ -115,6 +157,7 @@ namespace __gnu_posix
     return -1;
   }
 
+  using off_t = _off64_t;
   inline int truncate(const wchar_t* path, _off64_t length)
   {
     const int fd = ::_wopen(path, _O_BINARY|_O_RDWR);
@@ -128,7 +171,7 @@ namespace __gnu_posix
     return ret;
   }
   using char_type = wchar_t;
-#elif defined _GLIBCXX_HAVE_UNISTD_H
+#elif defined _GLIBCXX_HAVE_UNISTD_H && ! defined __AVR__
   using ::open;
   using ::close;
 # ifdef _GLIBCXX_HAVE_SYS_STAT_H
@@ -151,6 +194,7 @@ namespace __gnu_posix
   using ::utime;
 # endif
   using ::rename;
+  using ::off_t;
 # ifdef _GLIBCXX_HAVE_TRUNCATE
   using ::truncate;
 # else
@@ -170,15 +214,16 @@ namespace __gnu_posix
 # endif
   using char_type = char;
 #else // ! _GLIBCXX_FILESYSTEM_IS_WINDOWS && ! _GLIBCXX_HAVE_UNISTD_H
-  inline int open(const char*, int, ...) { errno = ENOTSUP; return -1; }
-  inline int close(int) { errno = ENOTSUP; return -1; }
+  inline int open(const char*, int, ...) { errno = ENOSYS; return -1; }
+  inline int close(int) { errno = ENOSYS; return -1; }
   using mode_t = int;
-  inline int chmod(const char*, mode_t) { errno = ENOTSUP; return -1; }
-  inline int mkdir(const char*, mode_t) { errno = ENOTSUP; return -1; }
-  inline char* getcwd(char*, size_t) { errno = ENOTSUP; return nullptr; }
-  inline int chdir(const char*) { errno = ENOTSUP; return -1; }
-  inline int rename(const char*, const char*) { errno = ENOTSUP; return -1; }
-  inline int truncate(const char*, long) { errno = ENOTSUP; return -1; }
+  inline int chmod(const char*, mode_t) { errno = ENOSYS; return -1; }
+  inline int mkdir(const char*, mode_t) { errno = ENOSYS; return -1; }
+  inline char* getcwd(char*, size_t) { errno = ENOSYS; return nullptr; }
+  inline int chdir(const char*) { errno = ENOSYS; return -1; }
+  inline int rename(const char*, const char*) { errno = ENOSYS; return -1; }
+  using off_t = long;
+  inline int truncate(const char*, off_t) { errno = ENOSYS; return -1; }
   using char_type = char;
 #endif // _GLIBCXX_FILESYSTEM_IS_WINDOWS
 } // namespace __gnu_posix
@@ -361,7 +406,7 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
     // 2712. copy_file() has a number of unspecified error conditions
     if (!is_regular_file(f))
       {
-	ec = std::make_error_code(std::errc::not_supported);
+	ec = std::make_error_code(std::errc::invalid_argument);
 	return false;
       }
 
@@ -369,7 +414,7 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
       {
 	if (!is_regular_file(t))
 	  {
-	    ec = std::make_error_code(std::errc::not_supported);
+	    ec = std::make_error_code(std::errc::invalid_argument);
 	    return false;
 	  }
 
@@ -400,7 +445,7 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 	  }
 	else if (!is_regular_file(t))
 	  {
-	    ec = std::make_error_code(std::errc::not_supported);
+	    ec = std::make_error_code(std::errc::invalid_argument);
 	    return false;
 	  }
       }
@@ -411,25 +456,26 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
       int fd;
     };
 
-    int iflag = O_RDONLY;
+    int common_flags = 0;
+#ifdef O_CLOEXEC
+    common_flags |= O_CLOEXEC;
+#endif
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-    iflag |= O_BINARY;
+    common_flags |= O_BINARY;
 #endif
 
+    const int iflag = O_RDONLY | common_flags;
     CloseFD in = { posix::open(from, iflag) };
     if (in.fd == -1)
       {
 	ec.assign(errno, std::generic_category());
 	return false;
       }
-    int oflag = O_WRONLY|O_CREAT;
+    int oflag = O_WRONLY | O_CREAT | common_flags;
     if (options.overwrite || options.update)
       oflag |= O_TRUNC;
     else
       oflag |= O_EXCL;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-    oflag |= O_BINARY;
-#endif
     CloseFD out = { posix::open(to, oflag, S_IWUSR) };
     if (out.fd == -1)
       {
@@ -454,25 +500,29 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 
     size_t count = from_st->st_size;
 #if defined _GLIBCXX_USE_SENDFILE && ! defined _GLIBCXX_FILESYSTEM_IS_WINDOWS
-    off_t offset = 0;
-    ssize_t n = ::sendfile(out.fd, in.fd, &offset, count);
-    if (n < 0 && errno != ENOSYS && errno != EINVAL)
+    ssize_t n = 0;
+    if (count != 0)
       {
-	ec.assign(errno, std::generic_category());
-	return false;
-      }
-    if ((size_t)n == count)
-      {
-	if (!out.close() || !in.close())
+	off_t offset = 0;
+	n = ::sendfile(out.fd, in.fd, &offset, count);
+	if (n < 0 && errno != ENOSYS && errno != EINVAL)
 	  {
 	    ec.assign(errno, std::generic_category());
 	    return false;
 	  }
-	ec.clear();
-	return true;
+	if ((size_t)n == count)
+	  {
+	    if (!out.close() || !in.close())
+	      {
+		ec.assign(errno, std::generic_category());
+		return false;
+	      }
+	    ec.clear();
+	    return true;
+	  }
+	else if (n > 0)
+	  count -= n;
       }
-    else if (n > 0)
-      count -= n;
 #endif // _GLIBCXX_USE_SENDFILE
 
     using std::ios;
@@ -502,11 +552,17 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
       }
 #endif
 
-    if (count && !(std::ostream(&sbout) << &sbin))
-      {
-	ec = std::make_error_code(std::errc::io_error);
-	return false;
-      }
+    // ostream::operator<<(streambuf*) fails if it extracts no characters,
+    // so don't try to use it for empty files. But from_st->st_size == 0 for
+    // some special files (e.g. procfs, see PR libstdc++/108178) so just try
+    // to read a character to decide whether there is anything to copy or not.
+    if (sbin.sgetc() != char_traits<char>::eof())
+      if (!(std::ostream(&sbout) << &sbin))
+	{
+	  ec = std::make_error_code(std::errc::io_error);
+	  return false;
+	}
+
     if (!sbout.close() || !sbin.close())
       {
 	ec.assign(errno, std::generic_category());
@@ -557,9 +613,9 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 	ec.clear();
       }
     else
-      ec.assign((int)GetLastError(), std::system_category());
+      ec = std::__last_system_error();
 #else
-    ec = std::make_error_code(std::errc::not_supported);
+    ec = std::make_error_code(std::errc::function_not_supported);
 #endif
   }
 #pragma GCC diagnostic pop
@@ -567,6 +623,48 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 
 #endif // _GLIBCXX_HAVE_SYS_STAT_H
 
+  // Find OS-specific name of temporary directory from the environment,
+  // Caller must check that the path is an accessible directory.
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  inline wstring
+  get_temp_directory_from_env(error_code& ec)
+  {
+    unsigned len = 1024;
+    std::wstring buf;
+    do
+      {
+	buf.resize(len);
+	len = GetTempPathW(buf.size(), buf.data());
+      }
+    while (len > buf.size());
+
+    if (len == 0)
+      ec = __last_system_error();
+    else
+      ec.clear();
+
+    buf.resize(len);
+    return buf;
+  }
+#else
+  inline const char*
+  get_temp_directory_from_env(error_code& ec) noexcept
+  {
+    ec.clear();
+    for (auto env : { "TMPDIR", "TMP", "TEMP", "TEMPDIR" })
+      {
+#if _GLIBCXX_HAVE_SECURE_GETENV
+	auto tmpdir = ::secure_getenv(env);
+#else
+	auto tmpdir = ::getenv(env);
+#endif
+	if (tmpdir)
+	  return tmpdir;
+      }
+    return "/tmp";
+  }
+#endif
+
 _GLIBCXX_END_NAMESPACE_FILESYSTEM
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 3f2290f372d..274878e8f6e 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -27,6 +27,10 @@
 # define NEED_DO_COPY_FILE
 # define NEED_DO_SPACE
 #endif
+#ifndef _GNU_SOURCE
+// Cygwin needs this for secure_getenv
+# define _GNU_SOURCE 1
+#endif
 
 #include <bits/largefile-config.h>
 #include <experimental/filesystem>
@@ -59,6 +63,8 @@
 #define _GLIBCXX_END_NAMESPACE_FILESYSTEM } }
 #include "ops-common.h"
 
+#include <filesystem> // std::filesystem::remove_all
+
 namespace fs = std::experimental::filesystem;
 namespace posix = std::filesystem::__gnu_posix;
 
@@ -293,7 +299,7 @@ fs::copy(const path& from, const path& to, copy_options options,
     }
   if (is_other(f) || is_other(t))
     {
-      ec = std::make_error_code(std::errc::not_supported);
+      ec = std::make_error_code(std::errc::invalid_argument);
       return;
     }
   if (is_directory(f) && is_regular_file(t))
@@ -344,8 +350,12 @@ fs::copy(const path& from, const path& to, copy_options options,
       // set an unused bit in options to disable further recursion
       if (!is_set(options, copy_options::recursive))
 	options |= static_cast<copy_options>(4096);
-      for (const directory_entry& x : directory_iterator(from))
-	copy(x.path(), to/x.path().filename(), options, ec);
+      for (const directory_entry& x : directory_iterator(from, ec))
+	{
+	  copy(x.path(), to/x.path().filename(), options, ec);
+	  if (ec)
+	    return;
+	}
     }
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2683. filesystem::copy() says "no effects"
@@ -372,7 +382,7 @@ fs::copy_file(const path& from, const path& to, copy_options options,
   return do_copy_file(from.c_str(), to.c_str(), copy_file_options(options),
 		      nullptr, nullptr, ec);
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
   return false;
 #endif
 }
@@ -491,7 +501,7 @@ namespace
 	created = true;
       }
 #else
-    ec = std::make_error_code(std::errc::not_supported);
+    ec = std::make_error_code(std::errc::function_not_supported);
 #endif
     return created;
   }
@@ -539,7 +549,7 @@ fs::create_directory(const path& p, const path& attributes,
     }
   return create_dir(p, static_cast<perms>(st.st_mode), ec);
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
   return false;
 #endif
 }
@@ -560,7 +570,7 @@ fs::create_directory_symlink(const path& to, const path& new_symlink,
 			     error_code& ec) noexcept
 {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #else
   create_symlink(to, new_symlink, ec);
 #endif
@@ -590,9 +600,9 @@ fs::create_hard_link(const path& to, const path& new_hard_link,
   if (CreateHardLinkW(new_hard_link.c_str(), to.c_str(), NULL))
     ec.clear();
   else
-    ec.assign((int)GetLastError(), system_category());
+    ec = __last_system_error();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -616,7 +626,7 @@ fs::create_symlink(const path& to, const path& new_symlink,
   else
     ec.clear();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -683,7 +693,7 @@ fs::current_path(error_code& ec)
     }
 #endif  // __GLIBC__
 #else   // _GLIBCXX_HAVE_UNISTD_H
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
   return p;
 }
@@ -706,7 +716,7 @@ fs::current_path(const path& p, error_code& ec) noexcept
   else
     ec.clear();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -746,7 +756,7 @@ fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept
     {
       if (is_other(s1) && is_other(s2))
 	{
-	  ec = std::make_error_code(std::errc::not_supported);
+	  ec = std::__unsupported();
 	  return false;
 	}
       ec.clear();
@@ -762,7 +772,7 @@ fs::equivalent(const path& p1, const path& p2, error_code& ec) noexcept
     ec.clear();
   return false;
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
   return false;
 }
@@ -793,7 +803,7 @@ namespace
       ec.clear();
       return f(st);
 #else
-      ec = std::make_error_code(std::errc::not_supported);
+      ec = std::make_error_code(std::errc::function_not_supported);
       return deflt;
 #endif
     }
@@ -817,7 +827,7 @@ fs::file_size(const path& p, error_code& ec) noexcept
       if (s.type == file_type::directory)
 	ec = std::make_error_code(std::errc::is_a_directory);
       else
-	ec = std::make_error_code(std::errc::not_supported);
+	ec = std::__unsupported();
     }
   return -1;
 }
@@ -920,7 +930,7 @@ fs::last_write_time(const path& p __attribute__((__unused__)),
   else
     ec.clear();
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
 }
 
@@ -967,7 +977,7 @@ fs::permissions(const path& p, perms prms, error_code& ec) noexcept
     err = errno;
 #else
   if (nofollow && is_symlink(st))
-    ec = std::make_error_code(std::errc::operation_not_supported);
+    ec = std::__unsupported();
   else if (posix::chmod(p.c_str(), static_cast<mode_t>(prms)))
     err = errno;
 #endif
@@ -1032,7 +1042,7 @@ fs::path fs::read_symlink(const path& p [[gnu::unused]], error_code& ec)
     }
   while (true);
 #else
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::make_error_code(std::errc::function_not_supported);
 #endif
   return result;
 }
@@ -1062,7 +1072,7 @@ fs::remove(const path& p, error_code& ec) noexcept
 	  return true;
 	}
       else if (!ec)
-	ec.assign((int)GetLastError(), system_category());
+	ec = __last_system_error();
     }
   else if (status_known(st))
     ec.clear();
@@ -1094,33 +1104,8 @@ fs::remove_all(const path& p)
 std::uintmax_t
 fs::remove_all(const path& p, error_code& ec)
 {
-  const auto s = symlink_status(p, ec);
-  if (!status_known(s))
-    return -1;
-
-  ec.clear();
-  if (s.type() == file_type::not_found)
-    return 0;
-
-  uintmax_t count = 0;
-  if (s.type() == file_type::directory)
-    {
-      directory_iterator d(p, ec), end;
-      while (!ec && d != end)
-	{
-	  const auto removed = fs::remove_all(d->path(), ec);
-	  if (removed == numeric_limits<uintmax_t>::max())
-	    return -1;
-	  count += removed;
-	  d.increment(ec);
-	  if (ec)
-	    return -1;
-	}
-    }
-
-  if (fs::remove(p, ec))
-    ++count;
-  return ec ? -1 : count;
+  // Use the C++17 implementation.
+  return std::filesystem::remove_all(p.native(), ec);
 }
 
 void
@@ -1153,16 +1138,12 @@ fs::resize_file(const path& p, uintmax_t size)
 void
 fs::resize_file(const path& p, uintmax_t size, error_code& ec) noexcept
 {
-#ifdef _GLIBCXX_HAVE_UNISTD_H
-  if (size > static_cast<uintmax_t>(std::numeric_limits<off_t>::max()))
+  if (size > static_cast<uintmax_t>(std::numeric_limits<posix::off_t>::max()))
     ec.assign(EINVAL, std::generic_category());
   else if (posix::truncate(p.c_str(), size))
     ec.assign(errno, std::generic_category());
   else
     ec.clear();
-#else
-  ec = std::make_error_code(std::errc::not_supported);
-#endif
 }
 
 
@@ -1195,13 +1176,43 @@ fs::space(const path& p, error_code& ec) noexcept
   return info;
 }
 
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+static bool has_trailing_slash(const fs::path& p)
+{
+  wchar_t c = p.native().back();
+  return c == '/' || c == L'\\';
+}
+#endif
+
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
 fs::file_status
 fs::status(const fs::path& p, error_code& ec) noexcept
 {
   file_status status;
+
+  auto str = p.c_str();
+
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  // stat() fails if there's a trailing slash (PR 88881)
+  path p2;
+  if (p.has_relative_path() && has_trailing_slash(p))
+    {
+      __try
+	{
+	  p2 = p.parent_path();
+	  str = p2.c_str();
+	}
+      __catch(const bad_alloc&)
+	{
+	  ec = std::make_error_code(std::errc::not_enough_memory);
+	  return status;
+	}
+      str = p2.c_str();
+    }
+#endif
+
   stat_type st;
-  if (posix::stat(p.c_str(), &st))
+  if (posix::stat(str, &st))
     {
       int err = errno;
       ec.assign(err, std::generic_category());
@@ -1224,8 +1235,30 @@ fs::file_status
 fs::symlink_status(const fs::path& p, std::error_code& ec) noexcept
 {
   file_status status;
+
+  auto str = p.c_str();
+
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  // stat() fails if there's a trailing slash (PR 88881)
+  path p2;
+  if (p.has_relative_path() && has_trailing_slash(p))
+    {
+      __try
+	{
+	  p2 = p.parent_path();
+	  str = p2.c_str();
+	}
+      __catch(const bad_alloc&)
+	{
+	  ec = std::make_error_code(std::errc::not_enough_memory);
+	  return status;
+	}
+      str = p2.c_str();
+    }
+#endif
+
   stat_type st;
-  if (posix::lstat(p.c_str(), &st))
+  if (posix::lstat(str, &st))
     {
       int err = errno;
       ec.assign(err, std::generic_category());
@@ -1280,7 +1313,7 @@ fs::system_complete(const path& p, error_code& ec)
       || p.root_name() == base.root_name())
     return absolute(p, base);
   // else TODO
-  ec = std::make_error_code(std::errc::not_supported);
+  ec = std::__unsupported();
   return {};
 #else
   if (ec.value())
@@ -1289,7 +1322,8 @@ fs::system_complete(const path& p, error_code& ec)
 #endif
 }
 
-fs::path fs::temp_directory_path()
+fs::path
+fs::temp_directory_path()
 {
   error_code ec;
   path tmp = temp_directory_path(ec);
@@ -1298,31 +1332,12 @@ fs::path fs::temp_directory_path()
   return tmp;
 }
 
-fs::path fs::temp_directory_path(error_code& ec)
+fs::path
+fs::temp_directory_path(error_code& ec)
 {
-  path p;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  unsigned len = 1024;
-  std::wstring buf;
-  do
-    {
-      buf.resize(len);
-      len = GetTempPathW(buf.size(), buf.data());
-    } while (len > buf.size());
-
-  if (len == 0)
-    {
-      ec.assign((int)GetLastError(), std::system_category());
-      return p;
-    }
-  buf.resize(len);
-  p = std::move(buf);
-#else
-  const char* tmpdir = nullptr;
-  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
-  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
-    tmpdir = ::getenv(*e);
-  p = tmpdir ? tmpdir : "/tmp";
+  path p = fs::get_temp_directory_from_env(ec);
+  if (ec)
+    return p;
   auto st = status(p, ec);
   if (ec)
     p.clear();
@@ -1331,7 +1346,5 @@ fs::path fs::temp_directory_path(error_code& ec)
       p.clear();
       ec = std::make_error_code(std::errc::not_a_directory);
     }
-#endif
   return p;
 }
-
diff --git a/libstdc++-v3/src/filesystem/path.cc b/libstdc++-v3/src/filesystem/path.cc
index a935573740f..8e8806a953f 100644
--- a/libstdc++-v3/src/filesystem/path.cc
+++ b/libstdc++-v3/src/filesystem/path.cc
@@ -337,15 +337,18 @@ path::_M_split_cmpts()
   _M_type = _Type::_Multi;
   _M_cmpts.clear();
 
-  if (_M_pathname.empty())
+  // Use const-reference to access _M_pathname, to avoid "leaking" COW string.
+  const auto& pathname = _M_pathname;
+
+  if (pathname.empty())
     return;
 
   {
     // Approximate count of components, to reserve space in _M_cmpts vector:
     int count = 1;
-    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_sep_last = _S_is_dir_sep(pathname[0]);
     bool saw_non_sep = !saw_sep_last;
-    for (value_type c : _M_pathname)
+    for (value_type c : pathname)
       {
        if (_S_is_dir_sep(c))
          saw_sep_last = true;
@@ -363,13 +366,13 @@ path::_M_split_cmpts()
   }
 
   size_t pos = 0;
-  const size_t len = _M_pathname.size();
+  const size_t len = pathname.size();
 
   // look for root name or root directory
-  if (_S_is_dir_sep(_M_pathname[0]))
+  if (_S_is_dir_sep(pathname[0]))
     {
       // look for root name, such as "//" or "//foo"
-      if (len > 1 && _M_pathname[1] == _M_pathname[0])
+      if (len > 1 && pathname[1] == pathname[0])
 	{
 	  if (len == 2)
 	    {
@@ -378,11 +381,11 @@ path::_M_split_cmpts()
 	      return;
 	    }
 
-	  if (!_S_is_dir_sep(_M_pathname[2]))
+	  if (!_S_is_dir_sep(pathname[2]))
 	    {
 	      // got root name, find its end
 	      pos = 3;
-	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
+	      while (pos < len && !_S_is_dir_sep(pathname[pos]))
 		++pos;
 	      if (pos == len)
 		{
@@ -409,7 +412,7 @@ path::_M_split_cmpts()
       ++pos;
     }
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  else if (len > 1 && _M_pathname[1] == L':')
+  else if (len > 1 && pathname[1] == L':')
     {
       // got disk designator
       if (len == 2)
@@ -418,7 +421,7 @@ path::_M_split_cmpts()
 	  return;
 	}
       _M_add_root_name(2);
-      if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
+      if (len > 2 && _S_is_dir_sep(pathname[2]))
 	_M_add_root_dir(2);
       pos = 2;
     }
@@ -426,9 +429,9 @@ path::_M_split_cmpts()
   else
     {
       size_t n = 1;
-      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+      for (; n < pathname.size() && !_S_is_dir_sep(pathname[n]); ++n)
 	{ }
-      if (n == _M_pathname.size())
+      if (n == pathname.size())
 	{
 	  _M_type = _Type::_Filename;
 	  return;
@@ -438,7 +441,7 @@ path::_M_split_cmpts()
   size_t back = pos;
   while (pos < len)
     {
-      if (_S_is_dir_sep(_M_pathname[pos]))
+      if (_S_is_dir_sep(pathname[pos]))
 	{
 	  if (back != pos)
 	    _M_add_filename(back, pos - back);
@@ -450,7 +453,7 @@ path::_M_split_cmpts()
 
   if (back != pos)
     _M_add_filename(back, pos - back);
-  else if (_S_is_dir_sep(_M_pathname.back()))
+  else if (_S_is_dir_sep(pathname.back()))
     {
       // [path.itr]/8
       // "Dot, if one or more trailing non-root slash characters are present."
diff --git a/libstdc++-v3/testsuite/17_intro/names.cc b/libstdc++-v3/testsuite/17_intro/names.cc
index 226b2d9c24a..554e32162ae 100644
--- a/libstdc++-v3/testsuite/17_intro/names.cc
+++ b/libstdc++-v3/testsuite/17_intro/names.cc
@@ -106,6 +106,8 @@
 #define z (
 
 #define tmp (
+#define sz (
+#define token (
 
 #if __cplusplus < 201103L
 #define uses_allocator  (
@@ -195,6 +197,8 @@
 #undef y
 // <sys/var.h> defines vario::v
 #undef v
+// <sys/timer.h> defines trb::func and cputime_tmr::func
+#undef func
 #endif
 
 #ifdef __APPLE__
diff --git a/libstdc++-v3/testsuite/19_diagnostics/system_error/cons-1.cc b/libstdc++-v3/testsuite/19_diagnostics/system_error/cons-1.cc
index effb6709f8b..168a6fca2a9 100644
--- a/libstdc++-v3/testsuite/19_diagnostics/system_error/cons-1.cc
+++ b/libstdc++-v3/testsuite/19_diagnostics/system_error/cons-1.cc
@@ -26,19 +26,19 @@ int main()
 {
   const std::string s("too late: boulangerie out of pain au raisin");
   const std::error_code
-    e(std::make_error_code(std::errc::operation_not_supported));
+    e(std::make_error_code(std::errc::invalid_argument));
 
   // 1
   {
     std::system_error err1(e, s);
-    VERIFY( err1.code() == e ); 
+    VERIFY( err1.code() == e );
     VERIFY( std::string(err1.what()).find(s) != std::string::npos );
   }
 
   // 2
   {
     std::system_error err2(95, std::system_category(), s);
-    VERIFY( err2.code() == std::error_code(95, std::system_category()) ); 
+    VERIFY( err2.code() == std::error_code(95, std::system_category()) );
     VERIFY( std::string((err2.what(), s)).find(s) != std::string::npos );
   }
 
diff --git a/libstdc++-v3/testsuite/20_util/allocator/void.cc b/libstdc++-v3/testsuite/20_util/allocator/void.cc
index e3d024d525b..3720774abaf 100644
--- a/libstdc++-v3/testsuite/20_util/allocator/void.cc
+++ b/libstdc++-v3/testsuite/20_util/allocator/void.cc
@@ -87,8 +87,23 @@ static_assert( std::is_same<std::allocator<void>::const_pointer, const void*>(),
     "const_pointer is const void*" );
 #endif // C++20
 
+void
+test02()
+{
+  std::allocator<void> av;
+  int* p = std::allocator<int>().allocate(1);
+  const int* c = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, c, 0);
+  volatile int* v = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, v, 0);
+  const volatile int* cv = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, cv, 0);
+  std::allocator<int>().deallocate(p, 1);
+}
+
 int
 main()
 {
   test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/20_util/any/cons/104242.cc b/libstdc++-v3/testsuite/20_util/any/cons/104242.cc
new file mode 100644
index 00000000000..8d5868b7ff9
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/any/cons/104242.cc
@@ -0,0 +1,12 @@
+// { dg-do compile { target c++17 } }
+
+// PR libstdc++/104242 - Class with constructor from std::any is not copyable
+
+#include <any>
+#include <type_traits>
+
+struct A {
+    A(const A&) = default;
+    explicit A(std::any value);
+};
+static_assert(std::is_copy_constructible_v<A>);
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/4.cc b/libstdc++-v3/testsuite/20_util/from_chars/4.cc
index 7cee4dcbc23..4064f1d4177 100644
--- a/libstdc++-v3/testsuite/20_util/from_chars/4.cc
+++ b/libstdc++-v3/testsuite/20_util/from_chars/4.cc
@@ -300,9 +300,11 @@ test_max_mantissa()
 
   if (Float_limits::is_iec559 && Float_limits::digits < UInt_limits::digits)
   {
+#ifdef _GLIBCXX_USE_C99_MATH_TR1
     std::printf("Testing %d-bit float, using %zu-bit integer\n",
 	Float_limits::digits + (int)std::log2(Float_limits::max_exponent) + 1,
 	sizeof(UIntT) * __CHAR_BIT__);
+#endif
 
     std::from_chars_result res;
     FloatT flt;
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
new file mode 100644
index 00000000000..ef24b4c5c7b
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
@@ -0,0 +1,16 @@
+// { dg-do run { target c++17 } }
+
+#include <charconv>
+#include <string>
+
+int main()
+{
+#if __cpp_lib_to_chars >= 201611L // FP from_char not available otherwise.
+  // PR libstdc++/105324
+  // std::from_chars() assertion at floating_from_chars.cc:78
+  std::string s(512, '1');
+  s[1] = '.';
+  long double d;
+  std::from_chars(s.data(), s.data() + s.size(), d);
+#endif
+}
diff --git a/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc b/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc
index 62633262948..028dce3df51 100644
--- a/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-options "-std=gnu++2a" }
+// { dg-options "-std=gnu++2a -O2" }
 // { dg-do compile { target c++2a } }
 
 #include <utility>
diff --git a/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc b/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc
index 48cb64d5676..f0422bc1948 100644
--- a/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-options "-std=gnu++2a" }
+// { dg-options "-std=gnu++2a -O2" }
 // { dg-do compile { target c++2a } }
 
 #include <utility>
diff --git a/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc b/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc
index a16b36a83c9..3bd5d6480fe 100644
--- a/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc
+++ b/libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-options "-std=gnu++2a" }
+// { dg-options "-std=gnu++2a -O2" }
 // { dg-do compile { target c++2a } }
 
 #include <utility>
diff --git a/libstdc++-v3/testsuite/20_util/integer_sequence/pr111357.cc b/libstdc++-v3/testsuite/20_util/integer_sequence/pr111357.cc
new file mode 100644
index 00000000000..1ad06b732af
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/integer_sequence/pr111357.cc
@@ -0,0 +1,34 @@
+// { dg-do compile { target c++14 } }
+
+// PR c++/111357 - __integer_pack fails to work with values of dependent type
+// convertible to integers in noexcept context
+
+#include <utility>
+
+using std::integer_sequence;
+using std::make_integer_sequence;
+
+template<int... V>
+void g(integer_sequence<int,V...>)
+{}
+
+template<typename ...T>
+struct c1
+{
+  static constexpr int value = 1;
+  constexpr operator int() { return value; }
+};
+
+template<typename T>
+struct R
+{
+  using S = make_integer_sequence<int,c1<T>{}>;
+
+  R() noexcept(noexcept(g(S()))) // { dg-bogus "argument to .__integer_pack." }
+  {}
+};
+
+int main()
+{
+  R<int>();
+}
diff --git a/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value.cc b/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value.cc
index 22d7c8c1df6..18dd6a5e5dd 100644
--- a/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value.cc
+++ b/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value.cc
@@ -21,9 +21,7 @@
 #include <type_traits>
 #include <testsuite_tr1.h>
 
-#ifndef IS_NT_CONVERTIBLE_DEFINED
 using std::is_nothrow_convertible;
-#endif
 
 void test01()
 {
diff --git a/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value_ext.cc b/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/91456.cc
similarity index 59%
rename from libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value_ext.cc
rename to libstdc++-v3/testsuite/20_util/is_nothrow_invocable/91456.cc
index 9c4d19ef5ab..574233986f8 100644
--- a/libstdc++-v3/testsuite/20_util/is_nothrow_convertible/value_ext.cc
+++ b/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/91456.cc
@@ -15,14 +15,21 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do compile { target c++11 } }
+// { dg-do compile { target c++17 } }
+
+// PR 91456
+// std::function and std::is_invocable_r do not understand guaranteed elision
 
 #include <type_traits>
 
-// Test the non-standard __is_nothrow_convertible trait
+#include <functional>
 
-template<typename From, typename To>
-  using is_nothrow_convertible = std::__is_nothrow_convertible<From, To>;
+struct Immovable {
+  Immovable() = default;
+  Immovable(const Immovable&) = delete;
+  Immovable& operator=(const Immovable&) = delete;
+};
 
-#define IS_NT_CONVERTIBLE_DEFINED
-#include "value.cc"
+static_assert(std::is_nothrow_invocable_r_v<Immovable, Immovable(*)() noexcept>);
+static_assert(std::is_nothrow_invocable_r_v<const Immovable, Immovable(*)() noexcept>);
+static_assert(std::is_nothrow_invocable_r_v<Immovable, const Immovable(*)() noexcept>);
diff --git a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
index 40180223bae..a98815d932b 100644
--- a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
@@ -238,8 +238,11 @@ test07()
   std::pmr::monotonic_buffer_resource mbr(&cr);
   try
   {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
     // Try to allocate a ridiculous size:
     void* p = mbr.allocate(std::size_t(-2), 1);
+#pragma GCC diagnostic pop
     // Should not reach here!
     VERIFY( !"attempt to allocate SIZE_MAX-1 should not have succeeded" );
     throw p;
diff --git a/libstdc++-v3/testsuite/20_util/pair/astuple/get-2.cc b/libstdc++-v3/testsuite/20_util/pair/astuple/get-2.cc
new file mode 100644
index 00000000000..573d239effa
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/pair/astuple/get-2.cc
@@ -0,0 +1,68 @@
+// { dg-do compile { target c++11 } }
+
+#include <utility>
+
+template<int N, typename T, typename Pair>
+constexpr bool
+check()
+{
+  return std::is_same<decltype(std::get<N>(std::declval<Pair>())), T>::value;
+}
+
+void
+test_value_category()
+{
+  using P = std::pair<int, long>;
+  static_assert( check<0, int&, P&>(),
+		 "get<0>(pair<T1, T2>&)" );
+  static_assert( check<1, long&, P&>(),
+		 "get<1>(pair<T1, T2>&)" );
+  static_assert( check<0, int&&, P&&>(),
+		 "get<0>(pair<T1, T2>&&)" );
+  static_assert( check<1, long&&, P&&>(),
+		 "get<1>(pair<T1, T2>&&)" );
+  static_assert( check<0, const int&, const P&>(),
+		 "get<0>(const pair<T1, T2>&)" );
+  static_assert( check<1, const long&, const P&>(),
+		 "get<1>(const pair<T1, T2>&)" );
+  static_assert( check<0, const int&&, const P&&>(),
+		 "get<0>(const pair<T1, T2>&&)" );
+  static_assert( check<1, const long&&, const P&&>(),
+		 "get<1>(const pair<T1, T2>&&)" );
+
+  using PL = std::pair<int&, long&>;
+  static_assert( check<0, int&, PL&>(),
+		 "get<0>(pair<T1&, T2&>&)" );
+  static_assert( check<1, long&, PL&>(),
+		 "get<1>(pair<T1&, T2&>&)" );
+  static_assert( check<0, int&, PL&&>(),
+		 "get<0>(pair<T1&, T2&>&&)" );
+  static_assert( check<1, long&, PL&&>(),
+		 "get<1>(pair<T1&, T2&>&&)" );
+  static_assert( check<0, int&, const PL&>(),
+		 "get<0>(const pair<T1&, T2&>&)" );
+  static_assert( check<1, long&, const PL&>(),
+		 "get<1>(const pair<T1&, T2&>&)" );
+  static_assert( check<0, int&, const PL&&>(),
+		 "get<0>(const pair<T1&, T2&>&&)" );
+  static_assert( check<1, long&, const PL&&>(),
+		 "get<1>(const pair<T1&, T2&>&&)" );
+
+  using PR = std::pair<int&&, long&&>;
+  static_assert( check<0, int&, P&>(),
+		 "get<0>(pair<T1&&, T2&&>&)" );
+  static_assert( check<1, long&, P&>(),
+		 "get<1>(pair<T1&&, T2&&>&)" );
+  static_assert( check<0, int&&, PR&&>(),
+		 "get<0>(pair<T1&&, T2&&>&&)" );
+  static_assert( check<1, long&&, PR&&>(),
+		 "get<1>(pair<T1&&, T2&&>&&)" );
+  static_assert( check<0, int&, const PR&>(),
+		 "get<0>(const pair<T1&&, T2&&>&)" );
+  static_assert( check<1, long&, const PR&>(),
+		 "get<1>(const pair<T1&&, T2&&>&)" );
+  static_assert( check<0, int&&, const PR&&>(),
+		 "get<0>(const pair<T1&&, T2&&>&&)" );
+  static_assert( check<1, long&&, const PR&&>(),
+		 "get<1>(const pair<T1&&, T2&&>&&)" );
+}
diff --git a/libstdc++-v3/testsuite/20_util/scoped_allocator/108952.cc b/libstdc++-v3/testsuite/20_util/scoped_allocator/108952.cc
new file mode 100644
index 00000000000..a6b9c67498c
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/scoped_allocator/108952.cc
@@ -0,0 +1,23 @@
+// { dg-do compile { target c++11 } }
+
+#include <scoped_allocator>
+
+struct move_only
+{
+  move_only(move_only&&);
+};
+
+using P = std::pair<move_only, move_only>;
+
+void
+test_pr108952(std::pair<move_only&&, move_only&&> rvals)
+{
+  // LWG 3527. uses_allocator_construction_args handles rvalue pairs of
+  // rvalue references incorrectly.
+  // PR libstdc++/108952 Regression in uses_allocator_construction_args
+  // for pair of rvalue references
+  std::scoped_allocator_adaptor<std::allocator<P>> a;
+  auto p = a.allocate(1);
+  a.construct(p, std::move(rvals));
+  a.deallocate(p, 1);
+}
diff --git a/libstdc++-v3/testsuite/20_util/tuple/swap.cc b/libstdc++-v3/testsuite/20_util/tuple/swap.cc
index 06d14612176..7142e95c782 100644
--- a/libstdc++-v3/testsuite/20_util/tuple/swap.cc
+++ b/libstdc++-v3/testsuite/20_util/tuple/swap.cc
@@ -38,7 +38,7 @@ struct MoveOnly
   MoveOnly(MoveOnly const&) = delete;
   MoveOnly& operator=(MoveOnly const&) = delete;
 
-  bool operator==(MoveOnly const& m)
+  bool operator==(MoveOnly const& m) const
   { return i == m.i; }
 
   void swap(MoveOnly& m)
diff --git a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
index a76afbe87a2..fe847dadd27 100644
--- a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
@@ -281,10 +281,13 @@ test07()
   std::pmr::unsynchronized_pool_resource upr(&cr);
   try
   {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
     // Try to allocate a ridiculous size (and use a large extended alignment
     // so that careful_resource::do_allocate can distinguish this allocation
     // from any required for the pool resource's internal data structures):
     void* p = upr.allocate(std::size_t(-2), 1024);
+#pragma GCC diagnostic pop
     // Should not reach here!
     VERIFY( !"attempt to allocate SIZE_MAX-1 should not have succeeded" );
     throw p;
diff --git a/libstdc++-v3/testsuite/20_util/uses_allocator/lwg3527.cc b/libstdc++-v3/testsuite/20_util/uses_allocator/lwg3527.cc
new file mode 100644
index 00000000000..ae377f4b5a3
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/uses_allocator/lwg3527.cc
@@ -0,0 +1,22 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+#include <memory>
+
+struct move_only
+{
+  move_only(move_only&&);
+};
+
+using P = std::pair<move_only, move_only>;
+
+void
+test_lwg3527(std::pair<move_only&&, move_only&&> rvals)
+{
+  // LWG 3527. uses_allocator_construction_args handles rvalue pairs of
+  // rvalue references incorrectly.
+  // PR libstdc++/108952 Regression in uses_allocator_construction_args
+  // for pair of rvalue references
+  std::allocator<move_only> a;
+  (void) std::uses_allocator_construction_args<P>(a, std::move(rvals));
+}
diff --git a/libstdc++-v3/testsuite/20_util/variant/lwg3585.cc b/libstdc++-v3/testsuite/20_util/variant/lwg3585.cc
new file mode 100644
index 00000000000..0cbfc0db7f5
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/variant/lwg3585.cc
@@ -0,0 +1,16 @@
+// { dg-do compile { target c++17 } }
+
+// LWG 3585. Variant converting assignment with immovable alternative
+
+#include <variant>
+#include <string>
+
+struct A {
+  A() = default;
+  A(A&&) = delete;
+};
+
+int main() {
+  std::variant<A, std::string> v;
+  v = "hello";
+}
diff --git a/libstdc++-v3/testsuite/20_util/weak_ptr/cons/self_move.cc b/libstdc++-v3/testsuite/20_util/weak_ptr/cons/self_move.cc
new file mode 100644
index 00000000000..c890d2ba94d
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/weak_ptr/cons/self_move.cc
@@ -0,0 +1,19 @@
+// { dg-do run { target c++11 } }
+
+#include <memory>
+#include <testsuite_hooks.h>
+
+void
+test_self_move()
+{
+  std::shared_ptr<int> sp(new int(66));
+  std::weak_ptr<int> wp(sp);
+  wp = std::move(wp); // PR libstdc++/108118
+  std::shared_ptr<int> sp2(wp);
+  VERIFY(sp2 == sp);
+}
+
+int main()
+{
+  test_self_move();
+}
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
index 5de2a5f9330..3ba39ec432d 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
@@ -35,7 +35,9 @@ void test01()
 
   std::string c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
index fe91c5ab539..5804ccb6bf8 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
@@ -44,7 +44,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
index 1caedcccfce..59d1d775134 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
@@ -42,7 +42,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
index d05afb7d466..67e25de2916 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
@@ -35,7 +35,9 @@ void test01()
 
   std::wstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
index e301984612d..c72eb9bfddb 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
@@ -44,7 +44,9 @@ void test01()
 
   twstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
index d3e4744ff34..6a2bc2714b5 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
@@ -42,7 +42,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
index 87d8c2f4068..6a3ed55f557 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
@@ -71,8 +71,8 @@ int main()
 
   string s = "PR libstdc++/87749 a string that is longer than a short string";
   const auto ptr = s.c_str();
-  oom = true;
   string ss;
+  oom = true;
   ss = std::move(s); // allocators are equal, should not allocate new storage
   VERIFY( ss.c_str() == ptr );
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
index 4d744f8a411..536ca6153d3 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
@@ -72,8 +72,8 @@ int main()
 
   string s = L"PR libstdc++/87749 a string that is longer than a short string";
   const auto ptr = s.c_str();
-  oom = true;
   string ss;
+  oom = true;
   ss = std::move(s); // allocators are equal, should not allocate new storage
   VERIFY( ss.c_str() == ptr );
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc
index fa85f1994c9..c95239c613b 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/char/range_c++20.cc
@@ -36,7 +36,7 @@ test01()
   };
 
   R r;
-  std::string_view s = r;
+  std::string_view s{r};
   VERIFY( s == r.str );
   VERIFY( s.data() == std::ranges::data(r) );
   VERIFY( s.size() == std::ranges::size(r) );
@@ -50,10 +50,15 @@ test01()
   static_assert( std::ranges::contiguous_range<R2> );
   static_assert( std::ranges::sized_range<R2> );
   R2 r2;
-  std::string_view s2 = r2; // uses conversion to string_view
+  std::string_view s2(r2); // uses conversion to string_view
   VERIFY( s2 == "Out of range" );
   VERIFY( std::string_view(const_cast<const R2&>(r2)) == s2 );
 
+  // And again using copy-initialization instead of direct-initialization.
+  std::string_view s2_implicit = r2; // uses conversion to string_view
+  VERIFY( s2_implicit == "Out of range" );
+  VERIFY( std::string_view(const_cast<const R2&>(r2)) == s2_implicit );
+
   struct R3 : R
   {
     using R::begin;
@@ -91,7 +96,7 @@ test01()
   static_assert( std::ranges::contiguous_range<R5> );
   static_assert( std::ranges::sized_range<R5> );
   R5 r5;
-  std::string_view s5 = r5; // Uses range constructor
+  std::string_view s5(r5); // Uses range constructor
   VERIFY( s5 == r5.str );
   s5 = std::string_view(std::move(r5)); // In C++20 this used conversion op.
   VERIFY( s5 == r5.str );	        // In C++23 it uses range constructor.
@@ -156,15 +161,30 @@ test04()
   };
 
   R r;
-  std::basic_string_view s = r; // Use deduction guide.
+  std::basic_string_view s(r); // Use deduction guide.
 
   static_assert( std::is_same_v<decltype(s), std::string_view> );
 }
 
+void
+test05()
+{
+  struct R
+  {
+    const char* begin() const { return nullptr; }
+    const char* end() const { return nullptr; }
+  };
+
+  // P2499R0 string_view range constructor should be explicit
+  // P2516R0 string_view is implicitly convertible from what?
+  static_assert( ! std::is_convertible_v<R, std::string_view> );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
   test04();
+  test05();
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc
index cf73ae36a60..2144ca49e77 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/cons/wchar_t/range_c++20.cc
@@ -36,7 +36,7 @@ test01()
   };
 
   R r;
-  std::wstring_view s = r;
+  std::wstring_view s{r};
   VERIFY( s == r.str );
   VERIFY( s.data() == std::ranges::data(r) );
   VERIFY( s.size() == std::ranges::size(r) );
@@ -50,10 +50,15 @@ test01()
   static_assert( std::ranges::contiguous_range<R2> );
   static_assert( std::ranges::sized_range<R2> );
   R2 r2;
-  std::wstring_view s2 = r2; // uses conversion to wstring_view
+  std::wstring_view s2(r2); // uses conversion to wstring_view
   VERIFY( s2 == L"Out of range" );
   VERIFY( std::wstring_view(const_cast<const R2&>(r2)) == s2 );
 
+  // And again using copy-initialization instead of direct-initialization.
+  std::wstring_view s2_implicit = r2; // uses conversion to wstring_view
+  VERIFY( s2_implicit == L"Out of range" );
+  VERIFY( std::wstring_view(const_cast<const R2&>(r2)) == s2_implicit );
+
   struct R3 : R
   {
     using R::begin;
@@ -91,10 +96,10 @@ test01()
   static_assert( std::ranges::contiguous_range<R5> );
   static_assert( std::ranges::sized_range<R5> );
   R5 r5;
-  std::wstring_view s5 = r5; // Uses range constructor
+  std::wstring_view s5(r5); // Uses range constructor
   VERIFY( s5 == r5.str );
   s5 = std::wstring_view(std::move(r5)); // In C++20 this used conversion op.
-  VERIFY( s5 == r5.str );	        // In C++23 it uses range constructor.
+  VERIFY( s5 == r5.str );	         // In C++23 it uses range constructor.
 
   wchar_t arr[] = L"arrangement\0with\0nulls";
   std::wstring_view sa = arr; // Does not use range constructor
@@ -156,15 +161,30 @@ test04()
   };
 
   R r;
-  std::basic_string_view s = r; // Use deduction guide.
+  std::basic_string_view s(r); // Use deduction guide.
 
   static_assert( std::is_same_v<decltype(s), std::wstring_view> );
 }
 
+void
+test05()
+{
+  struct R
+  {
+    const wchar_t* begin() const { return nullptr; }
+    const wchar_t* end() const { return nullptr; }
+  };
+
+  // P2499R0 string_view range constructor should be explicit
+  // P2516R0 string_view is implicitly convertible from what?
+  static_assert( ! std::is_convertible_v<R, std::wstring_view> );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
   test04();
+  test05();
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
index f467d114c24..7ae3ccda22f 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
@@ -22,7 +22,7 @@
 
 #ifndef __cpp_lib_constexpr_string_view
 # error "Feature test macro for constexpr copy is missing in <string_view>"
-#elif __cpp_lib_constexpr_iterator < 201811L
+#elif __cpp_lib_constexpr_string_view < 201811L
 # error "Feature test macro for constexpr copy has wrong value in <string_view>"
 #endif
 
diff --git a/libstdc++-v3/testsuite/23_containers/array/creation/111512.cc b/libstdc++-v3/testsuite/23_containers/array/creation/111512.cc
new file mode 100644
index 00000000000..f510480ae4b
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/array/creation/111512.cc
@@ -0,0 +1,25 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+// Bug libstdc++/111511 - Incorrect ADL in std::to_array in GCC 11/12/13
+// Bug c++/111512 - GCC's __builtin_memcpy can trigger ADL
+
+#include <array>
+#include <utility>
+
+struct incomplete;
+
+template<class T>
+struct holder {
+    T t; // { dg-bogus "'holder<T>::t' has incomplete type" }
+};
+
+// A complete type that cannot be used as an associated type for ADL.
+using adl_bomb = holder<incomplete>*;
+
+int main()
+{
+    adl_bomb a[1]{};
+    (void) std::to_array(a);
+    (void) std::to_array(std::move(a));
+}
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
new file mode 100644
index 00000000000..0f6f520c33b
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
@@ -0,0 +1,48 @@
+// { dg-do run { target c++11 } }
+// C++11 23.3.4.6 Operations [forwardlist.ops]
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+void
+test_stable()
+{
+  std::forward_list<double> a{1.5, 2.0, 3.5, 4.1};
+  std::forward_list<double> b{1.0, 2.5, 3.0, 4.3, 4.2, 5.0};
+
+  a.merge(b, std::less<int>{});
+
+  // result is sorted with respect to std::less<int>, so 1.0 and 1.5 are
+  // equivalent, and stability guarantee means the element from a comes first.
+  const std::forward_list<double> r { 1.5, 1.0,
+				      2.0, 2.5,
+				      3.5, 3.0,
+				      4.1, 4.3, 4.2,
+				      5.0};
+
+  VERIFY(a == r);
+}
+
+void
+test_lwg3088()
+{
+  // LWG 3088: forward_list::merge behavior unclear when passed *this
+  // PR libstdc++/103853
+  std::forward_list<int> c1{ 1, 2, 3 };
+  const std::forward_list<int> c2 = c1;
+  c1.merge(c1);
+  VERIFY( c1 == c2 );
+  c1.merge(c1, std::less<long>{});
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1));
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1), std::less<long>{});
+  VERIFY( c1 == c2 );
+}
+
+int
+main()
+{
+  test_stable();
+  test_lwg3088();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc b/libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc
index fb8c7adab27..e07069adab6 100644
--- a/libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc
+++ b/libstdc++-v3/testsuite/24_iterators/common_iterator/1.cc
@@ -27,15 +27,30 @@ test01()
   using I = std::common_iterator<int*, const int*>;
   static_assert( std::is_default_constructible_v<I> );
   static_assert( std::is_copy_constructible_v<I> );
+  static_assert( std::is_move_constructible_v<I> );
   static_assert( std::is_copy_assignable_v<I> );
+  static_assert( std::is_move_assignable_v<I> );
   static_assert( std::is_constructible_v<I, int*> );
   static_assert( std::is_constructible_v<I, const int*> );
 
-  struct sentinel { operator int*() const { return nullptr; } };
+  static_assert( std::is_nothrow_copy_constructible_v<I> ); // GCC extension
+  static_assert( std::is_nothrow_move_constructible_v<I> ); // GCC extension
+  static_assert( std::is_nothrow_copy_assignable_v<I> ); // GCC extension
+  static_assert( std::is_nothrow_move_assignable_v<I> ); // GCC extension
+
+  struct sentinel { operator int*() const noexcept { return nullptr; } };
   using K = std::common_iterator<int*, sentinel>;
   static_assert( std::is_constructible_v<I, const K&> );
   static_assert( std::is_assignable_v<I, const K&> );
 
+  static_assert( std::is_nothrow_assignable_v<I&, const K&> ); // GCC extension
+
+  struct sentinel_throwing { operator int*() const { return nullptr; } };
+  using K_throwing = std::common_iterator<int*, sentinel_throwing>;
+  // Conversion is noexcept(false)
+  static_assert( ! std::is_nothrow_assignable_v<I&, const K_throwing&> );
+
+
   struct sentinel2
   {
     const int* p;
@@ -46,6 +61,12 @@ test01()
   using J = std::common_iterator<const int*, sentinel2>;
   static_assert( std::is_constructible_v<J, const I&> );
   static_assert( std::is_convertible_v<const I&, J> );
+
+  static_assert( std::is_constructible_v<J, I> );
+  static_assert( std::is_convertible_v<I, J> );
+
+  // Constructor is noexcept(false)
+  static_assert( ! std::is_nothrow_constructible_v<J, I> );
 }
 
 void
@@ -88,7 +109,7 @@ test02()
     VERIFY( i == (&i - out) );
 }
 
-void
+constexpr bool
 test03()
 {
   int arr[2] = { 1, 2 };
@@ -117,6 +138,9 @@ test03()
   VERIFY( (j - end) == -2 );
   VERIFY( (j - i) == 0 );
 
+  if (std::is_constant_evaluated())
+    return true;
+
   try
   {
     struct S { operator const int*() const { throw 1; } };
@@ -126,8 +150,12 @@ test03()
   catch (int)
   {
   }
+
+  return true;
 }
 
+static_assert( test03() );
+
 void
 test04()
 {
@@ -150,6 +178,22 @@ test04()
   VERIFY( x.i == 2 );
 }
 
+constexpr bool
+test_pr103992()
+{
+  using C1 = std::common_iterator<std::reverse_iterator<int*>,
+				  std::unreachable_sentinel_t>;
+  using C2 = std::common_iterator<std::reverse_iterator<const int*>,
+				  std::unreachable_sentinel_t>;
+  C1 c1;
+  C2 c2 = c1;
+  C1 c3 = c1;
+
+  return true;
+}
+
+static_assert( test_pr103992() );
+
 int
 main()
 {
diff --git a/libstdc++-v3/testsuite/24_iterators/common_iterator/100823.cc b/libstdc++-v3/testsuite/24_iterators/common_iterator/100823.cc
new file mode 100644
index 00000000000..4f2b23de8cc
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/common_iterator/100823.cc
@@ -0,0 +1,43 @@
+// { dg-options "-std=gnu++20 -D_GLIBCXX_ASSERTIONS" }
+// { dg-do run { target c++20 } }
+#include <iterator>
+#include <testsuite_iterators.h>
+#include <testsuite_hooks.h>
+
+void
+test_valueless_assignment()
+{
+  int x[1] { };
+  __gnu_test::test_forward_range<int> r(x);
+  using Iter = decltype(r.begin());
+  using Sent = decltype(r.end());
+
+  std::common_iterator<Iter, Sent> i;
+  const std::common_iterator<Iter, Sent> j(r.begin());
+  try
+  {
+    struct Bomb
+    {
+      bool operator==(Iter) const { return true; }
+      operator Sent() const { throw 1; }
+    };
+    std::common_iterator<Iter, Bomb> b{Bomb{}};
+    i = b; // Throws, leaving i valueless-by-exception.
+    VERIFY(false);
+  }
+  catch (int)
+  {
+    std::common_iterator<Iter, Sent> k(i);
+
+    // PR libstdc++/100823
+    k = i; // Valid even though both operands are valueless.
+
+    i = j; // No longer valueless.
+  }
+  VERIFY( i == j );
+}
+
+int main()
+{
+  test_valueless_assignment();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/common_iterator/2.cc b/libstdc++-v3/testsuite/24_iterators/common_iterator/2.cc
index 80f4f2b0151..f8580b57890 100644
--- a/libstdc++-v3/testsuite/24_iterators/common_iterator/2.cc
+++ b/libstdc++-v3/testsuite/24_iterators/common_iterator/2.cc
@@ -32,18 +32,18 @@ struct iterator
   using difference_type = std::ptrdiff_t;
   using reference = value;
 
-  value operator*() const { return value{counter}; }
+  constexpr value operator*() const { return value{counter}; }
 
-  iterator& operator++() { ++counter; return *this; }
+  constexpr iterator& operator++() { ++counter; return *this; }
 
-  iterator operator++(int) { auto i = *this; ++counter; return i; }
+  constexpr iterator operator++(int) { auto i = *this; ++counter; return i; }
 
-  bool operator==(sentinel s) const { return counter == s.limit; }
+  constexpr bool operator==(sentinel s) const { return counter == s.limit; }
 
   int counter = 0;
 };
 
-void
+constexpr bool
 test01()
 {
   iterator i;
@@ -54,10 +54,12 @@ test01()
   VERIFY( begin->n == 1 );
   ++begin;
   VERIFY( begin == end );
+
+  return true;
 }
 
 int
 main()
 {
-  test01();
+  constexpr bool b1 = test01();
 }
diff --git a/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3643.cc b/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3643.cc
new file mode 100644
index 00000000000..e6f12b46c12
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/counted_iterator/lwg3643.cc
@@ -0,0 +1,27 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+#include <iterator>
+
+struct InputIterator
+{
+  using difference_type = int;
+  using value_type = int;
+
+  constexpr int operator*() const noexcept { return 0; }
+  InputIterator& operator++() { return *this; }
+  constexpr void operator++(int) { }
+};
+
+static_assert( std::input_iterator<InputIterator> );
+static_assert( !std::forward_iterator<InputIterator> );
+
+constexpr bool
+test_lwg3643()
+{
+  std::counted_iterator<InputIterator> iter({}, 1);
+  iter++;
+  return iter == std::default_sentinel;
+}
+
+static_assert( test_lwg3643() );
diff --git a/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc b/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
index e4219b8c78b..3ce0df5d111 100644
--- a/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
+++ b/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do compile { target c++11 } }
+// { dg-do run { target c++11 } }
 
 #include <iterator>
 
@@ -27,18 +27,18 @@ struct Iter
   using reference = int&;
   using difference_type = std::ptrdiff_t;
 
-  Iter();
+  Iter() { }
 
-  // Construction from int* is not valid:
-  Iter(int*) = delete;
+  // Construction from int* should not be used:
+  Iter(int*) { throw 1; }
 
-  // Assignment from int* is valid:
-  Iter& operator=(int*);
+  // Assignment from int* is OK:
+  Iter& operator=(int*) { return *this; }
 
-  Iter& operator++();
-  Iter operator++(int);
-  int& operator*() const;
-  int* operator->() const;
+  Iter& operator++() { return *this; }
+  Iter operator++(int) { return *this; }
+  int& operator*() const { static int i; return i; }
+  int* operator->() const { return &**this; }
 
   template<int N> friend bool operator==(Iter, Iter);
 };
@@ -49,3 +49,8 @@ void test01()
   int i = 0;
   m = std::make_move_iterator(&i); // Should use assignment not construction
 }
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/move_iterator/p2520r0.cc b/libstdc++-v3/testsuite/24_iterators/move_iterator/p2520r0.cc
new file mode 100644
index 00000000000..883d6cc09e0
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/move_iterator/p2520r0.cc
@@ -0,0 +1,37 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+// Verify P2520R0 changes to move_iterator's iterator_concept, which we treat
+// as a DR against C++20.
+
+#include <iterator>
+#if __cpp_lib_move_iterator_concept != 202207L
+# error "Feature-test macro __cpp_lib_move_iterator_concept has wrong value in <iterator>"
+#endif
+
+#undef __cpp_lib_move_iterator_concept
+#include <version>
+#if __cpp_lib_move_iterator_concept != 202207L
+# error "Feature-test macro __cpp_lib_move_iterator_concept has wrong value in <version>"
+#endif
+
+#include <testsuite_iterators.h>
+
+using __gnu_test::test_input_range;
+using __gnu_test::test_forward_range;
+using __gnu_test::test_bidirectional_range;
+using __gnu_test::test_random_access_range;
+
+using ty1 = std::move_iterator<decltype(std::declval<test_input_range<int>&>().begin())>;
+static_assert(std::same_as<ty1::iterator_concept, std::input_iterator_tag>);
+
+using ty2 = std::move_iterator<decltype(std::declval<test_forward_range<int>&>().begin())>;
+static_assert(std::same_as<ty2::iterator_concept, std::forward_iterator_tag>);
+
+using ty3 = std::move_iterator<decltype(std::declval<test_bidirectional_range<int>&>().begin())>;
+static_assert(std::same_as<ty3::iterator_concept, std::bidirectional_iterator_tag>);
+
+using ty4 = std::move_iterator<decltype(std::declval<test_random_access_range<int>&>().begin())>;
+static_assert(std::same_as<ty4::iterator_concept, std::random_access_iterator_tag>);
+
+static_assert(std::random_access_iterator<std::move_iterator<int*>>);
diff --git a/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc b/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc
new file mode 100644
index 00000000000..0fadcd6e99a
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc
@@ -0,0 +1,37 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+// Public domain testcase from Casey Carter, send to LWG list on 2021-07-24.
+//
+// Here's a compile-only test case for which n is INT_MIN, which will overflow
+// if simply negated to get |n|: https://godbolt.org/z/M7Wz1nW58.
+
+#include <cassert>
+#include <iterator>
+#include <limits>
+
+struct I {
+    using difference_type = int;
+    using value_type = int;
+
+    int x;
+
+    constexpr int operator*() const { return x; }
+    constexpr I& operator++() { ++x; return *this; }
+    constexpr I operator++(int) { ++x; return {x - 1}; }
+    constexpr bool operator==(const I&) const = default;
+
+    constexpr int operator-(const I& that) const { return x - that.x; }
+
+    constexpr I& operator--() { --x; return *this; }
+    constexpr I operator--(int) { --x; return {x - 1}; }
+};
+static_assert(std::bidirectional_iterator<I>);
+static_assert(std::sized_sentinel_for<I, I>);
+
+constexpr bool test() {
+    using L = std::numeric_limits<int>;
+    I i{-2};
+    return std::ranges::advance(i, L::min(), I{-4}) == L::min() + 2;
+}
+static_assert(test());
diff --git a/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc b/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc
index a05948a49c6..91f742dca76 100644
--- a/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/copy/constrained.cc
@@ -226,6 +226,29 @@ test06()
   VERIFY( ranges::equal(v, (int[]){1,2,3,0}) );
 }
 
+void
+test07()
+{
+  struct move_only_output_iterator
+  {
+    using value_type = int;
+    using difference_type = short;
+    using iterator_category = std::output_iterator_tag;
+
+    move_only_output_iterator() = default;
+    move_only_output_iterator(move_only_output_iterator&&) = default;
+    move_only_output_iterator& operator=(move_only_output_iterator&&) = default;
+
+    move_only_output_iterator& operator*() { return *this; }
+    move_only_output_iterator& operator++() { return *this; }
+    move_only_output_iterator operator++(int) { return std::move(*this); }
+
+    void operator=(int) { }
+  };
+
+  ranges::copy(std::vector<int>{1,2,3}, move_only_output_iterator{});
+}
+
 int
 main()
 {
@@ -235,4 +258,5 @@ main()
   test04();
   static_assert(test05());
   test06();
+  test07();
 }
diff --git a/libstdc++-v3/testsuite/26_numerics/gcd/105844.cc b/libstdc++-v3/testsuite/26_numerics/gcd/105844.cc
new file mode 100644
index 00000000000..3be18330a0f
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/gcd/105844.cc
@@ -0,0 +1,23 @@
+// { dg-do compile { target c++17 } }
+#include <numeric>
+#include <climits>
+
+// PR libstdc++/105844
+
+// |INT_MIN| can be represented in common_type_t<int, unsigned> i.e. unsigned.
+static_assert( std::gcd(INT_MIN, 2u) == 2 );
+static_assert( std::gcd(2u, INT_MIN) == 2 );
+
+// |LLONG_MIN| can be represented in unsigned long long.
+static_assert( std::gcd(LLONG_MIN, 2ull) == 2 );
+static_assert( std::gcd(2ull, LLONG_MIN) == 2 );
+
+// But |INT_MIN| cannot be represented in common_type<int, int> i.e. int.
+constexpr int a = std::gcd(INT_MIN, 1); // { dg-error "overflow" }
+constexpr int b = std::gcd(1, INT_MIN); // { dg-error "overflow" }
+
+// And |LLONG_MIN| cannot be represented in long.
+constexpr long long c = std::gcd(LLONG_MIN, 1); // { dg-error "overflow" }
+constexpr long long d = std::gcd(1, LLONG_MIN); // { dg-error "overflow" }
+
+// { dg-prune-output "in 'constexpr' expansion" }
diff --git a/libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc b/libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc
index e68a051aaa4..b0277b3f4d1 100644
--- a/libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc
+++ b/libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc
@@ -45,9 +45,11 @@ test01()
   std::gcd<const int&, const int&>(0.1, 0.1);   // { dg-error "from here" }
 }
 
-// { dg-error "must be integers" "" { target *-*-* } 169 }
-// { dg-error "must be integers" "" { target *-*-* } 170 }
-// { dg-error "must not be bool" "" { target *-*-* } 171 }
-// { dg-error "must not be bool" "" { target *-*-* } 172 }
+// { dg-error "must be integers" "" { target *-*-* } 0 }
+// { dg-error "must not be bool" "" { target *-*-* } 0 }
+// These prunes could be removed if a fix for PR c++/96286 stops them.
 // { dg-prune-output "deleted function" }
 // { dg-prune-output "incomplete type .*make_unsigned" }
+// { dg-prune-output "does not have integral type" }
+// { dg-prune-output "non-integral type" }
+// { dg-prune-output "invalid specialization" }
diff --git a/libstdc++-v3/testsuite/26_numerics/lcm/105844.cc b/libstdc++-v3/testsuite/26_numerics/lcm/105844.cc
new file mode 100644
index 00000000000..0b5ef5ae5e9
--- /dev/null
+++ b/libstdc++-v3/testsuite/26_numerics/lcm/105844.cc
@@ -0,0 +1,24 @@
+// { dg-do compile { target c++17 } }
+#include <numeric>
+#include <climits>
+
+// PR libstdc++/105844
+
+// |INT_MIN| can be represented in common_type_t<int, unsigned> i.e. unsigned.
+static_assert( std::lcm(INT_MIN, 1u) == INT_MAX+1u );
+static_assert( std::lcm(1u, INT_MIN) == INT_MAX+1u );
+
+// But |INT_MIN| cannot be represented in common_type<int, int> i.e. int.
+constexpr int a = std::lcm(INT_MIN, 1); // { dg-error "overflow" }
+constexpr int b = std::lcm(1, INT_MIN); // { dg-error "overflow" }
+
+// And the LCM of 50000 and 49999 cannot be represented in int.
+constexpr int c = std::lcm(50000, 49999); // { dg-error "overflow" }
+constexpr int d = std::lcm(49999, 50000); // { dg-error "overflow" }
+
+// Similarly for unsigned, but the diagnostic is a failed assertion instead.
+constexpr int e = std::lcm(500000u, 499999); // { dg-error "in 'constexpr'" }
+constexpr int f = std::lcm(499999u, 500000); // { dg-error "in 'constexpr'" }
+// { dg-error "unreachable" "" { target *-*-* } 0 }
+
+// { dg-prune-output "in 'constexpr' expansion" }
diff --git a/libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc b/libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc
index dbe23ab7f26..8cabfe2ea2f 100644
--- a/libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc
+++ b/libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc
@@ -45,9 +45,11 @@ test01()
   std::lcm<const int&, const int&>(0.1, 0.1);   // { dg-error "from here" }
 }
 
-// { dg-error "must be integers" "" { target *-*-* } 183 }
-// { dg-error "must be integers" "" { target *-*-* } 184 }
-// { dg-error "must not be bool" "" { target *-*-* } 185 }
-// { dg-error "must not be bool" "" { target *-*-* } 186 }
+// { dg-error "must be integers" "" { target *-*-* } 0 }
+// { dg-error "must not be bool" "" { target *-*-* } 0 }
+// These prunes could be removed if a fix for PR c++/96286 stops them.
 // { dg-prune-output "deleted function" }
 // { dg-prune-output "incomplete type .*make_unsigned" }
+// { dg-prune-output "does not have integral type" }
+// { dg-prune-output "non-integral type" }
+// { dg-prune-output "invalid specialization" }
diff --git a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
index f947f8ae848..e8705ca7879 100644
--- a/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
+++ b/libstdc++-v3/testsuite/26_numerics/random/normal_distribution/operators/serialize.cc
@@ -25,6 +25,7 @@
 
 #include <random>
 #include <sstream>
+#include <testsuite_hooks.h>
 
 void
 test01()
@@ -37,10 +38,43 @@ test01()
   str << u;
 
   str >> v;
+  VERIFY( u == v );
+}
+
+void
+test_pr105502()
+{
+  // PR libstdc++/105502 std::normal_distribution deserialization issue
+  std::stringstream str;
+  std::normal_distribution<> d{1, 2}, d2;
+  std::minstd_rand0 g;
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = true
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
+
+  (void) d(g); // sets d._M_saved_available = false
+  str.str("");
+  str.clear();
+  str << d;
+  VERIFY( str );
+  str >> d2;
+  VERIFY( str );
+  VERIFY( d == d2 );
 }
 
 int main()
 {
   test01();
-  return 0;
+  test_pr105502();
 }
diff --git a/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc b/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc
index 391a288b349..c884688b9f6 100644
--- a/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc
+++ b/libstdc++-v3/testsuite/26_numerics/valarray/87641.cc
@@ -39,7 +39,7 @@ struct X
   X() : val(1) { }
 
   X& operator+=(const X& x) { val += x.val; return *this; }
-  bool operator==(const X& x) { return val == x.val; }
+  bool operator==(const X& x) const { return val == x.val; }
 
   int val;
 };
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc
new file mode 100644
index 00000000000..6d89a0e5fef
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc
@@ -0,0 +1,40 @@
+// { dg-do run }
+
+#include <sstream>
+#include <testsuite_hooks.h>
+
+void
+test_pr106248()
+{
+  char buf[5] = {'x', 'x', 'x', 'x', 'x'};
+  std::string s("  four");
+  std::istringstream in(s);
+  in >> buf;
+#if __cplusplus >= 202002L
+  // Extraction stops because buffer is full.
+  VERIFY( in.good() );
+#else
+  // PR libstdc++/106248
+  // Extraction stops because all input has been consumed and eofbit is set.
+  VERIFY( in.eof() );
+#endif
+  // Extracted string must be null-terminated.
+  VERIFY( buf[4] == '\0' );
+  VERIFY( std::string(buf) == "four" );
+
+  in.clear();
+  in.str(s);
+  for (int i = 0; i < 5; ++i)
+    s[i] = 'x';
+
+  in.width(5);
+  in >> buf;
+  // Extraction stops due to field width, eofbit not set.
+  VERIFY( in.good() );
+  VERIFY( std::string(buf) == "four" );
+}
+
+int main()
+{
+  test_pr106248();
+}
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc
new file mode 100644
index 00000000000..7c226600b9e
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc
@@ -0,0 +1,40 @@
+// { dg-do run }
+
+#include <sstream>
+#include <testsuite_hooks.h>
+
+void
+test_pr106248()
+{
+  wchar_t buf[5] = {L'x', L'x', L'x', L'x', L'x'};
+  std::wstring s(L"  four");
+  std::wistringstream in(s);
+  in >> buf;
+#if __cplusplus >= 202002L
+  // Extraction stops because buffer is full.
+  VERIFY( in.good() );
+#else
+  // PR libstdc++/106248
+  // Extraction stops because all input has been consumed and eofbit is set.
+  VERIFY( in.eof() );
+#endif
+  // Extracted string must be null-terminated.
+  VERIFY( buf[4] == L'\0' );
+  VERIFY( std::wstring(buf) == L"four" );
+
+  in.clear();
+  in.str(s);
+  for (int i = 0; i < 5; ++i)
+    s[i] = L'x';
+
+  in.width(5);
+  in >> buf;
+  // Extraction stops due to field width, eofbit not set.
+  VERIFY( in.good() );
+  VERIFY( std::wstring(buf) == L"four" );
+}
+
+int main()
+{
+  test_pr106248();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/97731.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/97731.cc
new file mode 100644
index 00000000000..9021e6edf41
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/97731.cc
@@ -0,0 +1,48 @@
+// Copyright (C) 2020-2022 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++17 } }
+// { dg-require-filesystem-ts "" }
+
+#include <filesystem>
+#include <cerrno>
+#include <testsuite_hooks.h>
+
+bool used_custom_readdir = false;
+
+extern "C" void* readdir(void*)
+{
+  used_custom_readdir = true;
+  errno = EIO;
+  return nullptr;
+}
+
+void
+test01()
+{
+  using std::filesystem::recursive_directory_iterator;
+  std::error_code ec;
+  recursive_directory_iterator it(".", ec);
+  if (used_custom_readdir)
+    VERIFY( ec.value() == EIO );
+}
+
+int
+main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
index 1f297a731a3..a26b29f0974 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/error_reporting.cc
@@ -28,35 +28,44 @@
 
 int choice;
 
-struct dirent global_dirent;
-
 extern "C" struct dirent* readdir(DIR*)
 {
+  // On some targets dirent::d_name is very small, but the OS allocates
+  // a trailing char array after the dirent struct. Emulate that here.
+  union State
+  {
+    struct dirent d;
+    char buf[sizeof(struct dirent) + 16] = {};
+  };
+
+  static State state;
+  char* d_name = state.buf + offsetof(struct dirent, d_name);
+
   switch (choice)
   {
   case 1:
-    global_dirent.d_ino = 999;
+    state.d.d_ino = 999;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_REG
-    global_dirent.d_type = DT_REG;
+    state.d.d_type = DT_REG;
 #endif
-    global_dirent.d_reclen = 0;
-    std::char_traits<char>::copy(global_dirent.d_name, "file", 5);
+    state.d.d_reclen = 0;
+    std::char_traits<char>::copy(d_name, "file", 5);
     choice = 0;
-    return &global_dirent;
+    return &state.d;
   case 2:
-    global_dirent.d_ino = 111;
+    state.d.d_ino = 111;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_DIR
-    global_dirent.d_type = DT_DIR;
+    state.d.d_type = DT_DIR;
 #endif
-    global_dirent.d_reclen = 60;
-    std::char_traits<char>::copy(global_dirent.d_name, "subdir", 7);
+    state.d.d_reclen = 60;
+    std::char_traits<char>::copy(d_name, "subdir", 7);
     choice = 1;
-    return &global_dirent;
+    return &state.d;
   default:
     errno = EIO;
     return nullptr;
   }
-  return &global_dirent;
+  return &state.d;
 }
 
 void
@@ -98,7 +107,7 @@ void
 test02()
 {
   namespace fs = std::filesystem;
-  auto dir = __gnu_test::nonexistent_path();
+  const auto dir = __gnu_test::nonexistent_path();
   fs::create_directories(dir/"subdir");
 
   std::error_code ec;
@@ -128,7 +137,12 @@ test02()
   }
 #endif
 
-  fs::remove_all(dir, ec);
+  // Cannot use fs::remove_all here because that uses
+  // recursive_directory_iterator which would use the fake readdir above.
+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  ::rmdir((dir/"subdir").c_str());
+  ::rmdir(dir.c_str());
+#endif
 }
 
 int
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc
index 29a9f480649..014d030eb4f 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/recursive_directory_iterator.cc
@@ -184,6 +184,24 @@ test05()
   remove_all(p, ec);
 }
 
+void
+test06()
+{
+#if !(defined __MINGW32__ || defined __MINGW64__)
+  auto p = __gnu_test::nonexistent_path();
+  create_directories(p/"d1/d2");
+  create_directory_symlink("d1", p/"link");
+  fs::recursive_directory_iterator it(p), endit;
+  VERIFY( std::distance(it, endit) == 3 ); // d1 and d2 and link
+
+  it = fs::recursive_directory_iterator(p, fs::directory_options::follow_directory_symlink);
+  VERIFY( std::distance(it, endit) == 4 ); // d1 and d1/d2 and link and link/d2
+
+  std::error_code ec;
+  remove_all(p, ec);
+#endif
+}
+
 int
 main()
 {
@@ -192,4 +210,5 @@ main()
   test03();
   test04();
   test05();
+  test06();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc
index 24d59799ef1..2bd7f694b3c 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc
@@ -84,7 +84,7 @@ test03()
   VERIFY( eabs.empty() );
 
   try {
-    absolute(path{});
+    (void) absolute(path{});
     VERIFY( false );
   } catch (const std::filesystem::filesystem_error& e) {
     VERIFY( e.code() == std::errc::invalid_argument );
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/all.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/all.cc
index 414c2d8d72c..9a922632eee 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/all.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/all.cc
@@ -42,11 +42,11 @@ main()
   bool b [[maybe_unused]];
   std::uintmax_t size;
 
-  std::filesystem::absolute(p);
-  std::filesystem::absolute(p, ec);
+  p2 = std::filesystem::absolute(p);
+  p2 = std::filesystem::absolute(p, ec);
 
-  std::filesystem::canonical(p);
-  std::filesystem::canonical(p, ec);
+  p2 = std::filesystem::canonical(p);
+  p2 = std::filesystem::canonical(p, ec);
 
   std::filesystem::copy(p, p);
   std::filesystem::copy(p, p, ec);
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/canonical.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/canonical.cc
index 172ef09ee85..dd42ffd403b 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/canonical.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/canonical.cc
@@ -31,7 +31,7 @@ test01()
   const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);
   std::error_code ec;
   auto p = __gnu_test::nonexistent_path();
-  canonical( p, ec );
+  (void) canonical( p, ec );
   VERIFY( ec );
 
   create_directory(p);
@@ -90,7 +90,7 @@ test02()
 #if __cpp_exceptions
   fs::path e1, e2;
   try {
-    canonical(p);
+    (void) canonical(p);
   } catch (const fs::filesystem_error& e) {
     e1 = e.path1();
     e2 = e.path2();
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
index 761cfc29b13..c00cf85641e 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
@@ -193,6 +193,34 @@ test05()
   VERIFY( !ec );  // Previous value should be cleared (LWG 2683)
 }
 
+void
+test_pr99290()
+{
+  auto dir = __gnu_test::nonexistent_path();
+  auto source = dir/"source";
+  auto dest = dir/"dest";
+  create_directories(source/"emptydir");
+  create_directories(dest/"emptydir");
+  std::ofstream{source/"file"} << 'a';
+  std::ofstream{dest/"file"} << 'b';
+  // PR libstdc++/99290
+  // std::filesystem::copy does not always report errors for recursion
+  std::error_code ec;
+  copy(source, dest, ec);
+  VERIFY( ec == std::errc::file_exists );
+
+#if __cpp_exceptions
+  try {
+    copy(source, dest);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::file_exists );
+  }
+#endif
+
+  remove_all(dir);
+}
+
 int
 main()
 {
@@ -201,4 +229,5 @@ main()
   test03();
   test04();
   test05();
+  test_pr99290();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy_file_108178.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy_file_108178.cc
new file mode 100644
index 00000000000..25135834e21
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy_file_108178.cc
@@ -0,0 +1,33 @@
+// { dg-do run { target c++17 } }
+// { dg-require-filesystem-ts "" }
+
+// C++17 30.10.15.4 Copy [fs.op.copy_file]
+
+#include <filesystem>
+#include <fstream>
+#include <unistd.h> // getpid
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+namespace fs = std::filesystem;
+
+void
+test_procfs() // PR libstdc++/108178
+{
+  auto pid = ::getpid();
+  std::string from = "/proc/" + std::to_string(pid) + "/status";
+  if (fs::exists(from))
+  {
+    auto to = __gnu_test::nonexistent_path();
+    fs::copy_file(from, to);
+    std::ifstream f(to);
+    VERIFY(f.is_open());
+    VERIFY(f.peek() != std::char_traits<char>::eof());
+    fs::remove(to);
+  }
+}
+
+int main()
+{
+  test_procfs();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc
index f99a3346ed0..e97c34343ef 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/exists.cc
@@ -95,7 +95,7 @@ test04()
   ec.clear();
   try
   {
-    exists(unr);
+    (void) exists(unr);
   }
   catch(const std::filesystem::filesystem_error& ex)
   {
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc
index 11605748501..b2d021af90e 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/is_empty.cc
@@ -40,7 +40,7 @@ test01()
   VERIFY( !result );
 
   try {
-    fs::is_empty(p);
+    (void) fs::is_empty(p);
   } catch (const fs::filesystem_error& e) {
     ec2 = e.code();
   }
@@ -51,7 +51,7 @@ test01()
   VERIFY( !result );
 
   try {
-    fs::is_empty(p/"f");
+    (void) fs::is_empty(p/"f");
   } catch (const fs::filesystem_error& e) {
     ec2 = e.code();
   }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/read_symlink.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/read_symlink.cc
index 3a8244b8280..5221bf65082 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/read_symlink.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/read_symlink.cc
@@ -31,7 +31,7 @@ test01()
   auto p = __gnu_test::nonexistent_path();
   std::error_code ec;
 
-  read_symlink(p, ec);
+  (void) read_symlink(p, ec);
   VERIFY( ec );
 
   fs::path tgt = ".";
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc
index 4cabdcbe7f7..c2991f827ce 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/status.cc
@@ -74,7 +74,7 @@ test03()
   std::error_code ec2;
   fs::path p, p2;
   try {
-    fs::symlink_status(f.path);
+    (void) fs::symlink_status(f.path);
   } catch (const fs::filesystem_error& e) {
     caught = true;
     p = e.path1();
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc
index bb4c185dd33..775aa21f2d4 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/symlink_status.cc
@@ -94,7 +94,7 @@ test03()
   std::error_code ec2;
   fs::path p, p2;
   try {
-    fs::symlink_status(f.path);
+    (void) fs::symlink_status(f.path);
   } catch (const fs::filesystem_error& e) {
     caught = true;
     p = e.path1();
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
index b55cd6c60b6..22cb23ad81e 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
@@ -20,6 +20,7 @@
 
 #include <filesystem>
 #include <stdlib.h>
+#include <stdio.h>
 #include <testsuite_hooks.h>
 #include <testsuite_fs.h>
 
@@ -58,7 +59,10 @@ test01()
   clean_env();
 
   if (!fs::exists("/tmp"))
+  {
+    puts("/tmp doesn't exist, not testing it for temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec = make_error_code(std::errc::invalid_argument);
   fs::path p1 = fs::temp_directory_path(ec);
@@ -75,7 +79,10 @@ test02()
   clean_env();
 
   if (!set_env("TMP", __gnu_test::nonexistent_path().string()))
+  {
+    puts("Cannot set environment variables, not testing temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec;
   fs::path p = fs::temp_directory_path(ec);
@@ -110,7 +117,7 @@ test03()
 
   std::error_code ec2;
   try {
-    fs::temp_directory_path();
+    (void) fs::temp_directory_path();
   } catch (const fs::filesystem_error& e) {
     ec2 = e.code();
   }
@@ -134,7 +141,7 @@ test04()
 
   std::error_code ec2;
   try {
-    fs::temp_directory_path();
+    (void) fs::temp_directory_path();
   } catch (const fs::filesystem_error& e) {
     ec2 = e.code();
   }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/108636.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/108636.cc
new file mode 100644
index 00000000000..d58de461090
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/108636.cc
@@ -0,0 +1,8 @@
+// { dg-do link { target c++17 } }
+// { dg-options "-fkeep-inline-functions" }
+
+#include <filesystem>
+int main()
+{
+  // PR libstdc++/108636 - link failure with -fkeep-inline-functions
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/95048.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/95048.cc
new file mode 100644
index 00000000000..cd80d668b23
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/95048.cc
@@ -0,0 +1,51 @@
+// { dg-do run { target c++17 } }
+
+// C++17 30.10.8.4.1 path constructors [fs.path.construct]
+
+#include <filesystem>
+#include <testsuite_hooks.h>
+
+using std::filesystem::path;
+
+#define CHECK(E, S) (path(E##S) == path(u8##S))
+
+void
+test_wide()
+{
+  VERIFY( CHECK(L, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(L, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(L, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(L, "\U0001F4C4") ); // filing cabient
+
+  VERIFY( path(u8"\U0001D11E").wstring() == L"\U0001D11E" ); // G Clef
+}
+
+void
+test_u16()
+{
+  VERIFY( CHECK(u, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(u, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(u, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(u, "\U0001F4C4") ); // filing cabient
+
+  VERIFY( path(u8"\U0001D11E").u16string() == u"\U0001D11E" ); // G Clef
+}
+
+void
+test_u32()
+{
+  VERIFY( CHECK(U, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(U, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(U, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(U, "\U0001F4C4") ); // filing cabient
+
+  VERIFY( path(u8"\U0001D11E").u32string() == U"\U0001D11E" ); // G Clef
+}
+
+int
+main()
+{
+  test_wide();
+  test_u16();
+  test_u32();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc
index 7b7c912a6df..be15b314149 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/nonmember/hash_value.cc
@@ -42,9 +42,19 @@ test02()
   }
 }
 
+void
+test03()
+{
+  std::hash<path> h;
+  // LWG 3657. std::hash<std::filesystem::path> is not enabled
+  for (const path p : __gnu_test::test_paths)
+    VERIFY( h(p) == hash_value(p) );
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
diff --git a/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc b/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc
new file mode 100644
index 00000000000..48f733bf28a
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/headers/iosfwd/synopsis.cc
@@ -0,0 +1,119 @@
+// { dg-do compile }
+
+#include <iosfwd>
+
+namespace std
+{
+  // [iosfwd.syn]
+
+  template<class charT> struct char_traits;
+  template<> struct char_traits<char>;
+#if __cplusplus >= 202002L
+  template<> struct char_traits<char8_t>;
+#endif
+#if __cplusplus >= 201103L
+  template<> struct char_traits<char16_t>;
+  template<> struct char_traits<char32_t>;
+#endif
+  template<> struct char_traits<wchar_t>;
+
+  template<class T> class allocator;
+
+  template<class charT, class traits>
+    class basic_ios;
+  template<class charT, class traits>
+    class basic_streambuf;
+  template<class charT, class traits>
+    class basic_istream;
+  template<class charT, class traits>
+    class basic_ostream;
+  template<class charT, class traits>
+    class basic_iostream;
+
+_GLIBCXX_BEGIN_NAMESPACE_CXX11
+  template<class charT, class traits, class Allocator>
+    class basic_stringbuf;
+  template<class charT, class traits, class Allocator>
+    class basic_istringstream;
+  template<class charT, class traits, class Allocator>
+    class basic_ostringstream;
+  template<class charT, class traits, class Allocator>
+    class basic_stringstream;
+_GLIBCXX_END_NAMESPACE_CXX11
+
+  template<class charT, class traits>
+    class basic_filebuf;
+  template<class charT, class traits>
+    class basic_ifstream;
+  template<class charT, class traits>
+    class basic_ofstream;
+  template<class charT, class traits>
+    class basic_fstream;
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  template<class charT, class traits, class Allocator>
+    class basic_syncbuf;
+  template<class charT, class traits, class Allocator>
+    class basic_osyncstream;
+#endif
+
+  template<class charT, class traits>
+    class istreambuf_iterator;
+  template<class charT, class traits>
+    class ostreambuf_iterator;
+
+  typedef basic_ios<char>    ios;
+  typedef basic_ios<wchar_t> wios;
+
+  typedef basic_streambuf<char> streambuf;
+  typedef basic_istream<char>   istream;
+  typedef basic_ostream<char>   ostream;
+  typedef basic_iostream<char>  iostream;
+
+  typedef basic_stringbuf<char>     stringbuf;
+  typedef basic_istringstream<char> istringstream;
+  typedef basic_ostringstream<char> ostringstream;
+  typedef basic_stringstream<char>  stringstream;
+
+
+  typedef basic_filebuf<char>  filebuf;
+  typedef basic_ifstream<char> ifstream;
+  typedef basic_ofstream<char> ofstream;
+  typedef basic_fstream<char>  fstream;
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+  typedef basic_syncbuf<char>     syncbuf;
+  typedef basic_osyncstream<char> osyncstream;
+#endif
+
+  typedef basic_streambuf<wchar_t> wstreambuf;
+  typedef basic_istream<wchar_t>   wistream;
+  typedef basic_ostream<wchar_t>   wostream;
+  typedef basic_iostream<wchar_t>  wiostream;
+
+  typedef basic_stringbuf<wchar_t>     wstringbuf;
+  typedef basic_istringstream<wchar_t> wistringstream;
+  typedef basic_ostringstream<wchar_t> wostringstream;
+  typedef basic_stringstream<wchar_t>  wstringstream;
+
+  typedef basic_filebuf<wchar_t>  wfilebuf;
+  typedef basic_ifstream<wchar_t> wifstream;
+  typedef basic_ofstream<wchar_t> wofstream;
+  typedef basic_fstream<wchar_t>  wfstream;
+
+#if __cplusplus >= 202002L
+  typedef basic_syncbuf<wchar_t>     wsyncbuf;
+  typedef basic_osyncstream<wchar_t> wosyncstream;
+#endif
+
+  template<class state> class fpos;
+  typedef fpos<std::mbstate_t> streampos;
+  typedef fpos<std::mbstate_t> wstreampos;
+#if __cplusplus >= 202002L
+  typedef fpos<std::mbstate_t> u8streampos;
+#endif
+#if __cplusplus >= 201103L
+  typedef fpos<std::mbstate_t> u16streampos;
+  typedef fpos<std::mbstate_t> u32streampos;
+#endif
+}
diff --git a/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc b/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc
new file mode 100644
index 00000000000..e2c9c9b8dfa
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/headers/iosfwd/types.cc
@@ -0,0 +1,214 @@
+// { dg-do compile { target c++11 } }
+
+#include <iosfwd>
+
+template<class, class> struct Same { static constexpr bool value = false; };
+template<class T> struct Same<T, T> { static constexpr bool value = true; };
+
+template<class T> using Traits = std::char_traits<T>;
+template<class T> using Alloc = std::allocator<T>;
+
+using std::basic_ios;
+
+static_assert(Same<basic_ios<char>,
+		   basic_ios<char, Traits<char>>
+		   >::value,
+    "std::basic_ios<char> has the correct default template argument");
+
+static_assert(Same<basic_ios<wchar_t>,
+		   basic_ios<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ios<wchar_t> has the correct default template argument");
+
+using std::basic_streambuf;
+
+static_assert(Same<basic_streambuf<char>,
+		   basic_streambuf<char, Traits<char>>
+		   >::value,
+    "std::basic_streambuf<char> has the correct default template argument");
+
+static_assert(Same<basic_streambuf<wchar_t>,
+		   basic_streambuf<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_streambuf<wchar_t> has the correct default template argument");
+
+using std::basic_istream;
+
+static_assert(Same<basic_istream<char>,
+		   basic_istream<char, Traits<char>>
+		   >::value,
+    "std::basic_istream<char> has the correct default template argument");
+
+static_assert(Same<basic_istream<wchar_t>,
+		   basic_istream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_istream<wchar_t> has the correct default template argument");
+
+using std::basic_ostream;
+
+static_assert(Same<basic_ostream<char>,
+		   basic_ostream<char, Traits<char>>
+		   >::value,
+    "std::basic_ostream<char> has the correct default template argument");
+
+static_assert(Same<basic_ostream<wchar_t>,
+		   basic_ostream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ostream<wchar_t> has the correct default template argument");
+
+using std::basic_iostream;
+
+static_assert(Same<basic_iostream<char>,
+		   basic_iostream<char, Traits<char>>>::value,
+    "std::basic_iostream<char> has the correct default template argument");
+
+static_assert(Same<basic_iostream<wchar_t>,
+		   basic_iostream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_iostream<wchar_t> has the correct default template argument");
+
+using std::basic_stringbuf;
+
+static_assert(Same<basic_stringbuf<char>,
+		   basic_stringbuf<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_stringbuf<char> has the correct default template argument");
+
+static_assert(Same<basic_stringbuf<wchar_t>,
+		   basic_stringbuf<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_stringbuf<wchar_t> has the correct default template argument");
+
+using std::basic_istringstream;
+
+static_assert(Same<basic_istringstream<char>,
+		   basic_istringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_istringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_istringstream<wchar_t>,
+		   basic_istringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_istringstream<wchar_t> has the correct default template argument");
+
+using std::basic_ostringstream;
+
+static_assert(Same<basic_ostringstream<char>,
+		   basic_ostringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_ostringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ostringstream<wchar_t>,
+		   basic_ostringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_ostringstream<wchar_t> has the correct default template argument");
+
+using std::basic_stringstream;
+
+static_assert(Same<basic_stringstream<char>,
+		   basic_stringstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_stringstream<char> has the correct default template argument");
+
+static_assert(Same<basic_stringstream<wchar_t>,
+		   basic_stringstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_stringstream<wchar_t> has the correct default template argument");
+
+using std::basic_filebuf;
+
+static_assert(Same<basic_filebuf<char>,
+		   basic_filebuf<char, Traits<char>>
+		   >::value,
+    "std::basic_filebuf<char> has the correct default template argument");
+
+static_assert(Same<basic_filebuf<wchar_t>,
+		   basic_filebuf<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_filebuf<wchar_t> has the correct default template argument");
+
+using std::basic_ifstream;
+
+static_assert(Same<basic_ifstream<char>,
+		   basic_ifstream<char, Traits<char>>
+		   >::value,
+    "std::basic_ifstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ifstream<wchar_t>,
+		   basic_ifstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ifstream<wchar_t> has the correct default template argument");
+
+using std::basic_ofstream;
+
+static_assert(Same<basic_ofstream<char>,
+		   basic_ofstream<char, Traits<char>>
+		   >::value,
+    "std::basic_ofstream<char> has the correct default template argument");
+
+static_assert(Same<basic_ofstream<wchar_t>,
+		   basic_ofstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_ofstream<wchar_t> has the correct default template argument");
+
+using std::basic_fstream;
+
+static_assert(Same<basic_fstream<char>,
+		   basic_fstream<char, Traits<char>>
+		   >::value,
+    "std::basic_fstream<char> has the correct default template argument");
+
+static_assert(Same<basic_fstream<wchar_t>,
+		   basic_fstream<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::basic_fstream<wchar_t> has the correct default template argument");
+
+#if __cplusplus >= 202002L && _GLIBCXX_USE_CXX11_ABI
+using std::basic_syncbuf;
+
+static_assert(Same<basic_syncbuf<char>,
+		   basic_syncbuf<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_syncbuf<char> has the correct default template argument");
+
+static_assert(Same<basic_syncbuf<wchar_t>,
+		   basic_syncbuf<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_syncbuf<wchar_t> has the correct default template argument");
+
+using std::basic_osyncstream;
+
+static_assert(Same<basic_osyncstream<char>,
+		   basic_osyncstream<char, Traits<char>, Alloc<char>>
+		   >::value,
+    "std::basic_osyncstream<char> has the correct default template argument");
+
+static_assert(Same<basic_osyncstream<wchar_t>,
+		   basic_osyncstream<wchar_t, Traits<wchar_t>, Alloc<wchar_t>>
+		   >::value,
+    "std::basic_osyncstream<wchar_t> has the correct default template argument");
+#endif
+
+using std::istreambuf_iterator;
+
+static_assert(Same<istreambuf_iterator<char>,
+		   istreambuf_iterator<char, Traits<char>>
+		   >::value,
+    "std::istreambuf_iterator<char> has the correct default template argument");
+
+static_assert(Same<istreambuf_iterator<wchar_t>,
+		   istreambuf_iterator<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::istreambuf_iterator<wchar_t> has the correct default template argument");
+
+using std::ostreambuf_iterator;
+
+static_assert(Same<ostreambuf_iterator<char>,
+		   ostreambuf_iterator<char, Traits<char>>
+		   >::value,
+    "std::ostreambuf_iterator<char> has the correct default template argument");
+
+static_assert(Same<ostreambuf_iterator<wchar_t>,
+		   ostreambuf_iterator<wchar_t, Traits<wchar_t>>
+		   >::value,
+    "std::ostreambuf_iterator<wchar_t> has the correct default template argument");
diff --git a/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc
index 7df70604ea6..0d76e63da7b 100644
--- a/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc
+++ b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/cstring_bracket_01.cc
@@ -69,6 +69,16 @@ test01()
 void
 test02()
 {
+  VERIFY(regex_match("-", regex("[-]", regex_constants::ECMAScript)));
+  VERIFY(regex_match("-", regex("[--]", regex_constants::ECMAScript)));
+  VERIFY(regex_match("-", regex("[---]", regex_constants::ECMAScript)));
+  VERIFY(regex_match("-", regex("[----]", regex_constants::ECMAScript)));
+  VERIFY(regex_match("-", regex("[-----]", regex_constants::ECMAScript)));
+
+  VERIFY(regex_match("-", regex("[-]", regex_constants::extended)));
+  VERIFY(regex_match("-", regex("[--]", regex_constants::extended)));
+  VERIFY(regex_match("-", regex("[---]", regex_constants::extended)));
+  VERIFY(regex_match("-", regex("[----]", regex_constants::extended)));
   try
   {
     std::regex re("[-----]", std::regex::extended);
@@ -78,7 +88,6 @@ test02()
   {
     VERIFY(e.code() == std::regex_constants::error_range);
   }
-  std::regex re("[-----]", std::regex::ECMAScript);
 
   VERIFY(!regex_match("b", regex("[-ac]", regex_constants::extended)));
   VERIFY(!regex_match("b", regex("[ac-]", regex_constants::extended)));
@@ -93,7 +102,27 @@ test02()
   }
   catch (const std::regex_error& e)
   {
+    VERIFY(e.code() == std::regex_constants::error_range);
   }
+  try
+  {
+    regex("[@--]", regex_constants::extended);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+  try
+  {
+    regex("[--%]", regex_constants::extended);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+
   VERIFY(regex_match("].", regex("[][.hyphen.]-0]*", regex_constants::extended)));
 }
 
@@ -158,6 +187,36 @@ test06()
   VERIFY(regex_match("a-", debian_cron_namespace_ok));
 }
 
+// libstdc++/102447
+void
+test07()
+{
+  VERIFY(regex_match("-", std::regex("[\\w-]", std::regex::ECMAScript)));
+  VERIFY(regex_match("a", std::regex("[\\w-]", std::regex::ECMAScript)));
+  VERIFY(regex_match("-", std::regex("[a-]", std::regex::ECMAScript)));
+  VERIFY(regex_match("a", std::regex("[a-]", std::regex::ECMAScript)));
+
+  try
+  {
+    std::regex re("[\\w-a]", std::regex::ECMAScript);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+
+  try
+  {
+    std::regex re("[\\w--]", std::regex::ECMAScript);
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY(e.code() == std::regex_constants::error_range);
+  }
+}
+
 int
 main()
 {
@@ -167,6 +226,7 @@ main()
   test04();
   test05();
   test06();
+  test07();
 
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/multiline.cc b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/multiline.cc
new file mode 100644
index 00000000000..a1982fc8f78
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/algorithms/regex_match/multiline.cc
@@ -0,0 +1,74 @@
+// { dg-do run { target c++11 } }
+#include <regex>
+#include <testsuite_hooks.h>
+
+#if __cplusplus >= 201703L || !defined __STRICT_ANSI__
+static_assert( std::regex_constants::multiline == std::regex::multiline );
+static_assert( std::regex_constants::__multiline == std::regex::multiline );
+#else
+namespace test { constexpr int multiline = 0; }
+namespace check {
+  using namespace test;
+  using namespace std::regex_constants;
+  int ml = multiline;
+}
+#endif
+
+void
+test01()
+{
+  using namespace std::regex_constants;
+
+  std::regex ml{"^a.$", __multiline};
+  VERIFY( ml.flags() == __multiline );
+  VERIFY(!std::regex_search("abx\nxab", ml));
+  VERIFY(std::regex_search("x\nab", ml));
+  VERIFY(std::regex_search("ab\n", ml));
+  VERIFY(std::regex_search("x\nab\nx", ml));
+
+  ml.assign("a$\n^b$\n^c", ECMAScript|__multiline);
+  VERIFY( ml.flags() == ECMAScript|__multiline );
+  VERIFY( regex_search("a\nb\nc", ml) );
+
+  ml.assign("a$\n^b$\n^c", ECMAScript|__multiline|icase);
+  VERIFY( ml.flags() == ECMAScript|__multiline|icase );
+  VERIFY( regex_search("A\nB\nC", ml) );
+}
+
+void
+test_pr102480()
+{
+  using namespace std::regex_constants;
+
+  std::regex re("^a");
+  std::regex reml("^a", __multiline);
+  VERIFY( std::regex_match("\na" + 1, re));
+  VERIFY( std::regex_match("\na" + 1, reml));
+  // PR libstdc++/102480
+  VERIFY(!std::regex_match("\na" + 1, re, match_prev_avail));
+  VERIFY( std::regex_match("\na" + 1, reml, match_prev_avail));
+  VERIFY(!std::regex_match("\na" + 1, re, match_not_bol));
+  VERIFY(!std::regex_match("\na" + 1, re, match_prev_avail|match_not_bol));
+  VERIFY( std::regex_match("\na" + 1, reml, match_prev_avail|match_not_bol));
+  VERIFY(!std::regex_match("\ra" + 1, re, match_prev_avail));
+  VERIFY( std::regex_match("\ra" + 1, reml, match_prev_avail));
+  VERIFY(!std::regex_match("xa" + 1, re, match_prev_avail));
+  VERIFY(!std::regex_match("xa" + 1, reml, match_prev_avail));
+
+  std::regex bre("^a", basic|__multiline);
+  VERIFY(std::regex_match("\na" + 1, bre));
+  VERIFY(!std::regex_match("\na" + 1, bre, match_not_bol));
+  // multiline is ignored for any grammar except ECMAScript,
+  // so none of the following should match even though
+  // match_prev_avail is set and *--first == '\n'.
+  VERIFY(!std::regex_match("\na" + 1, bre, match_prev_avail));
+  VERIFY(!std::regex_match("\na" + 1, bre, match_prev_avail|match_not_bol));
+  VERIFY(!std::regex_match("\ra" + 1, bre, match_prev_avail));
+  VERIFY(!std::regex_match("xa" + 1, bre, match_prev_avail));
+}
+
+int main()
+{
+  test01();
+  test_pr102480();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/103664.cc b/libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/103664.cc
new file mode 100644
index 00000000000..c61912823d5
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/103664.cc
@@ -0,0 +1,12 @@
+// { dg-do run { target c++11 } }
+// { dg-timeout-factor 2 }
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+int main()
+{
+  // PR libstdc++/103664
+  std::string a = regex_replace("123", std::regex("2"), std::string("a\0b", 3));
+  VERIFY( a == std::string("1a\0b3", 5) );
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc
new file mode 100644
index 00000000000..f8e7fb2364d
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/106607.cc
@@ -0,0 +1,25 @@
+// { dg-do run { target c++11 } }
+
+#include <regex>
+#include <string>
+#include <climits>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/106607 - Regex integer overflow on large backreference value
+
+int main()
+{
+  std::regex r("(.)\\1"); // OK
+
+  try
+  {
+    long long n = (unsigned)-1 + 2LL;          // 4294967297 for 32-bit int
+    VERIFY( (int)n == 1 );                     // 4294967297 % 2^32 == 1
+    std::regex r("(.)\\" + std::to_string(n)); // Invalid back reference.
+    VERIFY(false);
+  }
+  catch (const std::regex_error& e)
+  {
+    VERIFY( e.code() == std::regex_constants::error_backref );
+  }
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/84110.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/84110.cc
new file mode 100644
index 00000000000..a4d5db6c14a
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/84110.cc
@@ -0,0 +1,43 @@
+// { dg-do run { target c++11 } }
+// { dg-timeout-factor 2 }
+#include <regex>
+#include <string>
+#include <testsuite_hooks.h>
+
+void test01()
+{
+  const std::string s(1ul, '\0');
+  std::regex re(s);
+  VERIFY( std::regex_match(s, re) ); // PR libstdc++/84110
+
+#if __cpp_exceptions
+  using namespace std::regex_constants;
+  // See https://gcc.gnu.org/pipermail/gcc-patches/2021-October/582486.html
+  using std::regex_constants::extended;
+
+  for (auto syn : {basic, extended, awk, grep, egrep})
+  {
+    try
+    {
+      std::regex{s, syn}; // '\0' is not valid for other grammars
+      VERIFY( false );
+    }
+    catch (const std::regex_error&)
+    {
+    }
+  }
+#endif
+}
+
+void test02()
+{
+  const std::string s("uh-\0h", 5);
+  std::regex re(s);
+  VERIFY( std::regex_match(s, re) );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/assign/exception_safety.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/assign/exception_safety.cc
new file mode 100644
index 00000000000..462eebcf2cd
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/assign/exception_safety.cc
@@ -0,0 +1,20 @@
+// { dg-do run { target c++11 } }
+#include <regex>
+#include <testsuite_hooks.h>
+
+int main()
+{
+  const auto f = std::regex::ECMAScript|std::regex::icase;
+  std::regex re("abc", f);
+  try
+  {
+    re.assign("[", std::regex::extended);
+    VERIFY( false );
+  }
+  catch (const std::regex_error&)
+  {
+    // [re.regex.assign] "If an exception is thrown, *this is unchanged."
+    VERIFY( re.flags() == f );
+    VERIFY( std::regex_match("abc", re) );
+  }
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/char/other.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/char/other.cc
new file mode 100644
index 00000000000..10c20d9d4bc
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/char/other.cc
@@ -0,0 +1,38 @@
+// { dg-do run { target c++11 } }
+// { dg-timeout-factor 2 }
+#include <regex>
+#include <testsuite_iterators.h>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  signed char s[] = { 'a', '.' };
+  std::regex re(s, s+2); // This used to fail up to GCC 11.2
+  // VERIFY( regex_match("an", re) );
+
+  std::wstring str = L"xx";
+  str[0] = '1';
+  str[1] = '2';
+  re.assign(str.begin(), str.end());
+  VERIFY( regex_match("12", re) );
+}
+
+void
+test02()
+{
+  int i[] = { 'a', '.', '[', 'x', 'y', 'z', ']' };
+  __gnu_test::forward_container<int> fwd(i);
+  std::regex re(fwd.begin(), fwd.end());
+  VERIFY( regex_match("any", re) );
+
+  __gnu_test::input_container<int> input(i);
+  re.assign(input.begin(), input.end(), std::regex::icase);
+  VERIFY( regex_match("ANY", re) );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/grammar.cc b/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/grammar.cc
new file mode 100644
index 00000000000..fd8531c4530
--- /dev/null
+++ b/libstdc++-v3/testsuite/28_regex/basic_regex/ctors/grammar.cc
@@ -0,0 +1,53 @@
+// { dg-do run { target c++11 } }
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::regex re{""};
+  VERIFY( re.flags() & std::regex::ECMAScript );
+
+  std::regex re2{"", std::regex::flag_type{}};
+  VERIFY( re2.flags() == std::regex::flag_type() ); // See also PR 83598
+}
+
+void
+test02()
+{
+  // A valid value of type syntax_option_type shall have at most one of the
+  // grammar elements ECMAScript, basic, extended, awk, grep, egrep, set.
+
+  try
+  {
+    std::regex{"", std::regex::ECMAScript|std::regex::basic};
+    VERIFY( false );
+  }
+  catch (const std::regex_error&)
+  {
+  }
+
+  try
+  {
+    std::regex{"", std::regex::extended|std::regex::basic};
+    VERIFY( false );
+  }
+  catch (const std::regex_error&)
+  {
+  }
+
+  try
+  {
+    std::regex{"", std::regex::grep|std::regex::basic};
+    VERIFY( false );
+  }
+  catch (const std::regex_error&)
+  {
+  }
+}
+
+int main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/28_regex/match_results/102667.cc b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
index 9e38c9edaa4..1614f3f9eb8 100644
--- a/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
+++ b/libstdc++-v3/testsuite/28_regex/match_results/102667.cc
@@ -1,4 +1,5 @@
 // { dg-do run { target c++11 } }
+// { dg-timeout-factor 2 }
 
 #include <regex>
 #include <testsuite_hooks.h>
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc b/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
index 7eab17b12e0..dffdaef7afd 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
@@ -1,3 +1,4 @@
+// { dg-options "-O1" }
 // { dg-do link { target c++11 } }
 
 // Copyright (C) 2009-2021 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/lwg3220.cc b/libstdc++-v3/testsuite/29_atomics/atomic/lwg3220.cc
new file mode 100644
index 00000000000..d2ff6cf9fe3
--- /dev/null
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/lwg3220.cc
@@ -0,0 +1,13 @@
+// { dg-do compile { target c++11 } }
+// DR 3220. P0558 broke conforming C++14 uses of atomic shared_ptr
+
+#include <atomic>
+#include <memory>
+
+struct Abstract { virtual void test() = 0; };
+struct Concrete : Abstract { virtual void test() override {} };
+
+int main() {
+  std::shared_ptr<Abstract> ptr;
+  std::atomic_store<Abstract>(&ptr, std::make_shared<Concrete>());
+}
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc b/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
index 9d92ff954f1..f572ce7ef11 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
@@ -5,13 +5,13 @@
 #include <atomic>
 
 void
-test1(const std::atomic<char*>& a, char* p)
+test1(std::atomic<char*>& a, char* p)
 {
   a.wait(p);
 }
 
 void
-test2(const std::atomic<int>* a, int v)
+test2(std::atomic<int>* a, int v)
 {
   std::atomic_wait(a, v);
   std::atomic_notify_one(a);
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic_flag/test/explicit.cc b/libstdc++-v3/testsuite/29_atomics/atomic_flag/test/explicit.cc
index 5d2fd10812c..751b78e8467 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic_flag/test/explicit.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic_flag/test/explicit.cc
@@ -22,7 +22,8 @@
 #include <atomic>
 #include <testsuite_hooks.h>
 
-int main()
+void
+test01()
 {
   using namespace std;
 
@@ -38,3 +39,26 @@ int main()
   VERIFY( ! af.test(memory_order_acquire) );
   VERIFY( ! caf.test(memory_order_acquire) );
 }
+
+void
+test02()
+{
+  using namespace std;
+
+  atomic_flag af{true};
+  const atomic_flag& caf = af;
+
+  VERIFY( atomic_flag_test_explicit(&af, memory_order_acquire) );
+  VERIFY( atomic_flag_test_explicit(&caf, memory_order_acquire) );
+  af.clear(memory_order_release);
+  VERIFY( ! atomic_flag_test_explicit(&af, memory_order_acquire) );
+  VERIFY( ! atomic_flag_test_explicit(&caf, memory_order_acquire) );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic_flag/test/implicit.cc b/libstdc++-v3/testsuite/29_atomics/atomic_flag/test/implicit.cc
index 5e592c4b4a1..aaab0e374ec 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic_flag/test/implicit.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic_flag/test/implicit.cc
@@ -22,7 +22,8 @@
 #include <atomic>
 #include <testsuite_hooks.h>
 
-int main()
+void
+test01()
 {
   using namespace std;
 
@@ -38,3 +39,26 @@ int main()
   VERIFY( ! af.test() );
   VERIFY( ! caf.test() );
 }
+
+void
+test02()
+{
+  using namespace std;
+
+  atomic_flag af{true};
+  const atomic_flag& caf = af;
+
+  VERIFY( atomic_flag_test(&af) );
+  VERIFY( atomic_flag_test(&caf) );
+  af.clear(memory_order_release);
+  VERIFY( ! atomic_flag_test(&af) );
+  VERIFY( ! atomic_flag_test(&caf) );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic_flag/wait_notify/1.cc b/libstdc++-v3/testsuite/29_atomics/atomic_flag/wait_notify/1.cc
index 9872a56a20e..70b5b50b9cd 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic_flag/wait_notify/1.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic_flag/wait_notify/1.cc
@@ -26,8 +26,8 @@
 
 #include <testsuite_hooks.h>
 
-int
-main()
+void
+test01()
 {
   std::atomic_flag a;
   VERIFY( !a.test() );
@@ -39,5 +39,27 @@ main()
     });
   a.wait(false);
   t.join();
+}
+
+void
+test02()
+{
+  std::atomic_flag a;
+  VERIFY( !std::atomic_flag_test(&a) );
+  std::atomic_flag_wait(&a, true);
+  std::thread t([&]
+    {
+      std::atomic_flag_test_and_set(&a);
+      std::atomic_flag_notify_one(&a);
+    });
+    std::atomic_flag_wait(&a, false);
+    t.join();
+}
+
+int
+main()
+{
+  test01();
+  test02();
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/30_threads/async/106695.cc b/libstdc++-v3/testsuite/30_threads/async/106695.cc
new file mode 100644
index 00000000000..74996342dc7
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/async/106695.cc
@@ -0,0 +1,29 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-gthreads "" }
+
+// PR libstdc++/106695
+// Explicit copy constructor does not work for a parameter passed via std::async
+
+#include <future>
+
+struct A {
+  A() = default;
+  explicit A(const A&) = default;
+};
+
+void func(const A&) { }
+
+void
+test_async()
+{
+  (void) std::async(std::launch::async, func, A{});
+  (void) std::async(std::launch::deferred, func, A{});
+  (void) std::async(func, A{});
+}
+
+void
+test_task()
+{
+  std::packaged_task<void(const A&)> task(func);
+  task(A{});
+}
diff --git a/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc b/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc
new file mode 100644
index 00000000000..0eb69763ab9
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc
@@ -0,0 +1,85 @@
+// // Copyright (C) 2017-2022 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++17 } }
+
+#include <future>
+
+template<typename T, typename U> struct require_same;
+template<typename T> struct require_same<T, T> { using type = void; };
+
+template<typename T, typename U>
+  typename require_same<T, U>::type
+  check_type(U&) { }
+
+void f0v();
+void f0vn() noexcept;
+int f0i();
+int f0in() noexcept;
+long f1l(int&);
+long f1ln(double*) noexcept;
+
+void
+test01()
+{
+  std::packaged_task task1{f0v};
+  check_type<std::packaged_task<void()>>(task1);
+
+  std::packaged_task task2{f0vn};
+  check_type<std::packaged_task<void()>>(task2);
+
+  std::packaged_task task3{f0i};
+  check_type<std::packaged_task<int()>>(task3);
+
+  std::packaged_task task4{f0in};
+  check_type<std::packaged_task<int()>>(task4);
+
+  std::packaged_task task5{f1l};
+  check_type<std::packaged_task<long(int&)>>(task5);
+
+  std::packaged_task task6{f1ln};
+  check_type<std::packaged_task<long(double*)>>(task6);
+
+  std::packaged_task task5a{std::move(task5)};
+  check_type<std::packaged_task<long(int&)>>(task5a);
+
+  std::packaged_task task6a{std::move(task6)};
+  check_type<std::packaged_task<long(double*)>>(task6a);
+}
+
+struct X {
+  int operator()(const short&, void*);
+};
+
+struct Y {
+  void operator()(int) const & noexcept;
+};
+
+void
+test02()
+{
+  X x;
+  std::packaged_task task1{x};
+  check_type<std::packaged_task<int(const short&, void*)>>(task1);
+
+  Y y;
+  std::packaged_task task2{y};
+  check_type<std::packaged_task<void(int)>>(task2);
+
+  std::packaged_task task3{[&x](float) -> X& { return x; }};
+  check_type<std::packaged_task<X&(float)>>(task3);
+}
diff --git a/libstdc++-v3/testsuite/30_threads/thread/106695.cc b/libstdc++-v3/testsuite/30_threads/thread/106695.cc
new file mode 100644
index 00000000000..97e9e922d8e
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/thread/106695.cc
@@ -0,0 +1,21 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-gthreads "" }
+
+// PR libstdc++/106695
+// Explicit copy constructor does not work for a parameter passed via std::async
+
+#include <thread>
+
+struct A {
+  A() = default;
+  explicit A(const A&) = default;
+};
+
+void func(const A&) { }
+
+void
+test_thread()
+{
+  std::thread t(func, A{});
+  t.join();
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc b/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
index 806c511ebef..aabed14679c 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/iterators/error_reporting.cc
@@ -29,35 +29,44 @@
 
 int choice;
 
-struct dirent global_dirent;
-
 extern "C" struct dirent* readdir(DIR*)
 {
+  // On some targets dirent::d_name is very small, but the OS allocates
+  // a trailing char array after the dirent struct. Emulate that here.
+  union State
+  {
+    struct dirent d;
+    char buf[sizeof(struct dirent) + 16] = {};
+  };
+
+  static State state;
+  char* d_name = state.buf + offsetof(struct dirent, d_name);
+
   switch (choice)
   {
   case 1:
-    global_dirent.d_ino = 999;
+    state.d.d_ino = 999;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_REG
-    global_dirent.d_type = DT_REG;
+    state.d.d_type = DT_REG;
 #endif
-    global_dirent.d_reclen = 0;
-    std::char_traits<char>::copy(global_dirent.d_name, "file", 5);
+    state.d.d_reclen = 0;
+    std::char_traits<char>::copy(d_name, "file", 5);
     choice = 0;
-    return &global_dirent;
+    return &state.d;
   case 2:
-    global_dirent.d_ino = 111;
+    state.d.d_ino = 111;
 #if defined _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE && defined DT_DIR
-    global_dirent.d_type = DT_DIR;
+    state.d.d_type = DT_DIR;
 #endif
-    global_dirent.d_reclen = 60;
-    std::char_traits<char>::copy(global_dirent.d_name, "subdir", 7);
+    state.d.d_reclen = 60;
+    std::char_traits<char>::copy(d_name, "subdir", 7);
     choice = 1;
-    return &global_dirent;
+    return &state.d;
   default:
     errno = EIO;
     return nullptr;
   }
-  return &global_dirent;
+  return &state.d;
 }
 
 void
@@ -99,7 +108,7 @@ void
 test02()
 {
   namespace fs = std::experimental::filesystem;
-  auto dir = __gnu_test::nonexistent_path();
+  const auto dir = __gnu_test::nonexistent_path();
   fs::create_directories(dir/"subdir");
 
   std::error_code ec;
@@ -129,7 +138,12 @@ test02()
   }
 #endif
 
-  fs::remove_all(dir, ec);
+  // Cannot use fs::remove_all here because that depends on
+  // recursive_directory_iterator which would use the fake readdir above.
+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  ::rmdir((dir/"subdir").c_str());
+  ::rmdir(dir.c_str());
+#endif
 }
 
 int
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc b/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
index a9a81c8c4cb..e3b00945285 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/iterators/recursive_directory_iterator.cc
@@ -174,7 +174,7 @@ test05()
 {
   auto p = __gnu_test::nonexistent_path();
   create_directory(p);
-  create_directory_symlink(p, p / "l");
+  create_directory(p / "x");
   fs::recursive_directory_iterator it(p), endit;
   VERIFY( begin(it) == it );
   static_assert( noexcept(begin(it)), "begin is noexcept" );
@@ -185,6 +185,24 @@ test05()
   remove_all(p, ec);
 }
 
+void
+test06()
+{
+#if !(defined __MINGW32__ || defined __MINGW64__)
+  auto p = __gnu_test::nonexistent_path();
+  create_directories(p/"d1/d2");
+  create_directory_symlink("d1", p/"link");
+  fs::recursive_directory_iterator it(p), endit;
+  VERIFY( std::distance(it, endit) == 3 ); // d1 and d2 and link
+
+  it = fs::recursive_directory_iterator(p, fs::directory_options::follow_directory_symlink);
+  VERIFY( std::distance(it, endit) == 4 ); // d1 and d1/d2 and link and link/d2
+
+  std::error_code ec;
+  remove_all(p, ec);
+#endif
+}
+
 int
 main()
 {
@@ -193,4 +211,5 @@ main()
   test03();
   test04();
   test05();
+  test06();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc
index e54bf7c1f91..e41027f39e7 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/canonical.cc
@@ -30,11 +30,11 @@ test01()
 {
   std::error_code ec;
   auto p = __gnu_test::nonexistent_path();
-  canonical( p, ec );
+  (void) canonical( p, ec );
   VERIFY( ec );
 
   p = fs::current_path();
-  canonical( p, ec );
+  (void) canonical( p, ec );
   VERIFY( !ec );
 
   const auto root = fs::absolute("/");
@@ -67,7 +67,7 @@ test02()
   fs::path p = "rel", base = __gnu_test::nonexistent_path();
   fs::path e1, e2;
   try {
-    canonical(p, base);
+    (void) canonical(p, base);
   } catch (const fs::filesystem_error& e) {
     e1 = e.path1();
     e2 = e.path2();
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
index 947d270e6a4..817e51d2d21 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
@@ -190,6 +190,34 @@ test05()
   VERIFY( !ec );  // Previous value should be cleared (LWG 2683)
 }
 
+void
+test_pr99290()
+{
+  auto dir = __gnu_test::nonexistent_path();
+  auto source = dir/"source";
+  auto dest = dir/"dest";
+  create_directories(source/"emptydir");
+  create_directories(dest/"emptydir");
+  std::ofstream{source/"file"} << 'a';
+  std::ofstream{dest/"file"} << 'b';
+  // PR libstdc++/99290
+  // std::filesystem::copy does not always report errors for recursion
+  std::error_code ec;
+  copy(source, dest, ec);
+  VERIFY( ec == std::errc::file_exists );
+
+#if __cpp_exceptions
+  try {
+    copy(source, dest);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::file_exists );
+  }
+#endif
+
+  remove_all(dir);
+}
+
 int
 main()
 {
@@ -198,4 +226,5 @@ main()
   test03();
   test04();
   test05();
+  test_pr99290();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc
index 79fe970e9f3..39d99c7cece 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/exists.cc
@@ -89,7 +89,7 @@ test04()
   ec.clear();
   try
   {
-    exists(unr);
+    (void) exists(unr);
   }
   catch(const std::experimental::filesystem::filesystem_error& ex)
   {
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/is_empty.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/is_empty.cc
index a474fa2a37f..21be254aad8 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/is_empty.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/is_empty.cc
@@ -41,7 +41,7 @@ test01()
   VERIFY( !result );
 
   try {
-    fs::is_empty(p);
+    (void) fs::is_empty(p);
   } catch (const fs::filesystem_error& e) {
     ec2 = e.code();
   }
@@ -52,7 +52,7 @@ test01()
   VERIFY( !result );
 
   try {
-    fs::is_empty(p/"f");
+    (void) fs::is_empty(p/"f");
   } catch (const fs::filesystem_error& e) {
     ec2 = e.code();
   }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/read_symlink.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/read_symlink.cc
index 62bea22683c..a6ab109e30d 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/read_symlink.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/read_symlink.cc
@@ -32,7 +32,7 @@ test01()
   auto p = __gnu_test::nonexistent_path();
   std::error_code ec;
 
-  read_symlink(p, ec);
+  (void) read_symlink(p, ec);
   VERIFY( ec );
 
   fs::path tgt = ".";
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
index 03e777b0041..43f515d7f7c 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
@@ -21,6 +21,7 @@
 
 #include <experimental/filesystem>
 #include <stdlib.h>
+#include <stdio.h>
 #include <testsuite_hooks.h>
 #include <testsuite_fs.h>
 
@@ -59,7 +60,10 @@ test01()
   clean_env();
 
   if (!fs::exists("/tmp"))
+  {
+    puts("/tmp doesn't exist, not testing it for temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec = make_error_code(std::errc::invalid_argument);
   fs::path p1 = fs::temp_directory_path(ec);
@@ -75,8 +79,11 @@ test02()
 {
   clean_env();
 
-  if (set_env("TMPDIR", __gnu_test::nonexistent_path().string()))
+  if (!set_env("TMP", __gnu_test::nonexistent_path().string()))
+  {
+    puts("Cannot set environment variables, not testing temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec;
   fs::path p = fs::temp_directory_path(ec);
@@ -98,6 +105,8 @@ test03()
   if (!__gnu_test::permissions_are_testable())
     return;
 
+  clean_env();
+
   auto p = __gnu_test::nonexistent_path();
   create_directories(p/"tmp");
   permissions(p, fs::perms::none);
@@ -109,7 +118,7 @@ test03()
 
   std::error_code ec2;
   try {
-    fs::temp_directory_path();
+    (void) fs::temp_directory_path();
   } catch (const fs::filesystem_error& e) {
     ec2 = e.code();
   }
@@ -122,8 +131,10 @@ test03()
 void
 test04()
 {
+  clean_env();
+
   __gnu_test::scoped_file f;
-  set_env("TMPDIR", f.path.string());
+  set_env("TMP", f.path.string());
   std::error_code ec;
   auto r = fs::temp_directory_path(ec);
   VERIFY( ec == std::make_error_code(std::errc::not_a_directory) );
@@ -131,7 +142,7 @@ test04()
 
   std::error_code ec2;
   try {
-    fs::temp_directory_path();
+    (void) fs::temp_directory_path();
   } catch (const fs::filesystem_error& e) {
     ec2 = e.code();
   }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/95048.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/95048.cc
new file mode 100644
index 00000000000..fc65bfecd4d
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/95048.cc
@@ -0,0 +1,53 @@
+// { dg-options "-lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+// 8.4.1 path constructors [path.construct]
+
+#include <experimental/filesystem>
+#include <testsuite_hooks.h>
+
+using std::experimental::filesystem::path;
+
+#define CHECK(E, S) (path(E##S) == path(u8##S))
+
+void
+test_wide()
+{
+  VERIFY( CHECK(L, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(L, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(L, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(L, "\U0001F4C4") ); // filing cabient
+
+  VERIFY( path(u8"\U0001D11E").wstring() == L"\U0001D11E" ); // G Clef
+}
+
+void
+test_u16()
+{
+  VERIFY( CHECK(u, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(u, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(u, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(u, "\U0001F4C4") ); // filing cabient
+
+  VERIFY( path(u8"\U0001D11E").u16string() == u"\U0001D11E" ); // G Clef
+}
+
+void
+test_u32()
+{
+  VERIFY( CHECK(U, "\u00E4") ); // PR libstdc++/95048
+  VERIFY( CHECK(U, "\U0001F4C1") ); // folder
+  VERIFY( CHECK(U, "\U0001F4C2") ); // open folder
+  VERIFY( CHECK(U, "\U0001F4C4") ); // filing cabient
+
+  VERIFY( path(u8"\U0001D11E").u32string() == U"\U0001D11E" ); // G Clef
+}
+
+int
+main()
+{
+  test_wide();
+  test_u16();
+  test_u32();
+}
diff --git a/libstdc++-v3/testsuite/experimental/simd/pr109261_constexpr_simd.cc b/libstdc++-v3/testsuite/experimental/simd/pr109261_constexpr_simd.cc
new file mode 100644
index 00000000000..43b47a614e7
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/simd/pr109261_constexpr_simd.cc
@@ -0,0 +1,91 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+// { dg-require-cmath "" }
+
+#include <experimental/simd>
+
+namespace stdx = std::experimental;
+
+template <typename T, typename V>
+  void
+  test01()
+  {
+    constexpr T data[V::size()] = {};
+    constexpr auto a = V(data, stdx::element_aligned);
+
+    constexpr auto b = []() constexpr {
+      V x = T(1);
+      where(x > T(), x) = T();
+      where(x < T(), x) += T();
+      where(x >= T(), x) -= T();
+      where(x <= T(), x) *= T();
+      where(x != T(), x) += T(1);
+      return x;
+    }();
+
+    constexpr T c = V()[0];
+
+    constexpr auto d = !V() && !!V() || !V() & !V() | !V() ^ !V();
+
+    constexpr auto e = []() constexpr {
+      T data[V::size()] = {};
+      V(T(1)).copy_to(data, stdx::element_aligned);
+      V x = T();
+      x[0] = T(1);
+      x.copy_from(data, stdx::element_aligned);
+      bool mask[V::size()] = {};
+      auto k = hmin(x + x - x * x) == V(T(1));
+      k.copy_to(mask, stdx::element_aligned);
+      mask[0] = false;
+      using M = typename V::mask_type;
+      return M(mask, stdx::element_aligned);
+    }();
+
+    static_assert(not e[0]);
+    static_assert(popcount(e) == V::size() - 1);
+
+    static_assert(all_of(V(T(1)) == []() constexpr {
+      float data[V::size()] = {};
+      V(T(1)).copy_to(data, stdx::element_aligned);
+      V x = T();
+      x.copy_from(data, stdx::element_aligned);
+      return x;
+    }()));
+
+    static_assert(hmin(V()) == T());
+    static_assert(hmax(V()) == T());
+    static_assert(reduce(V(1)) == T(V::size()));
+  }
+
+template <typename T>
+  void
+  iterate_abis()
+  {
+    test01<T, stdx::simd<T, stdx::simd_abi::scalar>>();
+    test01<T, stdx::simd<T>>();
+    test01<T, stdx::native_simd<T>>();
+    test01<T, stdx::fixed_size_simd<T, 3>>();
+    test01<T, stdx::fixed_size_simd<T, stdx::simd_abi::max_fixed_size<T> - 4>>();
+  }
+
+int main()
+{
+  iterate_abis<char>();
+  iterate_abis<wchar_t>();
+  iterate_abis<char16_t>();
+  iterate_abis<char32_t>();
+
+  iterate_abis<signed char>();
+  iterate_abis<unsigned char>();
+  iterate_abis<short>();
+  iterate_abis<unsigned short>();
+  iterate_abis<int>();
+  iterate_abis<unsigned int>();
+  iterate_abis<long>();
+  iterate_abis<unsigned long>();
+  iterate_abis<long long>();
+  iterate_abis<unsigned long long>();
+  iterate_abis<float>();
+  iterate_abis<double>();
+  iterate_abis<long double>();
+}
diff --git a/libstdc++-v3/testsuite/experimental/simd/pr109822_cast_functions.cc b/libstdc++-v3/testsuite/experimental/simd/pr109822_cast_functions.cc
new file mode 100644
index 00000000000..3deafbf7a1f
--- /dev/null
+++ b/libstdc++-v3/testsuite/experimental/simd/pr109822_cast_functions.cc
@@ -0,0 +1,63 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++17 } }
+
+#include <experimental/simd>
+
+namespace stdx = std::experimental;
+
+template <typename T, typename V>
+  void
+  test01()
+  {
+    using M = typename V::mask_type;
+    [[maybe_unused]] auto x = to_fixed_size(V());
+    [[maybe_unused]] auto k = to_fixed_size(M());
+    if constexpr (stdx::simd<T>::size() == V::size())
+      {
+	[[maybe_unused]] auto xx = to_compatible(x);
+	[[maybe_unused]] auto kk = to_compatible(k);
+	x = to_fixed_size(xx);
+	k = to_fixed_size(kk);
+      }
+    if constexpr (stdx::native_simd<T>::size() == V::size())
+      {
+	[[maybe_unused]] auto xx = to_native(x);
+	[[maybe_unused]] auto kk = to_native(k);
+	x = to_fixed_size(xx);
+	k = to_fixed_size(kk);
+      }
+  }
+
+template <typename T>
+  void
+  iterate_abis()
+  {
+    test01<T, stdx::simd<T, stdx::simd_abi::scalar>>();
+    test01<T, stdx::simd<T>>();
+    test01<T, stdx::native_simd<T>>();
+    test01<T, stdx::fixed_size_simd<T, 3>>();
+    test01<T, stdx::fixed_size_simd<T, stdx::simd_abi::max_fixed_size<T> - 4>>();
+  }
+
+int
+main()
+{
+  iterate_abis<char>();
+  iterate_abis<wchar_t>();
+  iterate_abis<char16_t>();
+  iterate_abis<char32_t>();
+
+  iterate_abis<signed char>();
+  iterate_abis<unsigned char>();
+  iterate_abis<short>();
+  iterate_abis<unsigned short>();
+  iterate_abis<int>();
+  iterate_abis<unsigned int>();
+  iterate_abis<long>();
+  iterate_abis<unsigned long>();
+  iterate_abis<long long>();
+  iterate_abis<unsigned long long>();
+  iterate_abis<float>();
+  iterate_abis<double>();
+  iterate_abis<long double>();
+}
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/bits/verify.h b/libstdc++-v3/testsuite/experimental/simd/tests/bits/verify.h
index 82016c66802..ffa3e7f4cda 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/bits/verify.h
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/bits/verify.h
@@ -137,7 +137,7 @@ public:
     {
       if (m_failed)
 	[&] {
-	  __builtin_fprintf(stderr, "%s:%d: (%s):\nInstruction Pointer: %x\n"
+	  __builtin_fprintf(stderr, "%s:%d: (%s):\nInstruction Pointer: %zx\n"
 				    "Assertion '%s' failed.\n",
 			    file, line, func, m_ip, cond);
 	  (print(extra_info, int()), ...);
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/fpclassify.cc b/libstdc++-v3/testsuite/experimental/simd/tests/fpclassify.cc
index fe8a06174b1..30888c28c39 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/fpclassify.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/fpclassify.cc
@@ -40,9 +40,11 @@ template <typename V>
   {
     using T = typename V::value_type;
     using intv = std::experimental::fixed_size_simd<int, V::size()>;
+#if __GCC_IEC_559 >= 2
     constexpr T inf = std::__infinity_v<T>;
     constexpr T denorm_min = std::__infinity_v<T>;
     constexpr T nan = std::__quiet_NaN_v<T>;
+#endif
     constexpr T max = std::__finite_max_v<T>;
     constexpr T norm_min = std::__norm_min_v<T>;
     test_values<V>(
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/frexp.cc b/libstdc++-v3/testsuite/experimental/simd/tests/frexp.cc
index 918182d2221..0d895c4913e 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/frexp.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/frexp.cc
@@ -27,11 +27,17 @@ template <typename V>
   {
     using int_v = std::experimental::fixed_size_simd<int, V::size()>;
     using T = typename V::value_type;
+#if __GCC_IEC_559 >= 2 || defined __STDC_IEC_559__
     constexpr auto denorm_min = std::__denorm_min_v<T>;
+#endif
+#if __GCC_IEC_559 >= 2
     constexpr auto norm_min = std::__norm_min_v<T>;
+#endif
     constexpr auto max = std::__finite_max_v<T>;
+#if defined __STDC_IEC_559__
     constexpr auto nan = std::__quiet_NaN_v<T>;
     constexpr auto inf = std::__infinity_v<T>;
+#endif
     test_values<V>(
       {0, 0.25, 0.5, 1, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 31, -0., -0.25, -0.5, -1,
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/integer_operators.cc b/libstdc++-v3/testsuite/experimental/simd/tests/integer_operators.cc
index 7416952ad42..7a456b9f3bf 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/integer_operators.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/integer_operators.cc
@@ -180,11 +180,10 @@ template <typename V>
 	  for (int j = 0; j < 100; ++j)
 	    {
 	      const V seq([&](auto i) -> T { return (j + i) % n_promo_bits; });
-	      COMPARE(V(1) >> seq, V([&](auto i) { return T(T(1) >> seq[i]); }))
-		<< "seq = " << seq;
-	      COMPARE(make_value_unknown(V(1)) >> make_value_unknown(seq),
-		V([&](auto i) { return T(T(1) >> seq[i]); }))
-		<< "seq = " << seq;
+	      const V expect([&](auto i) { return seq[i] == 0 ? T(1) : T(0); });
+	      COMPARE(V(1) >> seq, expect) << "\nseq = " << seq;
+	      COMPARE(make_value_unknown(V(1)) >> make_value_unknown(seq), expect)
+		<< "\nseq = " << seq;
 	    }
 	  for_constexpr<int, 0, n_promo_bits - 1>([](auto shift_ic) {
 	    constexpr int shift = shift_ic;
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/ldexp_scalbn_scalbln_modf.cc b/libstdc++-v3/testsuite/experimental/simd/tests/ldexp_scalbn_scalbln_modf.cc
index e9719cc67fe..3c4f0c80361 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/ldexp_scalbn_scalbln_modf.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/ldexp_scalbn_scalbln_modf.cc
@@ -139,7 +139,6 @@ template <typename V>
 	if (modf_is_broken)
 	  return;
 	V integral = {};
-	const V totest = modf(input, &integral);
 	auto&& expected = [&](const auto& v) -> std::pair<const V, const V> {
 	  std::pair<V, V> tmp = {};
 	  using std::modf;
@@ -151,8 +150,9 @@ template <typename V>
 	    }
 	  return tmp;
 	};
+#ifdef __STDC_IEC_559__
+	const V totest = modf(input, &integral);
 	const auto expect1 = expected(input);
-#ifdef __STDC_IEC_559__
 	COMPARE(isnan(totest), isnan(expect1.first))
 	  << "modf(" << input << ", iptr) = " << totest << " != " << expect1;
 	COMPARE(isnan(integral), isnan(expect1.second))
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/logarithm.cc b/libstdc++-v3/testsuite/experimental/simd/tests/logarithm.cc
index b0dc9af6c81..d2e52646a7d 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/logarithm.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/logarithm.cc
@@ -30,11 +30,13 @@ template <typename V>
     vir::test::setFuzzyness<double>(1);
 
     using T = typename V::value_type;
+#ifdef __STDC_IEC_559__
     constexpr T nan = std::__quiet_NaN_v<T>;
     constexpr T inf = std::__infinity_v<T>;
     constexpr T denorm_min = std::__denorm_min_v<T>;
-    constexpr T norm_min = std::__norm_min_v<T>;
     constexpr T min = std::__finite_min_v<T>;
+#endif
+    constexpr T norm_min = std::__norm_min_v<T>;
     constexpr T max = std::__finite_max_v<T>;
     test_values<V>({1,
 		    2,
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/operator_cvt.cc b/libstdc++-v3/testsuite/experimental/simd/tests/operator_cvt.cc
index 8e7cfc5c25b..972888f7bcb 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/operator_cvt.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/operator_cvt.cc
@@ -220,8 +220,6 @@ template <typename V>
 	binary_op_return_type<vldouble, short>();
 	binary_op_return_type<vldouble, ushort>();
 	binary_op_return_type<vldouble, uint>();
-	binary_op_return_type<vldouble, long>();
-	binary_op_return_type<vldouble, ulong>();
 	binary_op_return_type<vldouble, float>();
 	binary_op_return_type<vldouble, double>();
 
@@ -231,8 +229,6 @@ template <typename V>
 	binary_op_return_type<vf64<long double>, ushort>();
 	binary_op_return_type<vf64<long double>, int>();
 	binary_op_return_type<vf64<long double>, uint>();
-	binary_op_return_type<vf64<long double>, long>();
-	binary_op_return_type<vf64<long double>, ulong>();
 	binary_op_return_type<vf64<long double>, float>();
 	binary_op_return_type<vf64<long double>, double>();
 	binary_op_return_type<vf64<long double>, vf64<long double>>();
@@ -245,8 +241,6 @@ template <typename V>
 	binary_op_return_type<simd<long double, A>, ushort>();
 	binary_op_return_type<simd<long double, A>, int>();
 	binary_op_return_type<simd<long double, A>, uint>();
-	binary_op_return_type<simd<long double, A>, long>();
-	binary_op_return_type<simd<long double, A>, ulong>();
 	binary_op_return_type<simd<long double, A>, float>();
 	binary_op_return_type<simd<long double, A>, double>();
 
@@ -258,6 +252,24 @@ template <typename V>
 	    VERIFY((is_substitution_failure<vf64<ldouble>, ullong>));
 	    VERIFY((is_substitution_failure<simd<ldouble, A>, llong>));
 	    VERIFY((is_substitution_failure<simd<ldouble, A>, ullong>));
+	    if constexpr (sizeof(long) == sizeof(llong))
+	      {
+		VERIFY((is_substitution_failure<vldouble, long>));
+		VERIFY((is_substitution_failure<vldouble, ulong>));
+		VERIFY((is_substitution_failure<vf64<ldouble>, long>));
+		VERIFY((is_substitution_failure<vf64<ldouble>, ulong>));
+		VERIFY((is_substitution_failure<simd<ldouble, A>, long>));
+		VERIFY((is_substitution_failure<simd<ldouble, A>, ulong>));
+	      }
+	    else
+	      {
+		binary_op_return_type<vldouble, long>();
+		binary_op_return_type<vldouble, ulong>();
+		binary_op_return_type<vf64<long double>, long>();
+		binary_op_return_type<vf64<long double>, ulong>();
+		binary_op_return_type<simd<long double, A>, long>();
+		binary_op_return_type<simd<long double, A>, ulong>();
+	      }
 	  }
 	else
 	  {
@@ -267,6 +279,12 @@ template <typename V>
 	    binary_op_return_type<vf64<long double>, ullong>();
 	    binary_op_return_type<simd<long double, A>, llong>();
 	    binary_op_return_type<simd<long double, A>, ullong>();
+	    binary_op_return_type<vldouble, long>();
+	    binary_op_return_type<vldouble, ulong>();
+	    binary_op_return_type<vf64<long double>, long>();
+	    binary_op_return_type<vf64<long double>, ulong>();
+	    binary_op_return_type<simd<long double, A>, long>();
+	    binary_op_return_type<simd<long double, A>, ulong>();
 	  }
 
 	VERIFY((is_substitution_failure<vf64<long double>, vldouble>));
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/operators.cc b/libstdc++-v3/testsuite/experimental/simd/tests/operators.cc
index 171bae5b05e..d0f5a1e5ce1 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/operators.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/operators.cc
@@ -223,7 +223,14 @@ template <typename V>
     }
 
     // divides
-    constexpr bool is_iec559 = __GCC_IEC_559 >= 2;
+    constexpr bool is_iec559 =
+#ifdef __GCC_IEC_559
+      __GCC_IEC_559 >= 2;
+#elif defined __STDC_IEC_559__
+      true;
+#else
+      false;
+#endif
     if constexpr (std::is_floating_point_v<T> && !is_iec559)
       { // avoid testing subnormals and expect minor deltas for non-IEC559 float
 	V x = 2;
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/reductions.cc b/libstdc++-v3/testsuite/experimental/simd/tests/reductions.cc
index 1f20961825b..07ab50a2312 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/reductions.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/reductions.cc
@@ -114,6 +114,7 @@ template <typename V>
       T acc = x[0];
       for (size_t i = 1; i < V::size(); ++i)
 	acc += x[i];
-      ULP_COMPARE(reduce(x), acc, V::size() / 2).on_failure("x = ", x);
+      const T max_distance = std::is_integral_v<T> ? 0 : V::size() / 2;
+      ULP_COMPARE(reduce(x), acc, max_distance).on_failure("x = ", x);
     });
   }
diff --git a/libstdc++-v3/testsuite/experimental/simd/tests/trunc_ceil_floor.cc b/libstdc++-v3/testsuite/experimental/simd/tests/trunc_ceil_floor.cc
index 0687662fae6..71ac01a3d99 100644
--- a/libstdc++-v3/testsuite/experimental/simd/tests/trunc_ceil_floor.cc
+++ b/libstdc++-v3/testsuite/experimental/simd/tests/trunc_ceil_floor.cc
@@ -25,8 +25,10 @@ template <typename V>
   test()
   {
     using T = typename V::value_type;
+#ifdef __STDC_IEC_559__
     constexpr T inf = std::__infinity_v<T>;
     constexpr T denorm_min = std::__denorm_min_v<T>;
+#endif
     constexpr T norm_min = std::__norm_min_v<T>;
     constexpr T max = std::__finite_max_v<T>;
     constexpr T min = std::__finite_min_v<T>;
diff --git a/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc b/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
index 5df9f330cd4..ed0614e2797 100644
--- a/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
+++ b/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
@@ -20,6 +20,7 @@
 // { dg-do run }
 // { dg-options "-pthread"  }
 // { dg-require-effective-target pthread }
+// { dg-timeout-factor 2 }
 
 #include <ext/rope>
 #include <cstring>
@@ -33,7 +34,7 @@ typedef __gnu_cxx::rope<char, std::allocator<char> > rope_type;
 rope_type foo2;
 rope_type foo4;
 
-void* thread_main(void *) 
+void* thread_main(void *)
 {
   // To see a problem with gcc 3.3 and before, set a break point here.
   // Single step through c_str implementation, call sched_yield after
diff --git a/libstdc++-v3/testsuite/lib/prune.exp b/libstdc++-v3/testsuite/lib/prune.exp
index 6c905631f16..2ebfb922ef4 100644
--- a/libstdc++-v3/testsuite/lib/prune.exp
+++ b/libstdc++-v3/testsuite/lib/prune.exp
@@ -46,6 +46,7 @@ proc libstdc++-dg-prune { system text } {
     regsub -all "(^|\n)\[^\n\]*(: )?At (top level|global scope):\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*:   (recursively )?required \[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*:   . skipping \[0-9\]* instantiation contexts \[^\n\]*" $text "" text
+    regsub -all "(^|\n)\[^\n\]*:   in .constexpr. expansion \[^\n\]*" $text "" text
     regsub -all "(^|\n)    inlined from \[^\n\]*" $text "" text
     # Why doesn't GCC need these to strip header context?
     regsub -all "(^|\n)In file included from \[^\n\]*" $text "" text
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
index 7b5d9795df7..0545076fb6f 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx11.cc
@@ -25,6 +25,7 @@
 #include <memory>
 #include <iostream>
 #include <future>
+#include <initializer_list>
 #include "../util/testsuite_allocator.h" // NullablePointer
 
 typedef std::tuple<int, int> ExTuple;
@@ -191,6 +192,11 @@ main()
   std::error_code ecfut0 = std::make_error_code(std::future_errc{});
   // { dg-final { note-test ecfut0 {std::error_code = {"future": 0}} } }
 
+  std::initializer_list<int> emptyIl = {};
+  // { dg-final { note-test emptyIl {std::initializer_list of length 0} } }
+  std::initializer_list<int> il = {3, 4};
+  // { dg-final { note-test il {std::initializer_list of length 2 = {3, 4}} } }
+
   placeholder(""); // Mark SPOT
   use(efl);
   use(fl);
diff --git a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx20.cc b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx20.cc
index d9b47114d57..c0eded2302a 100644
--- a/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx20.cc
+++ b/libstdc++-v3/testsuite/libstdc++-prettyprinters/cxx20.cc
@@ -18,8 +18,10 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
+#include <array>
 #include <compare>
 #include <iostream>
+#include <span>
 
 struct X
 {
@@ -54,6 +56,15 @@ main()
   auto c10 = 0.0 <=> __builtin_nan("");
 // { dg-final { note-test c10 "std::partial_ordering::unordered" } }
 
+  auto il = {1, 2};
+  auto s1 = std::span(il);
+  static_assert(s1.extent == std::size_t(-1));
+// { dg-final { note-test s1 {std::span of length 2 = {1, 2}} } }
+  auto a = std::array{3, 4};
+  auto s2 = std::span(a);
+  static_assert(s2.extent == std::size_t(2));
+// { dg-final { note-test s2 {std::span of length 2 = {3, 4}} } }
+
   std::cout << "\n";
   return 0;			// Mark SPOT
 }
diff --git a/libstdc++-v3/testsuite/libstdc++-xmethods/shared_ptr.cc b/libstdc++-v3/testsuite/libstdc++-xmethods/shared_ptr.cc
index e7cdfa4bd53..7b9e3e5534d 100644
--- a/libstdc++-v3/testsuite/libstdc++-xmethods/shared_ptr.cc
+++ b/libstdc++-v3/testsuite/libstdc++-xmethods/shared_ptr.cc
@@ -36,6 +36,8 @@ main ()
 
   std::shared_ptr<x_struct[3]> s(new x_struct[2]{ {92}, {115} });
 
+  auto qq = q;
+
 // { dg-final { note-test *p 10 } }
 // { dg-final { regexp-test p.get() 0x.* } }
 
@@ -66,6 +68,11 @@ main ()
 // { dg-final { whatis-test s.get() "x_struct \*" } }
 // { dg-final { whatis-test s\[1].y int } }
 
+// { dg-final { note-test p.use_count() 1 } }
+// { dg-final { note-test p.unique() true } }
+// { dg-final { note-test q.use_count() 2 } }
+// { dg-final { note-test q.unique() false } }
+
   return 0;  // Mark SPOT
 }
 
diff --git a/libstdc++-v3/testsuite/std/ranges/access/empty.cc b/libstdc++-v3/testsuite/std/ranges/access/empty.cc
index b2d8b105325..693355c6cf5 100644
--- a/libstdc++-v3/testsuite/std/ranges/access/empty.cc
+++ b/libstdc++-v3/testsuite/std/ranges/access/empty.cc
@@ -119,6 +119,16 @@ test04()
   static_assert( ! noexcept(std::ranges::empty(E3{})) );
 }
 
+template<typename T>
+  concept has_empty = requires (T& t) { std::ranges::empty(t); };
+
+// If T is an array of unknown bound, ranges::empty(E) is ill-formed.
+static_assert( ! has_empty<int[]> );
+static_assert( ! has_empty<int(&)[]> );
+static_assert( ! has_empty<int[][2]> );
+struct Incomplete;
+static_assert( ! has_empty<Incomplete[]> );
+
 int
 main()
 {
diff --git a/libstdc++-v3/testsuite/std/ranges/access/size.cc b/libstdc++-v3/testsuite/std/ranges/access/size.cc
index f25a1cb9ddb..db843cddccb 100644
--- a/libstdc++-v3/testsuite/std/ranges/access/size.cc
+++ b/libstdc++-v3/testsuite/std/ranges/access/size.cc
@@ -120,6 +120,16 @@ test06()
   static_assert( std::ranges::size(R{}) == 42 );
 }
 
+template<typename T>
+  concept has_size = requires (T& t) { std::ranges::size(t); };
+
+// If T is an array of unknown bound, ranges::size(E) is ill-formed.
+static_assert( ! has_size<int[]> );
+static_assert( ! has_size<int(&)[]> );
+static_assert( ! has_size<int[][2]> );
+struct Incomplete;
+static_assert( ! has_size<Incomplete[]> );
+
 int
 main()
 {
diff --git a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
index d774e8d9385..14e254bc734 100644
--- a/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
+++ b/libstdc++-v3/testsuite/std/ranges/adaptors/join.cc
@@ -193,6 +193,20 @@ test11()
     ;
 }
 
+void
+test13()
+{
+  // PR libstdc++/106320
+  auto l = std::views::transform([](auto x) {
+    return x | std::views::transform([x=0](auto y) {
+      return y;
+    });
+  });
+  static_assert(!std::default_initializable<decltype(l)>);
+  std::vector<std::vector<int>> v{{5, 6, 7}};
+  v | l | std::views::join;
+}
+
 int
 main()
 {
@@ -207,4 +221,5 @@ main()
   test09();
   test10();
   test11();
+  test13();
 }
diff --git a/libstdc++-v3/testsuite/std/ranges/iota/max_size_type.cc b/libstdc++-v3/testsuite/std/ranges/iota/max_size_type.cc
index 983bdfbdaa6..5130447103f 100644
--- a/libstdc++-v3/testsuite/std/ranges/iota/max_size_type.cc
+++ b/libstdc++-v3/testsuite/std/ranges/iota/max_size_type.cc
@@ -25,8 +25,14 @@
 using max_size_t = std::ranges::__detail::__max_size_type;
 using max_diff_t = std::ranges::__detail::__max_diff_type;
 using rep_t = max_size_t::__rep;
+#if __SIZEOF_INT128__
+using signed_rep_t = __int128;
+#else
+using signed_rep_t = long long;
+#endif
 
 static_assert(sizeof(max_size_t) == sizeof(max_diff_t));
+static_assert(sizeof(rep_t) == sizeof(signed_rep_t));
 
 static_assert(std::regular<max_size_t>);
 static_assert(std::totally_ordered<max_size_t>);
@@ -53,6 +59,8 @@ test01()
   static_assert(max_diff_t(3) % -2 == 1);
   static_assert(max_diff_t(-3) << 1 == -6);
   static_assert(max_diff_t(-3) >> 1 == -2);
+  static_assert(max_diff_t(-3) >> 2 == -1);
+  static_assert(max_diff_t(-3) >> 10 == -1);
   static_assert(max_diff_t(3) >> 1 == 1);
   static_assert(max_diff_t(3) >> 2 == 0);
 
@@ -187,7 +195,7 @@ template<bool signed_p, bool shorten_p>
 void
 test02()
 {
-  using hw_type = std::conditional_t<signed_p, signed rep_t, rep_t>;
+  using hw_type = std::conditional_t<signed_p, signed_rep_t, rep_t>;
   using max_type = std::conditional_t<signed_p, max_diff_t, max_size_t>;
   using shorten_type = std::conditional_t<shorten_p, hw_type, max_type>;
   const int hw_type_bit_size = sizeof(hw_type) * __CHAR_BIT__;
@@ -245,7 +253,7 @@ template<bool signed_p, bool toggle_base_p>
 void
 test03()
 {
-  using hw_type = std::conditional_t<signed_p, signed rep_t, rep_t>;
+  using hw_type = std::conditional_t<signed_p, signed_rep_t, rep_t>;
   using max_type = std::conditional_t<signed_p, max_diff_t, max_size_t>;
   using base_type = std::conditional_t<toggle_base_p, hw_type, max_type>;
   constexpr int hw_type_bit_size = sizeof(hw_type) * __CHAR_BIT__;
diff --git a/libstdc++-v3/testsuite/std/ranges/p2325.cc b/libstdc++-v3/testsuite/std/ranges/p2325.cc
index 205b3458928..ab743916f5b 100644
--- a/libstdc++-v3/testsuite/std/ranges/p2325.cc
+++ b/libstdc++-v3/testsuite/std/ranges/p2325.cc
@@ -5,8 +5,8 @@
 // Parts of P2325R3 are deliberately omitted in libstdc++ 11, in particular the
 // removal of default ctors for back_/front_insert_iterator, ostream_iterator,
 // ref_view and basic_istream_view/::iterator, so as to maximize backward
-// compatibility with pre-P2325R3 code.  So most static_asserts in this test fail,
-// see the xfails at the end of this file.
+// compatibility with pre-P2325R3 code.  Namely all asserts that verify lack of
+// default constructibility fail; see the xfails at the end of this file.
 
 #include <ranges>
 #include <iterator>
@@ -93,7 +93,7 @@ test06()
   static_assert(default_initializable<decltype(views::single(0) | adaptor(f1))>);
   static_assert(!default_initializable<decltype(views::single(0) | adaptor(f2))>);
 
-  struct S { S() = delete; };
+  struct S { S() = delete; S(const S&) = default; S(S&&) = default; };
   static_assert(!default_initializable<decltype(views::single(declval<S>()) | adaptor(f1))>);
   static_assert(!default_initializable<decltype(views::single(declval<S>()) | adaptor(f2))>);
 }
@@ -109,7 +109,7 @@ void
 test07()
 {
   // Verify join_view is conditionally default constructible.
-  struct S { S() = delete; };
+  struct S { S() = delete; S(const S&) = default; S(S&&) = default; };
   using type1 = ranges::join_view<ranges::single_view<ranges::single_view<S>>>;
   static_assert(!default_initializable<type1>);
   using type2 = ranges::join_view<ranges::single_view<ranges::single_view<int>>>;
@@ -173,6 +173,10 @@ test11()
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 76 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 77 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 84 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 94 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 97 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 98 }
+// { dg-bogus "static assertion failed" "" { xfail *-*-* } 114 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 124 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 126 }
 // { dg-bogus "static assertion failed" "" { xfail *-*-* } 128 }
diff --git a/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc b/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
index d3374309034..a61f0095b06 100644
--- a/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
+++ b/libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc
@@ -59,5 +59,57 @@ constexpr_hh_mm_ss()
 
   static_assert(seconds{hh_mm_ss{100min}} == 100min);
 
-  // TODO: treat_as_floating_point_v
+  // treat_as_floating_point_v
+  using fseconds = duration<double, ratio<1>>;
+  constexpr hh_mm_ss<fseconds> fsec{0x123.0004p5s};
+  static_assert(std::is_same_v<hh_mm_ss<fseconds>::precision, fseconds>);
+  static_assert(fsec.hours() == 2h);
+  static_assert(fsec.minutes() == 35min);
+  static_assert(fsec.seconds() == 12s);
+  static_assert(fsec.subseconds() == 0x.0004p5s);
+  static_assert(!fsec.is_negative());
+  static_assert(fsec.to_duration() == 0x123.0004p5s);
+
+  using fminutes = duration<double, ratio<60>>;
+  constexpr hh_mm_ss<fminutes> fmin{-0x1.23p4min};
+  static_assert(std::is_same_v<hh_mm_ss<fminutes>::precision, fseconds>);
+  static_assert(fmin.hours() == 0h);
+  static_assert(fmin.minutes() == 18min);
+  static_assert(fmin.seconds() == 11s);
+  static_assert(fmin.subseconds() == 0.25s);
+  static_assert(fmin.is_negative());
+  static_assert(fmin.to_duration() == -0x1.23p4min);
+}
+
+constexpr void
+default_construction()
+{
+  using namespace std::chrono;
+
+  constexpr hh_mm_ss<seconds> s1;
+  static_assert(s1.to_duration() == s1.to_duration().zero());
+  constexpr hh_mm_ss<duration<char>> s2;
+  static_assert(s2.to_duration() == s2.to_duration().zero());
+  constexpr hh_mm_ss<duration<int, std::centi>> s3;
+  static_assert(s3.to_duration() == s3.to_duration().zero());
+  constexpr hh_mm_ss<duration<long long, std::femto>> s4;
+  static_assert(s4.to_duration() == s4.to_duration().zero());
+  constexpr hh_mm_ss<duration<double>> s5;
+  static_assert(s5.to_duration() == s5.to_duration().zero());
+}
+
+constexpr void
+unsigned_rep()
+{
+  using namespace std::chrono;
+
+  constexpr duration<unsigned, std::milli> ms(3690001);
+
+  constexpr hh_mm_ss hms(ms); // PR libstdc++/108265
+  static_assert( ! hms.is_negative() );
+  static_assert( hms.to_duration() == milliseconds(ms.count()) );
+  static_assert( hms.hours() == 1h );
+  static_assert( hms.minutes() == 1min );
+  static_assert( hms.seconds() == 30s );
+  static_assert( hms.subseconds() == 1ms );
 }
diff --git a/libvtv/ChangeLog b/libvtv/ChangeLog
index 645e54ac68a..461c60cc6a6 100644
--- a/libvtv/ChangeLog
+++ b/libvtv/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/lto-plugin/ChangeLog b/lto-plugin/ChangeLog
index 8f6a82dcb30..c2b293754b8 100644
--- a/lto-plugin/ChangeLog
+++ b/lto-plugin/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/maintainer-scripts/ChangeLog b/maintainer-scripts/ChangeLog
index fcc1d00c457..87162feab3a 100644
--- a/maintainer-scripts/ChangeLog
+++ b/maintainer-scripts/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/zlib/ChangeLog b/zlib/ChangeLog
index 3fe844981d3..f58f57983c1 100644
--- a/zlib/ChangeLog
+++ b/zlib/ChangeLog
@@ -1,3 +1,7 @@
+2023-05-29  Release Manager
+
+	* GCC 11.4.0 released.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
