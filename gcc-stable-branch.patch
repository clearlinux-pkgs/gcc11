Fritz Reese (1):
      fortran: Fix conv of UNION constructors [PR105310]

GCC Administrator (7):
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.
      Daily bump.

Hongyu Wang (1):
      AVX512F: Add missing macro for mask(z?)_scalf_s[sd] [PR 105339]

Iain Buclaw (2):
      libphobos: Don't call free on the TLS array in the emutls destroy function.
      libphobos: Give _Unwind_Exception an alignment that best resembles __attribute__((aligned))

Jakub Jelinek (2):
      emit-rtl: Fix -fcompare-debug bug with label references in debug insns [PR105203]
      sparc: Preserve ORIGINAL_REGNO in epilogue_renumber [PR105257]

Jonathan Wakely (29):
      libstdc++: Avoid -Wzero-as-null-pointer-constant warning [PR103848]
      libstdc++: Fix warning in __moneypunct_cache::_M_cache [PR104966]
      libstdc++: Fix macro checked by test
      libstdc++: Fix incorrect IS number in doc comment
      libstdc++: Use LTLIBICONV when linking libstdc++.so [PR93602]
      libstdc++: Fix test failure on AIX
      libstdc++: Increase timeout for pthread7-rope.cc test
      libstdc++: Avoid overflow in ranges::advance(i, n, bound)
      libstdc++: Do not use std::isdigit in <charconv> [PR103911]
      libstdc++: Ignore cv-quals when std::allocator<void> constructs
      libstdc++: Avoid unwanted allocations in filesystem::path
      libstdc++: Reorder constraints on std::span::span(Range&&) constructor.
      libstdc++: Improvements to standard error category objects (part deux)
      libstdc++: Use std::construct_at in net::ip::address
      libstdc++: Add missing noexcept to lazy_split_view iterator (LWG 3593)
      libstdc++: Add another non-reserved name to tests
      libstdc++: Fix non-reserved name in <regex> header
      libstdc++: Fix tests that fail with fully-dynamic-string
      libstdc++: Ensure C++20 std::stringstream definitions use correct ABI
      libstdc++: Use secure_getenv for filesystem::temp_directory_path() [PR65018]
      libstdc++: Remove bogus assertion in std::from_chars [PR105324]
      libstdc++: Fix filesystem::temp_directory_path [PR101709]
      libstdc++: Fix test that fails in C++20 mode
      libstdc++: Fix ambiguous comparisons for iterators in C++20
      libstdc++: Fix test failures at -O0
      libstdc++: Remove "no stronger" assertion in compare exchange [PR102177]
      libstdc++: Remove workaround for FE bug in std::tuple [PR96592]
      libstdc++: Add deduction guides for std::packaged_task [PR105375]
      libstdc++: Fix error reporting in filesystem::copy [PR99290]

Marek Polacek (4):
      c++: ambiguous call not diagnosed after DR2352 [PR97296]
      c++: wrong error with constexpr COMPOUND_EXPR [PR105321]
      c++: enum in generic lambda at global scope [PR105398]
      c++: global-namespace-qualified var after class def [PR90107]

Matthias Kretz (1):
      c++: don't ICE on NAMESPACE_DECL inside FUNCTION_DECL

Patrick Palka (3):
      c++: partial ordering with dependent NTTP type [PR105289]
      c++: ICE with requires-expr and -Wsequence-point [PR105304]
      c++: decltype of non-dependent call of class type [PR105386]

Pavel I. Kryukov (1):
      libstdc++: Add self-merge check to std::forward_list::merge [PR103853]

Richard Biener (1):
      Update BASE-VER to 11.3.1

Sergei Trofimovich (1):
      gcov-profile: Allow negative counts of indirect calls [PR105282]

Tamar Christina (1):
      testsuite: Backport testsuite changes from GCC 12 to GCC 11

Thomas W Rodgers (1):
      libstdc++: Make atomic notify_one and notify_all non-const

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index f628d2eafc5..0a47c95bb14 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-11.3.0
+11.3.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index a0587d18824..47f3049af9c 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,51 @@
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* config/i386/avx512fintrin.h (_mm512_scalef_round_pd):
+	Add parentheses for parameters and djust format.
+	(_mm512_mask_scalef_round_pd): Ditto.
+	(_mm512_maskz_scalef_round_pd): Ditto.
+	(_mm512_scalef_round_ps): Ditto.
+	(_mm512_mask_scalef_round_ps): Ditto.
+	(_mm512_maskz_scalef_round_ps): Ditto.
+	(_mm_scalef_round_sd): Use _mm_undefined_pd.
+	(_mm_scalef_round_ss): Use _mm_undefined_ps.
+	(_mm_mask_scalef_round_sd): New macro.
+	(_mm_mask_scalef_round_ss): Ditto.
+	(_mm_maskz_scalef_round_sd): Ditto.
+	(_mm_maskz_scalef_round_ss): Ditto.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* config/sparc/sparc.c (epilogue_renumber): If ORIGINAL_REGNO,
+	use gen_raw_REG instead of gen_rtx_REG and copy over also
+	ORIGINAL_REGNO.  Use return 0; instead of /* fallthrough */.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/105203
+	* emit-rtl.c (emit_copy_of_insn_after): Don't call mark_jump_label
+	on DEBUG_INSNs.
+
+2022-04-21  Sergei Trofimovich  <siarheit@google.com>
+
+	Backported from master:
+	2022-04-19  Sergei Trofimovich  <siarheit@google.com>
+
+	PR gcov-profile/105282
+	* value-prof.c (stream_out_histogram_value): Allow negative counts
+	on HIST_TYPE_INDIR_CALL.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 7b8f49d78dc..16fc52302e5 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -1854,12 +1854,12 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,
   enum tree_code code;
   enum tree_code_class cl;
 
+ restart:
   /* X may be NULL if it is the operand of an empty statement expression
      ({ }).  */
   if (x == NULL)
     return;
 
- restart:
   code = TREE_CODE (x);
   cl = TREE_CODE_CLASS (code);
 
diff --git a/gcc/config/i386/avx512fintrin.h b/gcc/config/i386/avx512fintrin.h
index 515ee0c1728..1ce6bade1b4 100644
--- a/gcc/config/i386/avx512fintrin.h
+++ b/gcc/config/i386/avx512fintrin.h
@@ -3244,31 +3244,67 @@ _mm_maskz_scalef_round_ss (__mmask8 __U, __m128 __A, __m128 __B, const int __R)
 						      (__mmask8) __U, __R);
 }
 #else
-#define _mm512_scalef_round_pd(A, B, C)            \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_undefined_pd(), -1, C)
-
-#define _mm512_mask_scalef_round_pd(W, U, A, B, C) \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, W, U, C)
-
-#define _mm512_maskz_scalef_round_pd(U, A, B, C)   \
-    (__m512d)__builtin_ia32_scalefpd512_mask(A, B, (__v8df)_mm512_setzero_pd(), U, C)
+#define _mm512_scalef_round_pd(A, B, C)					\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_undefined_pd(),	\
+				   -1, (C)))
+
+#define _mm512_mask_scalef_round_pd(W, U, A, B, C)			\
+  ((__m512d) __builtin_ia32_scalefpd512_mask((A), (B), (W), (U), (C)))
+
+#define _mm512_maskz_scalef_round_pd(U, A, B, C)			\
+  ((__m512d)								\
+   __builtin_ia32_scalefpd512_mask((A), (B),				\
+				   (__v8df) _mm512_setzero_pd(),	\
+				   (U), (C)))
+
+#define _mm512_scalef_round_ps(A, B, C)					\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_undefined_ps(),	\
+				   -1, (C)))
+
+#define _mm512_mask_scalef_round_ps(W, U, A, B, C)			\
+  ((__m512) __builtin_ia32_scalefps512_mask((A), (B), (W), (U), (C)))
+
+#define _mm512_maskz_scalef_round_ps(U, A, B, C)			\
+  ((__m512)								\
+   __builtin_ia32_scalefps512_mask((A), (B),				\
+				   (__v16sf) _mm512_setzero_ps(),	\
+				   (U), (C)))
+
+#define _mm_scalef_round_sd(A, B, C)					\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_undefined_pd (),	\
+				       -1, (C)))
 
-#define _mm512_scalef_round_ps(A, B, C)            \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_undefined_ps(), -1, C)
+#define _mm_scalef_round_ss(A, B, C)					\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_undefined_ps (),	\
+				       -1, (C)))
 
-#define _mm512_mask_scalef_round_ps(W, U, A, B, C) \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, W, U, C)
+#define _mm_mask_scalef_round_sd(W, U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B), (W), (U), (C)))
 
-#define _mm512_maskz_scalef_round_ps(U, A, B, C)   \
-    (__m512)__builtin_ia32_scalefps512_mask(A, B, (__v16sf)_mm512_setzero_ps(), U, C)
+#define _mm_mask_scalef_round_ss(W, U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B), (W), (U), (C)))
 
-#define _mm_scalef_round_sd(A, B, C)            \
-    (__m128d)__builtin_ia32_scalefsd_mask_round (A, B, \
-	(__v2df)_mm_setzero_pd (), -1, C)
+#define _mm_maskz_scalef_round_sd(U, A, B, C)				\
+  ((__m128d)								\
+   __builtin_ia32_scalefsd_mask_round ((A), (B),			\
+				       (__v2df) _mm_setzero_pd (),	\
+				       (U), (C)))
 
-#define _mm_scalef_round_ss(A, B, C)            \
-    (__m128)__builtin_ia32_scalefss_mask_round (A, B, \
-	(__v4sf)_mm_setzero_ps (), -1, C)
+#define _mm_maskz_scalef_round_ss(U, A, B, C)				\
+  ((__m128)								\
+   __builtin_ia32_scalefss_mask_round ((A), (B),			\
+				       (__v4sf) _mm_setzero_ps (),	\
+				       (U), (C)))
 #endif
 
 #define _mm_mask_scalef_sd(W, U, A, B) \
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index 7c8a1f18c39..0ef91935c1e 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -8956,8 +8956,20 @@ epilogue_renumber (rtx *where, int test)
       if (REGNO (*where) >= 8 && REGNO (*where) < 24)      /* oX or lX */
 	return 1;
       if (! test && REGNO (*where) >= 24 && REGNO (*where) < 32)
-	*where = gen_rtx_REG (GET_MODE (*where), OUTGOING_REGNO (REGNO(*where)));
-      /* fallthrough */
+	{
+	  if (ORIGINAL_REGNO (*where))
+	    {
+	      rtx n = gen_raw_REG (GET_MODE (*where),
+				   OUTGOING_REGNO (REGNO (*where)));
+	      ORIGINAL_REGNO (n) = ORIGINAL_REGNO (*where);
+	      *where = n;
+	    }
+	  else
+	    *where = gen_rtx_REG (GET_MODE (*where),
+				  OUTGOING_REGNO (REGNO (*where)));
+	}
+      return 0;
+
     case SCRATCH:
     case CC0:
     case PC:
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 85c8fdd38cd..67d7d721985 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,37 @@
+2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105398
+	* pt.c (uses_template_parms): Return false for any NAMESPACE_DECL.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105321
+	* constexpr.c (cxx_eval_logical_expression): Always pass false for lval
+	to cxx_eval_constant_expression.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97296
+	* call.c (direct_reference_binding): strip_top_quals when creating
+	a ck_qual.
+
+2022-04-21  Matthias Kretz  <m.kretz@gsi.de>
+
+	Backported from master:
+	2021-12-19  Matthias Kretz  <m.kretz@gsi.de>
+
+	* module.cc (trees_out::get_merge_kind): NAMESPACE_DECLs also
+	cannot have a DECL_TEMPLATE_INFO.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 55bb9c45f8c..023e5e0f4b5 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -1683,8 +1683,19 @@ direct_reference_binding (tree type, conversion *conv)
        because the types "int *" and "const int *const" are
        reference-related and we were binding both directly and they
        had the same rank.  To break it up, we add a ck_qual under the
-       ck_ref_bind so that conversion sequence ranking chooses #1.  */
-    conv = build_conv (ck_qual, t, conv);
+       ck_ref_bind so that conversion sequence ranking chooses #1.
+
+       We strip_top_quals here which is also what standard_conversion
+       does.  Failure to do so would confuse comp_cv_qual_signature
+       into thinking that in
+
+	 void f(const int * const &); // #1
+	 void f(const int *); // #2
+	 int *x;
+	 f(x);
+
+       #2 is a better match than #1 even though they're ambiguous (97296).  */
+    conv = build_conv (ck_qual, strip_top_quals (t), conv);
 
   return build_conv (ck_ref_bind, type, conv);
 }
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index c13c920ade3..d72a8712dab 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -4280,19 +4280,18 @@ cxx_eval_bit_cast (const constexpr_ctx *ctx, tree t, bool *non_constant_p,
 static tree
 cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,
                              tree bailout_value, tree continue_value,
-			     bool lval,
-			     bool *non_constant_p, bool *overflow_p)
+			     bool, bool *non_constant_p, bool *overflow_p)
 {
   tree r;
   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),
-					   lval,
-					   non_constant_p, overflow_p);
+					   /*lval*/false, non_constant_p,
+					   overflow_p);
   VERIFY_CONSTANT (lhs);
   if (tree_int_cst_equal (lhs, bailout_value))
     return lhs;
   gcc_assert (tree_int_cst_equal (lhs, continue_value));
   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),
-				    lval, non_constant_p,
+				    /*lval*/false, non_constant_p,
 				    overflow_p);
   VERIFY_CONSTANT (r);
   return r;
diff --git a/gcc/cp/module.cc b/gcc/cp/module.cc
index b97b1bcb2f8..6cb926c044a 100644
--- a/gcc/cp/module.cc
+++ b/gcc/cp/module.cc
@@ -10059,9 +10059,10 @@ trees_out::get_merge_kind (tree decl, depset *dep)
       tree ctx = CP_DECL_CONTEXT (decl);
       if (TREE_CODE (ctx) == FUNCTION_DECL)
 	{
-	  /* USING_DECLs cannot have DECL_TEMPLATE_INFO -- this isn't
-	     permitting them to have one.   */
+	  /* USING_DECLs and NAMESPACE_DECLs cannot have DECL_TEMPLATE_INFO --
+	     this isn't permitting them to have one.   */
 	  gcc_checking_assert (TREE_CODE (decl) == USING_DECL
+			       || TREE_CODE (decl) == NAMESPACE_DECL
 			       || !DECL_LANG_SPECIFIC (decl)
 			       || !DECL_TEMPLATE_INFO (decl));
 
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 90d119eaa28..365d5989773 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -24967,6 +24967,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)
       case CPP_OPEN_PAREN:
       case CPP_CLOSE_PAREN:
       case CPP_COMMA:
+      case CPP_SCOPE:
         want_semicolon = false;
         break;
 
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 318d42d800d..c98acbec481 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -5200,8 +5200,9 @@ process_partial_specialization (tree decl)
 	   && !get_partial_spec_bindings (maintmpl, maintmpl, specargs))
     {
       auto_diagnostic_group d;
-      if (permerror (input_location, "partial specialization %qD is not "
-		     "more specialized than", decl))
+      if (pedwarn (input_location, 0,
+		   "partial specialization %qD is not more specialized than",
+		   decl))
 	inform (DECL_SOURCE_LOCATION (maintmpl), "primary template %qD",
 		maintmpl);
     }
@@ -10889,7 +10890,7 @@ uses_template_parms (tree t)
 		   || uses_template_parms (TREE_CHAIN (t)));
   else if (TREE_CODE (t) == TYPE_DECL)
     dependent_p = dependent_type_p (TREE_TYPE (t));
-  else if (t == error_mark_node)
+  else if (t == error_mark_node || TREE_CODE (t) == NAMESPACE_DECL)
     dependent_p = false;
   else
     dependent_p = instantiation_dependent_expression_p (t);
@@ -23928,7 +23929,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,
 	      /* Now check whether the type of this parameter is still
 		 dependent, and give up if so.  */
 	      ++processing_template_decl;
-	      tparm = tsubst (tparm, targs, tf_none, NULL_TREE);
+	      tparm = tsubst (TREE_TYPE (parm), targs, tf_none, NULL_TREE);
 	      --processing_template_decl;
 	      if (uses_template_parms (tparm))
 		return unify_success (explain_p);
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index d447ce80174..36ad96febf3 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -10220,7 +10220,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,
     }
   else if (processing_template_decl)
     {
-      expr = instantiate_non_dependent_expr_sfinae (expr, complain);
+      expr = instantiate_non_dependent_expr_sfinae (expr, complain|tf_decltype);
       if (expr == error_mark_node)
 	return error_mark_node;
     }
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
index 07e908624a0..0dc51220682 100644
--- a/gcc/emit-rtl.c
+++ b/gcc/emit-rtl.c
@@ -6465,7 +6465,8 @@ emit_copy_of_insn_after (rtx_insn *insn, rtx_insn *after)
     }
 
   /* Update LABEL_NUSES.  */
-  mark_jump_label (PATTERN (new_rtx), new_rtx, 0);
+  if (NONDEBUG_INSN_P (insn))
+    mark_jump_label (PATTERN (new_rtx), new_rtx, 0);
 
   INSN_LOCATION (new_rtx) = INSN_LOCATION (insn);
 
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index ee1c7bb4b31..3d03b1cb5d2 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,11 @@
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* trans-expr.c (gfc_conv_union_initializer): Pass vec* by reference.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
index a5c391d077e..9b65b9cf474 100644
--- a/gcc/fortran/trans-expr.c
+++ b/gcc/fortran/trans-expr.c
@@ -8782,8 +8782,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init, bool coarray)
   return gfc_finish_block (&block);
 }
 
-void
-gfc_conv_union_initializer (vec<constructor_elt, va_gc> *v,
+static void
+gfc_conv_union_initializer (vec<constructor_elt, va_gc> *&v,
                             gfc_component *un, gfc_expr *init)
 {
   gfc_constructor *ctor;
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 5fc23605244..3f0edd90f3e 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,60 @@
+2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105398
+	* g++.dg/cpp1y/lambda-generic-enum2.C: New test.
+
+2022-04-27  Hongyu Wang  <hongyu.wang@intel.com>
+
+	Backported from master:
+	2022-04-25  Hongyu Wang  <hongyu.wang@intel.com>
+
+	PR target/105339
+	* gcc.target/i386/sse-14.c: Add tests for new macro.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/105321
+	* g++.dg/cpp0x/constexpr-105321.C: New test.
+
+2022-04-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from master:
+	2022-04-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/97296
+	* g++.dg/cpp0x/ref-bind4.C: Add dg-error.
+	* g++.dg/cpp0x/ref-bind8.C: New test.
+
+2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	Backported from master:
+	2022-04-21  Fritz Reese  <foreese@gcc.gnu.org>
+
+	PR fortran/105310
+	* gfortran.dg/dec_union_12.f90: New test.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/105257
+	* gcc.dg/pr105257.c: New test.
+
+2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/105203
+	* gfortran.dg/g77/pr105203.f: New test.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C
new file mode 100644
index 00000000000..adb6830ff22
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-105321.C
@@ -0,0 +1,18 @@
+// PR c++/105321
+// { dg-do compile { target c++11 } }
+
+bool handle_error();
+
+constexpr int echo(int value, bool yes = true) noexcept
+{
+    return (yes || handle_error()), value;
+}
+
+static_assert(echo(10) == 10, "");
+
+constexpr int echo2(int value, bool no = false) noexcept
+{
+    return (!no || handle_error()), value;
+}
+
+static_assert(echo2(10) == 10, "");
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype81.C b/gcc/testsuite/g++.dg/cpp0x/decltype81.C
new file mode 100644
index 00000000000..7d25db39d9c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype81.C
@@ -0,0 +1,15 @@
+// PR c++/105386
+// { dg-do compile { target c++11 } }
+
+template<class T> struct NoInst {
+  static_assert(sizeof(T) == 9999, "NoInst instantiated");
+};
+
+template<class T> NoInst<T> f(T);
+
+template<class>
+struct A {
+  using type = decltype(f(0));
+};
+
+A<int> a;
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C b/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
index 85ac9fbfd79..d296d7c3b72 100644
--- a/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-bind4.C
@@ -51,6 +51,6 @@ g (int *p, const int *pc, const int **q)
      similar  types  T1 and T2 (_conv.qual_), respectively, and the cv-
      qualification signature of type T1 is a proper subset of  the  cv-
      qualification signature of type T2  */
-  f8 (q);
+  f8 (q); // { dg-error "call of overloaded" }
   f9 (q);
 }
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C b/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C
new file mode 100644
index 00000000000..eee78fd5e74
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-bind8.C
@@ -0,0 +1,10 @@
+// PR c++/97296
+// { dg-do compile }
+
+void f(const int * const &);
+void f(const int *);
+int *x;
+int main()
+{
+  f(x); // { dg-error "call of overloaded" }
+}
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C
new file mode 100644
index 00000000000..77cf0bb9d02
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-enum2.C
@@ -0,0 +1,15 @@
+// PR c++/105398
+// { dg-do compile { target c++14 } }
+
+auto f = [](auto &&m) {
+    enum E { _,e3,e2,e1,C4,C3,C2,C1 };
+    static constexpr int x_coeffs[3][4] = {
+        {e1,C2,C3,C4},
+        {e2,C1,C3,C4},
+        {e3,C1,C2,C4},
+    };
+};
+
+int main() {
+    f(0);
+}
diff --git a/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C b/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C
new file mode 100644
index 00000000000..f500af3f616
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/concepts-requires30.C
@@ -0,0 +1,10 @@
+// PR c++/105304
+// { dg-do compile { target c++20 } }
+// { dg-additional-options "-Wall -Wsequence-point" }
+
+struct A { };
+
+int main() {
+  if (requires { A(); })
+    ;
+}
diff --git a/gcc/testsuite/g++.dg/parse/qualified6.C b/gcc/testsuite/g++.dg/parse/qualified6.C
new file mode 100644
index 00000000000..68b51f771ec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/parse/qualified6.C
@@ -0,0 +1,10 @@
+// PR c++/90107
+// { dg-do compile }
+
+struct A;
+namespace N { extern A a; }
+struct A {} ::N::a;
+
+struct A1;
+struct B { static A1 a1; };
+struct A1 {} ::B::a1;
diff --git a/gcc/testsuite/g++.dg/template/partial-specialization11.C b/gcc/testsuite/g++.dg/template/partial-specialization11.C
new file mode 100644
index 00000000000..556224a3104
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/partial-specialization11.C
@@ -0,0 +1,11 @@
+// PR c++/86193
+// CWG 455 (active)
+// { dg-options "" } // clear -pedantic-errors
+
+template<class T> struct value_type;
+
+template<class T, typename value_type<T>::type V>
+struct A;
+
+template<class T, int V>
+struct A<T*, V> { }; // { dg-warning "not more specialized" }
diff --git a/gcc/testsuite/g++.dg/template/partial-specialization12.C b/gcc/testsuite/g++.dg/template/partial-specialization12.C
new file mode 100644
index 00000000000..5f51e8a27de
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/partial-specialization12.C
@@ -0,0 +1,12 @@
+// PR c++/105289
+// CWG 455 (active)
+// { dg-do compile { target c++11 } }
+
+template<class T>
+struct value_type;
+
+template<class List, typename value_type<List>::type Element>
+struct push_front_vlist;
+
+template<template<class X, X...> class XList, class T, T Arg, T... Vs>
+struct push_front_vlist<XList<T, Vs...>, Arg> { }; // { dg-error "not more specialized" }
diff --git a/gcc/testsuite/gcc.dg/pr105257.c b/gcc/testsuite/gcc.dg/pr105257.c
new file mode 100644
index 00000000000..4232942d791
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr105257.c
@@ -0,0 +1,16 @@
+/* PR target/105257 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+extern int sigsetjmp (void **, int);
+void *buf[32];
+void (*fn) (void);
+
+const char *
+bar (void)
+{
+  sigsetjmp (buf, 0);
+  fn ();
+  return "";
+}
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
index 827687b92fa..8eb8baceb31 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-bb-slp-complex-mul-float.c
@@ -1,10 +1,11 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target vect_complex_add_float } */
+/* { dg-additional-options "-fno-tree-loop-vectorize" } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
 #define N 16
 #include "complex-mul-template.c"
 
-/* { dg-final { scan-tree-dump "Found COMPLEX_MUL_CONJ" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_MUL" "vect" } } */
+/* { dg-final { scan-tree-dump "Found COMPLEX_MUL_CONJ" "slp1" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump "Found COMPLEX_MUL" "slp1" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
index f935405e3d9..5cff373b80d 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-double.c
@@ -6,7 +6,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_double } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect"  { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect"  { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
index 71f391db7bb..312df88ee68 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-float.c
@@ -6,7 +6,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_float } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
index e5b826f1ca7..046f014240b 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-half-float.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
 /* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
@@ -6,5 +7,7 @@
 #define N 200
 #include "complex-add-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 2 "vect" { target { vect_complex_add_half } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 2 "vect" { target { vect_complex_add_half } } } } */
+/* Vectorization is failing for these cases.  They should work but for now ignore.  */
+
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { xfail *-*-* } } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
index 5b70d834c24..9c8b99bc003 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-double.c
@@ -6,8 +6,7 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_double } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_double } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
index 3ef05645a2c..ca5f5b257d3 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-float.c
@@ -6,8 +6,7 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_float } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_float } } } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
index 06a9216add7..c6617f5dad0 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-add-pattern-half-float.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-require-effective-target vect_float } */
+/* { dg-require-effective-target vect_complex_add_half } */
 /* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
@@ -7,10 +7,8 @@
 #define N 200
 #include "complex-add-pattern-template.c"
 
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 4 "vect" { target { vect_complex_add_half } } } } */
-/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_half } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT90" 1 "vect" { target { vect_complex_add_half } } } } */
+/* { dg-final { scan-tree-dump-times "stmt.*COMPLEX_ADD_ROT270" 1 "vect" { target { vect_complex_add_half } && ! target { arm*-*-* } } } } */
 
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "slp1" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT90" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
index 34146f3d1e7..7beb6b8b5d8 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mla-half-float.c
@@ -1,5 +1,7 @@
 /* { dg-do compile } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 
 #define TYPE _Float16
 #define N 200
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
index 0982a2b8ead..fc4cd6151c7 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-double.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_double } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE double
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
index a069533b22a..43a77ff8591 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-float.c
@@ -1,10 +1,10 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_float } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
 #define N 200
 #include "complex-mls-template.c"
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMA" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS_CONJ" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
index 89ac54c2a42..3d1c5755bef 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mls-half-float.c
@@ -1,9 +1,10 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
 #define TYPE _Float16
 #define N 200
 #include "complex-mls-template.c"
-/* { dg-final { scan-tree-dump "Found COMPLEX_ADD_ROT270" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS_CONJ" "vect" } } */
 /* { dg-final { scan-tree-dump "Found COMPLEX_FMS" "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
index 56a8ea4ae02..b6b21529a10 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-double.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_double } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE double
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
index 969416d7dc7..aa8efb4c2db 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-float.c
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_float } */
 /* { dg-add-options arm_v8_3a_complex_neon } */
 
 #define TYPE float
diff --git a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
index da1b9213a6b..51331625745 100644
--- a/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
+++ b/gcc/testsuite/gcc.dg/vect/complex/fast-math-complex-mul-half-float.c
@@ -1,4 +1,6 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target vect_complex_add_half } */
+/* { dg-require-effective-target float16 } */
 /* { dg-add-options arm_v8_3a_fp16_complex_neon } */
 
 #define TYPE _Float16
diff --git a/gcc/testsuite/gcc.dg/vect/vect.exp b/gcc/testsuite/gcc.dg/vect/vect.exp
index dca9a4db6f6..3c60eff7072 100644
--- a/gcc/testsuite/gcc.dg/vect/vect.exp
+++ b/gcc/testsuite/gcc.dg/vect/vect.exp
@@ -118,7 +118,7 @@ et-dg-runtest dg-runtest [lsort \
 set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS
 lappend DEFAULT_VECTCFLAGS "-ffast-math"
 et-dg-runtest dg-runtest [lsort \
-	[glob -nocomplain $srcdir/$subdir/fast-math-\[ipsv\]*.\[cS\]]] \
+	[glob -nocomplain $srcdir/$subdir/fast-math-\[ipsvc\]*.\[cS\]]] \
 	"" $DEFAULT_VECTCFLAGS
 
 # -ffast-math SLP tests
diff --git a/gcc/testsuite/gcc.target/i386/sse-14.c b/gcc/testsuite/gcc.target/i386/sse-14.c
index 4ce0ffffaf3..4c728f230f7 100644
--- a/gcc/testsuite/gcc.target/i386/sse-14.c
+++ b/gcc/testsuite/gcc.target/i386/sse-14.c
@@ -429,7 +429,9 @@ test_3 (_mm_maskz_mul_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_mul_round_ps, __m512, __mmask16, __m512, __m512, 9)
 test_3 (_mm_maskz_mul_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_scalef_round_pd, __m512d, __mmask8, __m512d, __m512d, 9)
+test_3 (_mm_maskz_scalef_round_sd, __m128d, __mmask8, __m128d, __m128d, 9)
 test_3 (_mm512_maskz_scalef_round_ps, __m512, __mmask16, __m512, __m512, 9)
+test_3 (_mm_maskz_scalef_round_ss, __m128, __mmask8, __m128, __m128, 9)
 test_3 (_mm512_maskz_shuffle_f32x4, __m512, __mmask16, __m512, __m512, 1)
 test_3 (_mm512_maskz_shuffle_f64x2, __m512d, __mmask8, __m512d, __m512d, 1)
 test_3 (_mm512_maskz_shuffle_i32x4, __m512i, __mmask16, __m512i, __m512i, 1)
@@ -543,7 +545,9 @@ test_4 (_mm_mask_mul_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_mul_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
 test_4 (_mm_mask_mul_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_scalef_round_pd, __m512d, __m512d, __mmask8, __m512d, __m512d, 9)
+test_4 (_mm_mask_scalef_round_sd, __m128d, __m128d, __mmask8, __m128d, __m128d, 9)
 test_4 (_mm512_mask_scalef_round_ps, __m512, __m512, __mmask16, __m512, __m512, 9)
+test_4 (_mm_mask_scalef_round_ss, __m128, __m128, __mmask8, __m128, __m128, 9)
 test_4 (_mm512_mask_shuffle_f32x4, __m512, __m512, __mmask16, __m512, __m512, 1)
 test_4 (_mm512_mask_shuffle_f64x2, __m512d, __m512d, __mmask8, __m512d, __m512d, 1)
 test_4 (_mm512_mask_shuffle_i32x4, __m512i, __m512i, __mmask16, __m512i, __m512i, 1)
diff --git a/gcc/testsuite/gfortran.dg/dec_union_12.f90 b/gcc/testsuite/gfortran.dg/dec_union_12.f90
new file mode 100755
index 00000000000..26671230b05
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dec_union_12.f90
@@ -0,0 +1,43 @@
+! { dg-do compile }
+! { dg-options "-std=legacy -ffree-form -finit-local-zero -finit-derived -fdec-structure" }
+!
+! PR fortran/105310
+!
+! Test that gfc_conv_union_initializer does not cause an ICE when called
+! to build the constructor for a field which triggers a vector resize.
+!
+
+program dec_union_12
+  implicit none
+STRUCTURE /foo8u/
+  ! 8 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo16u/
+  ! 16 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+STRUCTURE /foo32u/
+  ! 32 fields
+  INTEGER(4) :: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
+  INTEGER(4) :: aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap
+  UNION
+  MAP
+  ENDMAP
+  ENDUNION
+ENDSTRUCTURE
+  record /foo8u/ bar8u
+  record /foo16u/ bar16u
+  record /foo32u/ bar32u
+  bar8u.a = 1
+  bar16u.a = 1
+  bar32u.a = 1
+end
diff --git a/gcc/testsuite/gfortran.dg/g77/pr105203.f b/gcc/testsuite/gfortran.dg/g77/pr105203.f
new file mode 100644
index 00000000000..3b47210fb40
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/g77/pr105203.f
@@ -0,0 +1,20 @@
+C Test case for PR debug/105203
+C Origin: kmccarty@princeton.edu
+C
+C { dg-do compile }
+C { dg-options "-O2 -fcompare-debug -ftracer -w" }
+C { dg-additional-options "-fPIC" { target fpic } }
+      SUBROUTINE FOO (B)
+
+  10  CALL BAR (A)
+      ASSIGN 20 TO M
+      IF (100.LT.A) GOTO 10
+      GOTO 40
+C
+  20  IF (B.LT.ABS(A)) GOTO 10
+      ASSIGN 30 TO M
+      GOTO 40
+C
+  30  ASSIGN 10 TO M
+  40  GOTO M,(10,20,30)
+      END
diff --git a/gcc/value-prof.c b/gcc/value-prof.c
index 42748771192..688089b04d2 100644
--- a/gcc/value-prof.c
+++ b/gcc/value-prof.c
@@ -336,6 +336,10 @@ stream_out_histogram_value (struct output_block *ob, histogram_value hist)
 	/* Note that the IOR counter tracks pointer values and these can have
 	   sign bit set.  */
 	;
+      else if (hist->type == HIST_TYPE_INDIR_CALL && i == 0)
+	/* 'all' counter overflow is stored as a negative value. Individual
+	   counters and values are expected to be non-negative.  */
+	;
       else
 	gcc_assert (value >= 0);
 
diff --git a/libphobos/ChangeLog b/libphobos/ChangeLog
index acd0b312ef2..35950df774d 100644
--- a/libphobos/ChangeLog
+++ b/libphobos/ChangeLog
@@ -1,3 +1,19 @@
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2021-09-30  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/unwind/generic.d (__aligned__): Define.
+	(_Unwind_Exception): Align struct to __aligned__.
+
+2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	Backported from master:
+	2022-04-26  Iain Buclaw  <ibuclaw@gdcproject.org>
+
+	* libdruntime/gcc/emutls.d (emutlsDestroyThread): Clear the per-thread
+	TLS array, don't call free().
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libphobos/libdruntime/gcc/emutls.d b/libphobos/libdruntime/gcc/emutls.d
index 462230508ab..ebeeb8deda3 100644
--- a/libphobos/libdruntime/gcc/emutls.d
+++ b/libphobos/libdruntime/gcc/emutls.d
@@ -222,9 +222,9 @@ void** emutlsAlloc(shared __emutls_object* obj) nothrow @nogc
 }
 
 /*
- * When a thread has finished, remove the TLS array from the GC
- * scan list emutlsArrays, free all allocated TLS variables and
- * finally free the array.
+ * When a thread has finished, free all allocated TLS variables and empty the
+ * array.  The pointer is not free'd as it is stil referenced by the GC scan
+ * list emutlsArrays, which gets destroyed when druntime is unloaded.
  */
 extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
 {
@@ -236,7 +236,7 @@ extern (C) void emutlsDestroyThread(void* ptr) nothrow @nogc
             free(entry[-1]);
     }
 
-    free(arr);
+    arr.length = 0;
 }
 
 /*
diff --git a/libphobos/libdruntime/gcc/unwind/generic.d b/libphobos/libdruntime/gcc/unwind/generic.d
index 592b3afcb71..68ddd1d5410 100644
--- a/libphobos/libdruntime/gcc/unwind/generic.d
+++ b/libphobos/libdruntime/gcc/unwind/generic.d
@@ -123,7 +123,27 @@ enum : _Unwind_Reason_Code
 // @@@ The IA-64 ABI says that this structure must be double-word aligned.
 // Taking that literally does not make much sense generically.  Instead we
 // provide the maximum alignment required by any type for the machine.
-struct _Unwind_Exception
+     version (ARM)      private enum __aligned__ = 8;
+else version (AArch64)  private enum __aligned__ = 16;
+else version (HPPA)     private enum __aligned__ = 8;
+else version (HPPA64)   private enum __aligned__ = 16;
+else version (MIPS_N32) private enum __aligned__ = 16;
+else version (MIPS_N64) private enum __aligned__ = 16;
+else version (MIPS32)   private enum __aligned__ = 8;
+else version (MIPS64)   private enum __aligned__ = 8;
+else version (PPC)      private enum __aligned__ = 16;
+else version (PPC64)    private enum __aligned__ = 16;
+else version (RISCV32)  private enum __aligned__ = 16;
+else version (RISCV64)  private enum __aligned__ = 16;
+else version (S390)     private enum __aligned__ = 8;
+else version (SPARC)    private enum __aligned__ = 8;
+else version (SPARC64)  private enum __aligned__ = 16;
+else version (SystemZ)  private enum __aligned__ = 8;
+else version (X86)      private enum __aligned__ = 16;
+else version (X86_64)   private enum __aligned__ = 16;
+else static assert( false, "Platform not supported.");
+
+align(__aligned__) struct _Unwind_Exception
 {
     _Unwind_Exception_Class exception_class;
     _Unwind_Exception_Cleanup_Fn exception_cleanup;
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 85e04c45288..94026976c41 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,318 @@
+2022-04-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105375
+	* include/std/future (packaged_task): Add deduction guides.
+	* testsuite/30_threads/packaged_task/cons/deduction.cc: New test.
+
+2022-04-22  Thomas W Rodgers  <trodgers@redhat.com>
+
+	Backported from master:
+	2022-04-22  Thomas W Rodgers  <trodgers@redhat.com>
+
+	PR libstdc++/102994
+	* include/bits/atomic_base.h (atomic_flag::notify_one,
+	notify_all): Remove const qualification.
+	(__atomic_base::notify_one, notify_all): Likewise.
+	* include/std/atomic (atomic<bool>::notify_one, notify_all):
+	Likewise.
+	(atomic::notify_one, notify_all): Likewise.
+	(atomic<T*>::notify_one, notify_all): Likewise.
+	(atomic_notify_one, atomic_notify_all): Likewise.
+	* testsuite/29_atomics/atomic/wait_notify/102994.cc: Adjust test
+	to account for change in notify_one/notify_all signature.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/96592
+	* include/std/tuple (tuple::is_constructible): Remove.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/102177
+	* include/bits/atomic_base.h (__is_valid_cmpexch_failure_order):
+	New function to check if a memory order is valid for the failure
+	case of compare exchange operations.
+	(__atomic_base<I>::compare_exchange_weak): Simplify assertions
+	by using __is_valid_cmpexch_failure_order.
+	(__atomic_base<I>::compare_exchange_strong): Likewise.
+	(__atomic_base<P*>::compare_exchange_weak): Likewise.
+	(__atomic_base<P*>::compare_exchange_strong): Likewise.
+	(__atomic_impl::compare_exchange_weak): Add assertion.
+	(__atomic_impl::compare_exchange_strong): Likewise.
+	* include/std/atomic (atomic::compare_exchange_weak): Likewise.
+	(atomic::compare_exchange_strong): Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-02-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/monotonic_buffer_resource/allocate.cc:
+	Ignore -Walloc-larger-than warning.
+	* testsuite/20_util/unsynchronized_pool_resource/allocate.cc:
+	Likewise.
+	* testsuite/29_atomics/atomic/cons/user_pod.cc: Compile with -O1
+	to avoid linker error for __atomic_is_lock_free.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_iterator.h (operator==, operator<=>): Define
+	overloads for homogeneous specializations of reverse_iterator,
+	__normal_iterator and move_iterator.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/24_iterators/move_iterator/dr3265.cc: Fix test to
+	account for LWG 3435 resolution.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/101709
+	* src/filesystem/ops-common.h (get_temp_directory_from_env):
+	Add error_code parameter.
+	* src/c++17/fs_ops.cc (fs::temp_directory_path): Pass error_code
+	argument to get_temp_directory_from_env and check it.
+	* src/filesystem/ops.cc (fs::temp_directory_path): Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/105324
+	* src/c++17/floating_from_chars.cc (buffer_resource::do_allocate):
+	Remove assertion.
+	* testsuite/20_util/from_chars/pr105324.cc: New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/65018
+	* configure.ac: Check for secure_getenv.
+	* config.h.in: Regenerate.
+	* configure: Regenerate.
+	* src/filesystem/ops-common.h (get_temp_directory_from_env): New
+	helper function to obtain path from the environment.
+	* src/c++17/fs_ops.cc (fs::temp_directory_path): Use new helper.
+	* src/filesystem/ops.cc (fs::temp_directory_path): Likewise.
+	* testsuite/27_io/filesystem/operations/temp_directory_path.cc:
+	Print messages if test cannot be run.
+	* testsuite/experimental/filesystem/operations/temp_directory_path.cc:
+	Likewise. Fix incorrect condition. Use "TMP" to work with
+	Windows as well as POSIX.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++20/sstream-inst.cc (_GLIBCXX_USE_CXX11_ABI): Define to
+	select new ABI.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string/cons/char/moveable.cc: Allow
+	moved-from string to be non-empty.
+	* testsuite/21_strings/basic_string/cons/char/moveable2.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc:
+	Likewise.
+	* testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc:
+	Construct empty string before setting oom flag.
+	* testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc:
+	Likewise.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/regex_compiler.tcc (_Compiler::_M_match_token):
+	Use reserved name for parameter.
+	* testsuite/17_intro/names.cc: Check "token".
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-08-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/17_intro/names.cc: Check 'sz'.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/ranges (ranges::lazy_split_view::_InnerIter::end()):
+	Add neoxcept (LWG 3593).
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/internet (address): Use std::_Construct
+	to initialize union members.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/cxx11-ios_failure.cc (io_error_category): Define
+	class and virtual functions as 'final'.
+	(io_category_instance): Use constinit union to make the object
+	immortal.
+	* src/c++11/future.cc (future_error_category): Define class and
+	virtual functions as 'final'.
+	(future_category_instance): Use constinit union.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-11-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/span (span(Range&&)): Reorder constraints.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2021-12-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++17/fs_path.cc (path::_M_split_cmpts()): Remove
+	micro-optimization for "/" path.
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Only access
+	the contents of _M_pathname using const member functions.
+
+2022-04-21  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+
+	Backported from master:
+	2022-01-06  Pavel I. Kryukov  <pavel.kryukov@phystech.edu>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103853
+	* include/bits/forward_list.tcc (forward_list::merge): Check for
+	self-merge.
+	* testsuite/23_containers/forward_list/operations/merge.cc: New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_construct.h (_Construct, _Construct_novalue):
+	Also cast away cv-qualifiers when converting pointer to void.
+	* testsuite/20_util/allocator/void.cc: Test construct function
+	with cv-qualified types.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103911
+	* include/std/charconv (__from_chars_alpha_to_num): Return
+	char instead of unsigned char. Change invalid return value to
+	127 instead of using numeric trait.
+	(__from_chars_alnum): Fix comment. Do not use std::isdigit.
+	Change type of variable to char.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/ranges_base.h (ranges::advance): Avoid signed
+	overflow. Do nothing if already equal to desired result.
+	* testsuite/24_iterators/range_operations/advance_overflow.cc:
+	New test.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/ext/rope/pthread7-rope.cc: Add dg-timeout-factor.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-03-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/17_intro/names.cc (func): Undef on AIX.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93602
+	* doc/xml/manual/prerequisites.xml: Document libiconv
+	workarounds.
+	* doc/html/manual/setup.html: Regenerate.
+	* src/Makefile.am (CXXLINK): Add $(LTLIBICONV).
+	* src/Makefile.in: Regenerate.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Fix comment.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-04-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc:
+	Check correct feature test macro.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR middle-end/104966
+	* include/bits/locale_facets_nonio.tcc
+	(__moneypunct_cache::_M_cache): Store string sizes in local
+	variable that doesn't escape.
+
+2022-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from master:
+	2022-01-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/103848
+	* include/bits/stl_deque.h (operator-): Do not use 0 as null
+	pointer constant.
+
 2022-04-21  Release Manager
 
 	* GCC 11.3.0 released.
diff --git a/libstdc++-v3/config.h.in b/libstdc++-v3/config.h.in
index 61c342681d4..ea88281f438 100644
--- a/libstdc++-v3/config.h.in
+++ b/libstdc++-v3/config.h.in
@@ -310,6 +310,9 @@
 /* Define if readlink is available in <unistd.h>. */
 #undef HAVE_READLINK
 
+/* Define to 1 if you have the `secure_getenv' function. */
+#undef HAVE_SECURE_GETENV
+
 /* Define to 1 if you have the `setenv' function. */
 #undef HAVE_SETENV
 
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 3120d5855f6..1d5ffd8df11 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -28419,6 +28419,17 @@ if test "x$ac_cv_func__wfopen" = xyes; then :
 #define HAVE__WFOPEN 1
 _ACEOF
 
+fi
+done
+
+  for ac_func in secure_getenv
+do :
+  ac_fn_c_check_func "$LINENO" "secure_getenv" "ac_cv_func_secure_getenv"
+if test "x$ac_cv_func_secure_getenv" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SECURE_GETENV 1
+_ACEOF
+
 fi
 done
 
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
index fb256bb0287..4d16b094d7f 100644
--- a/libstdc++-v3/configure.ac
+++ b/libstdc++-v3/configure.ac
@@ -276,6 +276,7 @@ if $GLIBCXX_IS_NATIVE; then
   AC_CHECK_FUNCS(__cxa_thread_atexit_impl __cxa_thread_atexit)
   AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
   AC_CHECK_FUNCS(_wfopen)
+  AC_CHECK_FUNCS(secure_getenv)
 
   # C11 functions for C++17 library
   AC_CHECK_FUNCS(timespec_get)
diff --git a/libstdc++-v3/doc/html/manual/setup.html b/libstdc++-v3/doc/html/manual/setup.html
index 636a4401602..069354b8ce0 100644
--- a/libstdc++-v3/doc/html/manual/setup.html
+++ b/libstdc++-v3/doc/html/manual/setup.html
@@ -42,6 +42,39 @@
    </p><p>
    Finally, a few system-specific requirements:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">linux</span></dt><dd><p>
+	  The 'gnu' locale model makes use of <code class="function">iconv</code>
+	  for character set conversions. The relevant functions are provided
+	  by Glibc and so are always available, however they can also be
+	  provided by the separate GNU libiconv library. If GNU libiconv is
+	  found when GCC is built (e.g., because its headers are installed
+	  in <code class="filename">/usr/local/include</code>)
+	  then the <code class="filename">libstdc++.so.6</code> library will have a
+	  run-time dependency on <code class="filename">libiconv.so.2</code>.
+	  If you do not want that run-time dependency then you should do
+	  one of the following:
+	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
+	      Uninstall the libiconv headers before building GCC.
+	      Glibc already provides <code class="function">iconv</code> so you should
+	      not need libiconv anyway.
+	    </p></li><li class="listitem"><p>
+	    <a class="link" href="../">
+	    Download</a> the libiconv sources and extract them into the
+	    top level of the GCC source tree, e.g.,
+	    </p><pre class="programlisting">
+wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz
+tar xf libiconv-1.16.tar.gz
+ln -s libiconv-1.16 libiconv
+</pre><p>
+	      This will build libiconv as part of building GCC and link to
+	      it statically, so there is no <code class="filename">libiconv.so.2</code>
+	      dependency.
+	    </p></li><li class="listitem"><p>
+	      Configure GCC with <code class="option">--with-libiconv-type=static</code>.
+	      This requires the static <code class="filename">libiconv.a</code> library,
+	      which is not installed by default. You might need to reinstall
+	      libiconv using the <code class="option">--enable-static</code> configure
+	      option to get the static library.
+	    </p></li></ul></div><p>
 	  If GCC 3.1.0 or later on is being used on GNU/Linux, an attempt
 	  will be made to use "C" library functionality necessary for
 	  C++ named locale support.  For GCC 4.6.0 and later, this
diff --git a/libstdc++-v3/doc/xml/manual/intro.xml b/libstdc++-v3/doc/xml/manual/intro.xml
index 3e7843f58c1..99837988cf6 100644
--- a/libstdc++-v3/doc/xml/manual/intro.xml
+++ b/libstdc++-v3/doc/xml/manual/intro.xml
@@ -55,7 +55,7 @@
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxtr24733.xml">
     </xi:include>
 
-    <!-- Section 01.7 : Status C++ IS 24733 -->
+    <!-- Section 01.7 : Status C++ IS 29124 -->
     <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="xml" href="status_cxxis29124.xml">
     </xi:include>
   </section>
diff --git a/libstdc++-v3/doc/xml/manual/prerequisites.xml b/libstdc++-v3/doc/xml/manual/prerequisites.xml
index 22e90a7e79d..8799487c821 100644
--- a/libstdc++-v3/doc/xml/manual/prerequisites.xml
+++ b/libstdc++-v3/doc/xml/manual/prerequisites.xml
@@ -48,6 +48,56 @@
       <varlistentry>
 	<term>linux</term>
 
+	<listitem>
+	<para>
+	  The 'gnu' locale model makes use of <function>iconv</function>
+	  for character set conversions. The relevant functions are provided
+	  by Glibc and so are always available, however they can also be
+	  provided by the separate GNU libiconv library. If GNU libiconv is
+	  found when GCC is built (e.g., because its headers are installed
+	  in <filename class="directory">/usr/local/include</filename>)
+	  then the <filename>libstdc++.so.6</filename> library will have a
+	  run-time dependency on <filename>libiconv.so.2</filename>.
+	  If you do not want that run-time dependency then you should do
+	  one of the following:
+	</para>
+	<itemizedlist>
+	  <listitem>
+	    <para>
+	      Uninstall the libiconv headers before building GCC.
+	      Glibc already provides <function>iconv</function> so you should
+	      not need libiconv anyway.
+	    </para>
+	  </listitem>
+	  <listitem>
+	    <para>
+	    <link linkend="https://www.gnu.org/software/libiconv/#downloading">
+	    Download</link> the libiconv sources and extract them into the
+	    top level of the GCC source tree, e.g.,
+	    </para>
+<programlisting>
+wget https://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.16.tar.gz
+tar xf libiconv-1.16.tar.gz
+ln -s libiconv-1.16 libiconv
+</programlisting>
+	    <para>
+	      This will build libiconv as part of building GCC and link to
+	      it statically, so there is no <filename>libiconv.so.2</filename>
+	      dependency.
+	    </para>
+	  </listitem>
+	  <listitem>
+	    <para>
+	      Configure GCC with <option>--with-libiconv-type=static</option>.
+	      This requires the static <filename>libiconv.a</filename> library,
+	      which is not installed by default. You might need to reinstall
+	      libiconv using the <option>--enable-static</option> configure
+	      option to get the static library.
+	    </para>
+	  </listitem>
+	</itemizedlist>
+	</listitem>
+
 	<listitem>
 	<para>
 	  If GCC 3.1.0 or later on is being used on GNU/Linux, an attempt
diff --git a/libstdc++-v3/include/bits/atomic_base.h b/libstdc++-v3/include/bits/atomic_base.h
index 60b976bf8d1..2abdc400260 100644
--- a/libstdc++-v3/include/bits/atomic_base.h
+++ b/libstdc++-v3/include/bits/atomic_base.h
@@ -121,6 +121,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       | __memory_order_modifier(__m & __memory_order_modifier_mask));
   }
 
+  constexpr bool
+  __is_valid_cmpexch_failure_order(memory_order __m) noexcept
+  {
+    return (__m & __memory_order_mask) != memory_order_release
+	&& (__m & __memory_order_mask) != memory_order_acq_rel;
+  }
+
   _GLIBCXX_ALWAYS_INLINE void
   atomic_thread_fence(memory_order __m) noexcept
   { __atomic_thread_fence(int(__m)); }
@@ -245,13 +252,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     _GLIBCXX_ALWAYS_INLINE void
-    notify_one() const noexcept
+    notify_one() noexcept
     { std::__atomic_notify_address(&_M_i, false); }
 
     // TODO add const volatile overload
 
     _GLIBCXX_ALWAYS_INLINE void
-    notify_all() const noexcept
+    notify_all() noexcept
     { std::__atomic_notify_address(&_M_i, true); }
 
     // TODO add const volatile overload
@@ -511,13 +518,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(__int_type& __i1, __int_type __i2,
 			    memory_order __m1, memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
 					   int(__m1), int(__m2));
@@ -528,13 +529,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			    memory_order __m1,
 			    memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
 					   int(__m1), int(__m2));
@@ -560,13 +555,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(__int_type& __i1, __int_type __i2,
 			      memory_order __m1, memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
 					   int(__m1), int(__m2));
@@ -577,14 +566,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
 					   int(__m1), int(__m2));
@@ -618,13 +600,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       // TODO add const volatile overload
 
       _GLIBCXX_ALWAYS_INLINE void
-      notify_one() const noexcept
+      notify_one() noexcept
       { std::__atomic_notify_address(&_M_i, false); }
 
       // TODO add const volatile overload
 
       _GLIBCXX_ALWAYS_INLINE void
-      notify_all() const noexcept
+      notify_all() noexcept
       { std::__atomic_notify_address(&_M_i, true); }
 
       // TODO add const volatile overload
@@ -869,13 +851,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
 					   int(__m1), int(__m2));
@@ -886,14 +862,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      memory_order __m1,
 			      memory_order __m2) volatile noexcept
       {
-	memory_order __b2 __attribute__ ((__unused__))
-	  = __m2 & __memory_order_mask;
-	memory_order __b1 __attribute__ ((__unused__))
-	  = __m1 & __memory_order_mask;
-
-	__glibcxx_assert(__b2 != memory_order_release);
-	__glibcxx_assert(__b2 != memory_order_acq_rel);
-	__glibcxx_assert(__b2 <= __b1);
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 
 	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
 					   int(__m1), int(__m2));
@@ -996,6 +965,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			    _Val<_Tp> __desired, memory_order __success,
 			    memory_order __failure) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));
+
 	return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
 					 std::__addressof(__desired), true,
 					 int(__success), int(__failure));
@@ -1007,6 +978,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			      _Val<_Tp> __desired, memory_order __success,
 			      memory_order __failure) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__failure));
+
 	return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
 					 std::__addressof(__desired), false,
 					 int(__success), int(__failure));
diff --git a/libstdc++-v3/include/bits/forward_list.tcc b/libstdc++-v3/include/bits/forward_list.tcc
index bd7a859091f..1145230b910 100644
--- a/libstdc++-v3/include/bits/forward_list.tcc
+++ b/libstdc++-v3/include/bits/forward_list.tcc
@@ -367,6 +367,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       forward_list<_Tp, _Alloc>::
       merge(forward_list&& __list, _Comp __comp)
       {
+	// _GLIBCXX_RESOLVE_LIB_DEFECTS
+	// 3088. forward_list::merge behavior unclear when passed *this
+	if (std::__addressof(__list) == this)
+	  return;
+
 	_Node_base* __node = &this->_M_impl._M_head;
 	while (__node->_M_next && __list._M_impl._M_head._M_next)
 	  {
diff --git a/libstdc++-v3/include/bits/locale_facets_nonio.tcc b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
index 51c23d8003a..4aef5502032 100644
--- a/libstdc++-v3/include/bits/locale_facets_nonio.tcc
+++ b/libstdc++-v3/include/bits/locale_facets_nonio.tcc
@@ -78,32 +78,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       char* __grouping = 0;
       _CharT* __curr_symbol = 0;
       _CharT* __positive_sign = 0;
-      _CharT* __negative_sign = 0;     
+      _CharT* __negative_sign = 0;
+      size_t __sz;
       __try
 	{
 	  const string& __g = __mp.grouping();
-	  _M_grouping_size = __g.size();
-	  __grouping = new char[_M_grouping_size];
-	  __g.copy(__grouping, _M_grouping_size);
+	  __sz = _M_grouping_size = __g.size();
+	  __grouping = new char[__sz];
+	  __g.copy(__grouping, __sz);
 	  _M_use_grouping = (_M_grouping_size
 			     && static_cast<signed char>(__grouping[0]) > 0
 			     && (__grouping[0]
 				 != __gnu_cxx::__numeric_traits<char>::__max));
 
 	  const basic_string<_CharT>& __cs = __mp.curr_symbol();
-	  _M_curr_symbol_size = __cs.size();
-	  __curr_symbol = new _CharT[_M_curr_symbol_size];
-	  __cs.copy(__curr_symbol, _M_curr_symbol_size);
+	  __sz = _M_curr_symbol_size = __cs.size();
+	  __curr_symbol = new _CharT[__sz];
+	  __cs.copy(__curr_symbol, __sz);
 
 	  const basic_string<_CharT>& __ps = __mp.positive_sign();
-	  _M_positive_sign_size = __ps.size();
-	  __positive_sign = new _CharT[_M_positive_sign_size];
-	  __ps.copy(__positive_sign, _M_positive_sign_size);
+	  __sz = _M_positive_sign_size = __ps.size();
+	  __positive_sign = new _CharT[__sz];
+	  __ps.copy(__positive_sign, __sz);
 
 	  const basic_string<_CharT>& __ns = __mp.negative_sign();
-	  _M_negative_sign_size = __ns.size();
-	  __negative_sign = new _CharT[_M_negative_sign_size];
-	  __ns.copy(__negative_sign, _M_negative_sign_size);
+	  __sz = _M_negative_sign_size = __ns.size();
+	  __negative_sign = new _CharT[__sz];
+	  __ns.copy(__negative_sign, __sz);
 
 	  _M_pos_format = __mp.pos_format();
 	  _M_neg_format = __mp.neg_format();
diff --git a/libstdc++-v3/include/bits/ranges_base.h b/libstdc++-v3/include/bits/ranges_base.h
index 87283b84028..6d2d5bf939d 100644
--- a/libstdc++-v3/include/bits/ranges_base.h
+++ b/libstdc++-v3/include/bits/ranges_base.h
@@ -728,20 +728,23 @@ namespace ranges
 	  {
 	    const auto __diff = __bound - __it;
 
-	    // n and bound must not lead in opposite directions:
-	    __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));
-	    const auto __absdiff = __diff < 0 ? -__diff : __diff;
-	    const auto __absn = __n < 0 ? -__n : __n;;
-	    if (__absn >= __absdiff)
+	    if (__diff == 0)
+	      return __n;
+	    else if (__diff > 0 ? __n >= __diff : __n <= __diff)
 	      {
 		(*this)(__it, __bound);
 		return __n - __diff;
 	      }
-	    else
+	    else if (__n != 0) [[likely]]
 	      {
+		// n and bound must not lead in opposite directions:
+		__glibcxx_assert(__n < 0 == __diff < 0);
+
 		(*this)(__it, __n);
 		return 0;
 	      }
+	    else
+	      return 0;
 	  }
 	else if (__it == __bound || __n == 0)
 	  return __n;
diff --git a/libstdc++-v3/include/bits/regex_compiler.tcc b/libstdc++-v3/include/bits/regex_compiler.tcc
index 440669debe0..e4f73971bbb 100644
--- a/libstdc++-v3/include/bits/regex_compiler.tcc
+++ b/libstdc++-v3/include/bits/regex_compiler.tcc
@@ -586,9 +586,9 @@ namespace __detail
   template<typename _TraitsT>
     bool
     _Compiler<_TraitsT>::
-    _M_match_token(_TokenT token)
+    _M_match_token(_TokenT __token)
     {
-      if (token == _M_scanner._M_get_token())
+      if (__token == _M_scanner._M_get_token())
 	{
 	  _M_value = _M_scanner._M_get_value();
 	  _M_scanner._M_advance();
diff --git a/libstdc++-v3/include/bits/stl_construct.h b/libstdc++-v3/include/bits/stl_construct.h
index e53ed0d9f91..f14fba0cfb1 100644
--- a/libstdc++-v3/include/bits/stl_construct.h
+++ b/libstdc++-v3/include/bits/stl_construct.h
@@ -116,7 +116,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  return;
 	}
 #endif
-      ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...);
+      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
     }
 #else
   template<typename _T1, typename _T2>
@@ -132,7 +132,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<typename _T1>
     inline void
     _Construct_novalue(_T1* __p)
-    { ::new(static_cast<void*>(__p)) _T1; }
+    { ::new((void*)__p) _T1; }
 
   template<typename _ForwardIterator>
     _GLIBCXX20_CONSTEXPR void
diff --git a/libstdc++-v3/include/bits/stl_deque.h b/libstdc++-v3/include/bits/stl_deque.h
index 20c73b4fc3c..8236fe35ce7 100644
--- a/libstdc++-v3/include/bits/stl_deque.h
+++ b/libstdc++-v3/include/bits/stl_deque.h
@@ -353,7 +353,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
       {
 	return difference_type(_S_buffer_size())
-	  * (__x._M_node - __y._M_node - int(__x._M_node != 0))
+	  * (__x._M_node - __y._M_node - bool(__x._M_node))
 	  + (__x._M_cur - __x._M_first)
 	  + (__y._M_last - __y._M_cur);
       }
@@ -365,10 +365,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       template<typename _RefR, typename _PtrR>
 	friend difference_type
 	operator-(const _Self& __x,
-		  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
+		  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
+	_GLIBCXX_NOEXCEPT
 	{
 	  return difference_type(_S_buffer_size())
-	    * (__x._M_node - __y._M_node - int(__x._M_node != 0))
+	    * (__x._M_node - __y._M_node - bool(__x._M_node))
 	    + (__x._M_cur - __x._M_first)
 	    + (__y._M_last - __y._M_cur);
 	}
diff --git a/libstdc++-v3/include/bits/stl_iterator.h b/libstdc++-v3/include/bits/stl_iterator.h
index beeb4ef4c8a..4247bb116c3 100644
--- a/libstdc++-v3/include/bits/stl_iterator.h
+++ b/libstdc++-v3/include/bits/stl_iterator.h
@@ -537,6 +537,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     operator<=>(const reverse_iterator<_IteratorL>& __x,
 		const reverse_iterator<_IteratorR>& __y)
     { return __y.base() <=> __x.base(); }
+
+  // Additional, non-standard overloads to avoid ambiguities with greedy,
+  // unconstrained overloads in associated namespaces.
+
+  template<typename _Iterator>
+    constexpr bool
+    operator==(const reverse_iterator<_Iterator>& __x,
+	       const reverse_iterator<_Iterator>& __y)
+    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
+    { return __x.base() == __y.base(); }
+
+  template<three_way_comparable _Iterator>
+    constexpr compare_three_way_result_t<_Iterator, _Iterator>
+    operator<=>(const reverse_iterator<_Iterator>& __x,
+		const reverse_iterator<_Iterator>& __y)
+    { return __y.base() <=> __x.base(); }
 #endif // C++20
   ///@}
 
@@ -1113,6 +1129,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 		const __normal_iterator<_IteratorR, _Container>& __rhs)
     noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
     { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
+
+  template<typename _Iterator, typename _Container>
+    constexpr bool
+    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
+	       const __normal_iterator<_Iterator, _Container>& __rhs)
+    noexcept(noexcept(__lhs.base() == __rhs.base()))
+    requires requires {
+      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
+    }
+    { return __lhs.base() == __rhs.base(); }
+
+  template<typename _Iterator, typename _Container>
+    constexpr std::__detail::__synth3way_t<_Iterator>
+    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
+		const __normal_iterator<_Iterator, _Container>& __rhs)
+    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
+    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
 #else
    // Forward iterator requirements
   template<typename _IteratorL, typename _IteratorR, typename _Container>
@@ -1588,20 +1621,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 #endif
     { return !(__x < __y); }
 
-#if ! (__cplusplus > 201703L && __cpp_lib_concepts)
   // Note: See __normal_iterator operators note from Gaby to understand
   // why we have these extra overloads for some move_iterator operators.
 
-  // These extra overloads are not needed in C++20, because the ones above
-  // are constrained with a requires-clause and so overload resolution will
-  // prefer them to greedy unconstrained function templates.
-
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR bool
     operator==(const move_iterator<_Iterator>& __x,
 	       const move_iterator<_Iterator>& __y)
     { return __x.base() == __y.base(); }
 
+#if __cpp_lib_three_way_comparison
+  template<three_way_comparable _Iterator>
+    constexpr compare_three_way_result_t<_Iterator>
+    operator<=>(const move_iterator<_Iterator>& __x,
+		const move_iterator<_Iterator>& __y)
+    { return __x.base() <=> __y.base(); }
+#else
   template<typename _Iterator>
     inline _GLIBCXX17_CONSTEXPR bool
     operator!=(const move_iterator<_Iterator>& __x,
diff --git a/libstdc++-v3/include/experimental/internet b/libstdc++-v3/include/experimental/internet
index 6ce070ae775..07eb137fb80 100644
--- a/libstdc++-v3/include/experimental/internet
+++ b/libstdc++-v3/include/experimental/internet
@@ -441,13 +441,15 @@ namespace ip
     // constructors:
     constexpr address() noexcept : _M_v4(), _M_is_v4(true) { }
 
+#if __cpp_constexpr_dynamic_alloc
     constexpr
+#endif
     address(const address& __a) noexcept : _M_uninit(), _M_is_v4(__a._M_is_v4)
     {
       if (_M_is_v4)
-	::new (std::addressof(_M_v4)) address_v4(__a.to_v4());
+	std::_Construct(std::addressof(_M_v4), __a.to_v4());
       else
-	::new (std::addressof(_M_v6)) address_v6(__a.to_v6());
+	std::_Construct(std::addressof(_M_v6), __a.to_v6());
     }
 
     constexpr
@@ -470,7 +472,7 @@ namespace ip
     address&
     operator=(const address_v4& __a) noexcept
     {
-      ::new (std::addressof(_M_v4)) address_v4(__a);
+      std::_Construct(std::addressof(_M_v4), __a);
       _M_is_v4 = true;
       return *this;
     }
@@ -478,7 +480,7 @@ namespace ip
     address&
     operator=(const address_v6& __a) noexcept
     {
-      ::new (std::addressof(_M_v6)) address_v6(__a);
+      std::_Construct(std::addressof(_M_v6), __a);
       _M_is_v4 = false;
       return *this;
     }
diff --git a/libstdc++-v3/include/std/atomic b/libstdc++-v3/include/std/atomic
index fdffacc35df..0d4e3a7396e 100644
--- a/libstdc++-v3/include/std/atomic
+++ b/libstdc++-v3/include/std/atomic
@@ -172,11 +172,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { _M_base.notify_one(); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { _M_base.notify_all(); }
 #endif // __cpp_lib_atomic_wait
   };
@@ -320,6 +320,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
 			    memory_order __f) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -330,6 +332,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_weak(_Tp& __e, _Tp __i, memory_order __s,
 			    memory_order __f) volatile noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -352,6 +356,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
 			      memory_order __f) noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -362,6 +368,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
 			      memory_order __f) volatile noexcept
       {
+	__glibcxx_assert(__is_valid_cmpexch_failure_order(__f));
+
 	return __atomic_compare_exchange(std::__addressof(_M_i),
 					 std::__addressof(__e),
 					 std::__addressof(__i),
@@ -391,11 +399,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { std::__atomic_notify_address(&_M_i, false); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { std::__atomic_notify_address(&_M_i, true); }
 #endif // __cpp_lib_atomic_wait 
 
@@ -645,11 +653,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // TODO add const volatile overload
 
     void
-    notify_one() const noexcept
+    notify_one() noexcept
     { _M_b.notify_one(); }
 
     void
-    notify_all() const noexcept
+    notify_all() noexcept
     { _M_b.notify_all(); }
 #endif // __cpp_lib_atomic_wait
       __pointer_type
@@ -1421,12 +1429,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   template<typename _Tp>
     inline void
-    atomic_notify_one(const atomic<_Tp>* __a) noexcept
+    atomic_notify_one(atomic<_Tp>* __a) noexcept
     { __a->notify_one(); }
 
   template<typename _Tp>
     inline void
-    atomic_notify_all(const atomic<_Tp>* __a) noexcept
+    atomic_notify_all(atomic<_Tp>* __a) noexcept
     { __a->notify_all(); }
 #endif // __cpp_lib_atomic_wait
 
diff --git a/libstdc++-v3/include/std/charconv b/libstdc++-v3/include/std/charconv
index 8572e376c92..65f923993fa 100644
--- a/libstdc++-v3/include/std/charconv
+++ b/libstdc++-v3/include/std/charconv
@@ -39,7 +39,6 @@
 
 #include <type_traits>
 #include <bit>			// for __bit_width
-#include <cctype>		// for isdigit
 #include <bits/charconv.h>	// for __to_chars_len, __to_chars_10_impl
 #include <bits/error_constants.h> // for std::errc
 #include <ext/numeric_traits.h>
@@ -466,7 +465,7 @@ namespace __detail
       return true;
     }
 
-  constexpr unsigned char
+  constexpr char
   __from_chars_alpha_to_num(char __c)
   {
     switch (__c)
@@ -550,10 +549,10 @@ namespace __detail
     case 'Z':
       return 35;
     }
-    return __gnu_cxx::__int_traits<unsigned char>::__max;
+    return 127;
   }
 
-  /// std::from_chars implementation for integers in bases 11 to 26.
+  /// std::from_chars implementation for integers in bases 11 to 36.
   template<typename _Tp>
     bool
     __from_chars_alnum(const char*& __first, const char* __last, _Tp& __val,
@@ -562,8 +561,8 @@ namespace __detail
       bool __valid = true;
       while (__first != __last)
 	{
-	  unsigned char __c = *__first;
-	  if (std::isdigit(__c))
+	  char __c = *__first;
+	  if ('0' <= __c && __c <= '9') // isdigit
 	    __c -= '0';
 	  else
 	    {
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 09e54c3703b..f5d8da472f5 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -1621,6 +1621,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       }
     };
 
+  // _GLIBCXX_RESOLVE_LIB_DEFECTS
+  // 3117. Missing packaged_task deduction guides
+#if __cpp_deduction_guides >= 201606
+  template<typename _Res, typename... _ArgTypes>
+    packaged_task(_Res(*)(_ArgTypes...)) -> packaged_task<_Res(_ArgTypes...)>;
+
+  template<typename _Fun, typename _Signature = typename
+	   __function_guide_helper<decltype(&_Fun::operator())>::type>
+    packaged_task(_Fun) -> packaged_task<_Signature>;
+#endif
+
   /// swap
   template<typename _Res, typename... _ArgTypes>
     inline void
diff --git a/libstdc++-v3/include/std/ranges b/libstdc++-v3/include/std/ranges
index f55ee15e1b1..bbdfb7dbe5c 100644
--- a/libstdc++-v3/include/std/ranges
+++ b/libstdc++-v3/include/std/ranges
@@ -2916,7 +2916,7 @@ namespace views::__adaptor
 	    { return _InnerIter<_Const>{_M_i}; }
 
 	    constexpr default_sentinel_t
-	    end() const
+	    end() const noexcept
 	    { return default_sentinel; }
 	  };
 
diff --git a/libstdc++-v3/include/std/span b/libstdc++-v3/include/std/span
index af0d24b29f2..2adf1ca2e09 100644
--- a/libstdc++-v3/include/std/span
+++ b/libstdc++-v3/include/std/span
@@ -201,11 +201,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{ }
 
       template<typename _Range>
-	requires ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
-	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
-	  && (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
+	requires (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
 	  && (!__detail::__is_std_array<remove_cvref_t<_Range>>::value)
 	  && (!is_array_v<remove_cvref_t<_Range>>)
+	  && ranges::contiguous_range<_Range> && ranges::sized_range<_Range>
+	  && (ranges::borrowed_range<_Range> || is_const_v<element_type>)
 	  && __is_compatible_ref<ranges::range_reference_t<_Range>>::value
 	constexpr explicit(extent != dynamic_extent)
 	span(_Range&& __range)
diff --git a/libstdc++-v3/include/std/tuple b/libstdc++-v3/include/std/tuple
index dcf30bd9a8d..63bd68fbe43 100644
--- a/libstdc++-v3/include/std/tuple
+++ b/libstdc++-v3/include/std/tuple
@@ -553,10 +553,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   template<bool, typename... _Types>
     struct _TupleConstraints
     {
-      template<typename _Tp, typename _Up> // Workaround for PR 96592
-	using is_constructible
-	  = __bool_constant<__is_constructible(_Tp, _Up)>;
-
       // Constraint for a non-explicit constructor.
       // True iff each Ti in _Types... can be constructed from Ui in _UTypes...
       // and every Ui is implicitly convertible to Ti.
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 16f4cc6eff4..f92a52748c5 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -267,7 +267,9 @@ CXXLINK = \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CXX) \
 	$(VTV_CXXLINKFLAGS) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) \
+	$(LTLDFLAGS) $(LTLIBICONV) \
+	-o $@
 
 # Symbol versioning for shared libraries.
 if ENABLE_SYMVERS
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index 4df5c829a7f..2fff46209ad 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -631,7 +631,9 @@ CXXLINK = \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CXX) \
 	$(VTV_CXXLINKFLAGS) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) \
+	$(LTLDFLAGS) $(LTLIBICONV) \
+	-o $@
 
 @ENABLE_SYMVERS_TRUE@CLEANFILES = libstdc++-symbols.ver $(version_dep)
 @ENABLE_SYMVERS_DARWIN_TRUE@@ENABLE_SYMVERS_TRUE@version_arg = -Wl,-exported_symbols_list,libstdc++-symbols.explist
diff --git a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
index a918ab21015..e40685bf45a 100644
--- a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
+++ b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
@@ -44,14 +44,15 @@
 
 namespace
 {
-  struct io_error_category : std::error_category
+  struct io_error_category final : std::error_category
   {
-    virtual const char*
-    name() const noexcept
+    const char*
+    name() const noexcept final
     { return "iostream"; }
 
     _GLIBCXX_DEFAULT_ABI_TAG
-    virtual std::string message(int __ec) const
+    std::string
+    message(int __ec) const final
     {
       std::string __msg;
       switch (std::io_errc(__ec))
@@ -67,13 +68,17 @@ namespace
     }
   };
 
-  const io_error_category&
-  __io_category_instance() noexcept
+  struct constant_init
   {
-    static const io_error_category __ec{};
-    return __ec;
-  }
+    union {
+      unsigned char unused;
+      io_error_category cat;
+    };
+    constexpr constant_init() : cat() { }
+    ~constant_init() { /* do nothing, union member is not destroyed */ }
+  };
 
+  __constinit constant_init io_category_instance{};
 } // namespace
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -82,7 +87,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   const error_category&
   iostream_category() noexcept
-  { return __io_category_instance(); }
+  { return io_category_instance.cat; }
 
   ios_base::failure::failure(const string& __str)
   : system_error(io_errc::stream, __str) { }
diff --git a/libstdc++-v3/src/c++11/future.cc b/libstdc++-v3/src/c++11/future.cc
index c1a1a828e27..75f832ec1c5 100644
--- a/libstdc++-v3/src/c++11/future.cc
+++ b/libstdc++-v3/src/c++11/future.cc
@@ -27,14 +27,15 @@
 
 namespace
 {
-  struct future_error_category : public std::error_category
+  struct future_error_category final : public std::error_category
   {
-    virtual const char*
-    name() const noexcept
+    const char*
+    name() const noexcept final
     { return "future"; }
 
     _GLIBCXX_DEFAULT_ABI_TAG
-    virtual std::string message(int __ec) const
+    std::string
+    message(int __ec) const final
     {
       std::string __msg;
       switch (std::future_errc(__ec))
@@ -59,12 +60,17 @@ namespace
     }
   };
 
-  const future_error_category&
-  __future_category_instance() noexcept
+  struct constant_init
   {
-    static const future_error_category __fec{};
-    return __fec;
-  }
+    union {
+      unsigned char unused;
+      future_error_category cat;
+    };
+    constexpr constant_init() : cat() { }
+    ~constant_init() { /* do nothing, union member is not destroyed */ }
+  };
+
+  __constinit constant_init future_category_instance{};
 }
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -76,7 +82,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   { _GLIBCXX_THROW_OR_ABORT(future_error(make_error_code(future_errc(__i)))); }
 
   const error_category& future_category() noexcept
-  { return __future_category_instance(); }
+  { return future_category_instance.cat; }
 
   future_error::~future_error() noexcept { }
 
diff --git a/libstdc++-v3/src/c++17/floating_from_chars.cc b/libstdc++-v3/src/c++17/floating_from_chars.cc
index aa074869872..f815e4981dd 100644
--- a/libstdc++-v3/src/c++17/floating_from_chars.cc
+++ b/libstdc++-v3/src/c++17/floating_from_chars.cc
@@ -75,7 +75,6 @@ namespace
 	return m_buf + std::__exchange(m_bytes, m_bytes + bytes);
 
       __glibcxx_assert(m_ptr == nullptr);
-      __glibcxx_assert(alignment != 1);
 
       m_ptr = operator new(bytes);
       m_bytes = bytes;
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index acff0ff926e..e308cab6fa0 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -404,8 +404,12 @@ fs::copy(const path& from, const path& to, copy_options options,
       // set an unused bit in options to disable further recursion
       if (!is_set(options, copy_options::recursive))
 	options |= static_cast<copy_options>(4096);
-      for (const directory_entry& x : directory_iterator(from))
-	copy(x.path(), to/x.path().filename(), options, ec);
+      for (const directory_entry& x : directory_iterator(from, ec))
+	{
+	  copy(x.path(), to/x.path().filename(), options, ec);
+	  if (ec)
+	    return;
+	}
     }
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2683. filesystem::copy() says "no effects"
@@ -1584,7 +1588,8 @@ fs::symlink_status(const fs::path& p)
   return result;
 }
 
-fs::path fs::temp_directory_path()
+fs::path
+fs::temp_directory_path()
 {
   error_code ec;
   path tmp = temp_directory_path(ec);
@@ -1593,32 +1598,12 @@ fs::path fs::temp_directory_path()
   return tmp;
 }
 
-fs::path fs::temp_directory_path(error_code& ec)
+fs::path
+fs::temp_directory_path(error_code& ec)
 {
-  path p;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  unsigned len = 1024;
-  std::wstring buf;
-  do
-    {
-      buf.resize(len);
-      len = GetTempPathW(buf.size(), buf.data());
-    } while (len > buf.size());
-
-  if (len == 0)
-    {
-      ec.assign((int)GetLastError(), std::system_category());
-      return p;
-    }
-  buf.resize(len);
-  p = std::move(buf);
-#else
-  const char* tmpdir = nullptr;
-  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
-  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
-    tmpdir = ::getenv(*e);
-  p = tmpdir ? tmpdir : "/tmp";
-#endif
+  path p = fs::get_temp_directory_from_env(ec);
+  if (ec)
+    return p;
   auto st = status(p, ec);
   if (ec)
     p.clear();
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index 506ff25f9a6..967d9471134 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -1872,11 +1872,6 @@ path::_M_split_cmpts()
       _M_cmpts.type(_Type::_Filename);
       return;
     }
-  if (_M_pathname.length() == 1 && _M_pathname[0] == preferred_separator)
-    {
-      _M_cmpts.type(_Type::_Root_dir);
-      return;
-    }
 
   _Parser parser(_M_pathname);
 
diff --git a/libstdc++-v3/src/c++20/sstream-inst.cc b/libstdc++-v3/src/c++20/sstream-inst.cc
index b3fbd6ead44..55d1fe5234d 100644
--- a/libstdc++-v3/src/c++20/sstream-inst.cc
+++ b/libstdc++-v3/src/c++20/sstream-inst.cc
@@ -26,7 +26,9 @@
 // ISO C++ 14882:
 //
 
-// Instantiations in this file are only for the new SSO std::string ABI
+// Instantiations in this file are only for the new SSO std::string ABI.
+#define _GLIBCXX_USE_CXX11_ABI 1
+
 #include <sstream>
 
 #if _GLIBCXX_USE_CXX11_ABI
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index 529d4e09016..a76a2e6198d 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -567,6 +567,47 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 
 #endif // _GLIBCXX_HAVE_SYS_STAT_H
 
+  // Find OS-specific name of temporary directory from the environment,
+  // Caller must check that the path is an accessible directory.
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  inline wstring
+  get_temp_directory_from_env(error_code& ec)
+  {
+    unsigned len = 1024;
+    std::wstring buf;
+    do
+      {
+	buf.resize(len);
+	len = GetTempPathW(buf.size(), buf.data());
+      } while (len > buf.size());
+
+    if (len == 0)
+      ec.assign((int)GetLastError(), std::system_category());
+    else
+      ec.clear();
+
+    buf.resize(len);
+    return buf;
+  }
+#else
+  inline const char*
+  get_temp_directory_from_env(error_code& ec) noexcept
+  {
+    ec.clear();
+    for (auto env : { "TMPDIR", "TMP", "TEMP", "TEMPDIR" })
+      {
+#if _GLIBCXX_HAVE_SECURE_GETENV
+	auto tmpdir = ::secure_getenv(env);
+#else
+	auto tmpdir = ::getenv(env);
+#endif
+	if (tmpdir)
+	  return tmpdir;
+      }
+    return "/tmp";
+  }
+#endif
+
 _GLIBCXX_END_NAMESPACE_FILESYSTEM
 
 _GLIBCXX_END_NAMESPACE_VERSION
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index 3f2290f372d..bd5347468cf 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -344,8 +344,12 @@ fs::copy(const path& from, const path& to, copy_options options,
       // set an unused bit in options to disable further recursion
       if (!is_set(options, copy_options::recursive))
 	options |= static_cast<copy_options>(4096);
-      for (const directory_entry& x : directory_iterator(from))
-	copy(x.path(), to/x.path().filename(), options, ec);
+      for (const directory_entry& x : directory_iterator(from, ec))
+	{
+	  copy(x.path(), to/x.path().filename(), options, ec);
+	  if (ec)
+	    return;
+	}
     }
   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // 2683. filesystem::copy() says "no effects"
@@ -1289,7 +1293,8 @@ fs::system_complete(const path& p, error_code& ec)
 #endif
 }
 
-fs::path fs::temp_directory_path()
+fs::path
+fs::temp_directory_path()
 {
   error_code ec;
   path tmp = temp_directory_path(ec);
@@ -1298,31 +1303,12 @@ fs::path fs::temp_directory_path()
   return tmp;
 }
 
-fs::path fs::temp_directory_path(error_code& ec)
+fs::path
+fs::temp_directory_path(error_code& ec)
 {
-  path p;
-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  unsigned len = 1024;
-  std::wstring buf;
-  do
-    {
-      buf.resize(len);
-      len = GetTempPathW(buf.size(), buf.data());
-    } while (len > buf.size());
-
-  if (len == 0)
-    {
-      ec.assign((int)GetLastError(), std::system_category());
-      return p;
-    }
-  buf.resize(len);
-  p = std::move(buf);
-#else
-  const char* tmpdir = nullptr;
-  const char* env[] = { "TMPDIR", "TMP", "TEMP", "TEMPDIR", nullptr };
-  for (auto e = env; tmpdir == nullptr && *e != nullptr; ++e)
-    tmpdir = ::getenv(*e);
-  p = tmpdir ? tmpdir : "/tmp";
+  path p = fs::get_temp_directory_from_env(ec);
+  if (ec)
+    return p;
   auto st = status(p, ec);
   if (ec)
     p.clear();
@@ -1331,7 +1317,5 @@ fs::path fs::temp_directory_path(error_code& ec)
       p.clear();
       ec = std::make_error_code(std::errc::not_a_directory);
     }
-#endif
   return p;
 }
-
diff --git a/libstdc++-v3/src/filesystem/path.cc b/libstdc++-v3/src/filesystem/path.cc
index a935573740f..8e8806a953f 100644
--- a/libstdc++-v3/src/filesystem/path.cc
+++ b/libstdc++-v3/src/filesystem/path.cc
@@ -337,15 +337,18 @@ path::_M_split_cmpts()
   _M_type = _Type::_Multi;
   _M_cmpts.clear();
 
-  if (_M_pathname.empty())
+  // Use const-reference to access _M_pathname, to avoid "leaking" COW string.
+  const auto& pathname = _M_pathname;
+
+  if (pathname.empty())
     return;
 
   {
     // Approximate count of components, to reserve space in _M_cmpts vector:
     int count = 1;
-    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_sep_last = _S_is_dir_sep(pathname[0]);
     bool saw_non_sep = !saw_sep_last;
-    for (value_type c : _M_pathname)
+    for (value_type c : pathname)
       {
        if (_S_is_dir_sep(c))
          saw_sep_last = true;
@@ -363,13 +366,13 @@ path::_M_split_cmpts()
   }
 
   size_t pos = 0;
-  const size_t len = _M_pathname.size();
+  const size_t len = pathname.size();
 
   // look for root name or root directory
-  if (_S_is_dir_sep(_M_pathname[0]))
+  if (_S_is_dir_sep(pathname[0]))
     {
       // look for root name, such as "//" or "//foo"
-      if (len > 1 && _M_pathname[1] == _M_pathname[0])
+      if (len > 1 && pathname[1] == pathname[0])
 	{
 	  if (len == 2)
 	    {
@@ -378,11 +381,11 @@ path::_M_split_cmpts()
 	      return;
 	    }
 
-	  if (!_S_is_dir_sep(_M_pathname[2]))
+	  if (!_S_is_dir_sep(pathname[2]))
 	    {
 	      // got root name, find its end
 	      pos = 3;
-	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
+	      while (pos < len && !_S_is_dir_sep(pathname[pos]))
 		++pos;
 	      if (pos == len)
 		{
@@ -409,7 +412,7 @@ path::_M_split_cmpts()
       ++pos;
     }
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
-  else if (len > 1 && _M_pathname[1] == L':')
+  else if (len > 1 && pathname[1] == L':')
     {
       // got disk designator
       if (len == 2)
@@ -418,7 +421,7 @@ path::_M_split_cmpts()
 	  return;
 	}
       _M_add_root_name(2);
-      if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
+      if (len > 2 && _S_is_dir_sep(pathname[2]))
 	_M_add_root_dir(2);
       pos = 2;
     }
@@ -426,9 +429,9 @@ path::_M_split_cmpts()
   else
     {
       size_t n = 1;
-      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+      for (; n < pathname.size() && !_S_is_dir_sep(pathname[n]); ++n)
 	{ }
-      if (n == _M_pathname.size())
+      if (n == pathname.size())
 	{
 	  _M_type = _Type::_Filename;
 	  return;
@@ -438,7 +441,7 @@ path::_M_split_cmpts()
   size_t back = pos;
   while (pos < len)
     {
-      if (_S_is_dir_sep(_M_pathname[pos]))
+      if (_S_is_dir_sep(pathname[pos]))
 	{
 	  if (back != pos)
 	    _M_add_filename(back, pos - back);
@@ -450,7 +453,7 @@ path::_M_split_cmpts()
 
   if (back != pos)
     _M_add_filename(back, pos - back);
-  else if (_S_is_dir_sep(_M_pathname.back()))
+  else if (_S_is_dir_sep(pathname.back()))
     {
       // [path.itr]/8
       // "Dot, if one or more trailing non-root slash characters are present."
diff --git a/libstdc++-v3/testsuite/17_intro/names.cc b/libstdc++-v3/testsuite/17_intro/names.cc
index 226b2d9c24a..554e32162ae 100644
--- a/libstdc++-v3/testsuite/17_intro/names.cc
+++ b/libstdc++-v3/testsuite/17_intro/names.cc
@@ -106,6 +106,8 @@
 #define z (
 
 #define tmp (
+#define sz (
+#define token (
 
 #if __cplusplus < 201103L
 #define uses_allocator  (
@@ -195,6 +197,8 @@
 #undef y
 // <sys/var.h> defines vario::v
 #undef v
+// <sys/timer.h> defines trb::func and cputime_tmr::func
+#undef func
 #endif
 
 #ifdef __APPLE__
diff --git a/libstdc++-v3/testsuite/20_util/allocator/void.cc b/libstdc++-v3/testsuite/20_util/allocator/void.cc
index e3d024d525b..3720774abaf 100644
--- a/libstdc++-v3/testsuite/20_util/allocator/void.cc
+++ b/libstdc++-v3/testsuite/20_util/allocator/void.cc
@@ -87,8 +87,23 @@ static_assert( std::is_same<std::allocator<void>::const_pointer, const void*>(),
     "const_pointer is const void*" );
 #endif // C++20
 
+void
+test02()
+{
+  std::allocator<void> av;
+  int* p = std::allocator<int>().allocate(1);
+  const int* c = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, c, 0);
+  volatile int* v = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, v, 0);
+  const volatile int* cv = p;
+  std::allocator_traits<std::allocator<void>>::construct(av, cv, 0);
+  std::allocator<int>().deallocate(p, 1);
+}
+
 int
 main()
 {
   test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
new file mode 100644
index 00000000000..cecb17e41cc
--- /dev/null
+++ b/libstdc++-v3/testsuite/20_util/from_chars/pr105324.cc
@@ -0,0 +1,14 @@
+// { dg-do run { target c++17 } }
+
+#include <charconv>
+#include <string>
+
+int main()
+{
+  // PR libstdc++/105324
+  // std::from_chars() assertion at floating_from_chars.cc:78
+  std::string s(512, '1');
+  s[1] = '.';
+  long double d;
+  std::from_chars(s.data(), s.data() + s.size(), d);
+}
diff --git a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
index 40180223bae..a98815d932b 100644
--- a/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc
@@ -238,8 +238,11 @@ test07()
   std::pmr::monotonic_buffer_resource mbr(&cr);
   try
   {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
     // Try to allocate a ridiculous size:
     void* p = mbr.allocate(std::size_t(-2), 1);
+#pragma GCC diagnostic pop
     // Should not reach here!
     VERIFY( !"attempt to allocate SIZE_MAX-1 should not have succeeded" );
     throw p;
diff --git a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
index a76afbe87a2..fe847dadd27 100644
--- a/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
+++ b/libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc
@@ -281,10 +281,13 @@ test07()
   std::pmr::unsynchronized_pool_resource upr(&cr);
   try
   {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Walloc-size-larger-than="
     // Try to allocate a ridiculous size (and use a large extended alignment
     // so that careful_resource::do_allocate can distinguish this allocation
     // from any required for the pool resource's internal data structures):
     void* p = upr.allocate(std::size_t(-2), 1024);
+#pragma GCC diagnostic pop
     // Should not reach here!
     VERIFY( !"attempt to allocate SIZE_MAX-1 should not have succeeded" );
     throw p;
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
index 5de2a5f9330..3ba39ec432d 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable.cc
@@ -35,7 +35,9 @@ void test01()
 
   std::string c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
index fe91c5ab539..5804ccb6bf8 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2.cc
@@ -44,7 +44,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
index 1caedcccfce..59d1d775134 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/moveable2_c++17.cc
@@ -42,7 +42,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == '1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
index d05afb7d466..67e25de2916 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable.cc
@@ -35,7 +35,9 @@ void test01()
 
   std::wstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
index e301984612d..c72eb9bfddb 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2.cc
@@ -44,7 +44,9 @@ void test01()
 
   twstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
index d3e4744ff34..6a2bc2714b5 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/moveable2_c++17.cc
@@ -42,7 +42,9 @@ void test01()
 
   tstring c(std::move(b));
   VERIFY( c.size() == 1 && c[0] == L'1' );
-  VERIFY( b.size() == 0 );
+#if ! _GLIBCXX_FULLY_DYNAMIC_STRING
+  VERIFY( b.size() == 0 ); // not guaranteed by the standard
+#endif
 }
 
 int main()
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
index 87d8c2f4068..6a3ed55f557 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/char/87749.cc
@@ -71,8 +71,8 @@ int main()
 
   string s = "PR libstdc++/87749 a string that is longer than a short string";
   const auto ptr = s.c_str();
-  oom = true;
   string ss;
+  oom = true;
   ss = std::move(s); // allocators are equal, should not allocate new storage
   VERIFY( ss.c_str() == ptr );
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
index 4d744f8a411..536ca6153d3 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/modifiers/assign/wchar_t/87749.cc
@@ -72,8 +72,8 @@ int main()
 
   string s = L"PR libstdc++/87749 a string that is longer than a short string";
   const auto ptr = s.c_str();
-  oom = true;
   string ss;
+  oom = true;
   ss = std::move(s); // allocators are equal, should not allocate new storage
   VERIFY( ss.c_str() == ptr );
 }
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
index f467d114c24..7ae3ccda22f 100644
--- a/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/operations/copy/char/constexpr.cc
@@ -22,7 +22,7 @@
 
 #ifndef __cpp_lib_constexpr_string_view
 # error "Feature test macro for constexpr copy is missing in <string_view>"
-#elif __cpp_lib_constexpr_iterator < 201811L
+#elif __cpp_lib_constexpr_string_view < 201811L
 # error "Feature test macro for constexpr copy has wrong value in <string_view>"
 #endif
 
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
new file mode 100644
index 00000000000..0f6f520c33b
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/operations/merge.cc
@@ -0,0 +1,48 @@
+// { dg-do run { target c++11 } }
+// C++11 23.3.4.6 Operations [forwardlist.ops]
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+void
+test_stable()
+{
+  std::forward_list<double> a{1.5, 2.0, 3.5, 4.1};
+  std::forward_list<double> b{1.0, 2.5, 3.0, 4.3, 4.2, 5.0};
+
+  a.merge(b, std::less<int>{});
+
+  // result is sorted with respect to std::less<int>, so 1.0 and 1.5 are
+  // equivalent, and stability guarantee means the element from a comes first.
+  const std::forward_list<double> r { 1.5, 1.0,
+				      2.0, 2.5,
+				      3.5, 3.0,
+				      4.1, 4.3, 4.2,
+				      5.0};
+
+  VERIFY(a == r);
+}
+
+void
+test_lwg3088()
+{
+  // LWG 3088: forward_list::merge behavior unclear when passed *this
+  // PR libstdc++/103853
+  std::forward_list<int> c1{ 1, 2, 3 };
+  const std::forward_list<int> c2 = c1;
+  c1.merge(c1);
+  VERIFY( c1 == c2 );
+  c1.merge(c1, std::less<long>{});
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1));
+  VERIFY( c1 == c2 );
+  c1.merge(std::move(c1), std::less<long>{});
+  VERIFY( c1 == c2 );
+}
+
+int
+main()
+{
+  test_stable();
+  test_lwg3088();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc b/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
index e4219b8c78b..3ce0df5d111 100644
--- a/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
+++ b/libstdc++-v3/testsuite/24_iterators/move_iterator/dr3265.cc
@@ -15,7 +15,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-// { dg-do compile { target c++11 } }
+// { dg-do run { target c++11 } }
 
 #include <iterator>
 
@@ -27,18 +27,18 @@ struct Iter
   using reference = int&;
   using difference_type = std::ptrdiff_t;
 
-  Iter();
+  Iter() { }
 
-  // Construction from int* is not valid:
-  Iter(int*) = delete;
+  // Construction from int* should not be used:
+  Iter(int*) { throw 1; }
 
-  // Assignment from int* is valid:
-  Iter& operator=(int*);
+  // Assignment from int* is OK:
+  Iter& operator=(int*) { return *this; }
 
-  Iter& operator++();
-  Iter operator++(int);
-  int& operator*() const;
-  int* operator->() const;
+  Iter& operator++() { return *this; }
+  Iter operator++(int) { return *this; }
+  int& operator*() const { static int i; return i; }
+  int* operator->() const { return &**this; }
 
   template<int N> friend bool operator==(Iter, Iter);
 };
@@ -49,3 +49,8 @@ void test01()
   int i = 0;
   m = std::make_move_iterator(&i); // Should use assignment not construction
 }
+
+int main()
+{
+  test01();
+}
diff --git a/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc b/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc
new file mode 100644
index 00000000000..0fadcd6e99a
--- /dev/null
+++ b/libstdc++-v3/testsuite/24_iterators/range_operations/advance_overflow.cc
@@ -0,0 +1,37 @@
+// { dg-options "-std=gnu++20" }
+// { dg-do compile { target c++20 } }
+
+// Public domain testcase from Casey Carter, send to LWG list on 2021-07-24.
+//
+// Here's a compile-only test case for which n is INT_MIN, which will overflow
+// if simply negated to get |n|: https://godbolt.org/z/M7Wz1nW58.
+
+#include <cassert>
+#include <iterator>
+#include <limits>
+
+struct I {
+    using difference_type = int;
+    using value_type = int;
+
+    int x;
+
+    constexpr int operator*() const { return x; }
+    constexpr I& operator++() { ++x; return *this; }
+    constexpr I operator++(int) { ++x; return {x - 1}; }
+    constexpr bool operator==(const I&) const = default;
+
+    constexpr int operator-(const I& that) const { return x - that.x; }
+
+    constexpr I& operator--() { --x; return *this; }
+    constexpr I operator--(int) { --x; return {x - 1}; }
+};
+static_assert(std::bidirectional_iterator<I>);
+static_assert(std::sized_sentinel_for<I, I>);
+
+constexpr bool test() {
+    using L = std::numeric_limits<int>;
+    I i{-2};
+    return std::ranges::advance(i, L::min(), I{-4}) == L::min() + 2;
+}
+static_assert(test());
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
index 761cfc29b13..c00cf85641e 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/copy.cc
@@ -193,6 +193,34 @@ test05()
   VERIFY( !ec );  // Previous value should be cleared (LWG 2683)
 }
 
+void
+test_pr99290()
+{
+  auto dir = __gnu_test::nonexistent_path();
+  auto source = dir/"source";
+  auto dest = dir/"dest";
+  create_directories(source/"emptydir");
+  create_directories(dest/"emptydir");
+  std::ofstream{source/"file"} << 'a';
+  std::ofstream{dest/"file"} << 'b';
+  // PR libstdc++/99290
+  // std::filesystem::copy does not always report errors for recursion
+  std::error_code ec;
+  copy(source, dest, ec);
+  VERIFY( ec == std::errc::file_exists );
+
+#if __cpp_exceptions
+  try {
+    copy(source, dest);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::file_exists );
+  }
+#endif
+
+  remove_all(dir);
+}
+
 int
 main()
 {
@@ -201,4 +229,5 @@ main()
   test03();
   test04();
   test05();
+  test_pr99290();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
index b55cd6c60b6..1cfda583be3 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/temp_directory_path.cc
@@ -20,6 +20,7 @@
 
 #include <filesystem>
 #include <stdlib.h>
+#include <stdio.h>
 #include <testsuite_hooks.h>
 #include <testsuite_fs.h>
 
@@ -58,7 +59,10 @@ test01()
   clean_env();
 
   if (!fs::exists("/tmp"))
+  {
+    puts("/tmp doesn't exist, not testing it for temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec = make_error_code(std::errc::invalid_argument);
   fs::path p1 = fs::temp_directory_path(ec);
@@ -75,7 +79,10 @@ test02()
   clean_env();
 
   if (!set_env("TMP", __gnu_test::nonexistent_path().string()))
+  {
+    puts("Cannot set environment variables, not testing temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec;
   fs::path p = fs::temp_directory_path(ec);
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc b/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
index 7eab17b12e0..dffdaef7afd 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/cons/user_pod.cc
@@ -1,3 +1,4 @@
+// { dg-options "-O1" }
 // { dg-do link { target c++11 } }
 
 // Copyright (C) 2009-2021 Free Software Foundation, Inc.
diff --git a/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc b/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
index 9d92ff954f1..f572ce7ef11 100644
--- a/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
+++ b/libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/102994.cc
@@ -5,13 +5,13 @@
 #include <atomic>
 
 void
-test1(const std::atomic<char*>& a, char* p)
+test1(std::atomic<char*>& a, char* p)
 {
   a.wait(p);
 }
 
 void
-test2(const std::atomic<int>* a, int v)
+test2(std::atomic<int>* a, int v)
 {
   std::atomic_wait(a, v);
   std::atomic_notify_one(a);
diff --git a/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc b/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc
new file mode 100644
index 00000000000..0eb69763ab9
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/packaged_task/cons/deduction.cc
@@ -0,0 +1,85 @@
+// // Copyright (C) 2017-2022 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++17 } }
+
+#include <future>
+
+template<typename T, typename U> struct require_same;
+template<typename T> struct require_same<T, T> { using type = void; };
+
+template<typename T, typename U>
+  typename require_same<T, U>::type
+  check_type(U&) { }
+
+void f0v();
+void f0vn() noexcept;
+int f0i();
+int f0in() noexcept;
+long f1l(int&);
+long f1ln(double*) noexcept;
+
+void
+test01()
+{
+  std::packaged_task task1{f0v};
+  check_type<std::packaged_task<void()>>(task1);
+
+  std::packaged_task task2{f0vn};
+  check_type<std::packaged_task<void()>>(task2);
+
+  std::packaged_task task3{f0i};
+  check_type<std::packaged_task<int()>>(task3);
+
+  std::packaged_task task4{f0in};
+  check_type<std::packaged_task<int()>>(task4);
+
+  std::packaged_task task5{f1l};
+  check_type<std::packaged_task<long(int&)>>(task5);
+
+  std::packaged_task task6{f1ln};
+  check_type<std::packaged_task<long(double*)>>(task6);
+
+  std::packaged_task task5a{std::move(task5)};
+  check_type<std::packaged_task<long(int&)>>(task5a);
+
+  std::packaged_task task6a{std::move(task6)};
+  check_type<std::packaged_task<long(double*)>>(task6a);
+}
+
+struct X {
+  int operator()(const short&, void*);
+};
+
+struct Y {
+  void operator()(int) const & noexcept;
+};
+
+void
+test02()
+{
+  X x;
+  std::packaged_task task1{x};
+  check_type<std::packaged_task<int(const short&, void*)>>(task1);
+
+  Y y;
+  std::packaged_task task2{y};
+  check_type<std::packaged_task<void(int)>>(task2);
+
+  std::packaged_task task3{[&x](float) -> X& { return x; }};
+  check_type<std::packaged_task<X&(float)>>(task3);
+}
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
index 947d270e6a4..817e51d2d21 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/copy.cc
@@ -190,6 +190,34 @@ test05()
   VERIFY( !ec );  // Previous value should be cleared (LWG 2683)
 }
 
+void
+test_pr99290()
+{
+  auto dir = __gnu_test::nonexistent_path();
+  auto source = dir/"source";
+  auto dest = dir/"dest";
+  create_directories(source/"emptydir");
+  create_directories(dest/"emptydir");
+  std::ofstream{source/"file"} << 'a';
+  std::ofstream{dest/"file"} << 'b';
+  // PR libstdc++/99290
+  // std::filesystem::copy does not always report errors for recursion
+  std::error_code ec;
+  copy(source, dest, ec);
+  VERIFY( ec == std::errc::file_exists );
+
+#if __cpp_exceptions
+  try {
+    copy(source, dest);
+    VERIFY( false );
+  } catch (const fs::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::file_exists );
+  }
+#endif
+
+  remove_all(dir);
+}
+
 int
 main()
 {
@@ -198,4 +226,5 @@ main()
   test03();
   test04();
   test05();
+  test_pr99290();
 }
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
index 03e777b0041..badd8a884cc 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/temp_directory_path.cc
@@ -21,6 +21,7 @@
 
 #include <experimental/filesystem>
 #include <stdlib.h>
+#include <stdio.h>
 #include <testsuite_hooks.h>
 #include <testsuite_fs.h>
 
@@ -59,7 +60,10 @@ test01()
   clean_env();
 
   if (!fs::exists("/tmp"))
+  {
+    puts("/tmp doesn't exist, not testing it for temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec = make_error_code(std::errc::invalid_argument);
   fs::path p1 = fs::temp_directory_path(ec);
@@ -75,8 +79,11 @@ test02()
 {
   clean_env();
 
-  if (set_env("TMPDIR", __gnu_test::nonexistent_path().string()))
+  if (!set_env("TMP", __gnu_test::nonexistent_path().string()))
+  {
+    puts("Cannot set environment variables, not testing temp_directory_path");
     return; // just give up
+  }
 
   std::error_code ec;
   fs::path p = fs::temp_directory_path(ec);
diff --git a/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc b/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
index 5df9f330cd4..ed0614e2797 100644
--- a/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
+++ b/libstdc++-v3/testsuite/ext/rope/pthread7-rope.cc
@@ -20,6 +20,7 @@
 // { dg-do run }
 // { dg-options "-pthread"  }
 // { dg-require-effective-target pthread }
+// { dg-timeout-factor 2 }
 
 #include <ext/rope>
 #include <cstring>
@@ -33,7 +34,7 @@ typedef __gnu_cxx::rope<char, std::allocator<char> > rope_type;
 rope_type foo2;
 rope_type foo4;
 
-void* thread_main(void *) 
+void* thread_main(void *)
 {
   // To see a problem with gcc 3.3 and before, set a break point here.
   // Single step through c_str implementation, call sched_yield after
